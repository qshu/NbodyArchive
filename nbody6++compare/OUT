1,2c1,2
< 4990 2005-03-31 19:44 /work/Umi2/spurzem/5/nbody6compare/absorb.f
< nbody6compare/absorb.f
---
> 4460 2002-07-12 23:12 /work/Umi2/spurzem/5/nbody6++compare/absorb.f
> nbody6++compare/absorb.f
8c8,9
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMX4=4*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
24a26
>       TIME0 = TIME
27,46c29,30
< *       Avoid zero since TBLOCK = TPREV during the first block-step.
<       IF (DT8.EQ.0.0D0) DT8 = STEP(ICH)/8.0D0
< *
< *       Adopt the nearest truncated step (at most 8 subdivisions).
<       IF (DT2.GT.0.0D0) THEN
<           CALL STEPK(DT2,DTN2)
<           DTN = NINT(DTN2/DT8)*DT8
<       ELSE
< *       Choose negative step if pericentre time < TPREV.
<           DT2 = -DT2
<           CALL STEPK(DT2,DTN2)
<           DTN = -NINT(DTN2/DT8)*DT8
<       END IF
< *
< *       Update time for new polynomial initializations (but check T - T0).
<       TIME = TPREV + DTN
< *
< *       Avoid prediction skip by XVPRED in case TIME - T0 = 0.0.
<       IF (TIME - T0(ICH).EQ.0.0D0) TIME = TIME + DT8/16.0D0
< *
---
>       TIME = TPREV + NINT(DT2/DT8)*DT8
>       TIME = MIN(TBLOCK,TIME)
51,52c35,36
<           WRITE (6,1)  TIME+TOFF, DT2, DT8
<     1     FORMAT (' ABSORB:    TIME DT2 DT8 ',F12.6,1P,2E10.2)
---
>           WRITE (6,1)  TIME0+TOFF, TIME+TOFF, DT2, DT8
>     1     FORMAT (' ABSORB:   TIME0 TIME DT2 DT8 ',2F10.6,1P,2E10.2)
162a147,148
> 
> 
1,2c1,2
< 11230 2006-09-02 16:33 /work/Umi2/spurzem/5/nbody6compare/adjust.f
< nbody6compare/adjust.f
---
> 9701 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/adjust.f
> nbody6++compare/adjust.f
0a1,4
> # 1 "adjust.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "adjust.F"
4,5c8,9
< *       Parameter adjustment and energy check.
< *       --------------------------------------
---
> * Parameter adjustment and energy check.
> * --------------------------------------
8,10c12,15
<       COMMON/ECHAIN/  ECH
<       SAVE  DTOFF
<       DATA  DTOFF /100.0D0/
---
>       COMMON/ECHAIN/ ECH
>       COMMON/STSTAT/ TINIT,NIR,NIB,NRGL,NKS
>       SAVE DTOFF
>       DATA DTOFF /100.0D0/
13c18
< *       Predict X & XDOT for all particles (except unperturbed pairs).
---
> * Predict X & XDOT for all particles (except unperturbed pairs).
16c21,30
< *       Obtain the total energy at current time (resolve all KS pairs).
---
> * ico = ico + 1
> * do 556 i=1,n
> * write(55,100)ico,name(i),(xdot(k,i),k=1,3)
> *556 continue
> *100 format(1x,2i5,3f7.2)
> *
> * Obtain the total energy at current time (resolve all KS pairs).
> 
> 
> 
17a32
> 
19c34
< *       Initialize c.m. terms.
---
> * Initialize c.m. terms.
25c40
< *       Obtain c.m. & angular momentum integrals and Z-moment of inertia.
---
> * Obtain c.m. & angular momentum integrals and Z-moment of inertia.
29d43
<       ISUN = 1
31d44
<           IF (NAME(I).EQ.1) ISUN = I
36,38c49,53
<    15     CONTINUE
< *         RI2 = (X(1,I) - RDENS(1))**2 + (X(2,I) - RDENS(2))**2 +
< *    &                                   (X(3,I) - RDENS(3))**2
---
>    15 CONTINUE
>           RI2 = (X(1,I) - RDENS(1))**2 + (X(2,I) - RDENS(2))**2 +
>      & (X(3,I) - RDENS(3))**2
> * Skip contribution from escapers.
>           IF (RI2.GT.4.0*RTIDE**2) GO TO 20
43c58
< *       Form c.m. coordinates & velocities (vectors & scalars).
---
> * Form c.m. coordinates & velocities (vectors & scalars).
52c67
< *       Subtract the kinetic energy of c.m. due to possible cloud effects.
---
> * Subtract the kinetic energy of c.m. due to possible cloud effects.
55,56c70,71
< *       Form virial ratio using single particles & c.m. (isolated or tidal). 
<       IF (KZ(14).EQ.0.OR.KZ(14).EQ.3) THEN
---
> * Form virial ratio using single particles & c.m. (isolated or tidal).
>       IF (KZ(14).EQ.0) THEN
58,62d72
<           E(3) = ZKIN - POT
<       ELSE IF (KZ(14).EQ.4) THEN
< *       Employ actual virial energy for central Plummer potential.
<           Q = ZKIN/(POT - VIR)
<           E(3) = ZKIN - POT + ETIDE
64c74
< *       Use Chandrasekhar eq. (5.535) for virial ratio.
---
> * Use Chandrasekhar eq. (5.535) for virial ratio.
66,67c76,77
<           Q = ZKVIR/(POT + 2.0*ETIDE)
< *       Modify angular momentum integral using Chandrasekhar eq. (5.530).
---
>           Q = ZKVIR/(POT - 2.0*ETIDE)
> * Modify angular momentum integral using Chandrasekhar eq. (5.530).
69,74d78
<           E(3) = ZKIN - POT + ETIDE
<       END IF
< *       Include case of Plummer sphere for 3D orbit.
<       IF (KZ(14).EQ.3.AND.MP.GT.0.0D0) THEN
<           Q = ZKIN/(POT - VIR)
<           E(3) = ZKIN - POT + ETIDE
77,79c81,83
< *       Define crossing time using single particle energy (cf. option 14).
<       TCR = ZMASS**2.5/(2.0*ABS(E(3)))**1.5
< *       Note: see below for better definition in Plummer or 3D orbit case.
---
> * Define crossing time and save single particle energy.
>       ETOT = ZKIN - POT + ETIDE
>       TCR = ZMASS**2.5/(2.0*ABS(ETOT))**1.5
83,84c87
< *       Form provisional total energy.
<       ETOT = ZKIN - POT + ETIDE
---
>       E(3) = ETOT
86c89
< *       Include KS pairs, triple, quad, mergers, collisions & chain.
---
> * Include KS pairs, triple, quad, mergers, collisions & chain.
91,92c94
< *
< *       Update energies and form the relative error (divide by ZKIN or E(3)).
---
> * Update energies and form the relative error (divide by ZKIN or E(3)).
97d98
<           DELTA1 = 0.0D0
102d102
<           DELTA1 = DE
105c105
< *       Save sum of relative energy error for main output and accumulate DE.
---
> * Save sum of relative energy error for main output and accumulate DE.
110c110
< *       Set provisional half-mass radius.
---
> * Set provisional half-mass radius.
113c113
< *       Determine average neighbour number and smallest neighbour sphere.
---
> * Determine average neighbour number and smallest neighbour sphere.
116c116
<       DO 30 I = IFIRST,NTOT
---
>       DO 40 I = IFIRST,NTOT
119,120c119,122
<    30 CONTINUE
<       NNB = NNB/(N - NPAIRS)
---
>    40 CONTINUE
> *
> * Set average neighbour number.
>       NNB = FLOAT(NNB)/FLOAT(N - NPAIRS)
122c124
< *       Use current value if minimum neighbour sphere not implemented.
---
> * Use current value if minimum neighbour sphere not implemented.
125,126c127,128
< *       Find density centre & core radius (Casertano & Hut, Ap.J. 298, 80).
<       IF (N-NPAIRS.GE.20.AND.KZ(29).EQ.0.AND.KZ(5).NE.3) THEN
---
> * Find density centre & core radius (Casertano & Hut, Ap.J. 298, 80).
>       IF (N-NPAIRS.GE.20.AND.KZ(29).EQ.0) THEN
138,167c140
< *       Take the Sun as reference for plotting planetesimal disk members.
<       IF (KZ(5).EQ.3) THEN
<           DO 35 K = 1,3
<               RDENS(K) = X(K,ISUN)
<    35     CONTINUE
< *
< *       Determine the eccentricity dispersion and total energy of disk.
<           DISP2 = 0.0
<           EDISK = 0.0
<           DO 40 I = 1,N
<               IF (NAME(I).EQ.1.OR.NAME(I).EQ.NZERO) GO TO 40
<               RI2 = (X(1,I) - X(1,ISUN))**2 + (X(2,I) - X(2,ISUN))**2
<               VI2 = (XDOT(1,I) - XDOT(1,ISUN))**2 +
<      &              (XDOT(2,I) - XDOT(2,ISUN))**2
<               RRDOT = (X(1,I) - X(1,ISUN))*(XDOT(1,I) - XDOT(1,ISUN)) +
<      &                (X(2,I) - X(2,ISUN))*(XDOT(2,I) - XDOT(2,ISUN))
<               RI = SQRT(RI2)
<               SEMI = 2.0/RI - VI2/(BODY(ISUN) + BODY(I))
<               SEMI = 1.0/SEMI
<               ECC2 = (1.0 - RI/SEMI)**2 +
<      &                RRDOT**2/(SEMI*(BODY(I) + BODY(ISUN)))
<               DISP2 = DISP2 + ECC2
<               EDISK = EDISK - 0.5*BODY(I)/SEMI
<    40     CONTINUE
<           DISP = SQRT(DISP2/FLOAT(N-2))
<           WRITE (35,42)  TTOT, DISP, EDISK
<    42     FORMAT (' ',F8.1,1P,E10.2,E12.4)
<       END IF
< *
< *       Check optional sorting of Lagrangian radii & half-mass radius.
---
> * Check optional sorting of Lagrangian radii & half-mass radius.
172c145
< *       Scale average & maximum core density by the mean value.
---
> * Scale average & maximum core density by the mean value.
176c149
< *       Adopt density contrasts of unity for hot system.
---
> * Adopt density contrasts of unity for hot system.
182c155
< *       Check optional determination of regularization parameters.
---
> * Check optional determination of regularization parameters.
186c159
< *       Form close encounter distance from scale factor & density contrast.
---
> * Form close encounter distance from scale factor & density contrast.
188c161
< *       Use harmonic mean to reduce fluctuations (avoid initial value).
---
> * Use harmonic mean to reduce fluctuations (avoid initial value).
190c163
< *       Impose maximum value for sufficient perturbers.
---
> * Impose maximum value for sufficient perturbers.
192c165
< *       Define scaled DTMIN by RMIN & <M> and include ETAI for consistency.
---
> * Define scaled DTMIN by RMIN & <M> and include ETAI for consistency.
194c167
< *       Specify binding energy per unit mass of hard binary (impose Q = 0.5).
---
> * Specify binding energy per unit mass of hard binary (impose Q = 0.5).
196c169
< *       Adopt central velocity as upper limit (avoids large kick velocities).
---
> * Adopt central velocity as upper limit (avoids large kick velocities).
201d173
<           ECLOSE = MIN(ECLOSE,1.0D0)
204c176
< *       Check optional modification of DTMIN, ECLOSE & TCR for hot system.
---
> * Check optional modification of DTMIN, ECLOSE & TCR for hot system.
214c186
< *       Set useful scalars for the integrator.
---
> * Set useful scalars for the integrator.
219,220c191,193
<       IF (TIME.LE.0.0D0) STEPJ = 0.01*(60000.0/FLOAT(N))**0.3333
< *       Adopt 2*RSMIN for neighbour sphere volume factor in routine REGINT.
---
> * Specify square close encounter force from heaviest body at 5*RMIN.
>       FCRIT2 = (BODY1/(25.0*RMIN2))**2
> * Adopt 2*RSMIN for neighbour sphere volume factor in routine REGINT.
223c196
< *       Update density contrast factor for neighbour sphere modification.
---
> * Update density contrast factor for neighbour sphere modification.
227c200
< *       Include optional stabilization to increase neighbour number.
---
> * Include optional stabilization to increase neighbour number.
233,238c206,237
< *       Define tidal radius for isolated system (2*RTIDE used in ESCAPE).
<       IF (KZ(14).EQ.0) RTIDE = 10.0*RSCALE
< *       Redefine the crossing time for 3D cluster orbit or Plummer model.
<       IF ((KZ(14).EQ.3.OR.KZ(14).EQ.4).AND.ZKIN.GT.0.0) THEN
<           TCR = 2.0*RSCALE/SQRT(2.0*ZKIN/ZMASS)
<       END IF
---
> * Define tidal radius for isolated system (2*RTIDE used in ESCAPE).
>       IF (TIDAL(1).EQ.0.0D0) RTIDE = 10.0*RSCALE
> *
> * write(6,57)rank,ttfrc
> * 57 FORMAT(' IPE=',I4,' ttfrc=',f9.3)
> *
>       call cputim(tt1)
>       ttotal = (tt1-ttota)*60.
> *
>       if(rank.eq.0)then
> *
> * Print energy diagnostics & KS parameters.
>       ICR = INT(TTOT/TCR0)
> C New (Aug.1998) by P.Kroupa: (time also in Myr)
>       WRITE (6,50) rank, TTOT, ttot*tscale, Q, DE, BE(3)-EBIN, EBIN,
>      & EMERGE
>    50 FORMAT (/,' ',I2,' ADJUST:  TIME =',1P,D15.5,0P,'  T[Myr] = ',
>      & F8.2,'  Q =',F5.2,'  DE =',1P,E15.6,'  E =',E15.6,
>      & ' EBIN=',E15.6,' EMERGE=',E15.6)
> *
>       write(6,51) RMIN, DTMIN, RHOM, RSCALE, RSMIN, ECLOSE, ICR
>    51 FORMAT (/, '  RMIN =',1PE8.1,'  DTMIN =',E8.1,' RHOM =',E8.1,
>      &' RSCALE =',E8.1,' RSMIN =',E8.1,'  ECLOSE =',0PF5.2,'  TC =',I5)
> *
>       WRITE(6,55)
>    55 FORMAT('  PE  N       ttot            treg      tirr      ',
>      & 'tpredtot  tint      tinit      tks      ttcomm    tadj     ',
>      & 'tmov      tprednb    tsub     tsub2    xtsub1   xtsub2')
>       WRITE(6,56)isize,n,ttotal,ttreg,ttirr,ttpre,ttint,ttinit,
>      & ttks,ttcomm,ttadj,ttmov,ttnbp,ttsub,ttsub2,
>      & xtsub1,xtsub2
>    56 FORMAT(1X,I3,I6,F13.5,12F10.2,1P,2D13.5)
240,245d238
< *       Print energy diagnostics & KS parameters.
<       ICR = TTOT/TCR
<       WRITE (6,45)  TTOT, Q, DE, BE(3),RMIN, DTMIN, ECLOSE, ICR, DELTA1
<    45 FORMAT (/,' ADJUST:  TIME =',F8.2,'  Q =',F5.2,'  DE =',1P,E10.2,
<      &          '  E =',0P,F10.6,'  RMIN =',1P,E8.1,'  DTMIN =',E8.1,
<      &          '  ECLOSE =',0PF5.2,'  TC =',I5,'  DELTA =',1P,E9.1)
246a240
>       end if
248c242
< *       Perform automatic error control (RETURN on restart with KZ(2) > 1).
---
> * Perform automatic error control (RETURN on restart with KZ(2) > 1).
252c246
< *       Check for escaper removal.
---
> * Check for escaper removal.
257c251
< *       Check correction for c.m. displacements.
---
> * Check correction for c.m. displacements.
262,285c256
< *       Include diagnostics for massive binary (bound or unbound initially).
<       IF (KZ(5).EQ.4) THEN
<           IP = 0
<           DO 50 IPAIR = 1,NPAIRS
<               IF (NAME(2*IPAIR-1).LE.2.OR.NAME(2*IPAIR).LE.2) THEN
<                   IP = IPAIR
<               END IF
<    50     CONTINUE
<           IF (IP.GT.0) THEN
<               I1 = 2*IP - 1
<               I2 = I1 + 1
<               SEMI = -0.5*BODY(N+IP)/H(IP)
<               ECC2 = (1.0 - R(IP)/SEMI)**2 +
<      &                                  TDOT2(IP)**2/(SEMI*BODY(N+IP))
<               EB = BODY(I1)*BODY(I2)*H(IP)/BODY(N+IP)
<               WRITE (35,52)  TTOT, SEMI, EB, E(3), SQRT(ECC2),
<      &                       NAME(I1), NAME(I2)
<    52         FORMAT (' ',F8.1,1P,3E12.4,0P,F7.3,2I5)
< *  52         FORMAT (' T A E EB ECL NAME ',F8.1,1P,3E12.4,0P,F7.3,2I5)
<               CALL FLUSH(35)
<           END IF
<       END IF
< *
< *       See whether standard output is due (allow for setting TIME = TPREV).
---
> * See whether standard output is due (allow for setting TIME = TPREV).
290c261
< *       Update time for next adjustment.
---
> * Update time for next adjustment.
292,293d262
< *       Re-initialize marginal stability counter to avoid including old case.
<       NMARG = 0
295,298c264,266
< *       Obtain elapsed CPU time and update total since last output/restart.
<       CALL CPUTIM(TCOMP)
<       CPUTOT = CPUTOT + TCOMP - CPU0
<       CPU0 = TCOMP
---
> * Obtain elapsed CPU time and update total since last output/restart.
>       call cputim(tt1)
>       CPUTOT = (tt1-ttota)*60.
300c268
< *       Save COMMON after energy check (skip TRIPLE, QUAD, CHAIN).
---
> * Save COMMON after energy check (skip TRIPLE, QUAD, CHAIN).
304,311c272,319
< *       Check termination criteria (TIME > TCRIT & N <= NCRIT).
<       IF (TTOT.GE.TCRIT.OR.N.LE.NCRIT) THEN
< *       Terminate after optional COMMON save.
<           WRITE (6,60)  TTOT, CPUTOT/60.0, ERRTOT, DETOT
<    60     FORMAT (//,9X,'END RUN',3X,'TIME =',F7.1,'  CPUTOT =',F7.1,
<      &                  '  ERRTOT =',F10.6,'  DETOT =',F10.6)
<           IF (KZ(1).GT.0.AND.NSUB.EQ.0) CALL MYDUMP(1,1)
<           STOP
---
> * Check termination criteria (TIME > TCRIT & N <= NCRIT).
> *
> C New (Aug. 1998): P.Kroupa
> *
>       IF (TTOT*TSCALE.GT.TCRITp.OR.TTOT.GT.TCRIT - 20.0*DTMIN
>      & .OR.N.LE.NCRIT) THEN
> * Terminate after optional COMMON save.
>           if(rank.eq.0)
>      & WRITE (6,60) TTOT*TSCALE, TOFF, TIME, TIME+TOFF,
>      & CPUTOT/60.0,ERRTOT, DETOT
>    60 FORMAT (
>      & '  TOFF/TIME/TTOT=',3F16.8,
>      & '  CPUTOT =',F7.1,
>      & '  ERRTOT =',1P,D12.5,'  DETOT =',D12.5)
> *
> * Determine time interval and step numbers per time unit
>       TIMINT = TIME + TOFF - TINIT
> *
> 
> 
> 
>       WRITE (6,195) rank,TIMINT,NSTEPI-NIR,NSTEPB-NIB,NSTEPR-NRGL,
>      & NSTEPU-NKS
>   195 FORMAT (
>      & ' NIRRB=',I11,' NREG=',I11,' NKS=',I11)
>       WRITE (6,196) (NSTEPI-NIR)/TIMINT,(NSTEPB-NIB)/TIMINT,
>      & (NSTEPR-NRGL)/TIMINT,(NSTEPU-NKS)/TIMINT
>   196 FORMAT (
>      & D12.5,' NREG=',D12.5,' NKS=',D12.5)
> 
> 
> 
> *
>           IF (KZ(1).GT.0) CALL MYDUMP(1,1)
>       call cputim(tt1)
> *
> 
> 
> 
>           ttotal=(tt1-ttota)*60.
>       PRINT*,' Total CPU=',ttotal
> 
> 
> 
> 
> 
>       STOP
> *
314c322
< *       Check optional truncation of time.
---
> * Check optional truncation of time.
1,2c1,2
< 5995 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/bindat.f
< nbody6compare/bindat.f
---
> 5474 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/bindat.f
> nbody6++compare/bindat.f
0a1,4
> # 1 "bindat.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "bindat.F"
4,5c8,9
< *       Binary data bank.
< *       -----------------
---
> * Binary data bank.
> * -----------------
8,14c12,15
<       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
<       REAL*4  EB(KMAX),ECC(KMAX),RCM(KMAX),ECM(KMAX),PB(KMAX),AS(30)
<       LOGICAL  FIRST
<       SAVE  FIRST
<       DATA  FIRST /.TRUE./
---
>       COMMON/BINARY/ CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
>      & HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      & NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       REAL*4 EB(KMAX),ECC(KMAX),RCM(KMAX),ECM(KMAX),PB(KMAX),AS(30)
17c18
< *       Form binding energy and central distance for each KS pair.
---
> * Form binding energy and central distance for each KS pair.
25c26
< *       Determine merger & ghost index for negative c.m. name (skip ghost).
---
> * Determine merger & ghost index for negative c.m. name (skip ghost).
28c29
< *       Employ actual masses and two-body distance for energy & eccentricity.
---
> * Employ actual masses and two-body distance for energy & eccentricity.
33,34c34,35
<      &                                      XREL(3,IMERGE)**2)
< *       Assume that merged binary is near apo or peri (hence ignore TDOT2).
---
>      & XREL(3,IMERGE)**2)
> * Assume that merged binary is near apo or peri (hence ignore TDOT2).
36c37
< *       Include separate diagnostics for the hierarchy (inner comps J1 & J).
---
> * Include separate diagnostics for the hierarchy (inner comps J1 & J).
39c40
<      &                                 TDOT2(JPAIR)**2/(BODY(ICM)*SEMI1)
---
>      & TDOT2(JPAIR)**2/(BODY(ICM)*SEMI1)
51a53
>               if(rank.eq.0)then
53,55c55,57
<      &                     KSTARM(IMERGE), E0, E1, PM, RM, P0, P1, SEMI1
<     2         FORMAT (' BINDAT:    T NM K* E0 E1 PM/PC PM0/R* P0 P1 A1',
<      &                             F8.1,2I5,3I4,2F7.3,2F6.1,1P,3E9.1)
---
>      & KSTARM(IMERGE), E0, E1, PM, RM, P0, P1, SEMI1
>     2 FORMAT (' BINDAT:    T NM K* E0 E1 PM/PC PM0/R* P0 P1 A1',
>      & F8.1,2I5,3I4,2F7.3,2F6.1,1P,3E9.1)
56a59
>               end if
58c61
< *       Form binding energy and eccentricity for standard case.
---
> * Form binding energy and eccentricity for standard case.
60c63
<      &                                             (BODY(J1) + BODY(J2))
---
>      & (BODY(J1) + BODY(J2))
63c66
<      &                                  TDOT2(JPAIR)**2/(BODY(ICM)*SEMI)
---
>      & TDOT2(JPAIR)**2/(BODY(ICM)*SEMI)
66c69
< *       Search merger table to identify corresponding index of c.m. name.
---
> * Search merger table to identify corresponding index of c.m. name.
71c74
<     5         CONTINUE
---
>     5 CONTINUE
84c87
< *       Obtain binding energy (per unit mass) of c.m. motion.
---
> * Obtain binding energy (per unit mass) of c.m. motion.
91c94
<      &                                        (X(3,ICM) - X(3,J))**2 
---
>      & (X(3,ICM) - X(3,J))**2
93c96
<     9     CONTINUE
---
>     9 CONTINUE
95c98
< *       Check for external tidal field (note that HT includes mass).
---
> * Check for external tidal field (note that HT includes mass).
101,102c104,105
<      &                      (X(2,ICM) - RDENS(2))**2 +
<      &                      (X(3,ICM) - RDENS(3))**2)
---
>      & (X(2,ICM) - RDENS(2))**2 +
>      & (X(3,ICM) - RDENS(3))**2)
106,107c109,110
< *       Copy relevant binary diagnostics to single precision.
<       AS(1) = TIME + TOFF
---
> * Copy relevant binary diagnostics to single precision.
>       AS(1) = TTOT
131,135c134
< *       Write formatted data bank on unit 9.
<       IF (FIRST) THEN
<           OPEN (UNIT=9,STATUS='NEW',FORM='FORMATTED',FILE='OUT9')
<           FIRST = .FALSE.
<       END IF
---
> * Write formatted data bank on unit 9.
137c136,139
<       WRITE (9,30)  NPAIRS, MODEL, NRUN, N, NC, NMERGE, (AS(K),K=1,7)
---
> 
> 
> 
>       WRITE (9,30) NPAIRS, MODEL, NRUN, N, NC, NMERGE, (AS(K),K=1,7)
139c141
<       WRITE (9,35)  (AS(K),K=8,17)
---
>       WRITE (9,35) (AS(K),K=8,17)
141c143
<       WRITE (9,40)  (AS(K),K=18,30)
---
>       WRITE (9,40) (AS(K),K=18,30)
151,154c153,156
<           WRITE (9,45)  EB(JPAIR), ECC(JPAIR), ECM(JPAIR), RCM(JPAIR),
<      &                  BODY(J1)*ZMBAR, BODY(J2)*ZMBAR, PB(JPAIR),
<      &                  NAME(J1), NAME(J2), KSTAR(J1), KSTAR(J2), KCM
<    45     FORMAT (F8.5,F7.3,F7.2,F6.2,2F5.1,F8.1,2I6,3I4)
---
>           WRITE (9,45) EB(JPAIR), ECC(JPAIR), ECM(JPAIR), RCM(JPAIR),
>      & BODY(J1)*ZMBAR, BODY(J2)*ZMBAR, PB(JPAIR),
>      & NAME(J1), NAME(J2), KSTAR(J1), KSTAR(J2), KCM
>    45 FORMAT (F8.5,F7.3,F7.2,F6.2,2F5.1,F8.1,2I6,3I4)
156a159,161
> 
> 
> 
1,2c1,2
< 5366 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/binout.f
< nbody6compare/binout.f
---
> 5493 2002-02-20 20:20 /work/Umi2/spurzem/5/nbody6++compare/binout.f
> nbody6++compare/binout.f
94c94,95
<               WRITE (6,35)  J, LIST(1,J1), LIST(1,J2), LIST(2,J2),
---
>               if(rank.eq.0)
>      &        WRITE (6,35)  J, LIST(1,J1), LIST(1,J2), LIST(2,J2),
108c109,110
<               WRITE (8,40)  TTOT, NAME(J1), NAME(J2), LIST(2,J2), K,
---
>               if(rank.eq.0)
>      &        WRITE (8,40)  TTOT, NAME(J1), NAME(J2), LIST(2,J2), K,
130c132,133
<       WRITE (6,60)  JOR, JEX, DB, SBCOLL, BBCOLL, CHCOLL, JC,
---
>               if(rank.eq.0)
>      &WRITE (6,60)  JOR, JEX, DB, SBCOLL, BBCOLL, CHCOLL, JC,
132c135
<    60 FORMAT (/,' OR =',I4,'  EX =',I3,'  DB =',F7.3,'  SB =',F8.4,
---
>    60 FORMAT (/,' OR =',I4,'  EX =',I3,'  DB =',F12.3,'  SB =',F8.4,
138c141,142
<       WRITE (6,65)  DISP, EMAX, (NPOP(J),J=1,8), (JEB(K),K=1,KLAST)
---
>               if(rank.eq.0)
>      &WRITE (6,65)  DISP, EMAX, (NPOP(J),J=1,8), (JEB(K),K=1,KLAST)
150c154
<       ETOT = ETOT + ESUB + EMERGE + EMDOT + ECDOT + ECOLL
---
>       ETOT = ETOT + ESUB + EMERGE + EMDOT + ECOLL + ECDOT
157,158c161,162
<       WRITE (6,90)  (E(J),J=1,10), ETOT
<    90 FORMAT (' ENERGIES   ',10F11.5,'  ETOT =',F12.6)
---
>       if(rank.eq.0) WRITE (6,90)  (E(J),J=1,10), ETOT
>    90 FORMAT (' ENERGIES   ',10F12.5,'  ETOT =',F12.6)
1,2c1,2
< 10062 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/binpop.f
< nbody6compare/binpop.f
---
> 22118 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/binpop.f
> nbody6++compare/binpop.f
0a1,4
> # 1 "binpop.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "binpop.F"
1a6,17
> C
> C P. Kroupa 1.04.94
> C
> C NOTE: This routine works for <= 100 per cent binaries as the initial
> C set up. It allows choice of an
> C initial period distribution and allows eigenevolution of orbital parameters.
> C It also MERGES the closest binaries to one star.
> C
> C NOTE: A more realistic code for pre-main sequence eigenevolution
> C is contained in binpop_mardling.f. One day it will have to be
> C included in binpop_pk.f as an aditional pre-ms evoltuion sub-routine.
> C
4,5c20,21
< *       Initial binary population.
< *       --------------------------
---
> * Initial binary population.
> * --------------------------
8,10c24,32
<       REAL*8  XORB(2),VORB(2),XREL(3),VREL(3),PX(3),QX(3),BS(NMAX)
<       REAL*4  RAN2
<       DATA  ETA1,ETA2 /2.5,45.0/
---
>       integer pkmerge,pk_sing
>       REAL*8 XORB(2),VORB(2),XREL(3),VREL(3),PX(3),QX(3),BS(NMAX)
>       REAL*4 RAN2
>       real*8 pkmergedist,EBpk
> * Additional vars for MERGED components:
>       real*8 bodypk(nmax),xpk(3,nmax),xdotpk(3,nmax)
>       real*8 bodymergepk(nmax),xmergepk(3,nmax),xdotmergepk(3,nmax)
> * Additional vars for initially single stars:
>       real*8 s_body(nmax),s_x(3,nmax),s_xdot(3,nmax)
11a34
> # 39 "binpop.F"
13c36,45
<       READ (5,*)  NBIN, SEMI0, ECC0, RATIO, RANGE, NSKIP, IDORM, ICIRC
---
> * recover random number sequence from COMMON variable IDUM1.
>       KDUM = IDUM1
> *
>       pkmerge = 0
> *
> *
>       if(rank.eq.0)
>      & READ (5,*) NBIN, SEMI0, ECC0, RATIO,RANGE, NSKIP, IDORM
> *
> # 58 "binpop.F"
16c48,49
<       WRITE (6,1)  NBIN, SEMI0, ECC0, RATIO, RANGE, NSKIP, IDORM, ICIRC
---
>       if(rank.eq.0)
>      &WRITE (6,1) NBIN, SEMI0, ECC0, RATIO, RANGE, NSKIP, IDORM
18,19c51,52
<      &              '  RATIO =',F4.1,'  RANGE =',F6.1,'  NSKIP =',I3,
<      &              '  IDORM =',I2,'  ICIRC =',I2,/)
---
>      & '  RATIO =',F4.1,'  RANGE =',F6.1,'  NSKIP =',I3,
>      & '  IDORM =',I2,/)
21c54
< *       Check type of binary mass distribution (NSKIP, IMF2 or split c.m.).
---
> * Check type of binary mass distribution (NSKIP, IMF2 or split c.m.).
25c58
< *       Select binaries from the most massive bodies (frequency NSKIP).
---
> * Select binaries from the most massive bodies (frequency NSKIP).
31c64
< *       Transfer binary masses to first NBIN locations.
---
> * Transfer binary masses to first NBIN locations.
34c67
< *       Copy binary mass of body #I to new global location.
---
> * Copy binary mass of body #I to new global location.
40c73
< *       Save next NSKIP masses of single bodies.
---
> * Save next NSKIP masses of single bodies.
46c79
< *       Restore the single bodies in subsequent locations.
---
> * Restore the single bodies in subsequent locations.
53c86
< *       Move main variables of all single bodies.
---
> * Move main variables of all single bodies.
60c93
<    12     CONTINUE
---
>    12 CONTINUE
63c96
< *       Create space for each binary component next to primary.
---
> * Create space for each binary component next to primary.
70c103
<    25     CONTINUE
---
>    25 CONTINUE
73,81c106,109
<       IF (ICIRC.NE.0) THEN
<           ICOLL = 0
<           IC0 = 0
<           IC1 = 0
<           IC2 = 0
<           IC3 = 0
<       END IF
< *
< *       Introduce binary components from relative motion.
---
> *=========================================================
> *=======================THE LOOP==========================
> *=========================================================
> * Introduce binary components from relative motion.
84,87c112,115
< *       Randomize perihelion, node & inclination (ZI = 0.25 before 3/99).
<           PI = TWOPI*RAN2(IDUM1)
<           OMEGA = TWOPI*RAN2(IDUM1)
<           ZI = 0.5*TWOPI*RAN2(IDUM1)
---
> * Randomize perihelion, node & inclination.
>           PI = TWOPI*RAN2(KDUM)
>           OMEGA = TWOPI*RAN2(KDUM)
>           ZI = 0.5*TWOPI*RAN2(KDUM)
89c117
< *       Set transformation elements (Brouwer & Clemence p. 35).
---
> * Set transformation elements (Brouwer & Clemence p. 35).
95c123
<           QX(3) = COS(PI)*SIN(ZI) 
---
>           QX(3) = COS(PI)*SIN(ZI)
97c125
< *       Specify component masses (copy BODY0 from IMF2 or use RATIO).
---
> * Specify component masses (copy BODY0 from IMF2 or use RATIO).
104c132
<               BODY(I2) = BODY(I1) 
---
>               BODY(I2) = BODY(I1)
110c138,154
< *       Choose random (thermalized) or fixed eccentricity.
---
> ***************************
> * Choose
> *
> * ECC0<0: thermal distribution f(e)=2e
> * 0<=ECC0<=1 fixed eccentricity
> * ECC0=20 a uniform distr. between 0 and 1
> * ECC0=30 an exponentially decreasing distribution akin to the data in
> * Fig.6a of Duquennoy and Mayor 1991: f(e)=0.1765/(e*e), 0.15<=e<=1
> * ECC0=40:
> * The general distribution is (9.02.94):
> * f(e) = a e^b e0<=e<=1
> * with a = (1+b) / (1-e0^(1+b))
> * Its generating function is
> * e(X) = [((1+b)/a)X + e0^(1+b)]^(1/(1+b))
> * Choose some a and b below.
> * Get thermal distribution if b=1 with e0=0
> *
112c156
<               ECC2 = RAN2(IDUM1)
---
>               ECC2 = RAN2(KDUM)
114c158,175
<           ELSE
---
>           else if (ecc0.EQ.20) then
>               ecc = RAN2(KDUM)
> *
>           else if (ecc0.EQ.30) then
>               ecc = 1./0.15 - RAN2(KDUM)/0.1765
>               ecc = 1./ecc
> *
>           else if (ecc0.EQ.40) then
>               PK_e0 = 0.D0
>               PK_b = 1.D0
>               PK_a = (1.D0+PK_b) / (1.D0 - PK_e0**(1.D0+PK_b))
> 
>               ecc = RAN2(KDUM)
>               ecc = ((PK_b+1.D0)/PK_a)*ecc + PK_e0**(1.D0+PK_b)
>               ecc = ecc**(1.D0/(1.D0+PK_b))
> *
> *
>           ELSE if (ecc0.GE.0.0.AND.ecc0.LE.1.) then
118,124c179
< *       Select semi-major axis from uniform distribution in log(A) or SEMI0.
<           IF (RANGE.GT.0.0) THEN
<               EXP1 = RAN2(IDUM1)*LOG10(RANGE)
<               SEMI = SEMI0/10.0**EXP1
<           ELSE
<               SEMI = SEMI0
<           END IF
---
> *****************************
126,198c181,311
< *       Check for eigen-evolution (Pavel Kroupa & Rosemary Mardling).
<           IF (ICIRC.NE.0) THEN
<               ZMB = (BODY(I1) + BODY(I2))*ZMBAR
< *       Include minimum period (copy RANGE; at least 1 day).
<               PMIN = MAX(RANGE,1.0D0)
<               IT = 0
<    35         XR = RAN2(IDUM1)
< *       Generate period distribution (Pavel Kroupa: MN 277, 1491, eq.11b).
<               P0 = LOG10(PMIN) + SQRT(ETA2*(EXP(2.0*XR/ETA1) - 1.0))
<               TK = 10.0**P0
< *       Invert eccentricity from thermal distribution (XR = E**2).
<               XR = RAN2(IDUM1)
<               ES0 = SQRT(XR)
< *       Set pericentre distance in AU with period in days & mass in SU.
<               RP0 = (1.0 - ES0)*((TK/365.0)**2*ZMB)**0.3333
< *       Convert to N-body units.
<               RP0 = RP0/RAU
<               A0 = RP0/(1.0 - ES0)
<               E0 = ES0
< *       Limit the maximum semi-major axis to 1000 AU.
<               IF (A0*RAU.GT.1000.0) GO TO 35
< *       Define K* = 0/1 and enhanced radii for pre-main sequence.
<               KSTAR(I1) = 1
<               KSTAR(I2) = 1
<               IF (BODY(I1)*ZMBAR.LT.0.7) KSTAR(I1) = 0
<               IF (BODY(I2)*ZMBAR.LT.0.7) KSTAR(I2) = 0
<               RADIUS(I1) = 5.0*SQRT(BODY(I1)*ZMBAR)/SU
<               RADIUS(I2) = 5.0*SQRT(BODY(I2)*ZMBAR)/SU
<               IF (RP0.LT.MAX(RADIUS(I1),RADIUS(I2))) THEN
<                   WRITE (6,38)  I1, ZMB, ES0, A0, RP0
<    38             FORMAT (12X,'COLLISION:    I1 MB E A RP ',
<      &                                       I6,F6.1,F7.3,1P,2E10.2)
<                   ICOLL = ICOLL + 1
<                   GO TO 35
<               END IF
< *       Perform eigen-evolution of pericentre & eccentricity for 10^6 yrs.
<               TC = -1.0/TSCALE
<               CALL TCIRC(RP0,ES0,I1,I2,ICIRC,TC)
< *       Copy modified eccentricity and re-evaluate the semi-major axis.
<               ECC = ES0
<               SEMI = RP0/(1.0 - ECC)
<               IT = IT + 1
<               IF (SEMI.GT.SEMI0.AND.IT.LT.25) GO TO 35
<               TK = 365.0*SQRT((SEMI*RAU)**3/ZMB)
<               IF (ECC.LE.0.002) IC0 = IC0 + 1
<               IF (TK.LT.PMIN) IC1 = IC1 + 1
<               IF (TK.LT.2.0*PMIN) IC2 = IC2 + 1
<               IF (TK.LT.5.0*PMIN) IC3 = IC3 + 1
<               WRITE (23,40)  IT, I1, ZMB, E0, ECC, A0, SEMI, TK
<    40         FORMAT (12X,'BINARY:   IT I1 MB E0 E A0 A P ',
<      &                               I2,I5,F5.1,2F7.3,1P,3E10.2)
<               CALL FLUSH(23)
<           ELSE IF (KZ(27).EQ.1.OR.KZ(19).GE.3) THEN
< *       Obtain tidal encounter distance (4*RADIUS) from square root relation.
<               RSUN = 1.0/SU
<               ZM = MAX(BODY(I1),BODY(I2))*ZMBAR
<               RT = 4.0*RSUN*SQRT(ZM)
< *       Modify orbital elements to avoid tidal interaction or collision.
<    42         IF (SEMI*(1.0 - ECC).LT.2.0*RT) THEN
< *       Increase semi-major axis or reduce eccentricity until peri > 2*RT.
<    44             IF (SEMI.LT.2.0*RT) THEN
<                       SEMI = 2.0*SEMI
<                       GO TO 44
<                   ELSE
<                       ECC = 0.9*ECC
<                   END IF
<                   WRITE (17,46)  I1, I2, ECC, SEMI, SEMI*(1.0-ECC), RT
<    46             FORMAT (12X,'REDUCE ECC:    I1 I2 E A PM RT ',
<      &                                        2I5,F7.3,1P,3E10.2)
<                   CALL FLUSH(17)
<                   GO TO 42
<               END IF
<           END IF
---
> * Select semi-major axis from uniform distribution in log(A),
> * or a uniform distribution in the range semi0 (=min. ecc.)
> * to semi0+range (=max. ecc.), or SEMI0.
> *
> * Use distribution in semi-major axis if
> * BK(2)=0: RANGE>0: uniform distribution in log(semi) between SEMI0 and
> * SEMI0/RANGE
> * RANGE<0: uniform distribution in semi between SEMI0 and -1*RANGE.
> *
> * Use distribution in logP(days) if
> * BK(2)=1: linearly increasing distribution function f=0.03438*logP
> * BK(2)=2: f=3.5logP/[100+(logP)**2]
> * BK(2)=1,2 are 1st and 2nd iterations!
> * BK(2)=3: f=2.3(logP-1)/[45+(logP-1)**2] This is a "3rd" iteration when
> * pre-ms evolution is taken into account with BK(1).NE.0.
> * BK(2)=4: f=2.5(logP-1)/[45+(logP-1)**2] This is a "34th" iteration when
> * pre-ms evolution is taken into account with BK(1).NE.0, and
> * RBAR<1.5 (in runs /run34n RBAR=1.5 with BK(2)=3 lead to
> * wrong qone distr.
> * BK(2)=5: Duquennoy & Mayor 1991, Gaussian distr.
> * with mean logP=4.8, SDEV in logP=2.3. Use Num.Recipes
> * routine "gasdev.f" to obtain random deviates given "idum1".
> *========= BK(2) = 0 ========
>           if (BK(2).EQ.0) then
>              IF (RANGE.GT.0.0) THEN
>                  EXP1 = RAN2(KDUM)*LOG10(RANGE)
>                  SEMI = SEMI0/10.0**EXP1
>              else if (range.LT.0.0) then
>                  exp1 = RAN2(KDUM)*(-1*range-semi0)
>                  semi = semi0 + exp1
>              ELSE
>                  SEMI = SEMI0
>              END IF
> *========= BK(2) = 1 ========
>           else if (BK(2).EQ.1) then
> * exp = logP(days)
>              exp1 = SQRT(RAN2(KDUM)*2.0/0.03438)
> * Period in yrs:
>              exp1 = 10**exp1 /365.25
> * transform to semi-major axis in model units to continue prgrm from here
> * as before (i.e. when semi-major axis is chosen): Use Kepler law:
> * M1+M2 = a**3/P**2, where mass is in Msun, and a is in AU.
>              semi = (BODY(I1)+BODY(I2))*ZMBAR*exp1*exp1
>              semi = semi**(1./3.)
> * semi in pc and then in modell units:
>              semi = semi/206259.591
>              semi = semi/RBAR
> *========= BK(2) = 2 ========
>           else if (BK(2).EQ.2) then
>              exp1 = EXP(2.0*RAN2(KDUM)/3.50) - 1.
>              exp1 = SQRT(exp1*100.)
> * exp = logP(days)
> * Period in yrs:
>              exp1 = 10**exp1 /365.25
> * transform to semi-major axis in model units to continue prgrm from here
> * as before (i.e. when semi-major axis is chosen): Use Kepler law:
> * M1+M2 = a**3/P**2, where mass is in Msun, and a is in AU.
>              semi = (BODY(I1)+BODY(I2))*ZMBAR*exp1*exp1
>              semi = semi**(1./3.)
> * semi in pc and then in modell units:
>              semi = semi/206259.591
>              semi = semi/RBAR
> *========= BK(2) = 3 ========
>           else if (BK(2).EQ.3) then
>              exp1 = EXP(2.D0*RAN2(KDUM)/2.3D0) - 1.D0
>              exp1 = SQRT(exp1*45.D0) + 1.D0
> * exp = logP(days)
> * Period in yrs:
>              exp1 = 10**exp1 /365.25D0
> * transform to semi-major axis in model units to continue prgrm from here
> * as before (i.e. when semi-major axis is chosen): Use Kepler law:
> * M1+M2 = a**3/P**2, where mass is in Msun, and a is in AU.
>              semi = (BODY(I1)+BODY(I2))*ZMBAR*exp1*exp1
>              semi = semi**(1.D0/3.D0)
> * semi in pc and then in modell units:
>              semi = semi/206259.591D0
>              semi = semi/RBAR
> *========= BK(2) = 4 ========
>           else if (BK(2).EQ.4) then
>              exp1 = EXP(2.D0*RAN2(KDUM)/2.5D0) - 1.D0
>              exp1 = SQRT(exp1*45.D0) + 1.D0
> * exp = logP(days)
> * Period in yrs:
>              exp1 = 10**exp1 /365.25D0
> * transform to semi-major axis in model units to continue prgrm from here
> * as before (i.e. when semi-major axis is chosen): Use Kepler law:
> * M1+M2 = a**3/P**2, where mass is in Msun, and a is in AU.
>              semi = (BODY(I1)+BODY(I2))*ZMBAR*exp1*exp1
>              semi = semi**(1.D0/3.D0)
> * semi in pc and then in modell units:
>              semi = semi/206259.591D0
>              semi = semi/RBAR
> *========= BK(2) = 5 ========
>           else if (BK(2).EQ.5) then
>              exp1 = -10.
> C Only accept periods logP>1, i.e. longer than 10 days at birth
> C AND periods shorter than 10^(10) days!
>              do while (exp1.LT.-1.6522)
>                 exp1 = GASDEV_pk(KDUM)
>                 if (exp1.GT.2.2696) exp1=-10.
>              end do
> * exp1 is now a Gaussian deviate with mean zero and unit variance
> * Transform to mean=4.8 and variance = 2.3*2.3, i.e to logP, P in days
>             exp1 = 2.3*exp1 + 4.8
> * exp = logP(days)
> * Period in yrs:
>              exp1 = 10**exp1 /365.25D0
> * transform to semi-major axis in model units to continue prgrm from here
> * as before (i.e. when semi-major axis is chosen): Use Kepler law:
> * M1+M2 = a**3/P**2, where mass is in Msun, and a is in AU.
>              semi = (BODY(I1)+BODY(I2))*ZMBAR*exp1*exp1
>              semi = semi**(1.D0/3.D0)
> * semi in pc and then in modell units:
>              semi = semi/206259.591D0
>              semi = semi/RBAR
> *========= BK(2) = ? ========
>           else
>              if(rank.eq.0)write(6,*)' No BK(2) defined!!!!! '
>              STOP
>           end if
> *
> *
> * At this stage we have the mases, eccentricity and period of each binary
> * at "birth", i.e. prior to circularisation and "feeding". Now evolve these
> * to very, very roughly take into account complete circularisation,
> * partial circularisation and "feeding". Do this if option BK(1)=1:
> * (i.e. mass-exchange at proto-stellar time):
>           if (BK(1).EQ.1) then
>              call proto_star_evol(
>      & ZMBAR,RBAR,BODY(I1),BODY(I2),ECC,SEMI)
>           end if
200c313
< *       Specify relative motion at apocentre and sum binding energy.
---
> * Specify relative motion at apocentre.
206c319,321
<           EBIN0 = EBIN0 - 0.5*BODY(I1)*BODY(I2)/SEMI
---
>           EBpk = -0.5*BODY(I1)*BODY(I2)/SEMI
> C Moved below to account for accepted binaries only.
> C EBIN0 = EBIN0 - 0.5*BODY(I1)*BODY(I2)/SEMI
208,209c323,324
< *       Transform to relative variables.
<           DO 50 K = 1,3
---
> * Transform to relative variables.
>           DO 40 K = 1,3
212c327
<    50     CONTINUE
---
>    40 CONTINUE
214,215c329,330
< *       Set global variables for each component.
<           DO 55 K = 1,3
---
> * Set global variables for each component.
>           DO 50 K = 1,3
220c335,379
<    55     CONTINUE
---
>    50 CONTINUE
> *
> *
> * Merge binaries that have semi.LE.10 solar radii (all in AU):
> * Solar radius in AU is 4.6523D-3.
>           semi = semi*RBAR*206259.591D0
>           pkmergedist = 10.D0 * 4.6523D-3
> c pkmergedist = 50000.D0 * 4.6523D-3
>           J1 = I1 -2*pkmerge
>           J2 = I2 -2*pkmerge
>           if (semi.LE.pkmergedist) then
>              pkmerge = pkmerge + 1
>              ZMBIN = BODY(I1) + BODY(I2)
> C Added 20.8.96:
>              if(rank.eq.0)then
>              write(6,*)
>              write(6,*)' MERGED stars in binpop_pk.f:'
>              write(6,*)' mass1, mass2, total mass [Msun]'
>              write(6,'(3F8.3)')body(I1)*ZMBAR,body(I2)*ZMBAR,
>      + zmbin*ZMBAR
>              end if
> C End added bit.
>              do K = 1,3
>                  Xmergepk(K,pkmerge) = (BODY(I1)*X(K,I1) +
>      & BODY(I2)*X(K,I2))/ZMBIN
>                  XDOTmergepk(K,pkmerge) = (BODY(I1)*XDOT(K,I1) +
>      & BODY(I2)*XDOT(K,I2))/ZMBIN
>              end do
>              BODYmergepk(pkmerge) = ZMBIN
>           else
> C Sum binding energy for accepted binaries.
>              EBIN0 = EBIN0 + EBpk
>              bodypk(J1) = body(I1)
>              bodypk(J2) = body(I2)
>              do k=1,3
>                 xpk(k,J1) = x(k,I1)
>                 xpk(k,J2) = x(k,I2)
>                 xdotpk(k,J1) = xdot(k,I1)
>                 xdotpk(k,J2) = xdot(k,I2)
>              end do
>           end if
> *
> *=========================================================
> *=================end of THE LOOP=========================
> *=========================================================
223c382,397
< *       Update the total particle number after primary splitting or IMF2.
---
> C Kroupa: 5.11.96
> C Take into account possible initial single stars. Before merging above
> C these occupy positions: 2*NBIN+1....N+NBIN (before merging the stars
> C in binaries occupy positions 1,2,....2*NBIN).
>       pk_sing = 0
>       do i=2*NBIN+1,N+NBIN
>          pk_sing = pk_sing+1
>          s_body(pk_sing)=body(i)
>          do k=1,3
>             s_x(k,pk_sing) = x(k,i)
>             s_xdot(k,pk_sing) = xdot(k,i)
>          end do
>       end do
> *
> * Update the total particle number after primary splitting or IMF2
> * and introduce additional counters for MERGING:
229,233c403,407
<           IF (NSKIP.GT.0) THEN
<               WRITE (6,62)  (BODY(J),J=1,10)
<               WRITE (6,64)  (BODY(J),J=2*NBIN+1,2*NBIN+10)
<    62         FORMAT (/,12X,'BINARY MASSES (1-10):  ',10F9.5)
<    64         FORMAT (/,12X,'SINGLE MASSES (1-10):  ',10F9.5,/) 
---
>           IF (rank.eq.0.and.NSKIP.GT.0) THEN
>               WRITE (6,62) (BODY(J),J=1,10)
>               WRITE (6,64) (BODY(J),J=2*NBIN+1,2*NBIN+10)
>    62 FORMAT (/,12X,'BINARY MASSES (1-10):  ',10F9.5)
>    64 FORMAT (/,12X,'SINGLE MASSES (1-10):  ',10F9.5,/)
237c411,517
< *       Include procedure for introducing dormant binaries.
---
>       Npk = N - pkmerge
>       NZEROpk = Npk
>       NTOTpk = Npk
>       NBINpk = NBIN - pkmerge
> 
> c+++
> CCCCCCCCCCCC for testing:
>         if(rank.eq.0)then
>         write(6,*)
>         write(6,*)' In BINPOP_PK :'
>         write(6,*)'****************************************'
>         write(6,*)'N,NBIN,NBIN0,NBINpk,pkmerge,Npk,pk_sing:'
>         write(6,'(7(I6))')N,NBIN,NBIN0,NBINpk,pkmerge,
>      + Npk,pk_sing
> c write(6,*)
> c write(6,*)
> c write(6,*)' original stars'
> c do i=1,N
> c write(6,'(I4,7(F8.3))') i,body(i)*ZMBAR,
> c + (X(k,i),xdot(k,i),k=1,3)
> c end do
> c write(6,*)
> c write(6,*)
> c write(6,*)' remaining binaries'
> c do i=1,2*NBINpk
> c write(6,'(I4,7(F8.3))') i,bodypk(i)*ZMBAR,
> c + (Xpk(k,i),xdotpk(k,i),k=1,3)
> c end do
> c write(6,*)
> c write(6,*)' merged ones:'
> c do i=1,pkmerge
> c write(6,'(I4,7(F8.3))') i,bodymergepk(i)*ZMBAR,
> c + (Xmergepk(k,i),xdotmergepk(k,i),k=1,3)
> c end do
> c write(6,*)'****************************************'
> c call flush(6)
>          end if
> CCCCCCCCCCCCCC
> *
> * Now overwrite the old vars with the MERGED ones:
>       N = Npk
>       NTOT = ntotpk
>       NZERO = nzeropk
>       NBIN0 = NBIN0 - pkmerge
>       NBIN = NBINpk
> C The stars in remaining binaries:
>       do i=1,2*NBIN
>          body(i) = bodypk(i)
>          do k=1,3
>             x(k,i) = xpk(k,i)
>             xdot(k,i) = xdotpk(k,i)
>          end do
>       end do
> C Add merged (i.e single) stars to end of the above list of stars in binaries:
>       j = 2*NBIN
>       do i=1,pkmerge
>          j = j+1
>          body(j) = bodymergepk(i)
>          do k=1,3
>             x(k,j) = xmergepk(k,i)
>             xdot(k,j) = xdotmergepk(k,i)
>          end do
>       end do
> C Add the initially single stars again at end of the lot:
>       do i=1,pk_sing
>          j=j+1
>          body(j) = s_body(i)
>          do k=1,3
>             x(k,j)=s_x(k,i)
>             xdot(k,j)=s_xdot(k,i)
>          end do
>       end do
> *
> C Added 11.08.98 with Sverre Aarseth: (body0 needed for
> C stellar evolution!)
>       if (j.ne.ntot) then
>          if(rank.eq.0)
>      & write(6,*)j,ntot,' ****** j & ntot must be equal ******'
>          stop
>       end if
> *
>       zmass = 0.D0
>       do i=1,ntot
>          body0(i) = body(i)
>          zmass = zmass + body0(i)
>       end do
>       BODYM = ZMASS/FLOAT(N)
>       if(rank.eq.0)then
>       write(6,*)
>       write(6,*)' BODYM, ZMASS and BODY0(i) updated.'
>       write(6,'(2(a,F10.4))')' BODYM= ',BODYM,' ZMASS= ',ZMASS
>       write(6,*)
> *
> c+++ for testing:
> c write(6,*)
> c write(6,*)
> c write(6,*)' After merging & re-arranging:'
> c write(6,*)' N,NBIN0,NTOT: ',N,NBIN0,NTOT
> c do i=1,N
> c write(6,'(I3,7(F8.3))')i,body(i)*ZMBAR,
> c + (x(k,i),xdot(k,i),k=1,3)
> c end do
> c call flush(6)
>        end if
> *
> *
> * Include procedure for introducing dormant binaries.
246,247c526,527
<      &                         BODY(I2)*XDOT(K,I2))/ZMBIN
<    65         CONTINUE
---
>      & BODY(I2)*XDOT(K,I2))/ZMBIN
>    65 CONTINUE
249c529
<    66     CONTINUE
---
>    66 CONTINUE
251c531
< *       Move the original single particles up to form compact array.
---
> * Move the original single particles up to form compact array.
260,261c540,541
<    67         CONTINUE
<    68     CONTINUE
---
>    67 CONTINUE
>    68 CONTINUE
263c543
< *       Reset particle membership and turn off binary output option (if = 1).
---
> * Reset particle membership and turn off binary output option (if = 1).
272c552
< *       Set coordinates & velocities in c.m. rest frame.
---
> * Set coordinates & velocities in c.m. rest frame.
282c562
<    75     CONTINUE
---
>    75 CONTINUE
289c569
<    85     CONTINUE
---
>    85 CONTINUE
291a572,574
> * Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
> *
294a578,706
> C=======================================================
>       subroutine proto_star_evol(ZMBAR,RBAR,mass1,mass2,ECC,SEMI)
> *
>       implicit none
>       real*8 mass1,mass2,ecc,semi,period
>       real*8 ecc_initial,period_initial
>       real*8 qnew,qold,mtot,Ro,mtot_initial
>       real*8 R_periastron,alpha,beta
>       real*8 ZMBAR,RBAR,au,Rsun
> * astr. unit, solar radius, all in AU (1pc=206259.591AU)
>       parameter(au=206259.591D0,Rsun=4.6523D-3)
> *
> *
> *==============================
> * Choose these to define the model: (alpha==lambda, beta==chi)
> *
> c alpha = 10.D0
> c beta = 1.D0
> * best values:
>       alpha = 28.D0
>       beta = 0.75D0
> *==============================
> *
> *
> *
> * in Msun:
>       mtot = (mass1+mass2)*ZMBAR
>       mtot_initial = mtot
> * in AU:
>       semi = semi*RBAR*au
> * in years:
>       period = semi*semi*semi/mtot
>       period = DSQRT(period)
>       ecc_initial = ecc
>       period_initial = period
> *
> * 1) Circularisation and evolution of orbit as a function of
> * periastron distance (Ro in AU):
> * Note that the algorithm used here leads to circularised orbits for
> * logP<=1 approximately!! (if beta=1.5,alpha=35 approximately)
>       Ro = alpha *Rsun
>       R_periastron = semi*(1.D0-ecc)
>       alpha = -1.D0*(Ro/R_periastron)**beta
>       if (ecc.GT.0.D0) then
>          ecc = DEXP(alpha + DLOG(ecc))
>       else
>          ecc = ecc_initial
>       end if
> *
> * 2) Change mass-ratio towards unity as a function of initial periastron
> * distance:
> *
>       qold = mass1/mass2
>       if (qold.GT.1.D0) qold = 1.D0/qold
>       alpha = -1.D0*alpha
>       if (alpha.GT.1.D0) then
>          qnew = 1.D0
>       else
>          qnew = qold + (1.D0-qold) * alpha
>       end if
> *
> * new masses in model units (remembering q=m1/m2<1) if mass is conserved
> * NOT IMPLEMENTED!
> c mtot = mtot/ZMBAR
> c mass1 = mtot/(qnew+1.D0)
> c mass2 = mtot - mass1
> *
> * Keep the mass of primary fixed and adjust mass of secondary. Note that this
> * algorithm leads to a gain in mass of the binary, and thus of the whole
> * cluster!
> *
> C Added 20.06.96 write statements:
> * if(rank.eq.0)then
> * write(6,*)
> * write(6,*)' FEEDING in binpop_pk.f'
> * write(6,'(a,2F8.3)')' old masses [Msun]:',
> * + mass1*ZMBAR,mass2*ZMBAR
>         mass1 = DMAX1(mass1,mass2)
>         mass2 = qnew*mass1
> * write(6,'(a,2F8.3)')' new masses [Msun]:',
> * + mass1*ZMBAR,mass2*ZMBAR
> * end if
> C End added bit.
> *
> * In Msun:
>         mtot = (mass1+mass2)*ZMBAR
> *
> C This below is wrong as in ecc formula above constant Rperi was assumed!!!
> c* Duquennoy et al. 1992 in "Binaries as tracers of stellar evolution":
> c period = period_initial * DEXP((57.D0/14.D0) *
> c & (ecc*ecc - ecc_initial*ecc_initial))
> C This below is correct:
>        period = period_initial*((1.D0-ecc_initial)/(1.D0-ecc))**1.5D0
>        period = period * DSQRT(mtot_initial/mtot)
> *
> *
> * New semi-major axis and back to model units:
>       semi = mtot * period*period
>       semi = semi**(1.D0/3.D0)
>       semi = semi/(RBAR*au)
> *
>       return
>       end
> C=======================================================
>       FUNCTION gasdev_pk(idum)
>       INTEGER idum
>       REAL gasdev_pk
> CU USES ran1
> C P.Kroupa: 8.11.96: changed to RAN2
>       INTEGER iset
>       REAL fac,gset,rsq,v1,v2,ran2
>       SAVE iset,gset
>       DATA iset/0/
>       if (iset.eq.0) then
> 1 v1=2.*ran2(idum)-1.
>         v2=2.*ran2(idum)-1.
>         rsq=v1**2+v2**2
>         if(rsq.ge.1..or.rsq.eq.0.)goto 1
>         fac=sqrt(-2.*log(rsq)/rsq)
>         gset=v1*fac
>         gasdev_pk=v2*fac
>         iset=1
>       else
>         gasdev_pk=gset
>         iset=0
>       endif
>       return
>       END
> C (C) Copr. 1986-92 Numerical Recipes Software >).
1,2c1,2
< 708 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/block.f
< nbody6compare/block.f
---
> 647 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/block.f
> nbody6++compare/block.f
9c9
<       COMMON/RAND2/  IY,IFF,IR(97) 
---
>       COMMON/RAND/  IY,IFF,IR(97) 
15d14
<       COMMON/COUNTS/  NCOUNT(60)
24d22
<       DATA  NCOUNT  /60*0/
1,2c1,2
< 4426 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/bodies.f
< nbody6compare/bodies.f
---
> 4496 2000-08-21 21:05 /work/Umi2/spurzem/5/nbody6++compare/bodies.f
> nbody6++compare/bodies.f
35c35,36
<           WRITE (6,6)  I, NAME(I), BODY(I), STEP(I), STEPR(I), EI, RI,
---
>           if(rank.eq.0)
>      &    WRITE (6,6)  I, NAME(I), BODY(I), STEP(I), STEPR(I), EI, RI,
83c84,85
<           WRITE (6,35)  NAME(I), NAME(JMIN), BODY(I), BODY(JMIN), EREL,
---
>           if(rank.eq.0)
>      &    WRITE (6,35)  NAME(I), NAME(JMIN), BODY(I), BODY(JMIN), EREL,
85,86c87,88
<    35     FORMAT ('   BINARY ',2I5,2F8.4,F9.1,1P,4E10.2,0P,F7.2,2I5,
<      &                                              1P,E10.1,0P,F7.2,I4)
---
>    35     FORMAT ('   BINARY ',2I5,2F8.4,F9.1,1P4E10.2,0PF7.2,2I5,
>      &                                                1PE10.1,0PF7.2,I4)
107c109,110
<           WRITE (6,35)  NAME(I), NAME(JMIN), BODY(I), BODY(JMIN),
---
>           if(rank.eq.0)
>      &    WRITE (6,35)  NAME(I), NAME(JMIN), BODY(I), BODY(JMIN),
1,2c1,2
< 6957 2006-02-17 09:31 /work/Umi2/spurzem/5/nbody6compare/brake.f
< nbody6compare/brake.f
---
> 6121 2001-08-04 21:22 /work/Umi2/spurzem/5/nbody6++compare/brake.f
> nbody6++compare/brake.f
8c8
<       REAL*8 M1,M2,MFAC
---
>       REAL*8 M1,M2
52a53
>       GM = 1.3D+26
64,66c65
< *     ADOT = 2.0*SQRT(ACM/GMS)*ZJDOT/(1.989D+33*ZMBAR*ZMU)
< *       Ignore magnetic braking for now.
<       ADOT = 0.0
---
>       ADOT = 2.0*SQRT(ACM/GMS)*ZJDOT/(1.989D+33*ZMBAR*ZMU)
68,69c67,68
< *       Evaluate time scale for spin-down (yrs).
< *     TBR = ACM/(3.147D+07*ADOT)
---
> *       Define old primary and evaluate time scale for spin-down (yrs).
>       TBR = ACM/(3.147D+07*ADOT)
71c70
< *       Form alternative expression derived by J/JDOT (factor 2 longer).
---
> *       Evaluate alternative expression derived by J/JDOT (factor 2 longer).
77,81d75
< *       Set constants in N-body units.
<       CLIGHT = 3.0D+05/VSTAR
<       GMC = 1.0/CLIGHT**2
<       MFAC = BODY(I1)*BODY(I2)*BODY(I)
< *
84,90c78
< *     AGDOT = 1.23D+27*MFAC*(ZMBAR/ACM)**3
< *       Convert from cgs to scaled units.
< *     AGDOT = AGDOT/(1.0D+05*VSTAR)
< *       Adopt equivalent expression in N-body units (check agrees).
<       AGDOT = 64.0/5.0*GMC**3*CLIGHT*MFAC/SEMI**3
<       FE = (1.0 + 73.0/24.0*ECC2 + 37.0/96.0*ECC2**2)/(1.0 - ECC2)**3.5
<       AGDOT = AGDOT*FE
---
>       AGDOT = 1.23D+27*BODY(I1)*BODY(I2)*BODY(I)*(ZMBAR/ACM)**3
93,99d80
< *       Treat eccentricity change in similar way using N-body units.
<       ECC = SQRT(ECC2)
< *     EFAC = 304.0*((6.67D-08*1.989D+33)/3.0D+10)**3/(15.0*9.0D+20)
<       EFAC = 304.0/15.0*GMC**3*CLIGHT*MFAC/SEMI**4
<       FE2 = ECC*(1.0 + 121.0/304.0*ECC2)/(1.0 - ECC2)**2.5
<       EDOT = EFAC*FE2
< *
101,105c82,86
< *     IF (((M2.GT.1.3.OR.M2.LT.0.3).AND.KSTAR(J2).LE.2).OR.
< *    &      KSTAR(J2).GE.10) THEN
< *         ADOT = 0.0
< *         TBR = 1.0D+10
< *     END IF
---
>       IF (((M2.GT.1.3.OR.M2.LT.0.3).AND.KSTAR(J2).LE.2).OR.
>      &      KSTAR(J2).GE.10) THEN
>           ADOT = 0.0
>           TBR = 1.0D+10
>       END IF
110c91
< *       Set time-step to 1% change (with limit of 1) and new look-up time.
---
> *       Set time-step to 1% change and new look-up time (cf. MDOT re #34).
112d92
<       DT = MIN(DT,1.0D0)
115c95,96
< *       Modify new semi-major axis and eccentricity (E_max = 0.002).
---
> *       Convert from cgs to scaled units and update semi-major axis.
>       ADOT = ADOT/(1.0D+05*VSTAR)
117,118d97
<       ECC1 = ECC - EDOT*DT
<       ECC1 = MAX(ECC1,0.002D0)
129a109,114
> *       Form square of regularized velocity.
>       V20 = 0.0
>       DO 10 K = 1,4
>           V20 = V20 + UDOT(K,IPAIR)**2
>    10 CONTINUE
> *
136,139c121,123
<       RP0 = SEMI*(1.0 - ECC)
<       QPERI = SEMI1*(1.0 - ECC1)
<       C1 = SQRT(QPERI/RP0)
<       C2 = SQRT((BODY(I) + H(IPAIR)*QPERI)/(BODY(I) + HI*RP0))
---
>       C2 = SQRT(SEMI1/SEMI)
>       V2 = 0.5*(BODY(I) + H(IPAIR)*SEMI1*(1.0 - SQRT(ECC2)))
>       C1 = SQRT(V2/V20)
141c125
< *       Re-scale KS variables to new energy.
---
> *       Re-scale KS variables to new energy with constant eccentricity.
145,146c129,130
<           U(K,IPAIR) = C1*U(K,IPAIR)
<           UDOT(K,IPAIR) = C2*UDOT(K,IPAIR)
---
>           U(K,IPAIR) = C2*U(K,IPAIR)
>           UDOT(K,IPAIR) = C1*UDOT(K,IPAIR)
149c133
<           TDOT2(IPAIR) = TDOT2(IPAIR) + 2.0*U(K,IPAIR)*UDOT(K,IPAIR)
---
> *         TDOT2(IPAIR) = TDOT2(IPAIR) + 2.0*U(K,IPAIR)*UDOT(K,IPAIR)
152,162c136,137
< *       Initialize perturbed orbit.
<       IF (LIST(1,I1).GT.0) THEN
<           CALL RESOLV(IPAIR,1)
<           IMOD = KSLOW(IPAIR)
<           CALL KSPOLY(IPAIR,IMOD)
<       END IF
< *
< *       Transform back to apocentre for standard perturbed motion.
< *     IF (LIST(1,I1).GT.0) THEN
< *         CALL KSAPO(IPAIR)
< *     END IF
---
> *       Transform back to apocentre for standard unperturbed motion.
>       CALL KSAPO(IPAIR)
169c144
<               WRITE (6,25)  TIME, IPAIR, M2, R2, TGR, R(IPAIR),
---
>               WRITE (6,25)  TIME, IPAIR, M2, R2, TBR, TGR, R(IPAIR),
171,172c146,147
<    25         FORMAT (' BRAKE    T KS M2 R2 TGR R RCOLL ',
<      &                           F10.4,I4,F6.2,F7.3,1P,E9.1,2E10.2)
---
>    25         FORMAT (' BRAKE    T KS M2 R2 TBR TGR R RCOLL ',
>      &                           F10.4,I4,F6.2,F7.3,1P,2E9.1,2E10.2)
203,205c178,180
<      &                  ECC1, SEMI1, R(IPAIR), RCOLL, TK
<    30     FORMAT (' END BRAKE    T NAM K* EF AF R RCOLL P ',
<      &                           F10.4,2I6,2I4,F7.3,1P,4E9.1)
---
>      &                  M2, R2, TBR, TGR, R(IPAIR), RCOLL, TK
>    30     FORMAT (' END BRAKE    T NAM K* M2 R2 TBR TGR R RCOLL P ',
>      &                           F10.4,2I6,2I4,F6.2,F7.3,1P,5E9.1)
215a191
> 
1,2c1,2
< 1398 1999-11-03 09:53 /work/Umi2/spurzem/5/nbody6compare/cfuncs.f
< nbody6compare/cfuncs.f
---
> 1398 1999-11-03 09:53 /work/Umi2/spurzem/5/nbody6++compare/cfuncs.f
> nbody6++compare/cfuncs.f
1,2c1,2
< 22521 2006-09-08 12:34 /work/Umi2/spurzem/5/nbody6compare/chain.f
< nbody6compare/chain.f
---
> 21872 2005-03-09 22:47 /work/Umi2/spurzem/5/nbody6++compare/chain.f
> nbody6++compare/chain.f
12a13,15
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
30d32
<       COMMON/SWCALL/ NCALL
107c109
<       DO 2 J = 1,10
---
>       DO 1 J = 1,10
127d128
<       NCALL = 0
150d150
<           RCOLL = 0.0
232,233c232,233
<       GCRIT = 1.0D-05
<       IF (N.GT.4) GCRIT = 5.0D-06
---
>       GCRIT = 5.0D-05
>       IF (N.GT.4) GCRIT = 1.0D-05
236c236,237
<           WRITE (6,15)  N, NPERT, ENERGY, RSUM, RGRAV, TCR, RMAXS(ISUB),
---
>           if(rank.eq.0)
>      &    WRITE (6,15)  N, NPERT, ENERGY, RSUM, RGRAV, TCR, RMAXS(ISUB),
372c373
<           WRITE (6,*) ' Stepsize = 0!', char(7)
---
>           if(rank.eq.0)WRITE (6,*) ' Stepsize = 0!', char(7)
376c377
<       IF (KZ30.GT.2) THEN
---
>       IF (rank.eq.0.and.KZ30.GT.2) THEN
381c382
< *       Determine two-body distances for stability test and collision search.
---
> *       Update sum of 1/R^2 during forward integration (R^2 before 12/99).
386c387
< *       Find minimum separation for stability test and save chain index.
---
> *       Find minimum separation and chain index.
393d393
< *       Update sum of 1/R^2 during forward integration (R^2 before 12/99).
400c400
< *       Set search distance for closest separation.
---
> *       Specify search distance of two closest particles (2 x 4*r_max).
403,424c403,409
<           SX = MAX(SIZE(I1),SIZE(I2))
< *       Turn off circular orbit indicators for overlapping stars.
<           IF (IMCIRC.GT.0) THEN
<               IF (RM.LT.2.0*SX) THEN
<                   SX = 0.5*RM
<                   NCIRC = 0
<                   ISYNC = 0
<                   IMCIRC = 0
<               ELSE
<                   SX = 0.0
<               END IF
<           END IF
< *       See whether another star is a more likely collider (compare SIZE/R).
<           RY = RM
<           DO 36 K = 1,N-1
<               IF (K.NE.IX) THEN
<                   J1 = INAME(K)
<                   J2 = INAME(K+1)
<                   SY = MAX(SIZE(J1),SIZE(J2))
<                   IF (SY*RINV(K).GT.SX/RY) THEN
<                       SX = SY
<                       RY = 1.0/RINV(K)
---
>           RX = 8.0*MAX(SIZE(I1),SIZE(I2))
> *       Exclude circular binary from pericentre test (N = 3 is OK).
>           IF (IMCIRC.GT.0.AND.N.GT.3) THEN
>               RY = 0.0
>               DO 36 K = 1,N-1
>                   IF (RINV(K).GT.RY.AND.K.NE.IMCIRC) THEN
>                       RY = RINV(K)
426,429c411,415
<               END IF
<    36     CONTINUE
< *       Include factor of 2 in criterion QPMIN < 4*MAX(SIZE(K1),SIZE(K2)).
<           SX = 8.0*SX
---
>    36         CONTINUE
>               RY = 1.0/RY
>           ELSE
>               RY = RM
>           END IF
434c420
<       IF (RY.LT.SX.AND.NSTEP1.GT.NEXT) THEN
---
>       IF (RY.LT.RX.AND.NSTEP1.GT.NEXT) THEN
439d424
<                       GSAVE = GCRIT
443c428
<                       GCRIT = GSAVE
---
>                       GCRIT = 5.0D-05
453d437
<           IMCIRC = 0
502,509c486,487
<           IF (KZ27.LE.2) THEN
<               FAC = 0.5*(M(J1) + M(J2))/M(J1)
<               RCR = 1.7*FAC**0.3333*SIZE(J1)
<           ELSE
<               CLIGHT = 3.0D+05/VSTAR1
<               RCR = 6.0*(M(J1) + M(J2))/CLIGHT**2
<           END IF
< *
---
>           FAC = 0.5*(M(J1) + M(J2))/M(J1)
>           RCR = 1.7*FAC**0.3333*SIZE(J1)
591,592c569,570
< *       Check termination or strong perturbation (T > TMAX or GPERT > 0.01).
<       IF ((CHTIME.GT.TMAX).OR.GPERT.GT.0.01) THEN
---
> *       Check termination criteria (T > TMAX or RSUM > RMAXC).
>       IF ((CHTIME.GT.TMAX).OR.(RSUM.GT.RMAXC).OR.GPERT.GT.0.01) THEN
597c575
<           IF (KZ30.GT.2) THEN
---
>           IF (rank.eq.0.and.KZ30.GT.2) THEN
602,603c580
< *       Avoid checking after switch (just in case).
<           IF (ISW.EQ.0) THEN
---
>           IF (ISW.EQ.0.AND.(RSUM.GT.RMAXC.OR.GPERT.GT.0.01)) THEN
675c652
<       IF (KZ30.GT.1.AND.QPERI.LT.1.0) THEN
---
>       IF (rank.eq.0.and.KZ30.GT.1.AND.QPERI.LT.1.0) THEN
686a664
> 
1,2c1,2
< 1368 2001-04-07 13:23 /work/Umi2/spurzem/5/nbody6compare/chdata.f
< nbody6compare/chdata.f
---
> 1369 2001-08-04 17:17 /work/Umi2/spurzem/5/nbody6++compare/chdata.f
> nbody6++compare/chdata.f
43a44
> 
1,2c1,2
< 3947 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/check.f
< nbody6compare/check.f
---
> 4180 2001-08-06 16:32 /work/Umi2/spurzem/5/nbody6++compare/check.f
> nbody6++compare/check.f
22a23
>               if(rank.eq.0)then
25a27
>               end if
44a47
>           if(rank.eq.0)then
46a50
>           end if
65a70
>       if(rank.eq.0)then
68a74
>       end if
83a90
>           if(rank.eq.0)then
84a92
>           end if
94a103
>               if(rank.eq.0)then
95a105
>               end if
1,2c1,2
< 10001 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/checkl.f
< nbody6compare/checkl.f
---
> 10002 2000-07-26 04:59 /work/Umi2/spurzem/5/nbody6++compare/checkl.f
> nbody6++compare/checkl.f
317a318
> 
1,2c1,2
< 680 2001-04-07 13:23 /work/Umi2/spurzem/5/nbody6compare/chfind.f
< nbody6compare/chfind.f
---
> 680 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/chfind.f
> nbody6++compare/chfind.f
1,2c1,2
< 5653 2004-05-13 10:27 /work/Umi2/spurzem/5/nbody6compare/chfirr.f
< nbody6compare/chfirr.f
---
> 5734 2005-03-09 18:58 /work/Umi2/spurzem/5/nbody6++compare/chfirr.f
> nbody6++compare/chfirr.f
9c9,10
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
41c42,43
< *         CALL KSRES2(JP,J1,J2,RIJ2)
---
> *         IZZ = KVEC(JP)
> *         CALL KSRES2(JP,J1,J2,RIJ2,IZZ)
1,2c1,2
< 5201 2005-09-29 14:21 /work/Umi2/spurzem/5/nbody6compare/chinit.f
< nbody6compare/chinit.f
---
> 5292 2002-07-12 20:03 /work/Umi2/spurzem/5/nbody6++compare/chinit.f
> nbody6++compare/chinit.f
8c8,9
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMX4=4*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
143c144
< *       Check next treatment time of perturbers.
---
> *       Check next treatment time of perturbers & output time.
145a147
>       TMAX = MIN(TMAX,TADJ - TIME)
164a167
> 
1,2c1,2
< 2395 2006-09-04 10:37 /work/Umi2/spurzem/5/nbody6compare/chlist.f
< nbody6compare/chlist.f
---
> 2448 2000-07-26 04:59 /work/Umi2/spurzem/5/nbody6++compare/chlist.f
> nbody6++compare/chlist.f
9c9,10
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
74a76
> 
1,2c1,2
< 20406 2006-09-08 12:35 /work/Umi2/spurzem/5/nbody6compare/chmod.f
< nbody6compare/chmod.f
---
> 17089 2003-06-25 20:39 /work/Umi2/spurzem/5/nbody6++compare/chmod.f
> nbody6++compare/chmod.f
30c30
< *       Identify the dominant perturber (skip if none or NN >= 6).
---
> *       Identify the dominant perturber (skip if none or NN >= 4).
34c34
<       IF (NNB.EQ.0.OR.NN.GE.6) GO TO 10
---
>       IF (NNB.EQ.0.OR.NN.GE.5) GO TO 10
36c36
<       DO 2 L = 2,NNB+1
---
>       DO 5 L = 2,NNB+1
46c46
<     2 CONTINUE
---
>     5 CONTINUE
53c53
< *       Check for rejection (RIJ > 3*MIN(RSUM,RMIN); RDOT > 0 & G < 0.05).
---
> *       Check for rejection (RIJ > 2*MIN(RSUM,RMIN); RDOT > 0 & G < 0.05).
55,89c55
< *
< *       Include test on fast escaper approaching a perturber having RDOT > 0.
<       IF (GPERT.GT.0.05.AND.RDOT.GT.0) THEN
< *       Bypass test and repeated diagnostics for large perturbation.
<           IF (GPERT.GT.0.5) GO TO 5
<           RDX = 0.0
<           L = 0
< *       Evaluate actual distance and relative radial velocity of end member.
<     3     RJX2 = (XCH(L+1) - X(1,JCLOSE))**2 +
<      &           (XCH(L+2) - X(2,JCLOSE))**2 +
<      &           (XCH(L+3) - X(3,JCLOSE))**2
<           RDI = (XCH(L+1) - X(1,JCLOSE))*(VCH(L+1) - XDOT(1,JCLOSE)) +
<      &          (XCH(L+2) - X(2,JCLOSE))*(VCH(L+2) - XDOT(2,JCLOSE)) +  
<      &          (XCH(L+3) - X(3,JCLOSE))*(VCH(L+3) - XDOT(3,JCLOSE))
< *       See whether any chain member is approaching the intruder.
<           IF (RDI.LT.0.0) THEN
<               RJX = SQRT(RJX2)
<               RDX = RDI/RJX
<           END IF
< *       Consider the last chain member similarly.
<           IF (L.EQ.0) THEN
<               L = 3*(NN - 1)
<               GO TO 3
<           END IF
< *       Bypass RDOT < 0 test for approaching ejection candidate.
<           IF (RDX.LT.0.0.AND.RJX.LT.2.0*RSUM/FLOAT(NN-1)) THEN
<               WRITE (6,4)  NAME(JCLOSE), GPERT, RIJ, RJX, RDX
<     4         FORMAT (' TRY ABSORB    NAM PERT RIJ RJX RDX ',
<      &                                I6,F6.2,1P,4E9.1)
<               GO TO 5
<           END IF
<       END IF
< *
< *       Include conditions for skipping (large RIJ & size or small GPERT).
<       IF (RIJ.GT.3.0*MIN(RSUM,RMIN)) GO TO 10
---
>       IF (RIJ.GT.3.0*MIN(RSUM,RMIN).OR.NAME(JCLOSE).LT.0) GO TO 10
92,94c58
< *       Allow triple hierarchy subject to maximum membership of 6.
<     5 IF (NN.GT.3.AND.NAME(JCLOSE).LT.0) GO TO 10
<       IF (NN.GT.4.AND.JCLOSE.GT.N) GO TO 10
---
>       IF (RSUM+RIJ.GT.2.0*RMIN) GO TO 10
105,106c69,70
< *       Widen the impact parameter test to be on safe side.
<       IF (PMIN.GT.1.5*RSUM.AND.GPERT.LT.0.05) GO TO 10
---
>       IF (PMIN.GT.RSUM.AND.GPERT.LT.0.4) GO TO 10
>       IF (NN.GE.4.AND.JCLOSE.GT.N) GO TO 10
108,111c72,75
< *       Delay accepting very small binary (suppressed; eccentricity effect).
< *     IF (JCLOSE.GT.N.AND.GPERT.LT.0.25) THEN
< *         IF (100.0*R(JCLOSE-N).LT.RIJ) GO TO 10
< *     END IF
---
> *       Delay accepting very small binary.
>       IF (JCLOSE.GT.N.AND.GPERT.LT.0.4) THEN
>           IF (100.0*R(JCLOSE-N).LT.RIJ) GO TO 10
>       END IF
132,141c96,99
<           IF (KZ(30).GT.1) THEN
<               IF (JCLOSE.GT.N) THEN
<                   SEMI = -0.5*BODY(JCLOSE)/H(JCLOSE-N)
<               ELSE
<                   SEMI = 0.0
<               END IF
<               WRITE (6,6)  NSTEP1, JCLOSE, NAME(JCLOSE), GPERT, RIJ,
<      &                     RSUM, PMIN, SEMI
<     6         FORMAT (' ABSORB:    # JCLOSE NMJ GPERT RIJ RSUM PMIN A ',
<      &                             3I6,F6.2,1P,4E9.1)
---
>           IF (rank.eq.0.and.KZ(30).GT.1) THEN
>               WRITE (6,6)  JCLOSE, NAME(JCLOSE), GPERT, RIJ, RSUM, PMIN
>     6         FORMAT (' ABSORB:    JCLOSE NMJ GPERT RIJ RSUM PMIN ',
>      &                             2I6,F6.2,1P,3E9.1)
153,156c111
<               GCRIT = 1.0E-05
<               NEW = NN + 1
<               IF (JCLOSE.GT.N) NEW = NEW + 1
<               IF (NEW.GE.4) GCRIT = 5.0D-06
---
>               GCRIT = 5.0E-05
169c124
<               IF (RM.LT.SMALL.AND.SEMI.LT.SMALL) THEN
---
>               IF (rank.eq.0.and.RM.LT.SMALL.AND.SEMI.LT.SMALL) THEN
226,254d180
< *       Try escape check if middle distance is largest.
<       IF (KCASE.EQ.0.AND.NN.GE.5.AND.
<      &    1.0/RINV(ISORT(1)).GT.2.0*RMIN) THEN
<           R1 = 1.0/RINV(1)
<           R2 = 1.0/RINV(NN-1)
< *       Set relevant indices for beginning or end of chain.
<           IF (R1.GT.R2) THEN
<               IESC = INAME(1)
<               JX = INAME(2)
<               IB = 1
<               ISORT(1) = 1
<               R3 = 1.0/RINV(2)
<           ELSE
<               IESC = INAME(NN)
<               JX = INAME(NN-1)
<               IB = NN - 1
<               ISORT(1) = NN - 1
<               R3 = 1.0/RINV(NN-2)
<           END IF
< *       Define binary indices for large second separation.
<           IF (R3.GT.MAX(R1,R2)) THEN
<               JESC = JX
<               IBIN = IB
<               KCASE = 2
<           ELSE
<               KCASE = 1
<           END IF
<       END IF
< *
258c184
<       IF (KZ(30).GT.2) THEN
---
>       IF (rank.eq.0.and.KZ(30).GT.2) THEN
261c187
<    12     FORMAT (' CHMOD:    IESC JESC # ISORT1 R ',2I3,I6,I3,1P,5E9.1)
---
>    12     FORMAT (' CHMOD:    IESC JESC # ISORT1 R ',2I3,I5,I3,1P,5E9.1)
280,290c206,207
< *       Consider removal of outermost particle instead if binary is wide.
<           IF (RB.GT.0.25*RJB) THEN
< *       Change pointer to end of chain and redefine IESC.
<               IF (ISORT(1).EQ.2) THEN
<                   ISORT(1) = 1
<               ELSE
<                   ISORT(1) = NN - 1
<               END IF
<               IESC = JESC
<               GO TO 30
<           END IF
---
> *       Consider single particle for separation ratio > 1/4.
>           IF (RB.GT.0.25*RJB) GO TO 30
291a209
>           RB = 0.0
314c232
< *       Adopt arithmetic mean of RSUM and RMAXS for delaying escape.
---
> *       Adopt harmonic mean of RSUM and RMAXS for delaying escape.
317c235
<       IM = ISORT(1)
---
>       IM = ISORT(1)  
340,342c258,261
<               ELSE IF (GB.LT.0.01.AND.NCH.GT.4.AND.
<      &                 (RDOT**2.GT.BODY(ICH)/RI.OR.RI.GT.RMIN)) THEN
<                   WRITE (6,28)  IESC, JESC, NAMEC(IESC), NAMEC(JESC),
---
>               ELSE IF (GB.LT.0.001.AND.NCH.GT.4.AND.
>      &                 RDOT**2.GT.BODY(ICH)/RI) THEN
>                   if(rank.eq.0)
>      &            WRITE (6,28)  IESC, JESC, NAMEC(IESC), NAMEC(JESC),
362,374c281,285
<               HI = 0.5*RDOT**2 - BODY(ICH)/RI
<               IF (HI.GT.0.0) THEN
<                   VINF = SQRT(2.0*HI)*VSTAR
<               ELSE
<                   VINF = 0.0
<               END IF
<               IF (KZ(30).GT.1.OR.VINF.GT.1.0) THEN
<                   WRITE (6,28)  IESC, JESC, NAMEC(IESC), NAMEC(JESC),
<      &                          RI, RDOT**2, 2.0*BODY(ICH)/RI, RB, VINF
<    28             FORMAT (' CHAIN ESCAPE:    IESC JESC NM RI RDOT2 ',
<      &                                      '2*M/R RB VINF ',
<      &                                       2I3,2I6,1P,4E9.1,0P,F6.1)
<               END IF
---
>               if(rank.eq.0)
>      &         WRITE (6,28)  IESC, JESC, NAMEC(IESC), NAMEC(JESC),
>      &                      RI, RDOT**2, 2.0*BODY(ICH)/RI, RB
>    28         FORMAT (' CHAIN ESCAPE:    IESC JESC NM RI RDOT2 2*M/R ',
>      &                                   'RB',I4,I3,2I6,1P,4E9.1)
398d308
<       RB = 0.0
405c315
< *       Note that arithmetic mean tends to delay escape.
---
> *       Note that harmonic mean tends to delay escape.
420,421c330
<               IF ((ER.LT.0.0.AND.RX.LT.MIN(2.0*RSUM,2.0*RMIN)).OR.
<      &            (NN.EQ.3.AND.GI.GT.0.1)) THEN
---
>               IF (ER.LT.0.0.AND.RX.LT.2.0*RSUM) THEN
438,440c347,350
<                       IF (RY.LT.0.9*SEMI.AND.RI.LT.2.0*RMIN) THEN
<                           WRITE (6,31)  NSTEP1, RY/SEMI, RI, RDOT**2,
<      &                                  2.0*BODY(ICH)/RI, SEMI
---
>                       IF (RY.LT.0.9*SEMI) THEN
> *                         if(rank.eq.0)
> *    &                     WRITE (6,31)  NSTEP1, RY/SEMI, RI, RDOT**2,
> *    &                                  2.0*BODY(ICH)/RI, SEMI
490,494c400,405
<               IF (RY.LT.0.9*SEMI.AND.RI.LT.2.0*RMIN) THEN
<                   WRITE (6,31)  NSTEP1, RY/SEMI, RI, RDOT**2,
<      &                          2.0*BODY(ICH)/RI, SEMI
<    31             FORMAT (' CHAIN DELAY    # R/A RI RD2 VP2 A ',
<      &                                     I5,F6.2,1P,4E9.1)
---
>               IF (RY.LT.0.9*SEMI) THEN
> *                 if(rank.eq.0)
> *    &            WRITE (6,31)  NSTEP1, RY/SEMI, RI, RDOT**2,
> *    &                          2.0*BODY(ICH)/RI, SEMI
> *  31             FORMAT (' CHAIN DELAY    # R/A RI RD2 VP2 A ',
> *    &                                     I5,F6.2,1P,4E9.1)
514c425
<           IF (KZ(30).GT.1.OR.VINF.GT.2.0) THEN
---
>           IF (rank.eq.0.and.KZ(30).GT.1.OR.VINF.GT.10.0) THEN
542a454
> 
1,2c1,2
< 1476 2001-04-07 13:23 /work/Umi2/spurzem/5/nbody6compare/chpot.f
< nbody6compare/chpot.f
---
> 1476 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/chpot.f
> nbody6++compare/chpot.f
1,2c1,2
< 6178 2003-05-10 16:16 /work/Umi2/spurzem/5/nbody6compare/chstab.f
< nbody6compare/chstab.f
---
> 6388 2005-03-09 22:48 /work/Umi2/spurzem/5/nbody6++compare/chstab.f
> nbody6++compare/chstab.f
12a13,15
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
112c115
< *       Construct the Runge-Lenz vector (Heggie & Rasio 1995, Eq.(5)).
---
> *       Construct the Runge-Lenz vector (Heggie & Rasio 1996, Eq.(5)).
152c155,156
<           WRITE (6,20)  NAMEC(I1), NAMEC(I2), NAMEC(I3), ECC, EMAX,
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  NAMEC(I1), NAMEC(I2), NAMEC(I3), ECC, EMAX,
159c163,164
<           WRITE (81,30)  TIMEC, RI, NAMEC(I3), Q0, ECC, EMAX, ECC1,
---
>           if(rank.eq.0)
>      &    WRITE (81,30)  TIMEC, RI, NAMEC(I3), Q0, ECC, EMAX, ECC1,
170c175,176
<               WRITE (6,40)  ECC, ECC1, ALPHA, RB, R3, PCRIT, PMIN, APO
---
>               if(rank.eq.0)
>      &        WRITE (6,40)  ECC, ECC1, ALPHA, RB, R3, PCRIT, PMIN, APO
183a190,191
> 
> 
1,2c1,2
< 15545 2006-09-04 10:35 /work/Umi2/spurzem/5/nbody6compare/chterm.f
< nbody6compare/chterm.f
---
> 14439 2003-06-25 21:03 /work/Umi2/spurzem/5/nbody6++compare/chterm.f
> nbody6++compare/chterm.f
33c33
< *       Prepare KS regularization(s) and direct integration of other bodies.
---
> *       Prepare KS regularization and direct integration of any other bodies.
39d38
<       I6 = 0
46c45
<       ELSE IF (NCH.EQ.4) THEN
---
>       ELSE
48,72c47,48
<       ELSE IF (NCH.GT.4) THEN
< *       Determine indices for second closest pair.
<           RX1 = 1.0
<           RX0 = R2(I1,I2)
<           DO 2 J1 = 1,NCH
< *       Avoid choosing close pair I1-I2.
<               IF (J1.EQ.I1.OR.J1.EQ.I2) GO TO 2
<               DO 1 J2 = J1+1,NCH
<                   IF (J2.EQ.I1.OR.J2.EQ.I2) GO TO 1
<                   IF (R2(J1,J2).LT.RX1.AND.R2(J1,J2).GT.RX0) THEN
<                       RX1 = R2(J1,J2)
<                       I3 = J1
<                       I4 = J2
<                   END IF
<     1         CONTINUE
<     2     CONTINUE
< *       Identify remaining single particle(s) by exclusion.
<           DO 3 I = 1,NCH
<               IF (I.EQ.I1.OR.I.EQ.I2.OR.I.EQ.I3.OR.I.EQ.I4) GO TO 3
<               IF (I5.EQ.0) THEN
<                   I5 = I
<               ELSE 
<                   I6 = I
<               END IF
<     3     CONTINUE
---
>           I5 = I4
>           IF (NCH.EQ.5) I5 = IJ(5)
74,75d49
<       IF (I5.EQ.0) I5 = I4
<       IF (I6.EQ.0) I6 = I4
77,78c51,52
<       IF (KZ(30).GT.1) THEN
<           WRITE (6,4)  SQRT(R2(I1,I2)), SQRT(R2(I1,I3)),SQRT(R2(I2,I3)),
---
>       IF (rank.eq.0.and.KZ(30).GT.2) THEN
>           WRITE (6,1)  SQRT(R2(I1,I2)), SQRT(R2(I1,I3)),SQRT(R2(I2,I3)),
80c54
<     4     FORMAT (' CHTERM:   RIJ (1-2 1-3 2-3 2-4 3-4)  ',1P,5E9.1)
---
>     1     FORMAT (' CHTERM:   RIJ (1-2 1-3 2-3 2-4 3-4)  ',1P,5E9.1)
88d61
<       IF (NCH.EQ.6) JLIST(11) = NAMEC(I6)
128a102,110
> *       Predict current X & XDOT for c.m. and neighbours to order F3DOT.
>       CALL XVPRED(ICM,-1)
>       NNB1 = LIST(1,ICH) + 1
>       DO 25 L = 2,NNB1
> *       Note possibility T0(J) = TIME in routine REDUCE would skip on -2.
>           J = LIST(L,ICH)
>           CALL XVPRED(J,-1)
>    25 CONTINUE
> *
131a114,115
> *       Note TBLOCK = TPREV set in REDUCE which can precede termination.
>       IF (DT8.EQ.0.0D0) DT8 = STEP(ICM)/8.0D0
151c135
< *       Restrict TIME to current block-step and save for use by KSPERI.
---
> *       Include safety check just in case and save TIME for possible reset.
154,162c138
< *
< *       Predict current X & XDOT for c.m. and neighbours to order F3DOT.
<       CALL XVPRED(ICM,-1)
<       NNB1 = LIST(1,ICH) + 1
<       DO 25 L = 2,NNB1
< *       Note possibility T0(J) = TIME in routine REDUCE would skip on -2.
<           J = LIST(L,ICH)
<           CALL XVPRED(J,-1)
<    25 CONTINUE
---
>       IF (NSTEP1.GE.50000) TBLOCK = TPREV
171,176c147,151
<       JLIST(7) = I1
<       JLIST(8) = I2
<       JLIST(9) = I3
<       JLIST(10) = I4
<       JLIST(11) = I5
<       JLIST(12) = I6
---
>       JLIST(6) = I1
>       JLIST(7) = I2
>       JLIST(8) = I3
>       JLIST(9) = I4
>       JLIST(10) = I5
189c164
<           LL = JLIST(L+6)
---
>           LL = JLIST(L+5)
239,240c214,215
< *       Set JLIST(7) < 0 to denote that body #I3 & I4 will be new KS pair.
<                   JLIST(7) = -1
---
> *       Set JLIST(6) < 0 to denote that body #I3 & I4 will be new KS pair.
>                   JLIST(6) = -1
264c239
< *       Assign new neighbours for dominant KS and any other members.
---
> *       Assign new neighbours for dominant KS, I3 & I4.
265a241,242
>       J3 = JLIST(3)
>       J4 = JLIST(4)
267,270c244,245
<       DO 65 L = 3,NCH
<           J = JLIST(L)
<           CALL NBLIST(J,RS0)
<    65 CONTINUE
---
>       IF (NCH.GT.2) CALL NBLIST(J3,RS0)
>       IF (NCH.GT.3) CALL NBLIST(J4,RS0)
280c255
<           IF (NCH.EQ.3) JLIST(2) = MAX(IFIRST + 4,JLIST(1) + 1)
---
>           IF (NCH.EQ.3) JLIST(2) = JCLOSE
286c261
<           JLIST(1) = MAX(IFIRST + 4,JCOMP + 1)
---
>           JLIST(1) = JCLOSE
291,294c266,267
<       IF (NCH.GE.3) THEN
<           CALL FCLOSE(ICOMP,NNB)
<           CALL FCLOSE(JCOMP,NNB)
<       END IF
---
>       CALL FCLOSE(ICOMP,NNB)
>       CALL FCLOSE(JCOMP,NNB)
310,311c283
<       IF (NCH.GE.5) I5 = JLIST(5)
<       IF (NCH.EQ.6) I6 = JLIST(6)
---
>       IF (NCH.EQ.5) I5 = JLIST(5)
337c309
<               IF (NCH.GE.5.AND.I5.GT.0) THEN
---
>               IF (NCH.EQ.5.AND.I5.GT.0) THEN
340,343d311
<                   IF (NCH.EQ.6) THEN
<                       CALL FPOLY1(I6,I6,0)
<                       CALL FPOLY2(I6,I6,0)
<                   END IF
355,356c323,324
< *       Include initialization of #I5/I6 before KS calls change address.
<       ELSE IF (NCH.GE.5.AND.I5.GT.0) THEN
---
> *       Include initialization of 5th body before KS calls change address.
>       ELSE IF (NCH.EQ.5.AND.I5.GT.0) THEN
359,362d326
<           IF (NCH.EQ.6) THEN
<               CALL FPOLY1(I6,I6,0)
<               CALL FPOLY2(I6,I6,0)
<            END IF
397c361
<       IF (KZ(30).GT.1) THEN
---
>       IF (rank.eq.0.and.KZ(30).GT.1) THEN
420c384
<           IF (KZ(30).GT.1) THEN
---
>           IF (rank.eq.0.and.KZ(30).GT.1) THEN
485a450,451
> 
> 
1,2c1,2
< 1654 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/clint.f
< nbody6compare/clint.f
---
> 1654 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/clint.f
> nbody6++compare/clint.f
1,2c1,2
< 2243 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/cloud0.f
< nbody6compare/cloud0.f
---
> 2331 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/cloud0.f
> nbody6++compare/cloud0.f
0a1,4
> # 1 "cloud0.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "cloud0.F"
4,5c8,9
< *       Cloud initialization.
< *       ---------------------
---
> * Cloud initialization.
> * ---------------------
8,10c12,14
<       COMMON/CLOUDS/  XCL(3,MCL),XDOTCL(3,MCL),BODYCL(MCL),RCL2(MCL),
<      &                CLM(MCL),CLMDOT(MCL),CLDOT,VCL,SIGMA,RB2,PCL2,
<      &                TCL,STEPCL,NCL,NEWCL
---
>       COMMON/CLOUDS/ XCL(3,MCL),XDOTCL(3,MCL),BODYCL(MCL),RCL2(MCL),
>      & CLM(MCL),CLMDOT(MCL),CLDOT,VCL,SIGMA,RB2,PCL2,
>      & TCL,STEPCL,NCL,NEWCL
11a16
> # 21 "cloud0.F"
13c18
< *       Initialize cloud variables.
---
> * Initialize cloud variables.
19,23c24,40
< *
< *       Read the cloud parameters.
<       READ (5,*)  NCL, RB2, VCL, SIGMA, (CLM(J),J=1,NCL),
<      &            (RCL2(J),J=1,NCL)
<       WRITE (6,100)  NCL, RB2, VCL, SIGMA
---
>       RB2 = 0.0
>       BODYCL(1) = 0.0
>       CLMDOT(1) = 0.0
>       RCL2(1) = 0.0
>       DO 10 K = 1,3
>           XCL(K,1) = 0.0
>           XDOTCL(K,1) = 0.0
>    10 CONTINUE
> *
>       IF (KZ(13).EQ.0) GO TO 120
> *
> * Read the cloud parameters.
>       if(rank.eq.0)
>      &READ (5,*) NCL, RB2, VCL, SIGMA, (CLM(J),J=1,NCL),
>      & (RCL2(J),J=1,NCL)
> # 51 "cloud0.F"
>       WRITE (6,100) NCL, RB2, VCL, SIGMA
25c42
<      &    '  MEAN CLOUD VELOCITY (KM/SEC) =',F5.1,'  DISPERSION =',F5.1)
---
>      & '  MEAN CLOUD VELOCITY (KM/SEC) =',F5.1,'  DISPERSION =',F5.1)
28c45
< *       Set cloud parameters in scaled units.
---
> * Set cloud parameters in scaled units.
31c48
< *       Rms velocity of cluster members in km/sec.
---
> * Rms velocity of cluster members in km/sec.
33c50
< *       Velocity unit.
---
> * Velocity unit.
35c52
< *       Cloud velocity in scaled units.
---
> * Cloud velocity in scaled units.
37c54
< *       Specify conservative cloud integration step using crossing time.
---
> * Specify conservative cloud integration step using crossing time.
40,44c57
< *       Adopt a quantized value.
<       CALL STEPK(STEPCL,DTN)
<       STEPCL = DTN
< *
< *       Scale radii & masses to model units.
---
> * Scale radii & masses to model units.
50,51c63,64
<       WRITE (6,102)  RB2, VCL, SIGMA, STEPCL, (CLM(J),J=1,NCL),
<      &               (RCL2(J),J=1,NCL)
---
>       WRITE (6,102) RB2, VCL, SIGMA, STEPCL, (CLM(J),J=1,NCL),
>      & (RCL2(J),J=1,NCL)
54c67
< *       Time scale for 'sun-rise' is 0.05 of the cloud crossing time.
---
> * Time scale for 'sun-rise' is 0.05 of the cloud crossing time.
57c70
< *       Define the square of cloud half-mass radii & growth times.
---
> * Define the square of cloud half-mass radii & growth times.
63c76
< *       Set square boundary radius & impact parameter.
---
> * Set square boundary radius & impact parameter.
66c79
< *       Define density centre for routine CLOUD.
---
> * Define density centre for routine CLOUD.
71c84
< *       Initialize new clouds on the boundary.
---
> * Initialize new clouds on the boundary.
76c89
<       RETURN
---
>   120 RETURN
1,2c1,2
< 2357 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/cloud.f
< nbody6compare/cloud.f
---
> 2471 2002-08-24 22:40 /work/Umi2/spurzem/5/nbody6++compare/cloud.f
> nbody6++compare/cloud.f
13a14,15
> * recover random number sequence from COMMON variable IDUM1.
>       KDUM = IDUM1
20,21c22
< *       Note that IDUM1 is saved in COMMON6 for restarts.
<           A(K+1) = 2.0*RAN2(IDUM1) - 1.0
---
>           A(K+1) = 2.0*RAN2(KDUM) - 1.0
28,29c29,30
<       RANPHI = TWOPI*RAN2(IDUM1)
<       RANDI = SQRT(RAN2(IDUM1))
---
>       RANPHI = TWOPI*RAN2(KDUM)
>       RANDI = SQRT(RAN2(KDUM))
36c37
<       IF (KZ(13).GE.2) THEN
---
>       IF (KZ(13).NE.1.AND.KZ(13).NE.2) THEN
38,39c39,40
<               A(5) = RAN2(IDUM1)
<               A(6) = TWOPI*RAN2(IDUM1)
---
>               A(5) = RAN2(KDUM)
>               A(6) = TWOPI*RAN2(KDUM)
69a71,72
> *       Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
1,2c1,2
< 14979 2006-09-07 19:29 /work/Umi2/spurzem/5/nbody6compare/cmbody.f
< nbody6compare/cmbody.f
---
> 15446 2003-07-04 19:03 /work/Umi2/spurzem/5/nbody6++compare/cmbody.f
> nbody6++compare/cmbody.f
82,83c82,84
<                   WRITE (6,4)  KSPAIR, NAME(J), H(KSPAIR), ECC, A0, A1,
<      &                         RP, SQRT(ECC2), SR
---
>                   if(rank.eq.0)
>      &            WRITE (6,4)  KSPAIR, NAME(J), H(KSPAIR), ECC, A0, A1,
>      &                         RP, ECC, SR
85c86
<      &                            2I6,F7.0,F8.4,1P,3E9.1,0P,F6.2,F6.1)
---
>      &                              2I6,F7.0,F8.4,1P,3E9.1,0PF6.2,F6.1)
101,109c102,111
< *         NAM1 = NAME(2*KSPAIR-1)
< *         NAM2 = NAME(2*KSPAIR)
< *         NNB = LISTD(1)
< *         DO 7 K = 2,NNB+1
< *             IF (LISTD(K).EQ.NAM1.OR.LISTD(K).EQ.NAM2) THEN
< *                 WRITE (6,6)  NAM1, NAM2, LISTD(K), K
< *   6             FORMAT (' KS REMNANT:    NAM LISTD K  ',3I6,I4)
< *             END IF
< *   7     CONTINUE
---
>           NAM1 = NAME(2*KSPAIR-1)
>           NAM2 = NAME(2*KSPAIR)
>           NNB = LISTD(1)
>           DO 7 K = 2,NNB+1
>               IF (LISTD(K).EQ.NAM1.OR.LISTD(K).EQ.NAM2) THEN
>                   if(rank.eq.0)
>      &            WRITE (6,6)  NAM1, NAM2, LISTD(K), K
>     6             FORMAT (' KS REMNANT:    NAM LISTD K  ',3I6,I4)
>               END IF
>     7     CONTINUE
154,155c156,157
<           IF (NSYS.GT.4) I5 = JLIST(5)
< *       Note JLIST(1->NCH) contains global indices (JLIST(4)=0 for NCH=3).
---
>           I5 = JLIST(5)
> *       Ignore case of three-body system here (JLIST(4) = 0).
164a167,169
> *       Set new quantized time (note: restore if problems in CHTERM).
> *     TIME = TBLOCK
> *
184d188
<           AGE1 = MIN(TPHYS,AGE1)
190a195
>           AGE2 = TEV(I2)*TSTAR - EPOCH(I2)
228,229d232
< *       Ensure BH if one of components is type 14.
<           IF (KW1.EQ.14.OR.KW2.EQ.14) KW = 14
242c245,246
<           WRITE (6,15)  NAME(I1), KSTAR(I1), TEV(I1)*TSTAR, M1, M2,
---
>           if(rank.eq.0)
>      &    WRITE (6,15)  NAME(I1), KSTAR(I1), TEV(I1)*TSTAR, M1, M2,
249,256c253,257
< *       Ensure the heaviest body is new progenitor.
<       IF (BODY(I2).GT.BODY(I1)) THEN
<           I1S = I1
<           I1 = I2
<           I2 = I1S
<           ICOMP = I1
<           JCOMP = I2
<       END IF
---
> *       Copy all members of neighbour or perturber list.
>       NNB = LIST(1,I1)
>       DO 20 L = 1,NNB
>           JPERT(L) = LIST(L+1,I1)
>    20 CONTINUE
260,264d260
< *       Copy all members of neighbour list.
<           NNB = LIST(1,I1)
<           DO 20 L = 1,NNB
<               JPERT(L) = LIST(L+1,I1)
<    20     CONTINUE
272,277c268,276
< *       Obtain differential effect on #I1 & #I2 due to other members.
<           DO 25 L = 3,NSYS
<               JPERT(L-2) = JLIST(L)
<    25     CONTINUE
<           NP = NSYS - 2
<           CALL NBPOT(2,NP,POT1)
---
> *       Obtain differential effect on #I1 & #I2 due to closest member #I3.
>           JPERT(1) = I3
>           CALL NBPOT(2,1,POT1)
> *       Include possible fourth member.
>           IF (NSYS.GT.3) THEN
>               JPERT(1) = I4
>               CALL NBPOT(2,1,POT3)
>               POT1 = POT1 + POT3
>           END IF
317c316,322
<           CALL NBPOT(1,NP,POT2)
---
>           JPERT(1) = I3
>           CALL NBPOT(1,1,POT2)
>           IF (NSYS.GT.3) THEN
>               JPERT(1) = I4
>               CALL NBPOT(1,1,POT4)
>               POT2 = POT2 + POT4
>           END IF
323,326c328,331
<       IF (NSYS.EQ.2) THEN
<           JPERT(1) = I2
<           JLIST(1) = I2
<           CALL NBREM(I1,1,NNB)
---
>       JPERT(1) = I2
>       JLIST(1) = I2
>       CALL NBREM(I1,1,NNB)
> *
328,330c333,334
<           JPERT(1) = I1
<           CALL NBREM(NTOT,1,1)
<       END IF
---
>       JPERT(1) = I1
>       CALL NBREM(NTOT,1,1)
342c346
<       IF (JLIST(7).LT.0) THEN
---
>       IF (JLIST(6).LT.0) THEN
358,365d361
< *       Include kick velocity on BH formation.
<           IF (KZ(27).EQ.2) THEN
<               KW = KSTAR(ICOMP)
<               IF (KW.EQ.14) THEN
<                   DM = 0.0
<                   CALL FCORR(ICOMP,DM,KW)
<               END IF
<           END IF
375c371
< *       Initialize force polynomial for new single, third or fourth body.
---
> *       Initialize force polynomial for new single or third body (ICOMP).
383,386d378
<       IF (NSYS.EQ.5) THEN
<           CALL FPOLY1(I5,I5,0)
<           CALL FPOLY2(I5,I5,0)
<       END IF
391a384
>           RCOLL = DMINC
398c391
< *       Copy well defined binding energy.
---
> *       Copy well defined binding energy and skip explicit evaluation.
406d398
<           EB = EBS
411d402
<           EB = EBS
413a405,426
> *       Obtain binding energy of the subsystem (ignore ghost).
>       ZKE = 0.0D0
>       POTS = 0.0D0
>       DO 60 L = 1,NSYS
>           I = JLIST(L)
>           ZKE = ZKE + BODY(I)*(XDOT(1,I)**2 + XDOT(2,I)**2 +
>      &                                        XDOT(3,I)**2)
>    60 CONTINUE
> *
>       DO 70 L = 1,NSYS-1
>           DO 65 LL = L+1,NSYS
>               I = JLIST(L)
>               J = JLIST(LL)
>               RIJ2 = (X(1,I) - X(1,J))**2 + (X(2,I) - X(2,J))**2 +
>      &                                      (X(3,I) - X(3,J))**2
>               POTS = POTS + BODY(I)*BODY(J)/SQRT(RIJ2)
>    65     CONTINUE
>    70 CONTINUE
> *
> *       Form net energy correction for triple or quad case.
>       EB = ENERGY - (0.5D0*ZKE - POTS)
> *
430,431c443,445
<       WRITE (6,90)  WHICH1, NSYS, NAME1, NAME2, ZM*ZMBAR, RCOLL, EB,
<      &              VINF, ECC, DP
---
>       if(rank.eq.0)
>      &WRITE (6,90)  WHICH1, NSYS, NAME1, NAME2, ZM, RCOLL, EB, VINF,
>      &              ECC, DP
434c448
<      &             '  VINF =',E9.1,'  ECC =',0P,F9.5,'  DP =',1P,E9.1)
---
>      &             '  VINF =',0P,F5.1,'  ECC =',F9.5,'  DP =',1P,E9.1)
438a453,454
> 
> 
1,2c1,2
< 3313 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/cmcorr.f
< nbody6compare/cmcorr.f
---
> 3140 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/cmcorr.f
> nbody6++compare/cmcorr.f
53c53
<       IF (KZ(14).GT.0.AND.KZ(14).LE.2) THEN
---
>       IF (KZ(14).GT.0) THEN
55,56d54
< *       Skip ghosts to avoid spurious prediction inside 1.0E+10.
<               IF (BODY(I).EQ.0.0D0) GO TO 60
63d60
<                   FRDOT(K,I) = FRDOT(K,I) - DD
1,2c1,2
< 4603 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/cmfirr.f
< nbody6compare/cmfirr.f
---
> 3827 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/cmfirr.f
> nbody6++compare/cmfirr.f
10,11c10
< *
< *       Initialize the perturbing force & first derivative.
---
> *       Initialize the perturbing force & derivative.
17d15
< *       Set individual KS components and indicators for unresolved pair.
20a19
> *       Define indicator for summing over each KS component rather than c.m.
21a21
>       RPERT2 = CMSEP2*R(IPAIR)**2
23,28c23
< *       Specify perturber indices for decision-making.
<       NP = LIST(1,I1)
<       LP = 2
<       JP = LIST(2,I1)
< *
< *       Perform irregular force loop for perturbed c.m.
---
> *       Force loop treats case I > N and any other c.m. neighbours.
32,48c27,36
< *       Advance lower perturber index (includes possible old neighbour).
<     2     IF (K.GT.JP.AND.LP.LE.NP) THEN
<               LP = LP + 1
<               JP = LIST(LP,I1)
< *       Include rare case of two consecutive previous neighbours.
<               GO TO 2
<           END IF
< *
< *       Distinguish between nearby perturber and more distant neighbour.
<           IF (K.NE.JP) THEN
<               IF (K.LE.N) GO TO 10
< *       Check c.m. approximation (point-mass assumption OK for #I).
<               A1 = X(1,K) - XI(1)
<               A2 = X(2,K) - XI(2)
<               A3 = X(3,K) - XI(3)
<               RIJ2 = A1*A1 + A2*A2 + A3*A3
<               IF (RIJ2.GT.CMSEP2*R(K-N)**2) GO TO 10
---
>           A1 = X(1,K) - XI(1)
>           A2 = X(2,K) - XI(2)
>           A3 = X(3,K) - XI(3)
>           RIJ2 = A1*A1 + A2*A2 + A3*A3
> *
> *       Decide appropriate summation (c.m. approximation or components).
>           IF (K.LE.N) THEN
>               IF (RIJ2.GT.RPERT2) GO TO 10
>               GO TO 3
>           ELSE IF (RIJ2.LT.CMSEP2*R(K-N)**2) THEN
50,65c38,41
<               IF (LIST(1,KDUM).EQ.0) GO TO 10
<               K = KDUM
<               GO TO 10
< *       Consider more carefully the case of identified perturber.
<           ELSE
< *       Determine next perturber index (if any).
<               IF (LP.LE.NP) THEN
<                   LP = LP + 1
<                   JP = LIST(LP,I1)
<               END IF
< *       Specify first KS component if #JP is perturbed c.m.
<               IF (K.GT.N) THEN
<                   KDUM = 2*(K - N) - 1
<                   IF (LIST(1,KDUM).GT.0) THEN
<                       K = KDUM
<                   END IF
---
>               IF (LIST(1,KDUM).EQ.0) THEN
>                   KDUM = 0
>               ELSE
>                   K = KDUM
68a45,47
> *       Check c.m. approximation for current pair.
>           IF (RIJ2.GT.RPERT2) GO TO 10
> *
70c49
<           IFP = 1
---
>     3     IFP = 1
134d112
<    
1,2c1,2
< 9380 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/cmfreg.f
< nbody6compare/cmfreg.f
---
> 7829 2001-08-27 15:09 /work/Umi2/spurzem/5/nbody6++compare/cmfreg.f
> nbody6++compare/cmfreg.f
11,12c11
< *       Set non-zero indicator for perturbed c.m.
<       NP = 0
---
> *       Adopt accurate force for perturbed c.m. particle.
15c14,18
<           IF (LIST(1,2*IPAIR-1).GT.0) NP = 1
---
>           I2 = 2*IPAIR
>           I1 = I2 - 1
>           RPERT2 = CMSEP2*R(IPAIR)**2
>           BODYIN = 1.0/BODY(I)
>           IF (GAMMA(IPAIR).GE.GMIN) GO TO 10
18,19d20
< *       Prepare case of single particle or unperturbed c.m. (second call).
<       IF (I.LE.N.OR.NP.EQ.0) THEN
21,44c22,32
<           NNB1 = NPAIRS
<           RMAX1 = 0.0
<           DO 10 LJ = 1,NNB1
<               JLIST(LJ) = N + LJ
<               RMAX1 = MAX(RMAX1,R(LJ))
<    10     CONTINUE
< *
< *       Adopt adequate square distance for c.m. approximation.
<           RCM2 = MAX(RCRIT2,CMSEP2*RMAX1**2)
< *       Define dummy indices for skipping perturber test.
<           JP = 0
<           LP = 1
<           GO TO 25
<       END IF
< *
< *       Specify variables for treatment of perturbed c.m. particle.
<       I2 = 2*IPAIR
<       I1 = I2 - 1
<       RPERT2 = CMSEP2*R(IPAIR)**2
<       BODYIN = 1.0/BODY(I)
< *       Initialize perturber list for decision-making.
<       NP = LIST(1,I1)
<       LP = 2
<       JP = LIST(2,I1)
---
>       NNB1 = NPAIRS
>       RMAX1 = 0.0
>       DO 1 LJ = 1,NNB1
>           JLIST(LJ) = N + LJ
>           RMAX1 = MAX(RMAX1,R(LJ))
>     1 CONTINUE
> *
> *       Set minimum square distance for c.m. approximation.
>       RCM2 = MAX(RCRIT2,CMSEP2*RMAX1**2)
> *       Use accurate force algorithm for J > N.
>       GO TO 30
47c35
<       RCM2 = MAX(RCRIT2,RPERT2)
---
>    10 RCM2 = MAX(RCRIT2,RPERT2)
58c46
< *       Form a list of particles for more careful consideration.
---
> *       Form a list of c.m. particles to be resolved.
77,78c65,66
< *       Begin dual purpose force loop (all RIJ2 < RCM2, J > N or I <= N).
<    25 DO 60 LJ = 1,NNB1
---
> *       Begin dual purpose force loop (all RIJ2 < RCM2 or J > N).
>    30 DO 60 LJ = 1,NNB1
87c75
< *       First see if the distance exceeds c.m. approximation limit.
---
> *       First see whether the distance exceeds c.m. approximation limit.
91c79
< *       Check whether particle #J satisfies neighbour criteria.
---
> *       Test whether particle #J satisfies neighbour criteria.
94c82
< *       Consider small step particle (may give large correction terms).
---
>           IF (JDUM.EQ.I) GO TO 60
95a84
> *       Omission of small step particle may give large correction terms.
100d88
<           IF (JDUM.EQ.I) GO TO 60
105,112c93,98
<           KCM = 1
< *
< *       Advance lower perturber index (includes possible old neighbour).
<    26     IF (LP.LE.NP.AND.J.GT.JP) THEN
<               LP = LP + 1
<               JP = LIST(LP,I1)
< *       Include rare case of two consecutive previous neighbours.
<               GO TO 26
---
>           ICM = 1
> *       Irregular force indicator in case I > N or J > N are resolved.
>           IF (J.GT.N) THEN
> *       See whether c.m. approximation applies (skip perturbed case).
>               J1 = 2*(J - N) - 1
>               IF (RIJ2.LT.CMSEP2*R(J-N)**2.AND.LIST(1,J1).GT.0) GO TO 50
115,139c101,103
< *       Decide appropriate expressions from perturber comparison.
<           IF (J.NE.JP) THEN
<               IF (J.LE.N) GO TO 30
<               IF (RIJ2.GT.CMSEP2*R(J-N)**2) GO TO 30
<               KDUM = 2*(J - N) - 1
<               IF (LIST(1,KDUM).GT.0) THEN
<                   K = KDUM
<                   J2 = K + 1
<                   GO TO 50
<               END IF
<           ELSE
< *       Treat perturbers more carefully.
<               IF (LP.LE.NP) THEN
<                   LP = LP + 1
<                   JP = LIST(LP,I1)
<               END IF
<               J2 = 0
<               IF (J.GT.N) THEN
<                   KDUM = 2*(J - N) - 1
<                   IF (LIST(1,KDUM).GT.0) THEN
<                       J = KDUM
<                       J2 = J + 1
<                   END IF
<               END IF
<               GO TO 40
---
>           IF (I.GT.N) THEN
> *       See whether c.m. force needs summation over each component.
>               IF (RIJ2.LT.RPERT2.AND.GAMMA(IPAIR).GE.GMIN) GO TO 40
142c106
<    30     DR2I = 1.0/RIJ2
---
>           DR2I = 1.0/RIJ2
154c118
< *       Obtain relevant force on c.m (KCM = 0 denotes regular force).
---
> *       Obtain relevant force on c.m (ICM = 0 denotes resolved pair).
170c134
<           IF (KCM.NE.0) THEN
---
>           IF (ICM.NE.0) THEN
189c153,154
<           IF (K.EQ.J2) GO TO 42
---
>           IF (K.EQ.J + J) GO TO 42
> *
192,193c157,166
< *       Treat c.m. approximation for #I and #K as single or composite.
<    50     A1 = X(1,K) - XI(1)
---
>    50     J = J - N
>           J2 = J + J
> *       Sum over the components (unperturbed case is OK).
>           K = J2 - 1
> *       Treat all interactions between components of two perturbed pairs.
>           IF (I.GT.N) THEN
>               IF (RIJ2.LT.RPERT2.AND.GAMMA(I-N).GT.GMIN) GO TO 42
>           END IF
> *
>    52     A1 = X(1,K) - XI(1)
205c178
<           IF (KCM.NE.0) THEN
---
>           IF (ICM.NE.0) THEN
222c195
<           IF (K.EQ.J2) GO TO 50
---
>           IF (K.EQ.J2) GO TO 52
225,249c198,203
< *       Define regular force indicator.
<    54 KCM = 0
< *       Distinguish between second and first call (I > N & I <= N, J > N)
<       IF (JP.EQ.0) THEN
< *       Note that first case is for J > N and #I single or unperturbed c.m.
<           IF (RIJ2.LT.CMSEP2*R(J-N)**2) THEN
<               J2 = 2*(J - N)
<               K = J2 - 1
<               GO TO 50
<           END IF
<       ELSE IF (J.LE.N) THEN
< *       Consider case of single #J and perturbed c.m.
<           IF (RIJ2.LT.RPERT2) THEN
<               J2 = 0
<               GO TO 40
<           END IF
<       ELSE
< *       Split final case I > N & J > N into two parts according to RPERT2.
<           IF (RIJ2.GT.RPERT2) THEN
<               IF (RIJ2.GT.CMSEP2*R(J-N)**2) THEN
<                   K = J
<                   J2 = 0
<               ELSE
<                   J2 = 2*(J - N)
<                   K = J2 - 1
---
> *       Resolve components if I > N or J > N and no c.m. approximation.
>    54     IF (J.GT.N) THEN
>               IF (RIJ2.LT.CMSEP2*R(J-N)**2) THEN
> *       Set zero indicator to denote current pair resolved for regular force.
>                   ICM = 0
>                   GO TO 50
251,256c205,209
< *       Adopt c.m. approximation for #I.
<               GO TO 50
<           ELSE
< *       See whether both c.m. bodies should be resolved.
<               IF (RIJ2.GT.CMSEP2*R(J-N)**2) THEN
<                   J2 = 0
---
>           END IF
> *
>           IF (I.GT.N) THEN
>               IF (RIJ2.LT.RPERT2) THEN
>                   ICM = 0
258,261d210
<               ELSE
<                   J2 = 2*(J - N)
<                   K = J2 - 1
<                   GO TO 42
264d212
<       END IF
279c227
< *       Check force correction due to regularized chain (same as CMFIRR).
---
> *       Check force correction due to regularized chain (G < GMIN in REGINT).
281c229
<           IF (JP.GT.0) THEN
---
>           IF (GAMMA(I-N).GT.GMIN) THEN
1,2c1,2
< 108 1995-08-17 11:49 /work/Umi2/spurzem/5/nbody6compare/common2.h
< nbody6compare/common2.h
---
> 108 1995-08-17 11:49 /work/Umi2/spurzem/5/nbody6++compare/common2.h
> nbody6++compare/common2.h
1,2c1,2
< 3436 2006-09-02 12:38 /work/Umi2/spurzem/5/nbody6compare/common6.h
< nbody6compare/common6.h
---
> 3947 2006-06-17 08:31 /work/Umi2/spurzem/5/nbody6++compare/common6.h
> nbody6++compare/common6.h
1c1
< *       common6.
---
> *       COMMON6.
6c6
<       REAL*8  MP,MP0,MPDOT
---
>       INTEGER BK
8,11c8,17
<       COMMON/NBODY/  X(3,NMAX),X0(3,NMAX),X0DOT(3,NMAX),F(3,NMAX),
<      &               FDOT(3,NMAX),BODY(NMAX),RS(NMAX),XDOT(3,NMAX),
<      &               FI(3,NMAX),D1(3,NMAX),D2(3,NMAX),D3(3,NMAX),
<      &               FR(3,NMAX),D1R(3,NMAX),D2R(3,NMAX),D3R(3,NMAX),
---
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       SAVE
>       COMMON/MPIDAT/group,rank,ierr,isize,status
> *
>       COMMON/NBODY/  X(ID,NMAX),X0(ID,NMAX),X0DOT(ID,NMAX),F(ID,NMAX),
>      &               XN(ID,NMAX),XNDOT(ID,NMAX),
>      &               FDOT(ID,NMAX),BODY(NMAX),RS(NMAX),XDOT(ID,NMAX),
>      &               FI(ID,NMAX),D1(ID,NMAX),D2(ID,NMAX),D3(ID,NMAX),
>      &               FR(ID,NMAX),D1R(ID,NMAX),D2R(ID,NMAX),D3R(ID,NMAX),
19c25
<      &               FP0(4,KMAX),FD0(4,KMAX),TBLIST,DTB,KBLIST(KMAX),
---
>      &               FP0(4,KMAX),FD0(4,KMAX),TBLIST,DTB,KBLIST(10*KMAX),
22c28
<       COMMON/NAMES/  N,NTOT,NPAIRS,NNBMAX,NCRIT,NFIX,NMERGE,NSUB,NCH,
---
>       COMMON/NAMES/  N,NTOT,NPAIRS,NNBOPT,NCRIT,NFIX,NMERGE,NSUB,NCH,
24a31
>      &               BK(10),LSHORT(NMAX),NNBMAX,
31c38
<      &               NKSTRY,NKSREG,NKSHYP,NKSPER,NPRECT,NMARG,NKSMOD,
---
>      &               NKSTRY,NKSREG,NKSHYP,NKSPER,NPRECT,NKSREF,NKSMOD,
34c41,42
<      &               NDUMP,NBPREV,NPOP(10),JCMAX,NEWHI,NSTEPB,NBFLUX
---
>      &               NDUMP,NBPREV,NPOP(10),JCMAX,NEWHI,NBLCKR,IPE,NPES,
>      &               NSTEPB,NBFLUX,NDUMMY(8)
36c44,45
<       COMMON/PARAMS/ CPU,ETAI,ETAR,DTADJ,DELTAT,TCRIT,QE,RBAR,ZMBAR,
---
>       COMMON/PARAMS/ CPU,ETAI,ETAR,DTADJ,DELTAT,TCRIT,TCRITp,
>      &               QE,RBAR,ZMBAR,
39c48
<      &               SMIN,RMIN2,RMIN22,STEPJ,ALPHA,ZNBMIN,ZNBMAX,EBH,
---
>      &               SMIN,RMIN2,RMIN22,FCRIT2,ALPHA,ZNBMIN,ZNBMAX,EBH,
48c57
<      &               TDUMP,SCOEFF(12),TOFF,TTOT,CLIGHT,RZ,DUMMY(2)
---
>      &               TDUMP,SCOEFF(12),TOFF,TTOT,DUMMY
56,57c65
<      &               NBH,NKICK,NBKICK,KSAVE(2),ITAIL0,NTAIL,NTTOT,
<      &               NSTAIL,N1,ITYPE(5),KSTAR(NMAX)
---
>      &               NBH,NKICK,NBKICK,KSAVE(2),ITYPE(10),KSTAR(NMAX)
59c67,68
<       COMMON/PLPOT/  MP,AP2,VIR,MP0,MPDOT,TDELAY,RTIDE0,QVIR,PLDUM(4)
---
>       COMMON/HERMIT/ FIDOT(ID,NMAX),D0(ID,NMAX),FRDOT(ID,NMAX),
>      &               D0R(ID,NMAX),TIMENW(NMAX)
61,63c70
<       COMMON/HERMIT/ FIDOT(3,NMAX),D0(3,NMAX),FRDOT(3,NMAX),D0R(3,NMAX)
< *
<       COMMON/BLOCKS/ TPREV,TBLOCK,DTK(40),TIMENW(NMAX)
---
>       COMMON/BLOCKS/ TPREV,TBLOCK,DTK(64)
65a73,80
> *        Common block to keep neighbour density and potential high prec (R.Sp.)
>       COMMON/WORK2/RHO(NMAX),XNDBL(NMAX),PHIDBL(NMAX)
> *
>       COMMON/TIMING/ttota,ttreg,ttirr,ttpre,ttinit,ttint,ttks,
>      *  ttcomm,ttadj,ttmov,ttnbp,ttsub,ttsub2,ttfrc,xtsub1,xtsub2,
>      *  isernb,iserreg
> 
> 
1,2c1,2
< 414 1995-08-17 11:49 /work/Umi2/spurzem/5/nbody6compare/commonc.h
< nbody6compare/commonc.h
---
> 414 1995-08-17 11:49 /work/Umi2/spurzem/5/nbody6++compare/commonc.h
> nbody6++compare/commonc.h
1,2c1,2
< 982 2000-09-28 12:40 /work/Umi2/spurzem/5/nbody6compare/const.f
< nbody6compare/const.f
---
> 982 2005-03-09 22:59 /work/Umi2/spurzem/5/nbody6++compare/const.f
> nbody6++compare/const.f
1,2c1,2
< 4786 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/core.f
< nbody6compare/core.f
---
> 4837 2002-02-26 15:37 /work/Umi2/spurzem/5/nbody6++compare/core.f
> nbody6++compare/core.f
9c9
<       COMMON/WORK1/  RHO(NMAX)
---
>       DATA RHOM/1.0D0/
16a17
> *       Initialize neighbour densities of all singles and c.m.
18a20
>           RHO(I) = 0.D0
26a29
> 
37c40
< *       Skip and set density to zero if there are no neighbours.
---
> *       Skip and set density to zero of there are no neighbours
39,41c42,43
<               RHO(I) = 0.0
<               GO TO 50
<           END IF 
---
>           RHO(I) = 0.0D0
>           ELSE
87,89c89,96
<           RHO(I) = XMASS/(RLIST(I6)*SQRT(RLIST(I6)))
< *       Define particle number density (not used).
< *         RHON = RHO(I)/ZMASS
---
>           IF (RLIST(I6).GT.0.0D0) THEN
>               RINV32 = 1.0D0/(RLIST(I6)*SQRT(RLIST(I6)))
>           ELSE
>               RINV32 = 0.0D0
>           END IF
>           RHO(I) = XMASS*RINV32
> *       For multi-mass store also five neighbour particle density
>           XNDBL(I) = RINV32
92a100
>           END IF
113,116d120
< *       Ignore density centre for Plummer binary models except at end.
<           IF (KZ(5).EQ.2.AND.TTOT.LT.TCRIT) THEN
<               RDENS(K) = 0.0
<           END IF
1,2c1,2
< 639 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/cputim.f
< nbody6compare/cputim.f
---
> 535 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/cputim.f
> nbody6++compare/cputim.f
0a1,4
> # 1 "cputim.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "cputim.F"
4,5c8,9
< *       CPU time.
< *       ---------
---
> * CPU time.
> * ---------
7c11,12
<       REAL*8  TCOMP
---
>       INCLUDE 'common6.h'
>       REAL*8 TCOMP
9c14
<       REAL*4  TARRAY(2)
---
>       REAL*4 tt,TARRAY(2),etime
11,21c16,19
< *
< *       Initialize timer (first call) or obtain elapsed time.
<       IF (ICPU.EQ.0) THEN
< *         CALL LIB$INIT_TIMER
<           TCOMP = 0.0
< *         TCOMP = ETIME(TARRAY)
< *         TCOMP = MCLOCK()/6000.
<           ICPU = 1
<       ELSE
< *         CALL LIB$STAT_TIMER(2,ITIME)
< *         TCOMP = FLOAT(ITIME)/6000.0
---
> * Initialize timer (first call) or obtain elapsed time.
> * TCOMP = FLOAT(ITIME)/6000.0
> * TCOMP = REAL(IRTC())*6.67D-9/60.
> # 29 "cputim.F"
23,25c21,24
< *         TCOMP = MCLOCK()/6000.
< *       Elapsed CPU time in minutes on VAX, SUN or MIPS & IBM RS/6000.
<       END IF
---
> 
> * TCOMP = MCLOCK()/6000.
> * Elapsed CPU time in minutes on VAX, SUN or MIPS & IBM RS/6000.
> * and T3D
1,2c1,2
< 4228 2000-06-22 18:08 /work/Umi2/spurzem/5/nbody6compare/cstab2.f
< nbody6compare/cstab2.f
---
> 4452 2005-03-09 23:00 /work/Umi2/spurzem/5/nbody6++compare/cstab2.f
> nbody6++compare/cstab2.f
12a13,15
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
112a116
>           if(rank.eq.0)then
118a123
>           end if
121c126,128
<           WRITE (81,30)  TIMEC, RI, NAMEC(I3), QL, Q1, ECC, ECC1,
---
>           K = INAME(I3)
>           if(rank.eq.0)
>      &    WRITE (81,30)  TIMEC, RI, NAMEC(K), QL, Q1, ECC, ECC1,
1,2c1,2
< 4510 2001-11-27 11:39 /work/Umi2/spurzem/5/nbody6compare/cstab3.f
< nbody6compare/cstab3.f
---
> 4723 2005-03-09 23:02 /work/Umi2/spurzem/5/nbody6++compare/cstab3.f
> nbody6++compare/cstab3.f
11a12,14
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
113c116,117
<                   WRITE (6,19)  NSTEP1, ECC4, SEMI, PCRIT, PMIN4, G4
---
>                   if(rank.eq.0)
>      &            WRITE (6,19)  NSTEP1, ECC4, SEMI, PCRIT, PMIN4, G4
125c129,130
<           WRITE (6,20)  ECC, ECC1, SEMI, SEMI1, PMIN, PCRIT, EK, PZ
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  ECC, ECC1, SEMI, SEMI1, PMIN, PCRIT, EK, PZ
131c136,137
<           WRITE (81,30)  TIMEC, RI, NAMEC(I3), QL, Q1, ECC, ECC1,
---
>           if(rank.eq.0)
>      &    WRITE (81,30)  TIMEC, RI, NAMEC(I3), QL, Q1, ECC, ECC1,
139a146
> 
1,2c1,2
< 4508 2000-06-22 18:09 /work/Umi2/spurzem/5/nbody6compare/cstab4.f
< nbody6compare/cstab4.f
---
> 4685 2005-03-09 23:02 /work/Umi2/spurzem/5/nbody6++compare/cstab4.f
> nbody6++compare/cstab4.f
12a13,15
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
125,126c128
<       IF (PMIN.GT.PCRIT.AND.SEMI.GT.0.0.AND.SEMI1.GT.0.0.AND.
<      &    RB.GT.SEMI) THEN
---
>       IF (PMIN.GT.PCRIT.AND.SEMI.GT.0.0.AND.SEMI1.GT.0.0) THEN
128c130,131
<           WRITE (6,20)  ECC, ECC1, SEMI, SEMI1, PMIN, PCRIT, EK, ALPHA
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  ECC, ECC1, SEMI, SEMI1, PMIN, PCRIT, EK, ALPHA
134c137,139
<           WRITE (81,30)  TIMEC, RI, NAMEC(I3), QL, Q1, ECC, ECC1,
---
>           K = INAME(I3)
>           if(rank.eq.0)
>      &    WRITE (81,30)  TIMEC, RI, NAMEC(K), QL, Q1, ECC, ECC1,
1,2c1,2
< 7041 2005-04-01 14:38 /work/Umi2/spurzem/5/nbody6compare/cstab5.f
< nbody6compare/cstab5.f
---
> 6323 2005-03-09 23:02 /work/Umi2/spurzem/5/nbody6++compare/cstab5.f
> nbody6++compare/cstab5.f
8a9
>       COMMON/CHREG/  TIMEC,TMAX,RMAXC,CM(10),NAMEC(6),NSTEP1,KZ27,KZ30
11a13,15
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
15,16c19
<       IR = 0
<       DO 1 I = 1,N-2
---
>       DO 5 I = 1,N-2
17a21
>           IR = 0
21c25
<     1 CONTINUE
---
>     5 CONTINUE
24,26c28,31
<       IF (IR.GT.0) THEN
< *         WRITE (6,2)  I, (1.0/RINV(K),K=1,N-1)
< *   2     FORMAT (' CSTAB5 TEST    I R ',I4,1P,5E9.1)
---
>       IF (IR.GT.1) THEN
> *         if(rank.eq.0)
> *    &    WRITE (6,2)  NSTEP1, I, (1.0/RINV(K),K=1,N-1)
> *   2     FORMAT (' CSTAB5 TEST    # I R ',I6,I4,1P,5E9.1)
46,78c51
<       I5 = 0
<       IF (N.EQ.2) THEN
<           I3 = I2
<           I4 = I1
<       ELSE IF (N.EQ.3) THEN
<           I4 = I1
< *       Note N = 4 is already defined correctly.
<       ELSE IF (N.GT.4) THEN
< *       Determine indices of second closest pair (avoid pair I1-I2).
<           RX1 = 1.0
<           RX0 = R2(I1,I2)
<           DO 5 J1 = 1,N
<               IF (J1.EQ.I1.OR.J1.EQ.I2) GO TO 5
<               DO 4 J2 = J1+1,N
<                   IF (J2.EQ.I1.OR.J2.EQ.I2) GO TO 4
<                   IF (R2(J1,J2).LT.RX1.AND.R2(J1,J2).GT.RX0) THEN
<                       RX1 = R2(J1,J2)
<                       I3 = J1
<                       I4 = J2
<                   END IF
<     4         CONTINUE
<     5     CONTINUE
< *       Identify remaining single particle(s) by exclusion.
<           DO 8 I = 1,N
<               IF (I.EQ.I1.OR.I.EQ.I2.OR.I.EQ.I3.OR.I.EQ.I4) GO TO 8
<               IF (I5.EQ.0) THEN
<                   I5 = I
<               ELSE 
<                   I6 = I
<               END IF
<     8     CONTINUE
<       END IF
< *
---
>       I5 = IJ(5)
214c187,188
<           WRITE (6,20)  ECC0, ECC1, SEMI, SEMI1, PMIN, PCRIT, SEMI2,
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  ECC0, ECC1, SEMI, SEMI1, PMIN, PCRIT, SEMI2,
223a198
> 
1,2c1,2
< 2562 2006-09-02 12:16 /work/Umi2/spurzem/5/nbody6compare/data.f
< nbody6compare/data.f
---
> 4144 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/data.f
> nbody6++compare/data.f
0a1,4
> # 1 "data.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "data.F"
4,5c8,9
< *       Initial conditions.
< *       -------------------
---
> * Initial conditions.
> * -------------------
8c12,14
<       REAL*4  RAN2
---
>       REAL*8 A(8)
>       CHARACTER*1 CHAR(80)
>       LOGICAL LREADN,LREADP,LREADF
9a16
> # 21 "data.F"
11,29c18,24
< *       Initialize the portable random number generator (range: 0 to 1).
<       KDUM = -1
<       RN1 = RAN2(KDUM)
< *       Skip the first random numbers (IDUM1 specified at input).
<       DO 1 K = 1,IDUM1
<           RN1 = RAN2(KDUM)
<     1 CONTINUE
< *
< *       Save random number sequence in COMMON for future use.
<       IDUM1 = KDUM
< *
< *       Read mass function parameters, # primordials, Z-abundance & epoch.
<       READ (5,*)  ALPHA, BODY1, BODYN, NBIN0, ZMET, EPOCH0, DTPLOT
<       IF (ZMET.LE.0.0D0) ZMET = 1.0D-04
<       IF (ZMET.GT.0.03) ZMET = 0.03
< *
< *       Check option for reading initial conditions from input file.
<       IF (KZ(22).GE.2) THEN
<           ZMASS = 0.0
---
> * Set provisional total mass (rescaled in routine SCALE).
>       ZMASS = FLOAT(N)
> *
> * Check option for reading initial conditions from input file.
>       if(rank.eq.0)then
> *
>       IF (KZ(22).EQ.2.OR.KZ(22).EQ.6) THEN
31,35c26,31
<               READ (10,*)  BODY(I), (X(K,I),K=1,3), (XDOT(K,I),K=1,3)
<               ZMASS = ZMASS + BODY(I)
<     5     CONTINUE
< *       Include possibility of retaining the mass distribution.
<           IF (KZ(22).GT.2) GO TO 40
---
>               READ (10,*) BODY(I), (X(K,I),K=1,3), (XDOT(K,I),K=1,3)
>     5 CONTINUE
> * Read tidal radius if cutoff required
>       IF (KZ(23).GE.3) READ (10,*) RTIDE
>           PRINT*,' rank ',rank,N,' body data read from unit 10 ',
>      * ' RTIDE =',RTIDE
36a33,88
> * End reading NBODY input data format.
> *
> * Read TREE input format
>       IF (KZ(22).EQ.3.OR.KZ(22).EQ.7) THEN
>           READ(10,*) N
>           READ(10,*) DUMDY
>           READ(10,*) DUMDY
>           PRINT*,' N=',N
>           DO 51 I = 1,N
>           READ(10,*)BODY(I)
>    51 CONTINUE
>           PRINT*,' masses read ',BODY(1),BODY(N)
>           DO 52 I = 1,N
>    52 READ(10,*)(X(K,I),K=1,3)
>           DO 53 I = 1,N
>    53 READ(10,*)(XDOT(K,I),K=1,3)
>           NTOT = N
>           PRINT*,' rank ',rank,N,' body data read from unit 10 '
>           CALL FLUSH(6)
>       END IF
> * End read TREE input format
> * Read STARLAB input format
>       IF (KZ(22).EQ.4.OR.KZ(22).EQ.8) THEN
>           I = 0
>           IS = 0
>           LREADF = .FALSE.
>           LREADP = .FALSE.
>   61 CONTINUE
>           READ(10,'(2A1)')(CHAR(K),K=1,2)
> *
>           LREADN=(.NOT.LREADF).AND.CHAR(1).EQ.'('.AND.CHAR(2).EQ.'P'
>           IF(LREADN)THEN
>           LREADF=.TRUE.
>           READ(10,111)N
>           PRINT*,' Read N=',N
>           NTOT = N
>           END IF
> *
>           LREADP=CHAR(1).EQ.'('.AND.CHAR(2).EQ.'D'
>           IF(LREADP.AND.IS.EQ.0)THEN
>           IS = 1
>           ELSE
>           IF(LREADP)THEN
>           I = I + 1
>           READ(10,*)CHAR(1),CHAR(2),BODY(I)
>           READ(10,*)CHAR(1),CHAR(2),(X(K,I),K=1,3)
>           READ(10,*)CHAR(1),CHAR(2),(XDOT(K,I),K=1,3)
>           END IF
>           END IF
>           IF(I.LT.N)GO TO 61
>           PRINT*,N,' Particles read from Starlab File'
>  111 FORMAT(5X,I5)
>       END IF
> *
>       end if
> # 101 "data.F"
38c90,99
< *       Include the case of equal masses (ALPHA = 1 or BODY1 = BODYN).
---
> * Read mass function parameters, # primordials, Z-abundance & epoch.
> * And plot interval for HR diagram.
>        if(rank.eq.0)then
>        READ (5,*) ALPHA, BODY1, BODYN, NBIN0, ZMET, EPOCH0,DTPLOT
>        end if
> # 116 "data.F"
> *
>       IF(KZ(22).GE.2)GO TO 50
> *
> * Include the case of equal masses (ALPHA = 1 or BODY1 = BODYN).
42,45c103,104
<    10     CONTINUE
< *       Set provisional total mass (rescaled in routine SCALE).
<           ZMASS = FLOAT(N)
<           GO TO 40
---
>    10 CONTINUE
>           IF (KZ(20).NE.6) GO TO 40
48c107
< *       Choose between two realistic IMF's and standard Salpeter function.
---
> * Choose between two realistic IMFs and standard Salpeter function.
55a115,116
> * Metallicity should be set to minimum value.
>       IF(ZMET.EQ.0.D0) ZMET = 1.D-4
57,61c118
<       WRITE (6,15)  ALPHA, BODY1, BODYN
<    15 FORMAT (/,12X,'STANDARD IMF    ALPHA =',F5.2,
<      &              '  BODY1 =',F5.1,'  BODYN =',F5.2)
< *
< *       Generate a power-law mass function with exponent ALPHA.
---
> * Generate a power-law mass function with exponent ALPHA.
68c125
< *       Assign individual masses sequentially.
---
> * Assign individual masses sequentially.
75c132,139
< *       Scale the masses to <M> = 1 for now and set consistent total mass.
---
>       if(rank.eq.0)then
>       WRITE (6,15) ALPHA, BODY1, BODYN, ZMASS, NBIN0, ZMET, EPOCH0
>    15 FORMAT (/,12X,'STANDARD IMF    ALPHA =',F5.2,
>      & '  BODY1 =',F5.1,'  BODYN =',F5.2,' ZMASS =',1P,E12.5,0P,
>      & ' NBIN0=',I5,' ZMET =',F5.2,' EPOCH0 =',F5.2)
>       end if
> *
> * Scale the masses to <M> = 1 for now and set consistent total mass.
82c146
< *       Set up initial coordinates & velocities (uniform or Plummer model).
---
> * Set up initial coordinates & velocities (uniform or Plummer model).
86a151,152
>    50 CONTINUE
> *
1,2c1,2
< 14619 2006-09-02 12:20 /work/Umi2/spurzem/5/nbody6compare/define.f
< nbody6compare/define.f
---
> 14336 2005-03-09 14:56 /work/Umi2/spurzem/5/nbody6++compare/define.f
> nbody6++compare/define.f
4c4
< *       Definition of input parameters, options & counters.
---
> *       Definition of input parameters, options & counters. (NB6++)
6a7,8
> * ********** NOTE: Contents of [] to be removed with time.*************
> * ********** Not read by nb6++                            *************
12,14d13
< ***
< * NBODY6:
< *
17,20c16,24
< ***
< * INPUT:
< *
< *       N       Total particle number (singles + binary c.m.; < NMAX - 2).
---
> *       TCRITp  Termination time in Myrs.
> *       isernb  Max size of sequential irr blocks on parallel machine 
> *               for single CPU dummy
> *       iserreg as isernb for reg blocks
> *               for single CPU dummy
> *--------
> *       N       Total number of centre of masses (<NMAX - 2).
> *               e.g: N=100 binaries = NBIN0=NBIN below for f=1
> *                    N=100, and NBIN0=NBIN=50 for f=0.5
23,24c27,29
< *       NRAND   Random number sequence skip.
< *       NNBMAX  Maximum number of neighbours (< LMAX - 2).
---
> *       NRAND   Random number seed; any positive integer
> *               [ NNBMAX  Maximum neighb.numb. (= MIN(N/2,LMAX-3) set in input.F].
> *       NNBOPT  Desired optimal neighbour number (R.Sp.)
26c31
< *
---
> *--------
30,32c35,39
< *       DTADJ   Time interval for parameter adjustment (N-body units).
< *       DELTAT  Output time interval (N-body units).
< *       TCRIT   Termination time (N-body units).
---
> *       DTADJ   Time interval for parameter adjustment.
> *       DELTAT  Output time interval.
> *->             NFIX=1 and DTADJ=DELTAT => OUT3 written every adjust time
> *       TCRIT   Termination time.
> *->             The _earlier_ termination criterion becomes active
34c41
< *       RBAR    Virial cluster radius in pc (set = 1 for isolated cluster).
---
> *       RBAR    Virial cluster radius in pc (set = 0 for isolated cluster).
36,38c43,46
< *
< *       KZ(J)   Non-zero options for alternative paths (see table).
< *
---
> *--------
> *       KZ(J)   Non-zero options for alternative paths (see table below).
> *       BK(J)   Non-zero options for binpop_4new routine (see table below).
> *--------
45,48c53,54
< ***
< * INPUT: if (kz(4).gt.0)
< *
< *       DELTAS  Output interval for binary search (in TCR; suppressed).
---
> *--------
> *       DELTAS  Output interval for binary search (option 4).
51,54c57,58
< ***
< * DATA:
< *
< *       ALPHAS  Power-law index for initial mass function (used if #20 < 2).
---
> *--------
> *       ALPHAS  Power-law index for initial mass function (routine DATA).
56,57c60,61
< *       BODYN   Minimum particle mass before scaling.
< *       NBIN0   Number of primordial binaries (for IMF2 with KZ(20) > 1).
---
> *       BODYN   Minimum particle mass before scaling (KZ(20): solar mass).
> *       NBIN0   Number of primordial binaries (for IMF2 with KZ(20) > 2).
60,85c64,65
< *       DTPLOT  Plotting interval for HRDIAG (N-body units; >= DELTAT).
< ***
< * SETUP: if(kz(5).eq.2)
< *
< *       APO     Separation of two Plummer models (SEMI = APO/(1 + ECC).
< *       ECC     Eccentricity of two-body orbit (ECC < 0.999).
< *       N2      Membership of second Plummer model (N2 <= N).
< *       SCALE   Second scale factor (>= 0.2 for limiting minimum size).
< *
< *        if(kz(5).eq.3)
< *
< *       APO     Separation between the perturber and Sun.
< *       ECC     Eccentricity of orbit (=1 for parabolic encounter).
< *       DMIN    Minimum distance of approach (pericentre).
< *       SCALE   Perturber mass scale factor (=1 for Msun).
< *
< *        if(kz(5).eq.4)
< *
< *       SEMI    Initial semi-major axis (changes a bit on scaling).
< *       ECC     Eccentricity (ECC > 1: NAME = 1 & 2 free-floating).
< *       M1      Mass of first member (in units of mean mass).
< *       M2      Mass of second member (rescaled total mass = 1).
< ***
< * SCALE:
< *
< *       Q       Virial ratio (Q = 0.5 for equilibrium).
---
> *--------
> *       Q       Virial ratio (routine SCALE; Q = 0.5 for equilibrium).
88,122c68,92
< *       RTIDE   Unscaled tidal radius (#14 >= 2; otherwise copied to RSPH2).
< ***
< * XTRNL0: if (kz(14).eq.2)
< *
< *       GMG     Point-mass galaxy (solar masses, linearized circular orbit).
< *       RG0     Central distance (in kpc).
< *
< *         if (kz(14).eq.3)
< *       GMG     Point-mass galaxy (solar masses).
< *       DISK    Mass of Miyamoto disk (solar masses).
< *       A       Softening length in Miyamoto potential (in kpc).
< *       B       Vertical softening length (kpc).
< *       VCIRC   Galactic circular velocity (km/sec) at RCIRC (=0: no halo).
< *       RCIRC   Central distance for VCIRC with logarithmic potential (kpc).
< *       RG      Initial position; GMG+DISK=0, VG(3)=0: A(1+E)=RG(1), E=RG(2).
< *       VG      Initial cluster velocity vector (km/sec).
< *
< *         if (kz(14).eq.3.or.kz(14).eq.4)
< *       MP      Total mass of Plummer sphere (in scaled units).
< *       AP      Plummer scale factor (square saved in AP2).
< *       MPDOT   Decay time for gas expulsion (MP = MP0/(1 + MPDOT*(T-TD)).
< *       TDELAY  Delay time for starting gas expulsion (T > TDELAY).
< ***
< * HOTSYS: if (kz(29).gt.0)
< *
< *       SIGMA0  Hot initial velocities in km/sec (CALL REFLCT suppressed).
< ***
< * BINPOP: if (kz(8).eq.1.or.kz(8).gt.2)
< *
< *       NBIN    Number of primordial binaries.
< *       SEMI    Max semi-major axis in model units (all equal if RANGE = 0).
< *       ECC     Initial eccentricity (< 0 for thermal distribution).
< *       RATIO   Mass ratio M1/(M1 + M2); (= 1.0: M1 = M2 = <M>; not #20 > 1).
< *       RANGE   Range in SEMI for uniform logarithmic distribution (> 0).
< *       NSKIP   Binary frequency of mass spectrum (#20 < 2; body #1 first).
---
> *       RSPH2   Radius of reflecting sphere (option 29; units of RSCALE).
> *--------
> *       NCL     Number of interstellar clouds (routine CLOUD0; option 13).
> *       RB2     Radius of cloud boundary in pc (square is saved).
> *       VCL     Mean cloud velocity in km/sec.
> *       SIGMA   Gaussian velocity dispersion of clouds in km/sec.
> *       CLM     Individual cloud masses in solar masses (maximum is MCL).
> *       RCL2    Half-mass radii of clouds in pc (square is saved).
> *--------
> *       SIGMA0  Hot initial velocities in km/sec (routine HOTSYS; option 29).
> *--------
> *       NBIN    Number of initial binaries (routine BINPOP; option 8).
> *       SEMI    Initial semi-major axis (= 0 for range of energies).
> *       ECC     Initial eccentricity (for BINPOP_4NEW)
> *               <=1 AND >=0 for one particular fixed ecc. for all systems
> *               < 0 for thermal distribution,
> *               =20 for uniform distribution,
> *               =30 for f(e)=0.1765/(e*e)
> *               =40 for general f(e)=a*e^b, e0<=e<=1 with a=(1+b)/(1-e0^(1+b))
> *                   e0 and b must be defined in binpop routine
> *       RATIO   Mass ratio M1/(M1 + M2); (= 1.0: M1 = M2 = <M>).
> *       NBGR    Number of binaries in fixed energy groups.
> *       REDUCE  Reduction factor in semi-major axis for each group.
> *       RANGE   Energy range for uniform logarithmic distribution.
> *       NSKIP   Binary frequency of mass spectrum (starting from body #1).
125,129c95,97
< ***
< * HIPOP: if (kz(8).gt.0.and.kz(11).gt.1)
< *
< *       NHI     Number of primordial hierarchies.
< *       SEMI    Max semi-major axis in model units (all equal if RANGE = 0).
---
> *--------
> *       NHI     Number of primordial hierarchies (routine HIPOP; #11 > 1).
> *       SEMI    Semi-major axis in model units (all equal if RANGE = 0).
134,138c102,104
< ***
< * INTIDE: if (kz(27).gt.0)
< *
< *       RSTAR   Size of typical star in A.U.
< *       IMS     # idealized main-sequence stars.
---
> *--------
> *       RSTAR   Size of typical star in A.U. (routine INTIDE; option 27).
> *       IMS     # idealized main-sequence stars (routine INTIDE; option 27).
142,150d107
< ***
< * CLOUD0: if (kz(13).gt.0)
< *
< *       NCL     Number of interstellar clouds.
< *       RB2     Radius of cloud boundary in pc (square is saved).
< *       VCL     Mean cloud velocity in km/sec.
< *       SIGMA   Velocity dispersion (#13 > 1: Gaussian).
< *       CLM     Individual cloud masses in solar masses (maximum MCL).
< *       RCL2    Half-mass radii of clouds in pc (square is saved).
160,161c117
< *       3  Basic data on unit 3 at output time (unformatted, frequency NFIX).
< *             =1/2: standard and/or tail; =3: tail only; >3: cluster + tail.
---
> *       3  Basic data on unit 3 at output time (frequency NFIX).
163,166c119
< *       5  Initial conditions (#22 =0; =0: uniform & isotropic sphere;
< *                =1: Plummer; =2: two Plummer models in orbit, extra input;
< *                =3: massive perturber and planetesimal disk, extra input).
< *                =4: massive initial binary, extra input; output on unit 35).
---
> *       5  Initial conditions (#22 =0; =0: uniform & isotropic; =1: Plummer).
168,171c121,122
< *       7  Lagrangian radii (>0: RSCALE; =2, 3, 4: output units 6, 7, 12;
< *                 =5: density & rms velocity at given radii on unit 26 & 27;
< *                 =6: Lagrangian radii for two mass groups on unit 31 & 32.
< *       8  Primordial binaries (=1 & >=3; >0: BINOUT; >2: BINDAT; >3: HIDAT).
---
> *       7  Lagrangian radii (>0: RSCALE; =2, 3, 4: output on unit 6 & 7).
> *       8  Primordial binaries (=1 & 3; >0: BINOUT; >2: BINDAT; >3: HIDAT).
177,178c128
< *      14  External force (=1: standard tidal field; =2: point-mass galaxy;
< *             =3: point-mass + disk + halo + Plummer; =4: Plummer sphere).
---
> *      14  External force (=1: standard tidal field; =2: not implemented).
183,184c133,136
< *      19  Mass loss (=1: old supernova scheme; =3: Eggleton, Tout & Hurley).
< *      20  Initial mass function (=1: Scalo; =2,4,6: Kroupa; =3,5: Eggleton).
---
> *      19  Mass loss (=1: supernova scheme; =3: Eggleton, Tout & Hurley).
> *      20  Initial mass function (=1: Tout; =2,4: Kroupa; =3,5: Eggleton).
> *          >3 => mass ratio distr. as defined in imf2.f
> *          =2 for KTG93 IMF with random pairing (imf2.f)
187,189c139,142
< *      23  Escaper removal (>1: diagnostics in file ESC; =2: angles unit #6;
< *                           >=3: initialization  & integration of tidal tail).
< *      24  Initial conditions for subsystem (routine SCALE; KZ(24) = #).
---
> *                               (=4: starlab input format)
> *      23  Removal of escapers (=1: isolated cluster; =2: diag; 
> *                               =3: tidal cut       ; =4: diag).
> *      24  Initial conditions for subsystems (routine SCALE and input from dat.10).
192c145,146
< *      27  Tidal effects (=1: circularization; =2: Press-Teukolsky; =3: GR).
---
> *      27  Two-body tidal interaction (n = 1.5: type 3 & 5; n = 3: others).
> *      27  Tidal circularization & collisions (R_coll = 0.75*(R_1 + R_2)).
195c149
< *      30  Chain regularization (=1: basic; >1: extra output; >2: each step).
---
> *      30  Chain regularization (>=2: main output; >2: diagnostic output).
199,205c153,180
< *      34  Roche-lobe overflow (not implemented yet). 
< *      35  Time offset (global time from TTOT = TIME + TOFF; offset = 100).
< *      36  Step reduction for hierarchical systems (not recommended).
< *      37  Fast time-step criterion (>0: STEP; >1: STEPR; not recommended).
< *      38  Force polynomial corrections (=0: I > N; not recommended).
< *      39  No unique density centre (skips velocity modification of RS(I)).
< *      40  Increase of neighbour numbers if <NNB> < NNBMAX/2.
---
> *      34  Roche lobe overflow (not implemented yet).
> *      35  Time offset (global time from TTOT = TIME + DTOFF).
> *      36  Step reduction for hierarchical systems.
> *      37  Fast time-step criterion (>0: STEP; >1: STEPR).
> *      38  No force polynomial corrections (I <= N; block-step version).
> *      39  shape analysis by routine ellan (=2) with Ch. Theis
> *      40  adjust neighbour number to optimal neighbour number.
> *       ---------------------------------------------------------------------
> *
> *
> *       Options BK(J)   (for binpop_4new.f)
> *       *************
> *
> *       ---------------------------------------------------------------------
> *       1  =0: no proto-star evolution                                       
> *          =1:"proto-star" evol. of ecc,period in binpop_4new.f           
> *       2  = -1: use NBGR and REDUCE in binpop_pk.f
> *          =0:flat distr. in semi-major axis                                 
> *          =1:f=0.034388logP                                                 
> *          =2:f=3.5logP/[100+(logP)**2]                                      
> *             KZ(40)=1,2 are 1st and 2nd iterations                          
> *          =3:f=2.3(logP-1)/[45+(logP-1)**2]                                 
> *          =4:f=2.5(logP-1)/[45+(logP-1)**2] -- derived in K2
> *               NOTE: in routine adjust.f KZ(40)>0 is used to adjust         
> *                     neighbour number                                       
> *          =5:f = Duquennoy&Mayor (1991), i.e. Gaussian in logP 
> *       4  =1: file peri_hyperbol.dat opened and written to (see ksint.f)
> *          =0: not opened
229,231c204,208
< *       NFAST   Fast particles included in LISTV (option 18).
< *       NBFAST  Fast particles included in neighbour list (option 18).
< *       NBLOCK  Number of blocks (block-step version).
---
> *       NFAST   Fast particle included in LISTV (option 18).
> *       NBFAST  Fast particle included in neighbour list (option 18).
> *       NBREF   Boundary reflections (option 29; suppressed).
> *       NBLOCK  Number of irregular blocks (block-step version).
> *       NBLCKR  Number of regular blocks (block-step version) (R.Sp.)
245d221
< *       NMARG   Marginal merger stability (accepted after 10,000 tries).
247d222
< *       NEWHI   New hierarchical systems (counted by routine HIARCH).
251c226
< *       NDISS   Tidal dissipations at pericentre (option 27).
---
> *       NDISS   Tidal dissipation at pericentre (option 27).
253c228
< *       NSYNC   Number of synchronous binaries (option 27).
---
> *       NSYNC   Number of synchronous binaries (a < RSYNC; option 27).
258,265d232
< *       NRG     Red giants.
< *       NHE     Helium stars.
< *       NRS     Red supergiants.
< *       NNH     Naked Helium stars.
< *       NWD     White dwarfs.
< *       NSN     Neutron stars.
< *       NBH     Black holes.
< *       NBS     Blue stragglers.
289,292c256
< *      19       Circularizing binary (c.m. value).
< *      20       Circularized binary.
< *      21       First Roche stage (inactive).
< *      22       Second Roche stage.
---
> *      20       Circularized binary (c.m. value).
1,2c1,2
< 2054 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/delay.f
< nbody6compare/delay.f
---
> 1937 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/delay.f
> nbody6++compare/delay.f
27,31c27,28
< *      Preserve contents of KSAVE during chain regularization.
<           IF (NCH.EQ.0) THEN
<               KSAVE(1) = 0
<               KSAVE(2) = 0
<           END IF
---
>           KSAVE(1) = 0
>           KSAVE(2) = 0
1,2c1,2
< 7314 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/derqp3.f
< nbody6compare/derqp3.f
---
> 7314 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/derqp3.f
> nbody6++compare/derqp3.f
1,2c1,2
< 9994 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/derqp4.f
< nbody6compare/derqp4.f
---
> 9994 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/derqp4.f
> nbody6++compare/derqp4.f
1,2c1,2
< 11946 2006-09-07 19:29 /work/Umi2/spurzem/5/nbody6compare/derqp.f
< nbody6compare/derqp.f
---
> 11676 2001-08-04 17:17 /work/Umi2/spurzem/5/nbody6++compare/derqp.f
> nbody6++compare/derqp.f
349c349
<           IF (ECC.LT.0.003.AND.IMCIRC.EQ.0.AND.VSTAR1.LT.100.0) THEN
---
>           IF (ECC.LT.0.003.AND.IMCIRC.EQ.0) THEN
411,417d410
< *       Avoid apocentre region of secondary binary (algorithmic confusion).
<           ELSE IF (RB.GT.SEMI.AND.IMCIRC.GT.0) THEN
<               JC = 0
<               ITER = 0
<               IMCIRC = 0
<               ICOLL = 0
<               KCOLL = .false.
433a427
> 
1,2c1,2
< 3533 2004-05-11 13:03 /work/Umi2/spurzem/5/nbody6compare/difsy1.f
< nbody6compare/difsy1.f
---
> 3497 1999-03-23 10:20 /work/Umi2/spurzem/5/nbody6++compare/difsy1.f
> nbody6++compare/difsy1.f
16c16
<       PARAMETER  (NMX=80,NMX7=7*NMX)
---
>       PARAMETER  (NMX=80)
25d24
<       DATA DT /NMX7*0.0D0/
64c63
<       G=H/M
---
>       G=H/(M)
1,2c1,2
< 3215 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/difsy3.f
< nbody6compare/difsy3.f
---
> 3180 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/difsy3.f
> nbody6++compare/difsy3.f
16c16
<       PARAMETER  (NMX=17,NMX7=7*NMX)
---
>       PARAMETER  (NMX=17)
23d22
<       DATA DT /NMX7*0.0D0/
61c60
<       G=H/M
---
>       G=H/(M)
125c124
<       IF(FYBAD)THEN
---
>       IF(FY BAD)THEN
1,2c1,2
< 3200 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/difsy4.f
< nbody6compare/difsy4.f
---
> 3165 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/difsy4.f
> nbody6++compare/difsy4.f
16c16
<       PARAMETER  (NMX=25,NMX7=7*NMX)
---
>       PARAMETER  (NMX=25)
23d22
<       DATA DT /NMX7*0.0D0/
61c60
<       G=H/M
---
>       G=H/(M)
125c124
<       IF(FYBAD)THEN
---
>       IF(FY BAD)THEN
1,2c1,2
< 1503 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/efac2.f
< nbody6compare/efac2.f
---
> 1504 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/efac2.f
> nbody6++compare/efac2.f
51a52
> 
1,2c1,2
< 1510 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/efac3.f
< nbody6compare/efac3.f
---
> 1511 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/efac3.f
> nbody6++compare/efac3.f
51a52
> 
1,2c1,2
< 2484 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/endreg.f
< nbody6compare/endreg.f
---
> 2484 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/endreg.f
> nbody6++compare/endreg.f
1,2c1,2
< 2513 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/energy.f
< nbody6compare/energy.f
---
> 2327 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/energy.f
> nbody6++compare/energy.f
9d8
< *
25,26c24,26
<       I = 1
<    20 JMIN = I + 1
---
> *
>       DO 20 I = 1,NTOT
>       JMIN = I + 1
31a32,38
> *
>       IPAIR = 0
>       IF (I.GT.N)  THEN
> *       Binding energy at center of mass position without binary members
>           IPAIR = I - N
>       END IF
> *
32a40,41
>       POTI = 0.D00
> *       POTI contains potential at particles position to be stored later (R.Sp.)
34,35c43,45
<       DO 30 J = JMIN,N
<           IF (BODY(J).EQ.0.0D0) GO TO 30
---
>       DO 30 J = 1,N
>       IF (J.EQ.I .OR. J.EQ.2*IPAIR-1 .OR. J.EQ.2*IPAIR .OR.
>      *    BODY(J).EQ.0.0D0 .OR. BODY(I).EQ.0.0D0)  GO TO 30
39c49,52
<           POTJ = POTJ + BODY(J)/SQRT(A1*A1 + A2*A2 + A3*A3)
---
>       A4 = BODY(J)/DSQRT (A1*A1 + A2*A2 + A3*A3)
>       POTI = POTI - A4
> *  also J.LT.N?
>       IF(J.GE.JMIN)POTJ = POTJ + A4
41c54,55
< *
---
> *       Store potential in shared vector first (R.Sp.)
>       PHIDBL(I) = POTI
43,44c57
<       I = I + 1
<       IF (I.LT.N) GO TO 20
---
>    20 CONTINUE
50a64
> *
53,57c67,69
< *       Obtain the tidal potential energy for linearized external field. 
<       IF (KZ(14).EQ.0) THEN
< *       Note: ETIDE holds accumulated tidal energy if KZ(14) = 3.
<           ETIDE = 0.0D0
<       ELSE IF (KZ(14).LE.2) THEN
---
> *       Obtain the tidal potential if external field is present.
>       ETIDE = 0.0D0
>       IF (KZ(14).GT.0) THEN
59,73d70
<       ELSE IF (KZ(14).EQ.4.OR.(KZ(14).EQ.3.AND.MP.GT.0.0D0)) THEN
< *       Include optional tidal energy and virial for Plummer potential.
<           ETIDE = 0.0
<           VIR = 0.0
<           DO 50 I = 1,N
<               RI2 = AP2
<               DO 45 K = 1,3
<                   RI2 = RI2 + X(K,I)**2
<    45         CONTINUE
<               FM = BODY(I)*MP/(RI2*SQRT(RI2))
<               DO 48 K = 1,3
<                   VIR = VIR - FM*X(K,I)**2
<    48         CONTINUE
<               ETIDE = ETIDE - BODY(I)*MP/SQRT(RI2)
<    50     CONTINUE
1,2c1,2
< 1715 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/erel3.f
< nbody6compare/erel3.f
---
> 1715 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/erel3.f
> nbody6++compare/erel3.f
1,2c1,2
< 1451 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/erel4.f
< nbody6compare/erel4.f
---
> 1451 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/erel4.f
> nbody6++compare/erel4.f
1,2c1,2
< 1523 1997-03-01 11:44 /work/Umi2/spurzem/5/nbody6compare/erel.f
< nbody6compare/erel.f
---
> 1523 1997-03-01 11:44 /work/Umi2/spurzem/5/nbody6++compare/erel.f
> nbody6++compare/erel.f
1,2c1,2
< 19463 2006-02-19 19:36 /work/Umi2/spurzem/5/nbody6compare/escape.f
< nbody6compare/escape.f
---
> 18913 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/escape.f
> nbody6++compare/escape.f
0a1,4
> # 1 "escape.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "escape.F"
4,5c8,9
< *       Escaper removal.
< *       ----------------
---
> * Escaper removal.
> * ----------------
8,14c12,15
<       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
<       CHARACTER*11  WHICH1
<       LOGICAL  FIRST
<       SAVE  FIRST
<       DATA  FIRST /.TRUE./
---
>       COMMON/BINARY/ CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
>      & HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      & NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       CHARACTER*11 WHICH1
17c18
< *       Adopt twice the tidal radius as escape condition.
---
> * Adopt twice the tidal radius as escape condition.
19c20,26
<       IF (KZ(27).EQ.3) RESC2 = 1000.0
---
> * For tidal cutoff check only energy
>       IF(KZ(23).GE.3)THEN
>           RESC2 = 0.D0
>           ETID = ZMASS/RTIDE
>           ZMOLD = ZMASS
>       END IF
> *
22a30
>       NCRIT2 = 0
29c37
< *       Set the distance (squared) with respect to the density centre.
---
> * Set the distance (squared) with respect to the density centre.
31,32c39,40
<     5 RI2 = (X(1,I) - RDENS(1))**2 + (X(2,I) - RDENS(2))**2 + 
<      &                               (X(3,I) - RDENS(3))**2
---
>     5 RI2 = (X(1,I) - RDENS(1))**2 + (X(2,I) - RDENS(2))**2 +
>      & (X(3,I) - RDENS(3))**2
34d41
<       VI2 = XDOT(1,I)**2 + XDOT(2,I)**2 + XDOT(3,I)**2
36c43,44
< *       See whether escape is indicated (retain ghost particles).
---
>       IF(KZ(23).LE.2) THEN
> * See whether escape is indicated (retain ghost particles).
39c47
< *       Find distance to the nearest neighbour and calculate potential.
---
> * Find distance to the nearest neighbour and calculate potential.
44c52
<      &                                      (X(3,I) - X(3,J))**2
---
>      & (X(3,I) - X(3,J))**2
50c58
<     8     CONTINUE
---
>     8 CONTINUE
52c60
< *       Check escape criterion for external fields or isolated system.
---
> * Check escape criterion for tidal case or isolated system.
54,55c62,88
<           IF (KZ(14).EQ.4.OR.KZ(14).EQ.3) THEN
<               EI = EI - MP/SQRT(RI2 + AP2)
---
>           IF (KZ(14).GT.0.OR.EI.GT.0.0) GO TO 30
>           IF (NAME(I).LT.0) GO TO 30
>       END IF
> *
>       ELSE
> * Check tidal cutoff criterion - use last computed phi-value
> * Find distance to the nearest neighbour
>           POTI = 0.0D0
>           NNB = LIST(1,I)
>           RJMIN2 = 1.0D+10
>           DO 9 L = 1,NNB
>               J = LIST(L+1,I)
>               RIJ2 = (X(1,I) - X(1,J))**2 + (X(2,I) - X(2,J))**2 +
>      & (X(3,I) - X(3,J))**2
>               IF (RIJ2.LT.RJMIN2) THEN
>                   RJMIN2 = RIJ2
>                   JMIN = J
>               END IF
>     9 CONTINUE
>           VI2 = XDOT(1,I)**2 + XDOT(2,I)**2 + XDOT(3,I)**2
>           POTI = -PHIDBL(I)
> * Check escape criterion for tidal case or isolated system.
>           EI = 0.5*VI2 - POTI + ETID
> *
>           IF (EI.GT.0.0.AND.RI2.GT.RTIDE2) THEN
>           NCRIT2 = NCRIT2 + 1
>           GO TO 30
57d89
<           IF ((KZ(14).GT.0.AND.KZ(14).NE.4).OR.EI.GT.0.0) GO TO 30
66c98
< *       Form centre of mass terms.
---
> * Form centre of mass terms.
71c103
<    14     CONTINUE
---
>    14 CONTINUE
75,78c107,110
<       STEPI = MIN(STEPI,1.0D0)
<       JLAST = MIN(NCORR,NMAX)
<       WRITE (6,18)  N, NSESC, NBESC, ZMASS, BE(3), CMR(4), RESC, STEPI,
<      &              RSI, ZMASS/FLOAT(N), NCRIT1, (JLIST(J),J=1,JLAST)
---
>       JLAST = MIN(2*NCORR,NMAX)
>       if(rank.eq.0)
>      &WRITE (6,18) N, NSESC, NBESC, ZMASS, BE(3), CMR(4), RESC, STEPI,
>      & RSI, ZMASS/FLOAT(N), NCRIT1, (JLIST(J),J=1,JLAST)
80c112
<      &                                        I6,2X,6I6,/,5(10X,20I6,/))
---
>      & I6,2X,6I6,/,5(10X,20I6,/))
82,85c114,117
<       IF (KZ(23).EQ.2.AND.KZ(14).EQ.1) THEN
<           JLAST = MIN(2*NCORR,LMAX)
<           WRITE (6,20)  (ILIST(J),J=1,JLAST)
<    20     FORMAT (/,' ESCAPE ANGLES ',11(2I4,2X),9(/,15X,11(2I4,2X)))
---
>       IF (KZ(23).EQ.2.OR.KZ(23).EQ.4)THEN
>           JLAST = MIN(2*NCORR,NMAX)
>           if(rank.eq.0) WRITE (6,20) (ILIST(J),J=1,JLAST)
>    20 FORMAT (/,' ESCAPE ANGLES ',11(2I4,2X),9(/,15X,11(2I4,2X)))
88c120
< *       Check updating of global index for chain c.m.
---
> * Check updating of global index for chain c.m.
93c125
< *       Set phase indicator < 0 for new NLIST in routine INTGRT (Hermite).
---
> * Set phase indicator < 0 for new NLIST in routine INTGRT (Hermite).
99,100c131,132
<      &                                 (X(3,JMIN) - RDENS(3))**2
< *       See whether nearest body satisfies escape condition or RIJ > 10*RMIN.
---
>      & (X(3,JMIN) - RDENS(3))**2
> * See whether nearest body satisfies escape condition or RIJ > 10*RMIN.
102a135,141
> *
>       IF(KZ(23).GE.3)THEN
>           VI2 = XDOT(1,JMIN)**2 + XDOT(2,JMIN)**2 + XDOT(3,JMIN)**2
>           EI = 0.5*VI2 + PHIDBL(JMIN) + ETID
>           IF(EI.GT.0.D0) GO TO 40
>       END IF
> *
105,106c144,145
<      &     (XDOT(2,I) - XDOT(2,JMIN))**2 +
<      &     (XDOT(3,I) - XDOT(3,JMIN))**2
---
>      & (XDOT(2,I) - XDOT(2,JMIN))**2 +
>      & (XDOT(3,I) - XDOT(3,JMIN))**2
108c147
< *       Check velocity of binary component in case of bound pair.
---
> * Check velocity of binary component in case of bound pair.
111c150
< *       Retain escaper if dynamical effect on neighbour is significant.
---
> * Retain escaper if dynamical effect on neighbour is significant.
114c153
< *       Form optional output diagnostics.
---
> * Form optional output diagnostics.
122c161
< *       Escape angles with respect to the X-axis and XY-plane.
---
> * Escape angles with respect to the X-axis and XY-plane.
127c166
< *       Accumulate escaper names and save current name in case I > N.
---
> * Accumulate escaper names and save current name in case I > N.
135,140c174
< *       Check initialization of tidal tail integration for 3D model.
<       IF (KZ(23).GE.3.AND.KZ(14).EQ.3) THEN
<           CALL TAIL0(I)
<       END IF
< *
< *       Obtain binding energy of body #I and update optional tidal radius.
---
> * Obtain binding energy of body #I and update optional tidal radius.
142c176
<       IF (KZ(14).GT.0.AND.KZ(14).LT.3) THEN
---
>       IF (KZ(14).GT.0) THEN
146,149d179
<       ELSE IF (KZ(14).EQ.4.OR.KZ(14).EQ.3) THEN
< *       Include optional Plummer sphere and update tidal radius.
<           POTI = POTI + MP/SQRT(RI2 + AP2)
<           RTIDE = RTIDE0*ZMASS**0.3333
153c183,189
< *       Correct total energy (also ZKIN & POT for consistency).
---
> * Update tidal radius in case of tidal cutoff (R.Sp.)
>       IF(KZ(23).GE.3)THEN
>           RTOLD = RTIDE
>           RTIDE = RTIDE*(ZMASS/ZMOLD)**0.3333
>       END IF
> *
> * Correct total energy.
155,156d190
<       ZKIN = ZKIN - ZK
<       POT = POT - BODY(I)*POTI
158c192
< *       Update total mass and save energy & number of single escapers.
---
> * Update total mass and save energy & number of single escapers.
166,171c200,201
< *       Include optional escape output on unit 11.
<       IF (KZ(23).GT.1) THEN
<           IF (FIRST) THEN
<               OPEN (UNIT=11,STATUS='NEW',FORM='FORMATTED',FILE='ESC')
<               FIRST = .FALSE.
<           END IF
---
> * Include optional escape output on unit 11.
>       IF (KZ(23).EQ.2.OR.KZ(23).EQ.4) THEN
175,176c205,206
< *       Distinguish between tidal field and isolated system (ECRIT at RTIDE).
<           IF (KZ(14).GT.0.AND.KZ(14).LE.2) THEN
---
> * Distinguish between tidal field and isolated system (ECRIT at RTIDE).
>           IF (KZ(14).GT.0) THEN
186,188c216,223
<           WRITE (11,45)  TESC, BESC, EESC, VKM, KSTARI, NAME(I)
<    45     FORMAT (F8.1,3F6.1,I4,I6)
<           CALL FLUSH(11)
---
> 
> 
> 
>           WRITE (11,45) TESC, BESC, EESC, VKM, KSTARI
>    45 FORMAT (F8.1,3F6.1,I4)
> 
> 
> 
191c226
< *       Reduce particle number & total membership and check NNBMAX.
---
> * Reduce particle number & total membership and check NNBMAX.
194,197c229,232
<       NNBMAX = MIN((N - NPAIRS)/2,NNBMAX)
<       ZNBMAX = 0.9*NNBMAX
<       ZNBMIN = MAX(0.2*NNBMAX,1.0)
< *       Set indicator for removal of c.m. or KS components.
---
>       NNBMAX = MIN(N/2,NNBMAX)
>       ZNBMAX = 0.9*FLOAT(NNBMAX)
>       ZNBMIN = MAX(0.01*FLOAT(NNBMAX),1.0)
> * Set indicator for removal of c.m. or KS components.
200c235
< *       Update COMMON arrays to remove the escaper and correct F & FDOT.
---
> * Update COMMON arrays to remove the escaper and correct F & FDOT.
203c238
< *       Delete escaper from neighbour lists and reduce higher locations.
---
> * Delete escaper from neighbour lists and reduce higher locations.
208c243
<    70     IF (LIST(L,J).NE.I) GO TO 130
---
>    70 IF (LIST(L,J).NE.I) GO TO 130
210c245
< *       Move up the remaining list members and reduce membership by one.
---
> * Move up the remaining list members and reduce membership by one.
213c248
<    80     CONTINUE
---
>    80 CONTINUE
215,221c250,256
< *       Reduce the steps to minimize error effect (do not allow DT < 0).
< *         STEP(J) = MAX(0.5D0*STEP(J),TIME - T0(J))
< *         STEPR(J) = MAX(0.5D0*STEPR(J),TIME - T0R(J))
< *       Add body #J to time-step list unless already a member. 
< *         IF (T0(J) + STEP(J).LT.TLIST) THEN
< *             CALL NLMOD(J,1)
< *         END IF
---
> * Reduce the steps to minimize error effect (do not allow DT < 0).
> * STEP(J) = MAX(0.5D0*STEP(J),TIME - T0(J))
> * STEPR(J) = MAX(0.5D0*STEPR(J),TIME - T0R(J))
> * Add body #J to time-step list unless already a member.
> * IF (T0(J) + STEP(J).LT.TLIST) THEN
> * CALL NLMOD(J,1)
> * END IF
224c259
< *       Add a distant body as neighbour if list only contains escaper.
---
> * Add a distant body as neighbour if list only contains escaper.
226c261
<   100     K = K + 1
---
>   100 K = K + 1
228c263
<      &                                  (X(3,J) - X(3,K))**2
---
>      & (X(3,J) - X(3,K))**2
234,235c269,270
< *       Reduce higher particle locations by one.
<   130     IF (LIST(L,J).GT.I) LIST(L,J) = LIST(L,J) - 1
---
> * Reduce higher particle locations by one.
>   130 IF (LIST(L,J).GT.I) LIST(L,J) = LIST(L,J) - 1
240c275
< *       Modify time-step list due to escaper removal (-2 for extra test).
---
> * Modify time-step list due to escaper removal (-2 for extra test).
243c278
< *       Update list of old KS components (remove #I and rename > I).
---
> * Update list of old KS components (remove #I and rename > I).
247c282
< *       Remove both components of pair and reduce membership by two.
---
> * Remove both components of pair and reduce membership by two.
251c286
<   165         CONTINUE
---
>   165 CONTINUE
256c291
< *       Reduce higher particle locations by one (separate loop for pairs).
---
> * Reduce higher particle locations by one (separate loop for pairs).
261,263c296,298
< *       Update list of high velocity particles (remove #I and rename > I).
<       NNV = LISTV(1)
<       DO 190 L = 2,NNV+1
---
> * Update list of high velocity particles (remove #I and rename > I).
>       NNB = LISTV(1)
>       DO 190 L = 2,NNB+1
265,266c300,301
< *       Remove escaper and reduce the membership.
<               DO 185 K = L,NNV
---
> * Remove escaper and reduce the membership.
>               DO 185 K = L,NNB
268c303
<   185         CONTINUE
---
>   185 CONTINUE
271c306
< *       Reduce higher particle locations by one (or three for c.m.).
---
> * Reduce higher particle locations by one (or three for c.m.).
278c313
< *       Check special case of second KS component removal.
---
> * Check special case of second KS component removal.
281c316
< *       See whether the escaper is a single particle or c.m.
---
> * See whether the escaper is a single particle or c.m.
284c319
< *       Prepare removal of regularized pair.
---
> * Prepare removal of regularized pair.
287c322
< *       Skip correction if ghost is also merged binary (NAMEI = 0 below).
---
> * Skip correction if ghost is also merged binary (NAMEI = 0 below).
295c330
<           PMIN  = SEMI*(1.0 - ECC)
---
>           PMIN = SEMI*(1.0 - ECC)
301c336
< *       Obtain two-body elements of ghost binary and update energies.
---
> * Obtain two-body elements of ghost binary and update energies.
316c351
< *       Update total energy (ECOLL with EB < -1 & #27 > 0 affects BINOUT).
---
> * Update total energy (ECOLL with EB < -1 & #27 > 0 affects BINOUT).
318d352
<       EBIN = EBIN - EB
320c354
< *       Check optional diagnostics for hierarchical systems.
---
> * Check optional diagnostics for hierarchical systems.
326c360,364
< *       Distinguish between actual and ghost binary (mergers come later).
---
> * Specify binary type (0: standard; -1: merged binary).
>       M = 0
>       IF (NAMEI.LE.0) M = -1
> *
> * Distinguish between actual and ghost binary (mergers come later).
330c368
< *       Include rare case of higher-order system (4, 5 or 6 members).
---
> * Include rare case of higher-order system (4, 5 or 6 members).
335c373
<   195         CONTINUE
---
>   195 CONTINUE
339,340c377,378
<   196         CONTINUE
< *       Identify quartet, quintuplet or sextuplet.
---
>   196 CONTINUE
> * Identify quartet, quintuplet or sextuplet.
343c381
< *       Include both types of quintuplet: [[B,S],B] and [[B,B],S].
---
> * Include both types of quintuplet: [[B,S],B] and [[B,B],S].
351d388
<               ZM3 = (CM(3,JM) + CM(4,JM))*ZMBAR
355,360c392,396
<               WRITE (6,199)  WHICH1, NAME(2*IPAIR-1), NAME(2*IPAIR),
<      &                       NAME(I3HJ), ZM1, ZM2, ZM3, EB3, SEMI3, PB3
<   199         FORMAT (/,A11,' ESCAPE    NM =',3I6,'  M =',3F6.2,
<      &                    '  EB3 =',F8.4,'  A3 =',1P,E8.1,'  P3 =',E8.1)
< *       Copy actual name of outer component for KS binary output.
<               NAME2 = NAME(I3HJ)
---
>               if(rank.eq.0)
>      & WRITE (6,199) WHICH1, NAME(2*IPAIR-1), NAME(2*IPAIR),
>      & NAME(I3HJ), ZM1, ZM2, EB3, SEMI3, PB3
>   199 FORMAT (/,A11,' ESCAPE    NM =',3I6,'  M =',2F5.1,
>      & '  EB3 =',F8.4,'  A3 =',1P,E8.1,'  P3 =',E8.1)
363,371c399,409
<           VI = SQRT(0.5*VI2*ZMASS/ABS(ZKIN))
<           WRITE (6,200)  IPAIR, NAME(2*IPAIR-1), NAME2,
<      &                   KSTAR(2*IPAIR-1), KSTAR(2*IPAIR), KSTARI,
<      &                   LIST(2,2*IPAIR), BODY(2*IPAIR-1)*ZMBAR,
<      &                   BODY(2*IPAIR)*ZMBAR, EB, RATIO, VI, ECC, EI, PB
<   200     FORMAT (/,' BINARY ESCAPE    KS =',I5,'  NM =',2I6,
<      &                '  K* =',4I3,'  M =',2F5.1,'  EB =',F8.4,
<      &                '  R*/PM =',F5.2,'  V/<V> =',F5.2,'  E =',F5.2,
<      &                '  EI =',F8.5,'  P =',1P,E8.1)
---
>           if(rank.eq.0)then
>           VI = SQRT(0.5*VI2*ZMASS/ZKIN)
>           WRITE (6,200) IPAIR, NAME(2*IPAIR-1), NAME2,
>      & KSTAR(2*IPAIR-1), KSTAR(2*IPAIR), KSTARI,
>      & LIST(2,2*IPAIR), BODY(2*IPAIR-1)*ZMBAR,
>      & BODY(2*IPAIR)*ZMBAR, EB, RATIO, VI, ECC, EI, PB
>   200 FORMAT (/,' BINARY ESCAPE    KS =',I5,'  NM =',2I6,
>      & '  K* =',4I3,'  M =',2F5.1,'  EB =',F8.4,
>      & '  R*/PM =',F5.2,'  V/<V> =',F5.2,'  E =',F5.2,
>      & '  EI =',F8.5,'  P =',1P,E8.1)
>           end if
373,378c411,417
<           WRITE (6,202)  IPAIR, NAME(2*IPAIR-1), NAME(2*IPAIR),
<      &                   KSTAR(2*IPAIR-1), KSTAR(2*IPAIR), KSTAR(I),
<      &                   CM(3,IM)*SMU, CM(4,IM)*SMU, EB1, ECC, SEMI, PB
<   202     FORMAT (/,' QUAD ESCAPE    KS =',I5,'  NM =',2I6,
<      &                '  K* =',3I3,'  M =',2F5.1,'  EB =',F8.4,
<      &                '  E =',F7.3,'  A =',1P,E8.1,'  P =',E8.1)
---
>           if(rank.eq.0)
>      & WRITE (6,202) IPAIR, NAME(2*IPAIR-1), NAME(2*IPAIR),
>      & LIST(2,2*IPAIR), KSTAR(JM), CM(3,IM)*ZMBAR,
>      & CM(4,IM)*ZMBAR, EB1, ECC, SEMI, PB
>   202 FORMAT (/,' QUAD ESCAPE    KS =',I5,'  NM =',2I6,
>      & '  K* =',2I3,'  M =',2F5.1,'  EB =',F8.4,
>      & '  E =',F7.3,'  A =',1P,E8.1,'  P =',E8.1)
383c422
< *       Accumulate escaping binary energies and increase the counter.
---
> * Accumulate escaping binary energies and increase the counter.
394c433
<       IF (NAMEI.GT.0) THEN
---
>       IF (M.EQ.0) THEN
400c439
< *       Reduce particle number, pair index & single particle index. 
---
> * Reduce particle number, pair index & single particle index.
405c444
< *       Move up all tables of regularized pairs below IPAIR.
---
> * Move up all tables of regularized pairs below IPAIR.
410c449
< *       Increase index for removing KS components.
---
> * Increase index for removing KS components.
413c452
< *       Remove COMMON arrays of the second component before the first.
---
> * Remove COMMON arrays of the second component before the first.
416c455
< *       Reduce NTOT by 3 and N by 2 when KS pair escapes.
---
> * Reduce NTOT by 3 and N by 2 when KS pair escapes.
421c460
< *       Check selection of possible ghost in higher-order system.
---
> * Check selection of possible ghost in higher-order system.
428c467
<   208     CONTINUE
---
>   208 CONTINUE
435c474
< *       Include the case of escaping merger.
---
> * Include the case of escaping merger.
438c477
< *       Locate current position in the merger table (standard case).
---
> * Locate current position in the merger table (standard case).
443c482
< *       Skip on failed detection just in case.
---
> * Skip on failed detection just in case.
446c485
< *       Include case of higher-order system (outer single or binary).
---
> * Include case of higher-order system (outer single or binary).
449c488
< *       Determine the ghost index.
---
> * Determine the ghost index.
453,454c492,493
<   215     CONTINUE
< *       Specify nominal escape distance for ghost removal.
---
>   215 CONTINUE
> * Specify nominal escape distance for ghost removal.
456c495
< *       Define possible KS pair index for quadruple system correction.
---
> * Define possible KS pair index for quadruple system correction.
460c499
< *       Consider current ghost unless deeper hierarchy is present.
---
> * Consider current ghost unless deeper hierarchy is present.
463c502
< *       Search for c.m. name one level below current (NAMEI < 0).
---
> * Search for c.m. name one level below current (NAMEI < 0).
467,468c506,507
<   220         CONTINUE
< *       Use previous merger index to look for binary ghost at earlier level.
---
>   220 CONTINUE
> * Use previous merger index to look for binary ghost at earlier level.
472c511
<   225         CONTINUE
---
>   225 CONTINUE
476c515
< *       Adopt original solution on failure to identify binary.
---
> * Adopt original solution on failure to identify binary.
479c518
< *       Set nominal escape distance of any new ghost (I3HI <= N possible).
---
> * Set nominal escape distance of any new ghost (I3HI <= N possible).
484c523
< *       Copy merger energy to respective energy bins (primordial or new).
---
> * Copy merger energy to respective energy bins (primordial or new).
492c531
< *       Reduce membership if IM is last (otherwise done in RESET).
---
> * Reduce membership if IM is last (otherwise done in RESET).
497c536
< *       Identify merged ghost particle (single body or binary c.m.).
---
> * Identify merged ghost particle (single body or binary c.m.).
502c541
< *       Include search over lower level on failed identification.
---
> * Include search over lower level on failed identification.
506c545
<   232     CONTINUE
---
>   232 CONTINUE
509c548
< *       Skip if correct ghost not identified (note I3HI # JCOMP if JM # IM).
---
> * Skip if correct ghost not identified (note I3HI # JCOMP if JM # IM).
512c551
< *       Form two-body elements and period of inner binary.
---
> * Form two-body elements and period of inner binary.
522c561
< *       Include extra corrections for mergers between binary pairs.
---
> * Include extra correction for mergers between binary pairs.
528c567,568
<               IF (JM.EQ.NMERGE) NMERGE = NMERGE - 1
---
> * Copy smaller index for QUAD binary output.
>               IM = JM
535c575
<   235     CONTINUE
---
>   235 CONTINUE
542,547c582,588
<           WRITE (6,240)  NAME1, NAMEG(JM), KSTAR1, KSTAR(JCOMP),
<      &                   KSTARM(JM), CM(1,JM)*ZMBAR, CM(2,JM)*ZMBAR,
<      &                   EB, ECC0, PMIN/PCRIT, SEMI0, PB
<   240     FORMAT (/,' HIARCH ESCAPE    NM =',2I6,'  K* =',3I3,
<      &              '  M =',2F5.1,'  EB =',F8.4,'  E =',F7.3,
<      &              '  PM/PC =',1P,E8.1,'  A =',E8.1,'  P =',E8.1)
---
>           if(rank.eq.0)
>      & WRITE (6,240) NAME1, NAMEG(JM), KSTAR1, KSTAR(JCOMP),
>      & KSTARM(JM), CM(1,JM)*ZMBAR, CM(2,JM)*ZMBAR,
>      & EB, ECC0, PMIN/PCRIT, SEMI0, PB
>   240 FORMAT (/,' HIARCH ESCAPE    NM =',2I6,'  K* =',3I3,
>      & '  M =',2F5.1,'  EB =',F8.4,'  E =',F7.3,
>      & '  PM/PC =',1P,E8.1,'  A =',E8.1,'  P =',E8.1)
549c590
< *       Remove the ghost particle (NAME = 0 & EB = 0 for second binary).
---
> * Remove the ghost particle (NAME = 0 & EB = 0 for second binary).
1,2c1,2
< 2030 2006-02-15 19:32 /work/Umi2/spurzem/5/nbody6compare/events.f
< nbody6compare/events.f
---
> 2106 2005-03-11 12:58 /work/Umi2/spurzem/5/nbody6++compare/events.f
> nbody6++compare/events.f
28c28
<           WRITE (6,15)
---
>           if(rank.eq.0)WRITE (6,15)
32c32,33
<           WRITE (6,20)  NMDOT, NRG, NHE, NRS, NNH, NWD, NSN, NBH, NBS,
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  NMDOT, NRG, NHE, NRS, NNH, NWD, NSN, NBH, NBS,
57c58
<           WRITE (6,30)
---
>           if(rank.eq.0)WRITE (6,30)
60c61,62
<           WRITE (6,35)  NDISS, NTIDE, NSYNC, NCOLL, EBIN, ECOLL,
---
>           if(rank.eq.0)
>      &    WRITE (6,35)  NDISS, NTIDE, NSYNC, NCOLL, EBIN, ECOLL,
67a70,71
> 
> 
1,2c1,2
< 8664 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/evolve.f
< nbody6compare/evolve.f
---
> 8856 2005-03-11 16:10 /work/Umi2/spurzem/5/nbody6++compare/evolve.f
> nbody6++compare/evolve.f
7a8
> *
16c17
< *     NBSTAT = NBSTAT + 1
---
>       NBSTAT = NBSTAT + 1
54a56
>       if(rank.eq.0)then
62a65
>       end if
103c106,107
<               WRITE (4,100)  NAME(J), EB, SEMIJ, ECCJ, RIJ, GEFF, P,RDOT
---
>               if(rank.eq.0)
>      &        WRITE (4,100)  NAME(J), EB, SEMIJ, ECCJ, RIJ, GEFF, P,RDOT
125c129
<           WRITE (4,100)  NAME(JMIN), (WORK(K),K=1,7)
---
>           if(rank.eq.0)WRITE (4,100)  NAME(JMIN), (WORK(K),K=1,7)
224c228,229
<               WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
---
>               if(rank.eq.0)
>      &        WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
230c235,236
<               WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
---
>               if(rank.eq.0)
>      &        WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
236c242,243
<               WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
---
>               if(rank.eq.0)
>      &        WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
244c251,252
<               WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
---
>               if(rank.eq.0)
>      &        WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
1,2c1,2
< 1858 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/expand.f
< nbody6compare/expand.f
---
> 1859 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/expand.f
> nbody6++compare/expand.f
60a61
> 
1,2c1,2
< 2378 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/extend.f
< nbody6compare/extend.f
---
> 2378 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/extend.f
> nbody6++compare/extend.f
1,2c1,2
< 2345 2005-11-01 19:11 /work/Umi2/spurzem/5/nbody6compare/fchain.f
< nbody6compare/fchain.f
---
> 1636 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/fchain.f
> nbody6++compare/fchain.f
10c10
<       REAL*8  XI(3),XIDOT(3),DX(3),DV(3),FIRR(3),FD(3),XIS(3),VIS(3)
---
>       REAL*8  XI(3),XIDOT(3),DX(3),DV(3),FIRR(3),FD(3)
13,28c13
< *       Use c.m. values for correction of perturbed KS (call from KCPERT).
<       I2 = 0
<       IF (I.LT.IFIRST) THEN
<           IPAIR = KVEC(I)
<           IF (I.EQ.2*IPAIR) I2 = 1
<           ICM = N + IPAIR
< *       Save local variables for individual chain contributions.
<           DO 1 K = 1,3
<               XIS(K) = XI(K)
<               VIS(K) = XIDOT(K)
<               XI(K) = X(K,ICM)
<               XIDOT(K) = XDOT(K,ICM)
<     1     CONTINUE
<       END IF
< *
< *       Evaluate terms for the original chain c.m. interaction.
---
> *       Subtract chain c.m. force from the current value (I =< N).
41c26
< *       Subtract force and first derivative from current values.
---
> *       Subtract force & first derivative.
47,54d31
< *       Restore XI & XIDOT for KS components (perturbed case).
<       IF (I.LT.IFIRST) THEN
<           DO 12 K = 1,3
<               XI(K) = XIS(K)
<               XIDOT(K) = VIS(K)
<    12     CONTINUE
<       END IF
< *
56c33
<       IF (IR.EQ.0.AND.I2.EQ.0) THEN
---
>       IF (IR.EQ.0) THEN
1,2c1,2
< 1132 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/fclose.f
< nbody6compare/fclose.f
---
> 1132 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/fclose.f
> nbody6++compare/fclose.f
1,2c1,2
< 1939 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/fcloud.f
< nbody6compare/fcloud.f
---
> 1929 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/fcloud.f
> nbody6++compare/fcloud.f
28c28
<               A9 = 3.0*(A(1)*A(4) + A(2)*A(5) + A(3)*A(6))/RIJ2
---
>               A9 = 3.0*(A(1)*A(4) + A(2)*A(5) + A(3)*A(6))
47c47
<               A9 = 3.0*(A(1)*A(4) + A(2)*A(5) + A(3)*A(6))/RIJ2
---
>               A9 = 3.0*(A(1)*A(4) + A(2)*A(5) + A(3)*A(6))
1,2c1,2
< 4175 2006-09-27 18:09 /work/Umi2/spurzem/5/nbody6compare/fcorr.f
< nbody6compare/fcorr.f
---
> 4229 2000-04-13 20:22 /work/Umi2/spurzem/5/nbody6++compare/fcorr.f
> nbody6++compare/fcorr.f
4,5c4,5
< *       Total force corrections due to masss loss.
< *       ------------------------------------------
---
> *       Total force corrections due to mass loss.
> *       -----------------------------------------
86c86
< *       Use neighbour list of #J to distinguish irregular & regular terms.
---
> *       Use neighbour list to distinguish irregular & regular terms.
88c88
<           DO 25 L = 2,NNB1
---
>           DO 30 L = 2,NNB1
96a97,110
> *       Reduce the step and see whether body #J should be added to NLIST.
> *                 STEP(J) = MAX(0.5D0*STEP(J),TIME - T0(J))
>                   IF (T0(J) + STEP(J).LT.TLIST) THEN
>                       CALL NLMOD(J,1)
>                   END IF
>                   GO TO 40
>               ELSE IF (LIST(L,J).GT.I) THEN
>                   DO 25 K = 1,3
>                       F(K,J) = F(K,J) - 0.5*A(K)*A5
>                       FR(K,J) = FR(K,J) - A(K)*A5
>                       FDOT(K,J) = FDOT(K,J) - ONE6*A(K+3)
>                       D1R(K,J) = D1R(K,J) - A(K+3)
>                       FRDOT(K,J) = FRDOT(K,J) - A(K+3)
>    25             CONTINUE
99,105d112
<    25     CONTINUE      
<           DO 30 K = 1,3
<               F(K,J) = F(K,J) - 0.5*A(K)*A5
<               FR(K,J) = FR(K,J) - A(K)*A5
<               FDOT(K,J) = FDOT(K,J) - ONE6*A(K+3)
<               D1R(K,J) = D1R(K,J) - A(K+3)
<               FRDOT(K,J) = FRDOT(K,J) - A(K+3)
110c117
<       EMDOT = EMDOT - DM*POTJ + 0.5*DM*VI2
---
>       ECDOT = ECDOT - DM*POTJ + 0.5*DM*VI2
112,113c119,120
< *       Modify energy loss further for c.m. body.
<       IF (I.GT.N) THEN
---
> *       Check energy correction due to velocity kick.
>       IF (I.GT.N.AND.IKICK) THEN
117,119c124,126
< *       See whether linearized tidal terms should be included.
<       IF (KZ(14).GT.0.AND.KZ(14).LT.3) THEN
<           EMDOT = EMDOT - 0.5*DM*(TIDAL(1)*X(1,I)**2 +
---
> *       See whether tidal terms should be included.
>       IF (KZ(14).GT.0) THEN
>           ECDOT = ECDOT - 0.5*DM*(TIDAL(1)*X(1,I)**2 +
123,132d129
< *       Check optional Plummer potential.
<       IF (KZ(14).EQ.4.OR.KZ(14).EQ.3) THEN
<           RI2 = AP2
<           DO 50 K = 1,3
<               RI2 = RI2 + X(K,I)**2
<   50      CONTINUE
<           EMDOT = EMDOT - DM*MP/SQRT(RI2)
<       END IF
< *
< *       Accumulate energy loss for conservation check.
file /work/Umi2/spurzem/5/nbody6++compare/fdisk.f does not exist
file /work/Umi2/spurzem/5/nbody6++compare/fhalo.f does not exist
1,2c1,2
< 2177 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ficorr.f
< nbody6compare/ficorr.f
---
> 1862 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/ficorr.f
> nbody6++compare/ficorr.f
42d41
<               FIDOT(K,J) = FIDOT(K,J) - A(K+3)
64,66c63,65
< *       See whether linearized tidal terms should be included.
<       IF (KZ(14).GT.0.AND.KZ(14).LT.3) THEN
<           ECDOT = ECDOT - 0.5*DM*(TIDAL(1)*X(1,I)**2 +
---
> *       See whether tidal terms should be included.
>       IF (KZ(14).GT.0) THEN
>           EMDOT = EMDOT - 0.5*DM*(TIDAL(1)*X(1,I)**2 +
70,78d68
< *       Check optional Plummer potential.
<       IF (KZ(14).EQ.4.OR.KZ(14).EQ.3) THEN
<           RI2 = AP2
<           DO 50 K = 1,3
<               RI2 = RI2 + X(K,I)**2
<   50      CONTINUE
<           ECDOT = ECDOT - DM*MP/SQRT(RI2)
<       END IF
< *
1,2c1,2
< 1583 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/findj.f
< nbody6compare/findj.f
---
> 1583 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/findj.f
> nbody6++compare/findj.f
1,2c1,2
< 3932 2006-02-14 16:10 /work/Umi2/spurzem/5/nbody6compare/flyby.f
< nbody6compare/flyby.f
---
> 3422 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/flyby.f
> nbody6++compare/flyby.f
13c13
<       RJMIN2 = 1000.0
---
>       RJMIN2 = 1.0
76,77d75
<       RJJ = 0.0
<       VJJ = 0.0
80,81d77
<           RJJ = RJJ + (X(K,JCOMP) - X(K,J))**2
<           VJJ = VJJ + (XDOT(K,JCOMP) - XDOT(K,J))**2
98,106d93
< *
< *       Increase the cross section for quadruples.
<       IF (JCOMP.GT.N) THEN
<           SEMI2 = -0.5*BODY(JCOMP)/H(JCOMP-N)
<           APO = APO + ABS(SEMI2)
<       END IF
< *
<       SEMIJ = 2.0/SQRT(RJJ) - VJJ/(BODY(JCOMP) + BODY(J))
<       SEMIJ = 1.0/SEMIJ
109,112d95
<           IF (SEMI.LT.0.0.AND.GAMMA(IPAIR).LT.0.5) THEN
<               ITERM = 0
<               GO TO 20
<           END IF
120a104
> 
file /work/Umi2/spurzem/5/nbody6++compare/fnuc.f does not exist
1,2c1,2
< 4071 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/fpcorr.f
< nbody6compare/fpcorr.f
---
> 4610 2001-08-15 16:39 /work/Umi2/spurzem/5/nbody6++compare/fpcorr.f
> nbody6++compare/fpcorr.f
1c1
<       SUBROUTINE FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT)
---
>       SUBROUTINE FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT,FIRR,FREG,FD,FDR,KLIST)
9c9,10
<      &        A(12),F2DOT(3),F3DOT(4)
---
>      &        A(12),F1DOT(3),F2DOT(3),F3DOT(4)
>       REAL*8 FIRR(3),FREG(3),FD(3),FDR(3),FMPI(3),FDMPI(3)
10a12
>       INTEGER KLIST(LMAX)
12a15,16
>       NNB0 = KLIST(1)
> *
20a25,26
>           FMPI(K) = 0.5D0*(FREG(K) + FIRR(K))
>           FDMPI(K) = ONE6*(FDR(K) + FD(K))
24d29
<       NNB0 = LIST(1,I)
34,35d38
< *
< *       Use c.m. values of XDOT, F & FDOT for single KS components.
36a40
> *       Use c.m. values of XDOT, F & FDOT for single KS components.
38c42
< *         STEPJ = STEP(JCM)
---
>           STEPJ = STEP(JCM)
40c44,45
< *
---
>           S3 = 3.0*S
> *       Predict because we are in parallel section (R.Sp.)
42,45c47,52
<               A(K) = X(K,J) - XI(K)
<               A(K+3) = XDOT(K,J) - XIDOT(K)
<               A(K+6) = 2.0*(F(K,JCM) - F(K,I))
<               A(K+9) = 6.0*(FDOT(K,JCM) - FDOT(K,I))
---
>               A(K) = ((FDOT(K,JCM)*S + F(K,JCM))*S + X0DOT(K,JCM))*S +
>      &                                                 X0(K,JCM) - XI(K)
>               A(K+3) = (FDOT(K,JCM)*S3 + 2.0*F(K,JCM))*S + X0DOT(K,JCM)-
>      &                                                         XIDOT(K)
>               A(K+6) = 2.0*(F(K,JCM) - FMPI(K))
>               A(K+9) = 6.0*(FDOT(K,JCM) - FDMPI(K))
50c57
< *         STEPJ = STEP(J)
---
>           STEPJ = STEP(J)
53,54c60
< *
< *       Predict F & FDOT of body #J to order FDOT.
---
> *       Predict because we are in parallel section (R.Sp.)
56c62,63
<               A(K) = X(K,J) - XI(K)
---
>               A(K) = ((FDOT(K,J)*S + F(K,J))*S + X0DOT(K,J))*S +
>      &                                                 X0(K,J) - XI(K)
59,60c66,67
<               A(K+6) = 2.0*(FDOT(K,J)*S3 + F(K,J) - F(K,I))
<               A(K+9) = 6.0*(FDOT(K,J) - FDOT(K,I))
---
>               A(K+6) = 2.0*(FDOT(K,J)*S3 + F(K,J) - FMPI(K))
>               A(K+9) = 6.0*(FDOT(K,J) - FDMPI(K))
82,83c89
< *       Suppress F1DOT terms (already done in REGINT).
< *         F1DOT(K) = F1DOTK*A14
---
>           F1DOT(K) = F1DOTK*A14
102c108
< *             F1DOT(K) = -F1DOT(K)
---
>               F1DOT(K) = -F1DOT(K)
110c116
< *         SAVE1(K) = SAVE1(K) + F1DOT(K)
---
>           SAVE1(K) = SAVE1(K) + F1DOT(K)
122,123c128
< *       Note that corrected value of D1 & D1R already set in routine REGINT.
< *         D1(K,I) = D1(K,I) + SAVE1(K)
---
>           D1(K,I) = D1(K,I) + SAVE1(K)
125a131
> *       No correction of D1R because it is actually correct from regint.
1,2c1,2
< 896 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/fpert.f
< nbody6compare/fpert.f
---
> 896 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/fpert.f
> nbody6++compare/fpert.f
1,2c1,2
< 4267 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/fpoly1.f
< nbody6compare/fpoly1.f
---
> 4271 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/fpoly1.f
> nbody6++compare/fpoly1.f
10d9
< *
49a49
> *
94a95
> *
108a110
> *
1,2c1,2
< 4475 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/fpoly2.f
< nbody6compare/fpoly2.f
---
> 4474 2002-02-20 13:30 /work/Umi2/spurzem/5/nbody6++compare/fpoly2.f
> nbody6++compare/fpoly2.f
10d9
< *
15a15,17
> *       Include an initial skip for primordial binaries (large derivatives).
> *     IF (NBIN0.GT.0.AND.TIME.EQ.0.0D0) GO TO 80
> *
27,29d28
< *       Include an initial skip for primordial binaries (large derivatives).
<       IF (NBIN0.GT.0.AND.TIME.EQ.0.0D0) GO TO 80
< *
119c118
< *       Advance the neighbour list until last member is identified. 
---
> *       Advance the neighbour list until last member is identified.
125a125
> *
1,2c1,2
< 3429 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/freeze.f
< nbody6compare/freeze.f
---
> 3430 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/freeze.f
> nbody6++compare/freeze.f
30c30
< *       Specify regularized time (based on Baumgarte & Stielel, 1974).
---
> *       Specify regularized time (based on Stiefel & Scheifele, p. 85).
file /work/Umi2/spurzem/5/nbody6++compare/gcinit.f does not exist
file /work/Umi2/spurzem/5/nbody6++compare/gcint.f does not exist
1,2c1,2
< 1182 2001-04-07 13:23 /work/Umi2/spurzem/5/nbody6compare/ghost.f
< nbody6compare/ghost.f
---
> 1182 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/ghost.f
> nbody6++compare/ghost.f
1,2c1,2
< 6787 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/gntage.f
< nbody6compare/gntage.f
---
> 6789 2003-06-26 01:43 /work/Umi2/spurzem/5/nbody6++compare/gntage.f
> nbody6++compare/gntage.f
228a229,230
> 
> 
1,2c1,2
< 2413 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/hcorr.f
< nbody6compare/hcorr.f
---
> 1718 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/hcorr.f
> nbody6++compare/hcorr.f
8,10d7
<       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
21c18
< *       Define c.m. index and old semi-major axis.
---
> *       Define c.m. index and save old elements & reduced mass.
24,45c21,23
< *
< *       Distinguish different cases (KS, triple or outer ghost of quadruple).
<       IF (BODY(I).GT.0.0D0) THEN
<           ZMU0 = BODY(I1)*BODY(I2)/BODY(J)
<       ELSE
<           IM = 0
<           JJ = I
<           IF (I.LT.IFIRST) JJ = N + KVEC(I)
< *       Determine merger index for inner and outer binary masses.
<           DO 1 K = 1,NMERGE
<               IF (NAMEG(K).EQ.NAME(JJ)) IM = K
<     1     CONTINUE
<           IF (IM.EQ.0) THEN
<               WRITE (6,5) NAME(I), NAME(JJ), (NAMEG(K),K=1,NMERGE)
<     5         FORMAT (' DANGER HCORR!    NMI NMJJ NMG ',12I6)
<               STOP
<           END IF
< *       Form old reduced mass from inner and outer binary.
<           ZM1 = CM(1,IM) + CM(2,IM)
<           ZM2 = CM(3,IM) + CM(4,IM)
<           ZMU0 = ZM1*ZM2/BODY(J)
<       END IF
---
> *     ECC2 = (1.0 - R(IPAIR)/SEMI0)**2 + TDOT2(IPAIR)**2/(BODY(J)*SEMI0)
> *     ECC = SQRT(ECC2)
>       ZMU0 = BODY(I1)*BODY(I2)/BODY(J)
52,56c30
<       IF (BODY(I).GT.0.0D0) THEN
<           ZMU1 = (BODY(I1) - DM)*BODY(I2)/BODY(J)
<       ELSE
<           ZMU1 = ZM1*(ZM2 - DM)/BODY(J)
<       END IF
---
>       ZMU1 = (BODY(I1) - DM)*BODY(I2)/BODY(J)
69a44,46
> *       Set new mass temporarily to be consistent with routine EXPAND.
>       BODY(I) = BODY(I) - DM
> *
72a50,52
> *       Restore the component mass here to allow updating in routine MDOT.
>       BODY(I) = BODY(I) + DM
> *
75a56
> 
1,2c1,2
< 9811 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/hiarch.f
< nbody6compare/hiarch.f
---
> 9678 2002-06-14 23:09 /work/Umi2/spurzem/5/nbody6++compare/hiarch.f
> nbody6++compare/hiarch.f
17,21d16
< *       Open unit #10 the first time.
<       IF (FIRST) THEN
<           OPEN (UNIT=10,STATUS='NEW',FORM='FORMATTED',FILE='HIARCH')
<           FIRST = .FALSE.
< *
22a18
>       IF (FIRST) THEN
24c20
<               WRITE (10,1)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
---
>               WRITE (12,1)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
37c33
<           WRITE (10,2)
---
>           WRITE (12,2)
41c37
<           WRITE (10,3)
---
>           WRITE (12,3)
200c196
<           WRITE (10,10)  TTOT, SEMI, SEMI1, ECC1, PMIN, TK1, Q,
---
>           WRITE (12,10)  TTOT, SEMI, SEMI1, ECC1, PMIN, TK1, Q,
251c247
<           WRITE (10,20)  TTOT, SQRT(RI)/RC, SEMI, ECC, PMIN, TK1,
---
>           WRITE (12,20)  TTOT, SQRT(RI)/RC, SEMI, ECC, PMIN, TK1,
255c251
<           CALL FLUSH(10)
---
>           CALL FLUSH(12)
280a277,278
> 
> 
1,2c1,2
< 9222 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/hidat.f
< nbody6compare/hidat.f
---
> 8391 2002-07-31 07:17 /work/Umi2/spurzem/5/nbody6++compare/hidat.f
> nbody6++compare/hidat.f
12c12
< *     REAL*4  EB(KMAX),ECM(KMAX)
---
>       REAL*4  EB(KMAX),ECM(KMAX)
14c14
<       SAVE  FIRST
---
>       SAVE  FIRST 
17,18c17
< *
< *       Write formatted data bank on unit 87.
---
> *       Write formatted data bank on unit 13.
20d18
<           OPEN (UNIT=87,STATUS='NEW',FORM='FORMATTED',FILE='HIDAT')
22c20
<           WRITE (87,1)
---
>           if(rank.eq.0)WRITE (13,1)
30d27
<           ZMM = 0.0
33d29
<               IF (NAME(I).LT.0) ZMM = ZMM + BODY(I)
35,38c31,33
<           ZMM = ZMM*ZMBAR/FLOAT(NMERGE - MULT)
<           WRITE (87,3)  NPAIRS, NRUN, N, NC, NMERGE, MULT, NEWHI, TTOT,
<      &                  ZMM
<     3     FORMAT (/,I6,I4,I6,3I4,I6,F9.1,F6.2)
---
>           if(rank.eq.0)
>      &    WRITE (13,3)  NPAIRS, NRUN, N, NC, NMERGE, MULT, NEWHI, TIME
>     3     FORMAT (/,I6,I4,I6,3I4,I6,F9.1)
51d45
<           KCM = KSTARM(IM)
74c68
< *             EB(IPAIR) = CM(1,IM)*CM(2,IM)*HM(IM)/BODYCM
---
>               EB(IPAIR) = CM(1,IM)*CM(2,IM)*HM(IM)/BODYCM
94c88
< *             EB(IPAIR) = CM(1,IM)*CM(2,IM)*HM(IM)/BODYCM
---
>               EB(IPAIR) = CM(1,IM)*CM(2,IM)*HM(IM)/BODYCM
135c129,130
<                   WRITE (6,20)  NAME(J1), NAME(J), ANGLE, E1, PMIN,
---
>                   if(rank.eq.0)
>      &            WRITE (6,20)  NAME(J1), NAME(J), ANGLE, E1, PMIN,
149d143
<               KCM = KSTAR(ICM)
151,152c145,146
< *       Locate the first KS component (former c.m. hence subtract NZERO).
<               DO 23 K = 1,IFIRST
---
> *       Locate the massive KS component (former c.m. hence subtract NZERO).
>               DO 24 K = 1,IFIRST
154c148
<    23         CONTINUE
---
>    24         CONTINUE
156,171d149
< *       Include the case of [[B,S],[B,S]] which requires more work.
<               IF (BODY(J).EQ.0.0D0) THEN
<                   JM = 0
<                   DO 24 K = 1,NMERGE
<                       IF (NAMEM(IM).EQ.NAMEG(K)) JM = K
<    24             CONTINUE
<                   IF (JM.EQ.0) GO TO 30
<                   J = 0
< *       Employ new ghost identification to find the corresponding c.m index.
<                   DO 25 K = N+1,NTOT
<                       IF (NAME(K).EQ.NAMEM(JM)) J = K
<    25             CONTINUE
<                   IF (J.EQ.0) GO TO 30
<                   J = 2*(J - N)
< *       Note that both the triple masses (M1,M2) are saved in CM(1->4,JM).
<               END IF
191c169
< *             EB(IPAIR) = BODYJ1*BODYJ2*H(JPAIR)/BODYCM
---
>               EB(IPAIR) = BODYJ1*BODYJ2*H(JPAIR)/BODYCM
199c177
< *       Evaluate the potential energy of c.m.
---
> *       Evaluate the potential energy of c.m..
201,202c179,180
<           DO 26 K = IFIRST,NTOT
<               IF (K.EQ.ICM) GO TO 26
---
>           DO 25 K = IFIRST,NTOT
>               IF (K.EQ.ICM) GO TO 25
206c184
<    26     CONTINUE
---
>    25     CONTINUE
217c195
< *         ECM(IPAIR) = 0.5*VJ2 - PHI
---
>           ECM(IPAIR) = 0.5*VJ2 - PHI
220,221c198,201
<           WRITE (87,28)  NAME(J1), NAM2, NAME(J2), KSTAR(J1), KSTAR(J),
<      &                   KCM, M1, M2, M3, RI, EMAX, E0, E1, P0, P1
---
>           if(rank.eq.0)
>      &    WRITE (13,28)  NAME(J1), NAM2, NAME(J2), KSTAR(J1), KSTAR(J),
>      &                   KSTARM(IM), M1, M2, M3, RI, EMAX, E0, E1,
>      &                   P0, P1
224c204
<       CALL FLUSH(87)
---
>       CALL FLUSH(13)
235a216
> 
1,2c1,2
< 3955 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/himax2.f
< nbody6compare/himax2.f
---
> 4174 2001-05-20 16:20 /work/Umi2/spurzem/5/nbody6++compare/himax2.f
> nbody6++compare/himax2.f
4c4
< *       Maximum eccentricity of inner hierarchical binary.
---
> *       Maximum eccentricity of outer hierarchical binary.
8c8,12
<       REAL*8  A1(3),A2(3),XREL(3),VREL(3),EI(3),HI(3),HO(3),BHAT(3)
---
>       COMMON/BINARY/  CM(4,MMAX),YREL(3,MMAX),ZREL(3,MMAX),
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       REAL*8  A1(3),A2(3),XREL(3),VREL(3),EI(3),HI(3),HO(3),BHAT(3),
>      &        EVEC(3)
26c30
<       A12 = 0.0
---
>     4 A12 = 0.0
54c58
< *       Construct the Runge-Lenz vector (Heggie & Rasio 1995, IAU174, Eq.5).
---
> *       Construct the Runge-Lenz vector (Heggie & Rasio 1995, Eq.(5)).
59a64
>           EVEC(K) = EI(K)
1,2c1,2
< 4411 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/himax.f
< nbody6compare/himax.f
---
> 4303 1999-12-23 13:14 /work/Umi2/spurzem/5/nbody6++compare/himax.f
> nbody6++compare/himax.f
9,10c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAGM(MMAX)
12c12
<      &        UI(4),V(4)
---
>      &        UI(4),V(4),EVEC(3)
31,35d30
< *       Ensure that unperturbed binary is resolved.
<       IF (LIST(1,2*IPAIR-1).EQ.0.OR.X(1,JCOMP).EQ.X(1,I)) THEN
<           CALL RESOLV(IPAIR,1)
<       END IF
< *
37c32
<       A12 = 0.0
---
>     4 A12 = 0.0
68c63
< *       Construct the Runge-Lenz vector (Heggie & Rasio 1995, IAU174, Eq.5).
---
> *       Construct the Runge-Lenz vector (Heggie & Rasio 1995, Eq.(5)).
73a69
>           EVEC(K) = EI(K)
1,2c1,2
< 5282 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/hipop.f
< nbody6compare/hipop.f
---
> 5039 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/hipop.f
> nbody6++compare/hipop.f
0a1,4
> # 1 "hipop.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "hipop.F"
4,5c8,9
< *       Initial hierarchical population.
< *       --------------------------------
---
> * Initial hierarchical population.
> * --------------------------------
8,14c12,22
<       REAL*8  XORB(2),VORB(2),XREL(3),VREL(3),PX(3),QX(3),
<      &        BS(MMAX),XS(3,MMAX),VS(3,MMAX)
<       REAL*4  RAN2
< *
< *
< *       Read input parameters (same usage as routine BINPOP).
<       READ (5,*)  NHI, SEMI0, ECC0, RATIO, RANGE, ICIRC
---
>       REAL*8 XORB(2),VORB(2),XREL(3),VREL(3),PX(3),QX(3),
>      & BS(MMAX),XS(3,MMAX),VS(3,MMAX)
>       REAL*4 RAN2
> *
> # 21 "hipop.F"
> * recover random number sequence from COMMON variable IDUM1.
>       KDUM = IDUM1
> *
> * Read input parameters (same usage as routine BINPOP).
>       if(rank.eq.0)READ (5,*) NHI, SEMI0, ECC0, RATIO, RANGE, ICIRC
> # 34 "hipop.F"
16c24
<       WRITE (6,1)  NHI, SEMI0, ECC0, RATIO, RANGE, ICIRC
---
>       WRITE (6,1) NHI, SEMI0, ECC0, RATIO, RANGE, ICIRC
18,19c26,27
<      &              '  E =',F6.2,'  RATIO =',F4.1,'  RANGE =',F6.1,
<      &              '  ICIRC =',I2,/)
---
>      & '  E =',F6.2,'  RATIO =',F4.1,'  RANGE =',F6.1,
>      & '  ICIRC =',I2,/)
22,23c30,31
<           WRITE (6,2)  NBIN0, NHI
<     2     FORMAT (5X,'FATAL ERROR!   NBIN0 =',I4,'  NHI =',I4)
---
>           WRITE (6,2) NBIN0, NHI
>     2 FORMAT (5X,'FATAL ERROR!   NBIN0 =',I4,'  NHI =',I4)
27c35
< *       Introduce binary components by splitting the primary.
---
> * Introduce binary components by splitting the primary.
30,33c38,41
< *       Randomize perihelion, node & inclination.
<           PI = TWOPI*RAN2(IDUM1)
<           OMEGA = TWOPI*RAN2(IDUM1)
<           ZI = 0.5*TWOPI*RAN2(IDUM1)
---
> * Randomize perihelion, node & inclination.
>           PI = TWOPI*RAN2(KDUM)
>           OMEGA = TWOPI*RAN2(KDUM)
>           ZI = 0.25*TWOPI*RAN2(KDUM)
35c43
< *       Set transformation elements (Brouwer & Clemence p. 35).
---
> * Set transformation elements (Brouwer & Clemence p. 35).
41c49
<           QX(3) = COS(PI)*SIN(ZI) 
---
>           QX(3) = COS(PI)*SIN(ZI)
43c51
< *       Determine two-body elements for original binary.
---
> * Determine two-body elements for original binary.
55c63
<     5     CONTINUE
---
>     5 CONTINUE
64,65c72,73
< *       Specify component masses (primary fraction range 0.5 - 0.9).
<           Q0 = 0.5 + 0.4*RAN2(IDUM1)
---
> * Specify component masses (primary fraction range 0.5 - 0.9).
>           Q0 = 0.5 + 0.4*RAN2(KDUM)
72c80
< *       Choose random (thermalized) or fixed eccentricity.
---
> * Choose random (thermalized) or fixed eccentricity.
74c82
<               ECC2 = RAN2(IDUM1)
---
>               ECC2 = RAN2(KDUM)
80c88
< *       Select semi-major axis from uniform distribution in log(A) or SEMI0.
---
> * Select semi-major axis from uniform distribution in log(A) or SEMI0.
82,89c90,92
<    10     IF (RANGE.GT.0.0) THEN
<               IF (ITER.LE.5) THEN
<                   EXP = RAN2(IDUM1)*LOG10(RANGE)
<                   SEMI = SEMI1/10.0**EXP
<               ELSE
< *       Shrink by factor 2 if no success after 5 iterations.
<                   SEMI = 0.5*SEMI
<               END IF
---
>    10 IF (RANGE.GT.0.0) THEN
>               EXP = RAN2(KDUM)*LOG10(RANGE)
>               SEMI = SEMI0/10.0**EXP
94c97
< *       Check stability criterion (maximum 12 tries including inclination).
---
> * Check standard stability criterion (maximum of 10 tries).
97,99c100,101
<           PCRIT = 2.8*XFAC**0.4*SEMI
<           YFAC = 1.0 - 0.3*ZI/3.1415
<           PCRIT = YFAC*PCRIT
---
>           FE = 1.0
>           PCRIT = 2.8*FE*XFAC**0.4*SEMI
101c103
<           IF (PMIN.LT.PCRIT.AND.ITER.LE.12.AND.SEMI.LT.SEMI0) GO TO 10
---
>           IF (PMIN.LT.PCRIT.AND.ITER.LT.10) GO TO 10
105,107c107,109
<           WRITE (6,20)  ITER, ECC, ECC1, PMIN, PCRIT, P0, P1
<    20     FORMAT (' HIERARCHY:    IT E E1 PMIN PCRIT P0 P1 ',
<      &                            I4,2F7.3,1P,4E9.1)
---
>           WRITE (6,20) ITER, ECC, ECC1, PMIN, PCRIT, P0, P1
>    20 FORMAT (' HIERARCHY:    IT E E1 PMIN PCRIT P0 P1 ',
>      & I4,2F7.3,1P,4E9.1)
109c111
< *       Specify relative motion at apocentre and sum binding energy.
---
> * Specify relative motion at apocentre and sum binding energy.
116c118
< *       Transform to relative variables.
---
> * Transform to relative variables.
120c122
<    25     CONTINUE
---
>    25 CONTINUE
122c124
< *       Save old secondary and set global variables for each component.
---
> * Save old secondary and set global variables for each component.
130c132
<    30     CONTINUE
---
>    30 CONTINUE
133c135
< *       Move single particles down by NHI to make room for outer components.
---
> * Move single particles down by NHI to make room for outer components.
141c143
<    45     CONTINUE
---
>    45 CONTINUE
145c147
< *       Place hierarchical components immediately after the binaries.
---
> * Place hierarchical components immediately after the binaries.
152c154
<    55     CONTINUE
---
>    55 CONTINUE
155c157
< *       Update the particle number and reset NHI (might be used elsewhere).
---
> * Update the particle number.
159c161,163
<       NHI = 0
---
> *
> * Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
1,2c1,2
< 2788 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/histab.f
< nbody6compare/histab.f
---
> 2790 2003-06-23 19:31 /work/Umi2/spurzem/5/nbody6++compare/histab.f
> nbody6++compare/histab.f
96a97,98
> 
> 
1,2c1,2
< 5574 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/hivel.f
< nbody6compare/hivel.f
---
> 3618 2001-08-06 16:36 /work/Umi2/spurzem/5/nbody6++compare/hivel.f
> nbody6++compare/hivel.f
10c10
< *       Copy membership and add 1 for analogy with HARP/GRAPE.
---
> *       Copy membership and add 1 for analogy with HARP.
34c34,35
<               WRITE (29,3)  LI, NAME(LI), SQRT(RL2), SQRT(VL2)
---
>               if(rank.eq.0)
>      &        WRITE (29,3)  LI, NAME(LI), SQRT(RL2), SQRT(VL2)
36d36
<               CALL FLUSH(29)
71,72c71
< *       Add any new high-velocity particles (save F**2 > N & STEP < DTMIN).
<       NHV = 0
---
> *       Add any new high-velocity particles (skip F**2 > N & STEP < DTMIN).
74a74,76
> *       Adopt geometric mean of close encounter and core mass force.
>           IF (FI2.GT.FLOAT(N).OR.STEP(I).LT.DTMIN.OR.
>      &        STEPR(I).LT.20.0*DTMIN) GO TO 10
78,87c80
< *       Form a list of recently ejected candidates.
<           IF (FI2.GT.FLOAT(N).OR.STEP(I).LT.DTMIN.OR.
<      &        STEPR(I).LT.20.0*DTMIN) THEN
<               IF (VI2.GT.VMAX2) THEN
<                   NHV = NHV + 1
<                   JLIST(NHV) = I
<               END IF
<               GO TO 10
<           END IF
<           IF (VI2.GT.VMAX2.AND.RI2.LT.4.0*RSCALE**2) THEN
---
>           IF (VI2.GT.VMAX2.AND.RI2.LT.9.0*RSCALE**2) THEN
97c90,91
<               WRITE (29,9)  TIME+TOFF, NHI-1, I, NAME(I), KSTAR(I),
---
>               if(rank.eq.0)
>      &        WRITE (29,9)  TIME+TOFF, NHI, I, NAME(I), KSTAR(I),
101d94
<               CALL FLUSH(29)
105,151d97
< *       Consider single fast particle or hyperbolic two-body motion.
<       IF ((NHV.EQ.1.OR.NHV.EQ.2).AND.NHI.LT.MLV-NHV) THEN
< *       Compare any candidates with existing members.
<           DO 20 K = 1,NHV
<               DO 15 L = 2,NHI
<                   IF (JLIST(K).EQ.LISTV(L)) GO TO 30
<    15         CONTINUE
<    20     CONTINUE
<           I1 = JLIST(1)
< *       Include single particles without further tests.
<           IF (NHV.EQ.1) THEN
<               NHI = NHI + 1
<               LISTV(1) = LISTV(1) + 1
<               NFAST = NFAST + 1
<               LISTV(NHI) = I1
<               WRITE (29,22)  TTOT, NHI-1, NAME(I1), IPHASE, STEP(I1)
<    22         FORMAT (' HIVEL ADD    T NHI NM IPH DT ',
<      &                               F10.4,I4,I6,I4,1P,E10.2)
<               GO TO 30
<           END IF
< *       Evaluate two-body energy.
<           I2 = JLIST(2)
<           RIJ2 = 0.0
<           VIJ2 = 0.0
<           RDOT = 0.0
<           DO 25 K = 1,3
<               RIJ2 = RIJ2 + (X(K,I1) - X(K,I2))**2
<               VIJ2 = VIJ2 + (XDOT(K,I1) - XDOT(K,I2))**2
<               RDOT = RDOT + (X(K,I1) - X(K,I2))*(XDOT(K,I1)-XDOT(K,I2))
<    25     CONTINUE
<           RIJ = SQRT(RIJ2)
<           SEMI = 2.0/RIJ - VIJ2/(BODY(I1) + BODY(I2))
< *       Accept outwards hyperbolic motion arising from recent interaction.
<           IF (SEMI.LT.0.0.AND.RIJ.LT.10.0*RMIN.AND.RDOT.GT.0.0) THEN
<               NHI = NHI + 1
<               LISTV(NHI) = I1
<               NHI = NHI + 1
<               LISTV(NHI) = I2
<               LISTV(1) = LISTV(1) + 2
<               NFAST = NFAST + 2
<               WRITE (29,28) TTOT, NHI-1, NAME(I1), NAME(I2), IPHASE, RIJ
<    28         FORMAT (' HIVEL ADD    T NHI NM IPH RIJ ',
<      &                               F10.4,I4,2I6,I4,1P,E10.2)
<           END IF
<       END IF
< *
<    30 CONTINUE
159a106
> 
1,2c1,2
< 5031 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/hmdot2.f
< nbody6compare/hmdot2.f
---
> 5081 2002-06-12 23:18 /work/Umi2/spurzem/5/nbody6++compare/hmdot2.f
> nbody6++compare/hmdot2.f
97c97,98
<           WRITE (6,15)  NAME(J), KSTAR(J), KSTAR(IGHOST), SQRT(ECC2),
---
>           if(rank.eq.0)
>      *    WRITE (6,15)  NAME(J), KSTAR(J), KSTAR(IGHOST), SQRT(ECC2),
140c141,142
<           WRITE (6,30)  NAME(J), KSTAR(J), IMERGE, KM, M1, DMS, PMIN,
---
>           if(rank.eq.0)
>      *    WRITE (6,30)  NAME(J), KSTAR(J), IMERGE, KM, M1, DMS, PMIN,
148a151,152
> 
> 
1,2c1,2
< 4943 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/hmdot.f
< nbody6compare/hmdot.f
---
> 4634 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/hmdot.f
> nbody6++compare/hmdot.f
21c21
< *       Decide between #I1 and ghost (NB! choose I1 first if TEV equal).
---
> *       Decide which component needs updating by comparing evolution times.
23c23
<       IF (TEV(I1).LE.TEV(J)) J = I1
---
>       IF (TEV(I1).LT.TEV(J)) J = I1
28c28
<       IF (KSTARM(IMERGE).LT.0.OR.BODY(ICM).EQ.0.0D0) IQUIT = .TRUE.
---
>       IF (KSTARM(IMERGE).LT.0) IQUIT = .TRUE.
30c30
< *       Quit for mis-identification, tidal evolution or double merger.
---
> *       Quit for mis-identification or advanced evolution.
61,76d60
< *       Evaluate old separation, square regularized velocity, t'' & ECC.
<       RI = 0.0D0
<       V20 = 0.0
<       TD2 = 0.0
<       DO 10 K = 1,4
<           RI = RI + UM(K,IMERGE)**2
<           V20 = V20 + UMDOT(K,IMERGE)**2
<           TD2 = TD2 + 2.0*UM(K,IMERGE)*UMDOT(K,IMERGE)
<    10 CONTINUE
<       ECC2 = (1.0 - RI/SEMI0)**2 + TD2**2/(SEMI0*ZMB0)
<       ECC = SQRT(ECC2)
< *
< *       Determine inclination and YFAC (use #I1 as first KS component).
<       CALL HIMAX(I1,IMERGE,ECC,SEMI0,EMAX,EMIN,ZI,TG,EDAV)
<       YFAC = 1.0 - 0.3*ZI/180.0
< *
79c63
<       PCRIT = 2.8*XFAC**0.4*SEMI2*YFAC
---
>       PCRIT = 2.8*XFAC**0.4*SEMI2
90,93c74,87
< *       Check condition for sequential circularization.
<       RP = SEMI0*(1.0 - ECC)
<       DR = ABS(RP - 4.0*RADIUS(J))
<       IF (KZ(27).GT.0.AND.DR.GT.0.01*RP.AND.
---
> *       Evaluate old separation, square regularized velocity & t''.
>       RI = 0.0D0
>       V20 = 0.0
>       TD2 = 0.0
>       DO 10 K = 1,4
>           RI = RI + UM(K,IMERGE)**2
>           V20 = V20 + UMDOT(K,IMERGE)**2
>           TD2 = TD2 + 2.0*UM(K,IMERGE)*UMDOT(K,IMERGE)
>    10 CONTINUE
> *
> *       Check condition for likely tidal dissipation (TCIRC not possible).
>       ECC2 = (1.0 - RI/SEMI0)**2 + TD2**2/(SEMI0*ZMB0)
>       RP = SEMI0*(1.0 - SQRT(ECC2))
>       IF (KZ(27).GT.1.AND.RP.LT.3.0*RADIUS(J).AND.
95c89
<           WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), ECC,
---
>           WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), SQRT(ECC2),
117c111
< *       Note: no need to update XREL & VREL for RESET (c.m. error cancels).
---
> *       Note no need to update XREL & VREL for RESTART (c.m. error cancels).
135,141c129,133
< *       Print some diagnostics on significant mass loss.
<       IF (DMS.GT.0.005*M1) THEN
<           WRITE (6,30)  NAME(J), KSTAR(J), IMERGE, KM, M1, DMS, PMIN,
<      &                  PCRIT, SEMI2, SEMI1, DECORR
<    30     FORMAT (' HMDOT    NAM K* IM KM M1 DM PM PC A A1 DE ',
<      &                       I6,3I4,2F6.2,1P,4E10.2,0P,F10.6)
<       END IF
---
> *       Print some diagnostics.
>       WRITE (6,30)  NAME(J), KSTAR(J), IMERGE, KM, M1, DMS, PMIN, PCRIT,
>      &              SEMI2, SEMI1, DECORR
>    30 FORMAT (' HMDOT    NAM K* IM KM M1 DM PM PC A A1 DE ',
>      &                   I6,3I4,2F6.2,1P,4E10.2,0P,F10.6)
145a138
> 
1,2c1,2
< 1593 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/hotsys.f
< nbody6compare/hotsys.f
---
> 1584 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/hotsys.f
> nbody6++compare/hotsys.f
0a1,4
> # 1 "hotsys.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "hotsys.F"
4,5c8,9
< *       Hot initial system.
< *       -------------------
---
> * Hot initial system.
> * -------------------
8a13
> # 18 "hotsys.F"
10c15
< *       Determine the rms velocity from current kinetic energy.
---
> * Determine the rms velocity from current kinetic energy.
15c20
<     5     CONTINUE
---
>     5 CONTINUE
19c24
< *       Define GM & PC in cgs units and form velocity scale in km/sec.
---
> * Define GM & PC in cgs units and form velocity scale in km/sec.
24c29
< *       Ensure ZMBAR & RBAR > 0 (=0: assume <M>/Sun = 1, RBAR = 1 pc).
---
> * Ensure ZMBAR & RBAR > 0 (=0: assume <M>/Sun = 1, RBAR = 1 pc).
28c33
< *       Scale to working units of RBAR in pc & ZMBAR in solar masses.
---
> * Scale to working units of RBAR in pc & ZMBAR in solar masses.
31,32c36,40
< *       Read central velocity dispersion and form scaling factor.
<       READ (5,*)  SIGMA0
---
> * Read central velocity dispersion and form scaling factor.
>       if(rank.eq.0)READ (5,*) SIGMA0
> 
> 
> 
35c43
< *       Scale the velocities to central velocity dispersion of SIGMA0 km/sec.
---
> * Scale the velocities to central velocity dispersion of SIGMA0 km/sec.
40c48
<    15     CONTINUE
---
>    15 CONTINUE
43c51
< *       Rescale crossing time, output times & termination time.
---
> * Rescale crossing time, output times & termination time.
52c60
<       WRITE (6,30)  SIGMA0, VRMS, VSCALE
---
>       WRITE (6,30) SIGMA0, VRMS, VSCALE
54c62
<      &                                              '  VSCALE =',F6.3,/)
---
>      & '  VSCALE =',F6.3,/)
1,2c1,2
< 974 2003-11-08 17:13 /work/Umi2/spurzem/5/nbody6compare/hpsort.f
< nbody6compare/hpsort.f
---
> 972 2005-03-11 11:18 /work/Umi2/spurzem/5/nbody6++compare/hpsort.f
> nbody6++compare/hpsort.f
9,10c9,10
<       REAL*8 Array(45)
<       INTEGER Indx(45)
---
>       REAL*8 Array(N)
>       INTEGER Indx(N)
1,2c1,2
< 19188 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/hrdiag.f
< nbody6compare/hrdiag.f
---
> 19188 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/hrdiag.f
> nbody6++compare/hrdiag.f
1,2c1,2
< 5683 2006-09-02 12:18 /work/Umi2/spurzem/5/nbody6compare/hrplot.f
< nbody6compare/hrplot.f
---
> 6866 2006-06-20 02:26 /work/Umi2/spurzem/5/nbody6++compare/hrplot.f
> nbody6++compare/hrplot.f
15c15
<       WRITE (82,1)  NPAIRS, TPHYS
---
>       if(rank.eq.0) WRITE (82,1)  NPAIRS, TPHYS
19c19
<       WRITE (83,1)  NS, TPHYS
---
>       if(rank.eq.0) WRITE (83,1)  NS, TPHYS
35c35
<                   WRITE (6,3)  I, NCH
---
>                   if(rank.eq.0) WRITE (6,3)  I, NCH
45a46,57
> * 1. Patch by Jarrod against fpe's (A. Ernst)
>          IF((KW.LE.1.OR.KW.EQ.7).AND.AGE.GT.TM)THEN
>             AGE = 0.999D0*TM
>          ELSEIF(KW.LE.9.AND.AGE.GT.TN)THEN
>             IF(KW.LE.6)THEN
>                AGE = MIN(AGE,0.9999D0*TSCLS(11))
>             ELSE
>                AGE = MIN(AGE,0.9999D0*TSCLS(5))
>                AGE = MIN(AGE,0.99D0*TN)
>             ENDIF
>          ENDIF
> * End patch
71c83
<                   AGE = MAX(TPLOT,TEV0(J1))*TSTAR - EPOCH(J1)
---
>                   AGE = MAX(TPLOT,TEV0(J))*TSTAR - EPOCH(J1)
72a85,89
> * 2. Patch by Jarrod against fpe's (A. Ernst)  
>                   IF(AGE.GT.TN)THEN
>                     AGE = MIN(0.98D0*TN,TEV0(J)*TSTAR - EPOCH(J))
>                   ENDIF
> * End patch
90,91c107,108
<                   AGE = MAX(TPLOT,TEV0(J1))*TSTAR - EPOCH(J1)
<                   KW = KSTAR(J1)
---
>                   AGE = MAX(TPLOT,TEV0(J2))*TSTAR - EPOCH(J2)
>                   KW = KSTAR(J2)
92a110,114
> * 3. Patch by Jarrod against fpe's (A. Ernst)
>                   IF(AGE.GT.TN)THEN
>                     AGE = MIN(0.98D0*TN,TEV0(J)*TSTAR - EPOCH(J))
>                   ENDIF
> * End patch
99c121,133
<               CALL STAR(KW2,M0,M2,TM,TN,TSCLS,LUMS,GB,ZPARS)
---
>               CALL STAR(KW2,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
> * 4. Patch by Jarrod against fpe's (A. Ernst)
>               IF((KW2.LE.1.OR.KW2.EQ.7).AND.AGE.GT.TM)THEN
>                  AGE = 0.999D0*TM
>               ELSEIF(KW2.LE.9.AND.AGE.GT.TN)THEN
>                  IF(KW2.LE.6)THEN
>                     AGE = MIN(AGE,0.9999D0*TSCLS(11))
>                  ELSE
>                     AGE = MIN(AGE,0.9999D0*TSCLS(5))
>                     AGE = MIN(AGE,0.99D0*TN)
>                  ENDIF
>               ENDIF
> * End patch              
101c135
<      &                    RM2,LUM2,KW2,MC,RCC)
---
>      &                    RM2,LUM2,KW,MC,RCC)
120,124c154,157
<               TE1 = 0.25*(ZL1 - 2.0*R1) + 3.7
<               TE2 = 0.25*(ZL2 - 2.0*R2) + 3.7
<               WRITE (82,5)  NAME(J1), NAME(J2), KW, KW2, KSTAR(ICM),
<      &            RI, ECC, PB, SEMI, M1, M2, ZL1, ZL2, R1, R2, TE1, TE2
<     5         FORMAT (2I6,2I3,I4,F6.1,F6.3,10F7.3)
---
>               if(rank.eq.0)
>      &        WRITE (82,5)TTOT, NAME(J1), NAME(J2), KW, KW2, KSTAR(ICM),
>      &                    RI, ECC, PB, SEMI, M1, M2, ZL1, ZL2, R1, R2
>     5         FORMAT (1X,1P,D15.7,2I8,3I5,10D15.5)
136,137c169,171
<               WRITE (83,10)  NAME(I), KW, RI, M1, ZL1, R1, TE
<    10         FORMAT (I6,I3,F6.1,4F7.3)
---
>               if(rank.eq.0) 
>      &    WRITE (83,10)  TTOT, NAME(I), KW, RI, M1, ZL1, R1
>    10         FORMAT (1X,1P,D15.7,I8,I5,4D15.5)
141,142d174
< *       Update next plotting time.
<       TPLOT = TPLOT + DTPLOT
148a181,182
> 
> 
1,2c1,2
< 390 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/iblock.f
< nbody6compare/iblock.f
---
> 390 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/iblock.f
> nbody6++compare/iblock.f
12c12
<       DO 1 K = 2,40
---
>       DO 1 K = 2,64
1,2c1,2
< 1903 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ichain.f
< nbody6compare/ichain.f
---
> 1903 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/ichain.f
> nbody6++compare/ichain.f
1,2c1,2
< 3643 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/imf2.f
< nbody6compare/imf2.f
---
> 3730 2005-03-09 14:24 /work/Umi2/spurzem/5/nbody6++compare/imf2.f
> nbody6++compare/imf2.f
6d5
< *       BODY10,BODYN are in M_sun.
9,11c8,10
<       REAL*4  RAN2
<       REAL*8  IMFBD
<       REAL*8  LM,UM,BCM
---
>       REAL*4 RAN2
>       REAL*8  BTMP(NMAX)
>       REAL*8  LM,UM,ZM,IMFBD
13d11
<       COMMON/WORK1/  BCM(NMAX)
15c13
< *=========================  if KZ(20)=2:
---
> *=========================
22c20
< *       Generate initial mass function (N-NBIN0 singles & 2*NBIN0 binaries).
---
> * recover random number sequence from COMMON variable IDUM1.
23a22,23
> *
> *       Generate initial mass function (KZ(20) = 2 or > 2).
40c40
<           IF (ZM.GE.BODYN.AND.ZM.LE.BODY10) THEN
---
>           IF (ZM.GT.BODYN.AND.ZM.LT.BODY10) THEN
53c53
<           BCM(I) = BODY(2*I-1) + BODY(2*I)
---
>           BTMP(I) = BODY(2*I-1) + BODY(2*I)
59c59
<           CALL SORT1(NBIN0,BCM,JLIST)
---
>           CALL SORT1(NBIN0,BTMP,JLIST)
79,80c79,80
<           BODY(NBIN0-I+1) = BCM(I)
<           ZMB = ZMB + BCM(I)
---
>           BODY(NBIN0-I+1) = BTMP(I)
>           ZMB = ZMB + BTMP(I)
83,85c83,87
<       WRITE (6,45)  NBIN0, BODY(1), BODY(NBIN0), ZMB/FLOAT(NBIN0)
<    45 FORMAT (//,12X,'BINARY STAR IMF:    NB =',I5,
<      &               '  RANGE =',1P,2E10.2,'  <MB> =',E9.2)
---
>       if(rank.eq.0)then
>       WRITE (6,45)  NBIN0, BODY(1), BODY(NBIN0), ZMB, ZMB/FLOAT(NBIN0)
>    45 FORMAT (/,12X,'BINARY STAR IMF:   NB =',I5,'  RANGE =',1P,2E10.2,
>      &     ' ZMB =',E9.2,'  <MB> =',E9.2)
>       end if
93c95
<           BCM(NS) = BODY(NBIN0+L)
---
>           BTMP(NS) = BODY(NBIN0+L)
98c100
<       CALL SORT1(NS,BCM,JLIST)
---
>       CALL SORT1(NS,BTMP,JLIST)
103,104c105,106
<           BODY(N-I+1) = BCM(I)
<           ZMS = ZMS + BCM(I)
---
>           BODY(N-I+1) = BTMP(I)
>           ZMS = ZMS + BTMP(I)
107,109c109,112
<       WRITE (6,80)  N-NBIN0, BODY(NBIN0+1), BODY(N), ZMS/FLOAT(N-NBIN0)
<    80 FORMAT (/,12X,'SINGLE STAR IMF:    NS =',I5,'  RANGE =',1P,2E10.2,
<      &                                            '  <MS> =',E9.2)
---
>       if(rank.eq.0)
>      &WRITE (6,80)N-NBIN0,BODY(NBIN0+1),BODY(N),ZMS,ZMS/FLOAT(N-NBIN0)
>    80 FORMAT (/,12X,'SINGLE STAR IMF:   NS =',I5,'  RANGE =',1P,2E10.2,
>      &     ' ZMS =',E9.2,'  <MS> =',E9.2)
112c115,117
<    90 ZMBAR = ZMASS/FLOAT(N)
---
>    90 CONTINUE
> *       Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
1,2c1,2
< 19966 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/imfbd.f
< nbody6compare/imfbd.f
---
> 19400 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/imfbd.f
> nbody6++compare/imfbd.f
1,8c1
< C
< C Note: this routine contains the correction from Carsten Weidner
< C       (Nov.2004), that for LOM above a certain value the integral
< C       was not computed correctly.
< C
< C
< C===========================================================
<       REAL*8 FUNCTION IMFBD(XX,LOM,UPM)
---
>       real*8 FUNCTION IMFBD(XX,LOM,UPM)
17,18c10
< * (For equal masses, LOM=UPM and IMFBD = UPM.)
< * LOM and UPM must be kept unchanged.
---
> * For equal masses, LOM=UPM and IMFBD = UPM.
22,27c14,19
<       REAL*8    ML,MH,M0,M1,M2,MU
<       REAL*8    ALPHA0,ALPHA1,ALPHA2,ALPHA3,ALPHA4
<       REAL*8    K,XH,X0,X1,X2,XU,MUP
<       REAL*8    MTOT,MASSH,MASS0,MASS1,MASS2,MASSU
<       REAL*8    XX,LOM,UPM,LM,UM,ZM
<       REAL*8    BETA,INTGR,MINTGR,MGEN,XIN
---
>       REAL*8   ML,MH,M0,M1,M2,MU
>       REAL*8   ALPHA0,ALPHA1,ALPHA2,ALPHA3,ALPHA4
>       REAL*8   K,XH,X0,X1,X2,XU,MUP
>       REAL*8   MTOT,MASSH,MASS0,MASS1,MASS2,MASSU
>       REAL*8   XX,LOM,UPM,LM,UM,ZM
>       REAL*8   BETA,INTGR,MINTGR,MGEN,XIN
39,46d30
< c      DATA    ML,     MH,    M0,      M1,      M2,    MU/
< c     &      0.01D0, 0.08D0, 0.5D0,  1.0D0,   8.0D0, 100.0D0/
< c      DATA      ALPHA0, ALPHA1, ALPHA2, ALPHA3, ALPHA4/
< c     &          0.3D0,  1.3D0,  2.2D0,   2.7D0,  2.7D0/
< *
< *
< C       Standard of average IMF:
< *
48c32
<      &      0.01D0, 0.08D0, 0.5D0,  1.0D0,   8.0D0, 100.0D0/
---
>      &      0.01D0, 0.08D0, 0.5D0,  1.0D0,   5.0D0, 100.0D0/
50,51c34
<      &          0.3D0,  1.3D0,  2.3D0,   2.3D0,  2.3D0/
< *
---
>      &          1.3D0,  1.3D0,  2.2D0,   2.7D0,  2.7D0/
54,57d36
< C      DATA    ML,     MH,    M0,      M1,      M2,    MU/
< C     &      0.01D0, 0.08D0, 0.5D0,  1.0D0,   8.0D0, 150.0D0/
< C      DATA      ALPHA0, ALPHA1, ALPHA2, ALPHA3, ALPHA4/
< C     &          0.3D0,  1.3D0,  2.3D0,   2.35D0,  2.35D0/
58a38,41
> c      DATA    ML,     MH,    M0,      M1,      M2,    MU/
> c     &      2.D0, 2.D0, 2.D0,  2.0D0,   5.0D0, 500.0D0/
> c      DATA      ALPHA0, ALPHA1, ALPHA2, ALPHA3, ALPHA4/
> c     &          1.3D0,  -0.3D0,  2.2D0,   -.7D0,  7.D0/
63,66c46,49
< C      DATA   ML,       MH,    M0,      M1,      M2,    MU/
< C     &     0.01D0,   0.08D0, 0.08D0,   1.0D0,  8.0D0, 100.0D0/
< C      DATA    ALPHA0,  ALPHA1,   ALPHA2,  ALPHA3, ALPHA4/
< C     &        0.3D0,   0.3D0,    1.2D0,   2.3D0,  2.3D0/
---
> c      DATA   ML,       MH,    M0,      M1,      M2,    MU/
> c     &     0.01D0,   0.08D0, 0.5D0,   1.0D0,  5.0D0, 100.0D0/
> c      DATA    ALPHA0,  ALPHA1,   ALPHA2,  ALPHA3, ALPHA4/
> c     &        2.3D0,   2.3D0,    2.3D0,   2.3D0,  2.3D0/
660a644
> 
1,2c1,2
< 1773 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/imf.f
< nbody6compare/imf.f
---
> 1692 2005-03-09 14:16 /work/Umi2/spurzem/5/nbody6++compare/imf.f
> nbody6++compare/imf.f
10,11d9
< *       Generate Scalo IMF (Eggleton, Fitchett & Tout, Ap.J. 347, 998).
<       ITER = 1
14a13,14
> *       Generate Scalo IMF (Eggleton, Fitchett & Tout, Ap.J. 347, 998).
>       ITER = 1
49c49
<       WRITE (6,20)  BODY(1), BODY(N), ZMASS/FLOAT(N)
---
>       if(rank.eq.0)WRITE (6,20) BODY(1), BODY(N), ZMASS, ZMASS/FLOAT(N)
51,54c51
<      &                                '  BODY(N) =',E9.2,'  <M> =',E9.2)
< *
< *       Replace input value by actual mean mass in solar units.
<       ZMBAR = ZMASS/FLOAT(N)
---
>      &           '  BODY(N) =',E9.2,' ZMASS =',E9.2,'  <M> =',E9.2)
1,2c1,2
< 23991 2006-02-16 12:13 /work/Umi2/spurzem/5/nbody6compare/impact.f
< nbody6compare/impact.f
---
> 24880 2003-06-26 01:12 /work/Umi2/spurzem/5/nbody6++compare/impact.f
> nbody6++compare/impact.f
7a8,10
>       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
12,13c15,16
<       SAVE  NWARN
<       DATA  NWARN /0/
---
>       SAVE  NMARG,NWARN
>       DATA  NMARG,NWARN /0,0/
162,163c165
< *     IF ((APO.GT.0.01*RMIN.OR.JCOMP.GT.N).AND.PMIN.GT.1.5*APO) GO TO 30
<       IF ((APO.GT.0.01*RMIN.OR.JCOMP.GT.N).AND.PMIN.GT.APO) GO TO 30
---
>       IF ((APO.GT.0.01*RMIN.OR.JCOMP.GT.N).AND.PMIN.GT.1.5*APO) GO TO 30
171,172c173,174
< *       Skip chain for pericentre outside 1.5*SEMI*(1 + ECC).
<       IF (JCOMP.LE.N.AND.PMIN.GT.1.5*APO) THEN
---
> *       Check almost stable triples (factor 1.2 is experimental).
>       IF (JCOMP.LE.N.AND.PMIN.GT.2.5*SEMI) THEN
174,177c176,195
< *         WRITE (6,12) ECC1, PMIN, RSTAB
< *  12     FORMAT (' HISTAB    E1 PM RSTAB ',F8.4,1P,4E10.2)
<           IF (PMIN.GT.0.9*RSTAB) GO TO 30
<           GO TO 100
---
>           RA = SEMI1*(1.0 + ECC1)
>           IF (SEMI1.LT.0.0) RA = RIJ
>           GI = PERT*(RA/RIJ)**3
> *       Use estimated apocentre perturbation for decision-making.
>           IF (PMIN.GT.1.2*RSTAB) THEN
>               IF (GI.LT.0.05) GO TO 30
> *       Choose chain for critical case of highly eccentric outer orbit.
>               IF (ECC1.LT.0.95) GO TO 100
>           ELSE IF (PMIN.GT.RSTAB) THEN
> *       Treat marginally stable triple according to external perturbation.
>               IF (GI.LT.0.05) GO TO 30
>               IF (GI.LT.1.0.OR.ECC1.LT.0.9) GO TO 100
>           END IF
>       END IF
> *
> *       Specify maximum size of unperturbed motion.
>       IF (PERT2.GT.0.0) THEN
>          RPERT = (100.0*GSTAR*(BODY(I) + BODY(JCOMP))/(2.0*PERT2))**0.33
>       ELSE
>          RPERT = 10.0*SEMI
179d196
<       IF (PMIN.GT.3.0*SEMI.AND.JCOMP.LE.N) GO TO 40
184c201
< *      Compare with existing subsystem of same type (if any).
---
> *       Compare with existing subsystem of same type (if any).
186,187d202
<           PERIM = R(IPAIR) + RIJ
<           IF (JCOMP.GT.N) PERIM = PERIM + R(JPAIR)
189c204
<           CALL PERMIT(PERIM,IGO)
---
>           CALL PERMIT(RPERT,IGO)
192,193c207,208
<               IF (NWARN.LT.50) WRITE (6,18)  PERIM
<    18         FORMAT (' IMPACT    TERMINATION REQUEST    PERIM',1P,E9.1)
---
>               IF (NWARN.LT.50.and.rank.eq.0) WRITE (6,19)  RPERT
>    19         FORMAT (' IMPACT    TERMINATION REQUEST    RPERT',1P,E9.1)
202,203c217,219
<           WRITE (6,19)  I, JCOMP, ECC, ECC1, SEMI1, RIJ, GAMMA(IPAIR)
<    19     FORMAT (' HYP CHAIN    I J E E1 A1 RIJ G  ',
---
>           if(rank.eq.0)
>      &    WRITE (6,18)  I, JCOMP, ECC, ECC1, SEMI1, RIJ, GAMMA(IPAIR)
>    18     FORMAT (' HYP CHAIN    I J E E1 A1 RIJ G  ',
208c224,225
<           WRITE (6,20)  WHICH1, IPAIR, TIME+TOFF, H(IPAIR), R(IPAIR),
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  WHICH1, IPAIR, TIME+TOFF, H(IPAIR), R(IPAIR),
218,228c235,242
< *       Include any close single or c.m. perturber (cf. routine SETSYS).
<       IF (JMAX.NE.JCOMP.AND.SQRT(RMAX2).LT.MIN(2.0D0*RSUM,RMIN).AND.
<      &    NAME(JMAX).GT.0) THEN
<           IF (JCOMP.GT.N.AND.JMAX.GT.N) THEN
<               JCMAX = 0
<           ELSE
<               WRITE (6,21)  NAME(JCOMP), NAME(JMAX), RSUM, SQRT(RMAX2)
<    21         FORMAT (' B+2 CHAIN    NAM RSUM RMX ',2I7,1P,2E10.2)
<               CALL XVPRED(JMAX,-1)
<               JCMAX = JMAX
<           END IF
---
> *       Include any close single perturber (cf. routine SETSYS).
>       IF (JMAX.NE.JCOMP.AND.SQRT(RMAX2).LT.2.0*RIJ.AND.
>      &    JMAX.LE.N.AND.NAME(JMAX).GT.0) THEN
>           if(rank.eq.0)
>      &    WRITE (6,22)  NAME(JCOMP), NAME(JMAX), RSUM, SQRT(RMAX2)
>    22     FORMAT (' B+2 CHAIN    NAM RSUM RMX ',2I6,1P,2E10.2)
>           CALL XVPRED(JMAX,-1)
>           JCMAX = JMAX
240c254
< *       Check possible switch or inert assumption (#27 > 0) for B-B event.
---
> *       Replace unperturbed near-synchronous binary by inert body in CHAIN.
243c257,258
<           WRITE (6,24)  NAME(I1), NAME(I2), NAME(K1), NAME(K1+1),
---
>           if(rank.eq.0)
>      &    WRITE (6,24)  NAME(I1), NAME(I2), NAME(K1), NAME(K1+1),
260c275,276
<                   WRITE (6,25)  SEMI0, RIJ, R(JPAIR), GAMMA(JPAIR)
---
>                   if(rank.eq.0)
>      &            WRITE (6,25)  SEMI0, RIJ, R(JPAIR), GAMMA(JPAIR)
275,276c291,292
< *       Switch pair indices and rename JCOMP if JPAIR has smaller size.
<           IF (STEP(J1).LT.STEP(I1).AND.LIST(1,I1).GT.0) THEN
---
> *       Switch pair indices and rename JCOMP if JPAIR has smaller step.
>           IF (STEP(J1).LT.STEP(I1)) THEN
305c321,322
<           WRITE (6,28)  NAME(I), NAME(JCOMP), NAME(JG), ECC1, PMIN, RIJ
---
>           if(rank.eq.0)
>      &    WRITE (6,28)  NAME(I), NAME(JCOMP), NAME(JG), ECC1, PMIN, RIJ
380c397
<           RT = 10.0*MAX(RADIUS(I1),RADIUS(I2))
---
>           RT = 4.0*MAX(RADIUS(I1),RADIUS(I2))
390c407,408
<               WRITE (6,35)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
---
>               if(rank.eq.0)
>      &        WRITE (6,35)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
395c413
<               KSTAR(I) = 19
---
>               KSTAR(I) = 0
516c534,535
< *         WRITE (6,44)  NMARG, ANGLE, YF, PMIN, YF*PCRIT, TK
---
> *         if(rank.eq.0)
> *    &    WRITE (6,44)  NMARG, ANGLE, YF, PMIN, YF*PCRIT, TK
524c543,544
<               WRITE (6,45)  NMARG, NAME(I), NAME(JCOMP), ANGLE, Q,
---
>               if(rank.eq.0)
>      &        WRITE (6,45)  NMARG, NAME(I), NAME(JCOMP), ANGLE, Q,
530c550,551
<               WRITE (6,46)  ECC1, PERT, RP, RSI, TK1
---
>               if(rank.eq.0)
>      &        WRITE (6,46)  ECC1, PERT, RP, RSI, TK1
542c563,564
<               WRITE (6,48)  TIME+TOFF, Q, ECC, ECC1, SEMI, PMIN, PCRIT,
---
>               if(rank.eq.0)
>      &        WRITE (6,48)  TIME+TOFF, Q, ECC, ECC1, SEMI, PMIN, PCRIT,
548c570,571
<           WRITE (73,49)  TIME+TOFF, Q, ECC, ECC1, SEMI, PMIN, PCRIT,
---
>           if(rank.eq.0)
>      &    WRITE (73,49)  TIME+TOFF, Q, ECC, ECC1, SEMI, PMIN, PCRIT,
559c582,583
<           WRITE (6,50)  NMERGE
---
>           if(rank.eq.0)
>      &    WRITE (6,50)  NMERGE
588c612,613
<               WRITE (6,58)  ECC1, EMAX, YFAC, PM, PCRIT, YFAC*PCRIT2, TG
---
>               if(rank.eq.0)
>      &        WRITE (6,58)  ECC1, EMAX, YFAC, PM, PCRIT, YFAC*PCRIT2, TG
593c618,619
<               WRITE (6,59)  ECC1, EMAX, YFAC, PM, PCRIT, YFAC*PCRIT2, TG
---
>               if(rank.eq.0)
>      &        WRITE (6,59)  ECC1, EMAX, YFAC, PM, PCRIT, YFAC*PCRIT2, TG
603c629,630
<               WRITE (6,20)  WHICH1, IPAIR, TIME+TOFF, H(IPAIR),R(IPAIR),
---
>               if(rank.eq.0)
>      &        WRITE (6,20)  WHICH1, IPAIR, TIME+TOFF, H(IPAIR),R(IPAIR),
612,614c639,641
<               WRITE (6,60)  NAME(I1), NAME(JI), NAME(I1+1), NAME(J1),
<      &                      NAME(JJ), NAME(J1+1),  ECC, ECC1, R(JPAIR)
<    60         FORMAT (' HI MERGE    NM E E1 RJ ',6I6,2F7.3,1P,E10.2)
---
>               if(rank.eq.0)
>      &        WRITE (6,60)  NAME(JI), NAME(JJ), ECC, ECC1, R(JPAIR)
>    60         FORMAT (' HI MERGE    NM E E1 RJ ',2I6,2F7.3,1P,E10.2)
618c645,646
<           WRITE (6,20)  WHICH1, IPAIR, TIME+TOFF, H(IPAIR), R(IPAIR),
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  WHICH1, IPAIR, TIME+TOFF, H(IPAIR), R(IPAIR),
635a664,665
> 
> 
1,2c1,2
< 1104 2004-04-02 12:00 /work/Umi2/spurzem/5/nbody6compare/inclin.f
< nbody6compare/inclin.f
---
> 1077 1997-07-17 15:49 /work/Umi2/spurzem/5/nbody6++compare/inclin.f
> nbody6++compare/inclin.f
36d35
<       FAC = MIN(FAC,1.0D0)
1,2c1,2
< 449 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/inext.f
< nbody6compare/inext.f
---
> 449 2001-08-14 19:20 /work/Umi2/spurzem/5/nbody6++compare/inext.f
> nbody6++compare/inext.f
1,2c1,2
< 2614 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/input.f
< nbody6compare/input.f
---
> 3117 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/input.f
> nbody6++compare/input.f
0a1,4
> # 1 "input.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "input.F"
4,5c8,9
< *       Parameter input.
< *       ----------------
---
> * Parameter input.
> * ----------------
9a14
> # 19 "input.F"
11c16
< *       Make a formal call to define input parameters & counters.
---
> * Make a formal call to define input parameters & counters.
14,22c19,36
< *       Read & print the main input parameters.
<       READ (5,*)  N, NFIX, NCRIT, NRAND, NNBMAX, NRUN
<       READ (5,*)  ETAI, ETAR, RS0, DTADJ, DELTAT, TCRIT, QE, RBAR, ZMBAR
<       READ (5,*)  (KZ(J),J=1,40)
<       READ (5,*)  DTMIN, RMIN, ETAU, ECLOSE, GMIN, GMAX
< *
<       WRITE (6,10)
<    10 FORMAT (/////,15X,'N  NFIX  NCRIT  NRAND  NNBMAX  NRUN')
<       WRITE (6,12)  N, NFIX, NCRIT, NRAND, NNBMAX, NRUN
---
>       IF(rank.eq.0)THEN
> * Read & print the main input parameters.
>          READ (5,*) N, NFIX, NCRIT, NRAND, NNBOPT, NRUN
> C Termination time in physical units, TCRITp, read in nbody6.F
>          READ (5,*) ETAI, ETAR, RS0, DTADJ, DELTAT, TCRIT,
>      & QE, RBAR, ZMBAR
>          READ (5,*) (KZ(J),J=1,40)
>          READ (5,*) (BK(J),J=1,10)
>          READ (5,*) DTMIN, RMIN, ETAU, ECLOSE, GMIN, GMAX
>       END IF
> *
> # 61 "input.F"
> *
> # 70 "input.F"
>       if(rank.eq.0)then
>          WRITE (6,10)
>    10 FORMAT (
>          WRITE (6,12) N, NFIX, NCRIT, NRAND, NNBOPT, NRUN
24,32c38,52
<       WRITE (6,15)
<    15 FORMAT (//,12X,'ETAI      ETAR      RS0       DTADJ     DELTAT',
<      &                        '    TCRIT     QE        RBAR      ZMBAR')
<       WRITE (6,20)  ETAI, ETAR, RS0, DTADJ, DELTAT, TCRIT, QE, RBAR,
<      &                                                             ZMBAR
<    20 FORMAT (/,9X,1P,10E10.1)
<       WRITE (6,22)
<    22 FORMAT (//,12X,'OPTIONS')
<       WRITE (6,24)  (J,J=1,40)
---
> *
> C New: (Aug.1998, P.Kroupa)
>          WRITE(6,15)
>    15 FORMAT (
>      & '     DELTAT',
>      & '     TCRITp    TCRIT     QE',
>      & '        RBAR       ZMBAR')
>          WRITE (6,20) ETAI, ETAR, RS0, DTADJ, DELTAT, TCRITp, TCRIT,
>      & QE, RBAR,
>      & ZMBAR
>    20 FORMAT (/,10X,1P10E10.1)
> *
>          WRITE (6,22)
>    22 FORMAT (
>          WRITE (6,24) (J,J=1,40)
34c54
<       WRITE (6,26)  (KZ(J),J=1,40)
---
>          WRITE (6,26) (KZ(J),J=1,40)
36,40c56,67
<       WRITE (6,28)
<    28 FORMAT (//,12X,'DTMIN     RMIN      ETAU      ECLOSE    GMIN',
<      &                                                     '      GMAX')
<       WRITE (6,30)  DTMIN, RMIN, ETAU, ECLOSE, GMIN, GMAX
<    30 FORMAT (/,9X,1P,6E10.1)
---
>          WRITE (6,21)
>    21 FORMAT (
>          WRITE (6,25) (J,J=1,10)
>    25 FORMAT (/,9X,10I3)
>          WRITE (6,27) (BK(J),J=1,10)
>    27 FORMAT (/,9X,10I3)
>          WRITE (6,28)
>    28 FORMAT (
>      & '      GMAX')
>          WRITE (6,30) DTMIN, RMIN, ETAU, ECLOSE, GMIN, GMAX
>    30 FORMAT (/,9X,1P6E10.1)
>       end if
42c69,80
< *       Perform a simple validation check on main input parameters.
---
> * Define total particle number & neighbour membership range.
>       NTOT = N
>       NZERO = N
>       NNBMAX = MIN(N/2,LMAX - 3)
>       ZNBMIN = MAX(0.01*FLOAT(NNBMAX),1.0)
>       ZNBMAX = 0.9*FLOAT(NNBMAX)
> * Save initial ETAI.
>       ETA0 = ETAI
>       RSMIN = RS0
>       RC = RS0
> *
> * Perform a simple validation check on main input parameters.
48c86
< *       Read parameters for binary evolution analysis.
---
> * Read parameters for binary evolution analysis.
50,54c88,101
<           READ (5,*)  DELTAS, ORBITS(1), (GPRINT(J),J=1,K)
<           WRITE (6,40)  DELTAS, ORBITS(1), (GPRINT(J),J=1,K)
<    40     FORMAT (//,12X,'DELTAS =',F6.2,'  ORBITS(1) =',F6.2,
<      &                                            '  GPRINT(J) =',9F7.3)
< *       Modify binary output factor by perturbation at different levels.
---
>           if(rank.eq.0)then
>           READ (5,*) DELTAS, ORBITS(1), (GPRINT(J),J=1,K)
>           end if
> *
> 
> 
> 
> 
> 
> *
>       if(rank.eq.0)WRITE (6,40) DELTAS, ORBITS(1), (GPRINT(J),J=1,K)
>    40 FORMAT (
>      & '  GPRINT(J) =',9F7.3)
> * Modify binary output factor by perturbation at different levels.
57c104
<    50     CONTINUE
---
>    50 CONTINUE
60,61c107,119
< *       Set random number skip for routine DATA.
<       IDUM1 = NRAND
---
> C Old version:
> * Set random number skip for routine DATA.
> c IDUM1 = NRAND
> C NEW version (14.08.98, P.Kroupa):
> C* Set random number SEED for routine DATA.
>       IDUM1 = -1*NRAND
> c+++ Notify others of this change on log file:
>       if(rank.eq.0)then
>       write(6,*)
>       write(6,*)' ****** NOTE: new random number seed initialisation!'
>       write(6,*)' ****** AND new ran2 from new ed. of Press et al.'
>       write(6,*)
>       end if
63,64d120
< *       Save square of c.m. approximation parameter (coupled to GMIN).
<       CMSEP2 = GMIN**(-0.666666667)
66,75c122,123
< *       Define total particle number & neighbour membership range.
<       NTOT = N
<       NZERO = N
<       ZNBMIN = 0.2*FLOAT(NNBMAX)
<       ZNBMAX = 0.9*FLOAT(NNBMAX)
< *       Save initial ETAI.
<       ETA0 = ETAI
<       RSMIN = RS0
<       RC = RS0
< *       Temporary save of initial neighbour sphere for OUTPUT & NBLIST.
---
> * Save square of c.m. approximation parameter (coupled to GMIN).
>       CMSEP2 = GMIN**(-0.666666667)
1,2c1,2
< 2635 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/insert.f
< nbody6compare/insert.f
---
> 2515 2001-09-30 19:50 /work/Umi2/spurzem/5/nbody6++compare/insert.f
> nbody6++compare/insert.f
39a40,42
>       IF (LSTAR.GT.NNTB) THEN
>           LSTAR = (LI + NNTB)/2
>       END IF
44,51c47,51
< *       Avoid division by zero (unperturbed steps may also be quantized).
<       IF (TBLIST.NE.TJ) THEN
<           FAC = (TI - TJ)/(TBLIST - TJ)
<           LSTAR = LSTAR + FLOAT(NNTB - LSTAR)*FAC
<           LSTAR = MAX(LSTAR,LI+1)
<           LSTAR = MIN(LSTAR,NNTB)
<           J = KBLIST(LSTAR)
<       END IF
---
>       FAC = (TI - TJ)/(TBLIST - TJ)
>       LSTAR = LSTAR + FLOAT(NNTB - LSTAR)*FAC
>       LSTAR = MAX(LSTAR,LI+1)
>       LSTAR = MIN(LSTAR,NNTB)
>       J = KBLIST(LSTAR)
67,71c67
<           IF (J.EQ.I) THEN
<               LI = LI - 1
<               GO TO 50
<           END IF
<           IF (TI.LT.T0(J) + STEP(J)) GO TO 20
---
>           IF (LSTAR.GT.LI.AND.TI.LT.T0(J) + STEP(J)) GO TO 20
86c82,84
<    50 RETURN
---
>    50 CONTINUE
> *
>       RETURN
88a87
> 
1,2c1,2
< 2654 2006-02-15 18:45 /work/Umi2/spurzem/5/nbody6compare/instar.f
< nbody6compare/instar.f
---
> 1980 2006-06-20 02:33 /work/Umi2/spurzem/5/nbody6++compare/instar.f
> nbody6++compare/instar.f
8,10c8,9
<       REAL*8  LUMS(10),TSCLS(20),GB(10)
<       REAL*8  M0,M1,LUM,MC
<       EXTERNAL  RZAMSF
---
>       REAL*8  LUMS(10),TSCLS(20),GB(10),TM,TN
>       REAL*8  M0,M1,RM,LUM,AGE,MC,RCC
15c14
<       TPLOT = 0.0
---
>       TPLOT = 0.0D0
29d27
<       NBH = 0
32,34c30
<       NKICK = 0
<       NBKICK = 0
<       AGE = 0.D0
---
>       AGE = 0.d0
40,41c36
< *       Skip stellar evolution scheme for old routine MLOSS.
<       IF (KZ(19).EQ.1) GO TO 20
---
> *     Set the Hydrogen & Helium abundances.
43d37
< *       Set the Hydrogen & Helium abundances.
47c41,42
< *       Set evolution parameters which depend solely on metallicity.
---
> *     Set evolution parameters which depend solely on metallicity.
> *
55,67c50,54
<           IF (M1.GT.0.1) THEN
<               KW = 1
<               AGE = 0.0
<               CALL STAR(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
<               CALL HRDIAG(M0,AGE,M1,TM,TN,TSCLS,LUMS,GB,ZPARS,
<      &                    RM,LUM,KW,MC,RCC)
< *       Set initial look-up time 0.05 of main sequence time (but < 10**7 yrs).
<               TEV(I) = MIN(0.05*TM,10.0D0)/TSTAR
<           ELSE
<               KW = 0
<               RM = RZAMSF(M1)
<               TEV(I) = 1.0D+10/TSTAR
<           END IF
---
>           KW = 1
>           AGE = 0.0
>           CALL STAR(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
>           CALL HRDIAG(M0,AGE,M1,TM,TN,TSCLS,LUMS,GB,ZPARS,
>      &                RM,LUM,KW,MC,RCC)
72,80c59,61
<           IF (KZ(27).EQ.3.AND.KZ(28).GT.0) THEN
<               RADIUS(I) = 1.0D-12/(3.0*RBAR)
<               KW = 13
<               TEV(I) = 1000.0
<               M0 = 25.0
<               EPOCH(I) = -15.0/TSTAR
<               IF (I.EQ.1) WRITE (6,5)  M1, KW, RADIUS(I)*SU
<     5         FORMAT (/,12X,'FIRST STAR:    M K* R/SU ',F7.2,I4,1P,E9.1)
<           END IF
---
> *       Set initial look-up time 0.05 of main sequence time (but < 10**7 yrs).
>           TEV(I) = MIN(0.05*TM,10.0D0)/TSTAR
> *
95c76
<    20 DT = 1.0E-03/TSCALE
---
>       DT = 1.0E-03/TSCALE
1,2c1,2
< 13145 2006-09-09 19:13 /work/Umi2/spurzem/5/nbody6compare/intgrt.f
< nbody6compare/intgrt.f
---
> 18656 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/intgrt.f
> nbody6++compare/intgrt.f
0a1,4
> # 1 "intgrt.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "intgrt.F"
4,5c8,9
< *       N-body integrator flow control.
< *       -------------------------------
---
> * N-body integrator flow control.
> * -------------------------------
8,14c12,19
<       COMMON/CLUMP/   BODYS(NCMAX,5),T0S(5),TS(5),STEPS(5),RMAXS(5),
<      &                NAMES(NCMAX,5),ISYS(5)
<       REAL*8  XI(3),XIDOT(3)
<       INTEGER  NXTLST(NMAX),IBL(LMAX),NBLIST(NMAX),LISTQ(NMAX),NL(20)
<       LOGICAL LOOP,LSTEPM
<       SAVE IQ,ICALL,NQ,LQ,LOOP,LSTEPM,STEPM,ISAVE,JSAVE
<       DATA IQ,ICALL,LQ,LOOP,LSTEPM,STEPM /0,2,11,.TRUE.,.FALSE.,0.03125/
---
>       COMMON/CLUMP/ BODYS(NCMAX,5),T0S(5),TS(5),STEPS(5),RMAXS(5),
>      & NAMES(NCMAX,5),ISYS(5)
>       INTEGER JHIST,JHISTR
>       LOGICAL LSHRNK,LSTEPM
>       EXTERNAL SHORT
>       COMMON/BLKLVL/JHIST(0:NMAX),JHISTR(0:NMAX)
>       INTEGER NXTLST(NMAX),IREG(NMAX),NBLIST(NMAX),IBL(LMAX)
>       COMMON/STSTAT/ TINIT,NIR,NIB,NRGL,NKS
15a21,25
> 
> 
> 
> 
>       INTEGER IMPI(LMAX,NMAX),JMPI(11,maxpe)
17,18c27,28
< *       Enforce level search on return, except new and terminated KS.
<       IF (IPHASE.NE.1.AND.IPHASE.NE.2) LOOP = .TRUE.
---
>       SAVE IQ,ICALL,LSTEPM,STEPM
>       DATA IQ,ICALL,LSTEPM,STEPM /0,2,.FALSE.,0.03125/
20c30
< *       Update quantized value of STEPM for large N (first time only).
---
> * Update quantized value of STEPM for large N (first time only).
27c37
< *       Search for high velocities after escape or KS/chain termination.
---
> * Search for high velocities after escape or KS/chain termination.
32c42
< *       Reset control & regularization indicators.
---
> * Reset control & regularization indicators.
34a45
> * Initialize end-point of integration times and set TMIN.
36,37c47
<       DTM = 1.0
< *       Initialize end-point of integration times and set TMIN and DTM.
---
> * Initialize end-point of integration times and set TMIN and DTM.
39,48c49,52
<           TIMENW(I) = T0(I) + STEP(I)
<           TMIN = MIN(TIMENW(I),TMIN)
<           DTM = MIN(DTM,STEP(I))
<  1000 CONTINUE
< *
< *       Determine level for the smallest step (ignore extreme values).
<       LQS = 20
<       DO 1001 L = 6,20
<           IF (DTM.EQ.DTK(L)) THEN
<               LQS = L
---
>          TIMENW(I) = T0(I) + STEP(I)
>           IF(TIMENW(I).LT.TMIN)THEN
>              TMIN = TIMENW(I)
>              IMIN = I
50c54
<  1001 CONTINUE
---
>  1000 CONTINUE
52,53d55
< *       Specify upper level for optimized membership.
<       LQB = LQS - 4
56,57d57
< *       Enforce new block step search on significant changes.
<       TLISTQ = TIME
59,101c59,60
< *       Check updating new list of block steps with T0 + STEP =< TLISTQ.
<     1 ICALL = ICALL + 1
< *       Reset TMIN second & third time after change to catch new chain step.
<       IF (TIME.GE.TLISTQ.OR.ICALL.LE.3) THEN
< *       Update interval by optimization at major times (sqrt of N-NPAIRS).
<           IF (DMOD(TLISTQ,2.0D0).EQ.0.0D0.OR.LOOP) THEN
<               LOOP = .FALSE.
<               DO 10 L = 1,20
<                   NL(L) = 0
<    10         CONTINUE
<               DO 14 I = IFIRST,NTOT
< *       Count steps at five different levels for the smallest values.
<                   DO 12 L = LQB,LQS
<                       IF (STEP(I).LT.DTK(L)) NL(L) = NL(L) + 1
<    12             CONTINUE
<    14         CONTINUE
<               NLSUM = 0
< *       Determine interval by summing smallest steps until near sqrt(N-N_b).
<               NSQ = SQRT(FLOAT(N - NPAIRS))
<               LQ = LQS
<               DO 15 L = LQS,LQB,-1
<                   NLSUM = NLSUM + NL(L)
<                   IF (NLSUM.LE.NSQ) LQ = L
<    15         CONTINUE
< *             WRITE (6,16)  TIME+TOFF,NQ,NLSUM,LQ,(NL(K),K=LQB,LQS)
< *  16         FORMAT (' LEVEL CHECK:    T NQ NLSUM LQ NL  ',
< *    &                                  F9.3,3I5,2X,7I4)
<           END IF
< *
< *       Increase interval by optimized value.
<           NQ = 0
<           TMIN = 1.0D+10
<    18     TLISTQ = TLISTQ + DTK(LQ)
<           DO 20 I = IFIRST,NTOT
<               IF (TIMENW(I).LE.TLISTQ) THEN
<                   NQ = NQ + 1
<                   LISTQ(NQ) = I
<                   TMIN = MIN(TIMENW(I),TMIN)
<               END IF
<    20     CONTINUE
< *       Increase interval in rare case of zero membership.
<           IF (NQ.EQ.0) GO TO 18
<       END IF
---
> * Find all particles due at next block time.
>     1 CONTINUE
103,104c62
< *       Find all particles in next block (TIMENW = TMIN).
<       CALL INEXT(NQ,LISTQ,TMIN,NXTLEN,NXTLST)
---
>       NXTLEN = 0
106,111c64,85
< *       Set new time and save block time (for regularization terminations).
<       I = NXTLST(1)
<       TIME = T0(I) + STEP(I)
<       TBLOCK = TIME
<       LI = 0
<       IPRED = 0
---
> * Reset TSMALL second time after main change to catch new small steps.
>       ICALL = ICALL + 1
>       IF (ICALL.EQ.2) GO TO 999
> *
> * determine next block particles without assuming
> * sorted time step list (R.Sp.)
> *
>       DO 5 J = IFIRST, NTOT
>          IF(DABS(TIMENW(J)-TMIN).LT.DTK(40)) THEN
>             NXTLEN = NXTLEN + 1
>             NXTLST(NXTLEN) = J
>          END IF
>   5 CONTINUE
> *
> * if(ixxxx.gt.0)then
> * if(time.gt.2.0D0)
> * *print*,' nxtlen,block=',nxtlen,(name(nxtlst(k)),k=1,nxtlen)
> * if(ixxxx.gt.3)ixxxx=0
> * end if
> *
> * Update short timestep list for regularization search.
>       CALL SHORT(NXTLEN,NXTLST)
113,114c87,89
< *       Re-determine list if current time exceeds boundary.
<       IF (TIME.GT.TLISTQ) GO TO 1
---
> * Set new time and save block time (for regularization terminations).
>       TIME = TMIN
>       TBLOCK = TIME
116c91
< *       Check option for advancing interstellar clouds.
---
> * Check option for advancing interstellar clouds.
121,138c96,103
< *       Check optional integration of cluster guiding centre.
<       IF (KZ(14).EQ.3.OR.KZ(14).EQ.4) THEN
<           IF (KZ(14).EQ.3.AND.DMOD(TIME,STEPX).EQ.0.0D0) THEN
<               CALL GCINT
<           END IF
< *       Include mass loss by gas expulsion (Kroupa et al. MN 321, 699).
<           IF (MPDOT.GT.0.0D0.AND.TIME + TOFF.GT.TDELAY) THEN
<               MP = MP0/(1.0 + MPDOT*(TIME + TOFF - TDELAY))
<           END IF
<       END IF
< *
< *       Include commensurability test (may be suppressed if no problems).
< *     IF (DMOD(TIME,STEP(I)).NE.0.0D0) THEN
< *         WRITE (6,25)  I, NAME(I), NSTEPI, TIME, STEP(I), TIME/STEP(I)
< *  25     FORMAT (' DANGER!   I NM # TIME STEP T/DT ',
< *    &                        2I6,I11,F12.5,1P,E9.1,0P,F16.4)
< *         STOP
< *     END IF
---
> * Include commensurability test (may be suppressed if no problems).
> * IF (STEP(IMIN).LT.1.0E-15.OR.DMOD(TIME,STEP(IMIN)).NE.0.0D0) THEN
> * WRITE (6,1005) IMIN, NAME(IMIN), NSTEPI, TIME, STEP(IMIN),
> * & TIME/STEP(IMIN)
> *1005 FORMAT (' DANGER!   I NM # TIME STEP T/DT ',
> * & 2I5,I11,F12.5,1P,E9.1,0P,F16.4)
> * CALL ABORT
> * END IF
140c105
< *       Check for new regularization at end of block.
---
> * Check for new regularization at end of block.
144,146d108
< *       Copy the saved component indices.
<           ICOMP = ISAVE
<           JCOMP = JSAVE
150c112
< *       Check next adjust time before beginning a new block.
---
> * Check next adjust time before beginning a new block.
157c119
< *       Check output time in case DTADJ & DELTAT not commensurate.
---
> * Also check output time in case DTADJ & DELTAT not commensurate.
164c126
< *       See whether to advance any close encounters at first new time.
---
> * See whether to advance any close encounters at first new time.
165a128
>             call cputim(tt5)
166a130,132
>             call cputim(tt6)
>             ttks = ttks + (tt6-tt5)*60.
> *
170c136,183
< *       Check regular force condition for small block memberships.
---
> * Check regularization criterion for single particles.
>       IKS = 0
>       ISMIN = 0
>       DSMIN = DTMIN
> * Search only in prepared list of short-step particles. (R.Sp.)
>       ISHORT = LSHORT(1)
>       DO 50 L = 2,ISHORT+1
>           I = LSHORT(L)
> * Search for minimum timestep candidate for not ordered steps (R.Sp.)
> * Beware that members of LSHORT may be members of KS pair (R.Sp.)
>           IF (STEP(I).LT.DTMIN.AND.STEP(I).LT.DSMIN.AND.I.LE.N.AND.
>      & I.GE.IFIRST) THEN
>               DSMIN = STEP(I)
>               ISMIN = I
>           END IF
>    50 CONTINUE
> *
> * See whether dominant body can be regularized.
>       IF(ISMIN.GT.0) THEN
>           CALL SEARCH(ISMIN,IKS)
> *
> * Include close encounter search for low-eccentric massive binaries.
>       IF (IKS.EQ.0.AND.STEP(ISMIN).LT.4.0*DTMIN) THEN
> * Consider massive single bodies in absence of subsystems.
>           IF (ISMIN.LE.N.AND.BODY(I).GT.2.0*BODYM.AND.NSUB.EQ.0) THEN
> *
> * Obtain two-body elements and relative perturbation.
>               JMIN = 0
>               CALL ORBIT(ISMIN,JMIN,SEMI,ECC,GI)
> *
>               EB = -0.5*BODY(ISMIN)*BODY(JMIN)/SEMI
>               IF (EB.LT.EBH.AND.GI.LT.0.25.AND.JMIN.GE.IFIRST) THEN
>                   APO = SEMI*(1.0 + ECC)
> * Check eccentricity (cf. max perturbation) and neighbour radius.
>                   IF (ECC.LT.0.5.AND.APO.LT.0.02*RS(ISMIN)) THEN
> * PRINT*, ' KS TRY: NAM E A EB ',
> * * NAME(ISMIN), NAME(JMIN), ECC, SEMI, EB
> * CALL FLUSH(6)
>                       IKS = IKS + 1
>                       ICOMP = ISMIN
>                       JCOMP = JMIN
>                   END IF
>               END IF
>           END IF
>       END IF
>       END IF
> *
> * Check regular force condition for small block memberships.
178c191
<    28     CONTINUE
---
>    28 CONTINUE
181,182c194,197
< *       Decide between merging of neighbour lists or full N prediction.
<       IF (NXTLEN.LE.10.AND.IR.EQ.0) THEN
---
> * Choose between predicting all neighbours or full N.
> * Warning do not distribute prediction on PEs for consistency
>           call cputim(tt1)
>       IF (NXTLEN.LT.10.AND.IR.EQ.0) THEN
184c199
< *       Initialize pointers for neighbour lists.
---
> * Initialize pointers for neighbour lists.
187c202
<    30     CONTINUE
---
>    30 CONTINUE
189c204
< *       Merge all neighbour lists (with absent members of IBL added).
---
> * Merge all neighbour lists (with absent members of NXTLST added).
192c207
< *       Predict coordinates & velocities of neighbours and #I to order FDOT.
---
> * Predict coordinates & velocities of neighbours and #I to order FDOT.
193a209,210
>           NBFLAG = 1
>           IPRED = 0
205c222
<    35     CONTINUE
---
>    35 CONTINUE
207d223
<           IPRED = 1
208a225,226
>           NBFLAG = 1
>           IPRED = 1
219c237
<    40     CONTINUE
---
>  40 CONTINUE
222c240,242
< *       Resolve perturbed KS pairs with c.m. prediction after NBSORT.
---
> * Resolve any KS coordinates & velocities using most recent c.m.
>       IF (NPAIRS.GT.0) THEN
> * Resolve perturbed KS pairs with c.m. prediction after NBSORT.
227c247
< *       Ignore c.m. prediction after full N loop (all active KS needed).
---
> * Ignore c.m. prediction after full N loop (all active KS needed).
240,243c260,263
<           ZZ = 1.0
< *       Distinguish between low and high-order prediction of U & UDOT.
<           IF (GAMMA(JPAIR).GT.1.0D-04) ZZ = 0.0
<           CALL KSRES2(JPAIR,J1,J2,ZZ)
---
>           IZZ = -1
> * Predict ALL binaries even unperturbed ones for parallel code (R.Sp.)
>           ZZ = 0.0
>           CALL KSRES2(JPAIR,J1,J2,ZZ,IZZ)
247c267,293
< *       Save new time (output time at TIME > TADJ) and increase # blocks.
---
>       END IF
> * Resolve Chain if it is in block or in neighbour lists (RS Nov. 03).
>       IF(NCH.GT.0) THEN
>       ICHPR = 0
> * First check whether chain c.m. is in current block (ICHPR = 2).
>           DO 46 L = 1,NXTLEN
>               I = NXTLST(L)
>               IF(I.EQ.ICH) ICHPR = 2
>  46 CONTINUE
> * Second check whether neighbour lists contain chain c.m. (ICHPR = 1).
>           IF (ICHPR.EQ.0) THEN
>               DO 47 L = 1,NXTLEN
>                   I = NXTLST(L)
>                   NNB1 = LIST(1,I) + 1
> * Second check whether neighbour lists contain chain c.m. (ICHPR = 1).
>                   DO 48 K = 2,NNB1
>                       J = LIST(K,I)
>                       IF (J.GT.ICH) GO TO 47
>                       IF (J.EQ.ICH) ICHPR = 1
>  48 CONTINUE
>  47 CONTINUE
>           END IF
>           IF (ICHPR.GT.1) CALL CHLIST(ICH)
>           IF (ICHPR.GT.0) CALL XCPRED(0)
>       END IF
> *
> * Save new time (output time at TIME> TADJ) and increase # of blocks.
252,262c298,375
< *       Advance the pointer (<= NXTLEN) and select next particle index.
<    50 LI = LI + 1
<       IF (LI.GT.NXTLEN) GO TO 1
<       I = NXTLST(LI)
<       TIME = T0(I) + STEP(I)
< *
< *       See whether the regular force needs to be updated (IR > 0).
<       IF (T0R(I) + STEPR(I).LE.TIME) THEN
<           IR = 1
<       ELSE
<           IR = 0
---
>                   call cputim(tt2)
>           ttnbp = ttnbp + (tt2-tt1)*60.
> *
> * Initialize counters for irregular & regular integrations.
>       NREG = 0
> *
> * Advance the irregular step for all particles in the current block.
> * Block-Step Level Diagnostics (R.Sp. 29.Apr. 1993)
>           IF(KZ(33).GT.0)JHIST(NXTLEN) = JHIST(NXTLEN) + 1
> *
> 
> 
> 
> *
>       DO 701 L = 1,NXTLEN
> *
>           I = NXTLST(L)
> *
>       CALL NBINT(I,NBFLAG)
> *
>  701 CONTINUE
> *
>           call cputim(tt3)
>           ttirr = ttirr + (tt3-tt2)*60.
> *
> # 443 "intgrt.F"
> *
>        DO 71 L = 1,NXTLEN
>           I = NXTLST(L)
> * Save new block step and update T0 & next time
>           T0(I) = TIME
>           TIMENW(I) = T0(I) + STEP(I)
> *
> * Set non-zero indicator for new regular force.
>           IF (T0R(I) + STEPR(I).LE.TIME) THEN
>               NREG = NREG + 1
>               IREG(NREG) = I
>           ELSE
> * Extrapolate regular force & first derivatives to obtain F & FDOT.
>               DTR = TIME - T0R(I)
>               DO 65 K = 1,3
>                   F(K,I) = 0.5*(FRDOT(K,I)*DTR + FR(K,I) + FI(K,I))
>                   FDOT(K,I) = ONE6*(FRDOT(K,I) + FIDOT(K,I))
> * Higher order extrapolation?
> * F(K,I) = FI(K,I) + FR(K,I) + DTR*(FRDOT(K,I)
> * * + DTR*(D2R(K,I)/2.D0 + DTR*D3R(K,I)/6.D0))
> * FDOT(K,I) = FIDOT(K,I) + FRDOT(K,I)
> * * + DTR*(D2R(K,I) + DTR*D3R(K,I)/2.D0)
> * F(K,I) = F(K,I)/2.D0
> * FDOT(K,I) = FDOT(K,I)/6.D0
>    65 CONTINUE
>           END IF
> *
>               DO 67 K = 1,3
>                   X0(K,I) = XN(K,I)
>                   X0DOT(K,I) = XNDOT(K,I)
>                   D0(K,I) = FI(K,I)
>                   D1(K,I) = FIDOT(K,I)
>    67 CONTINUE
> *
>  71 CONTINUE
> *
> * CALL nemo_savestate(n,3,time,body,x,xdot)
> *
> * See whether any KS candidates are in the same block.
>       IF (IKS.GT.0) THEN
> * Accept same time, otherwise reduce STEP(ICOMP) and/or delay.
>           IF (T0(JCOMP).EQ.T0(ICOMP)) THEN
>               I = ICOMP
>               ICOMP = MIN(ICOMP,JCOMP)
>               JCOMP = MAX(I,JCOMP)
>           ELSE IF (T0(JCOMP) + STEP(JCOMP).LT.T0(ICOMP)) THEN
>               STEP(ICOMP) = 0.5D0*STEP(ICOMP)
>               TIMENW(ICOMP) = T0(ICOMP) + STEP(ICOMP)
>               IKS = 0
>           ELSE
>               IKS = 0
>           END IF
265,267c378,382
< *       Advance the irregular step.
<       IKS0 = IKS
<       CALL NBINT(I,IKS,IR,XI,XIDOT)
---
>       NSTEPI = NSTEPI + NXTLEN
> *
> * Obtain total force for all particles due in the current block.
> *
>       IF(NREG.GT.0)THEN
269,272c384,408
< *       Save indices of first KS candidates in the block.
<       IF (IKS0.EQ.0.AND.IKS.GT.0) THEN
<           ISAVE = ICOMP
<           JSAVE = JCOMP
---
>            call cputim(tt7)
>               DO 811 J=IFIRST,NTOT
>               S = TIME - T0(J)
>               S1 = 1.5*S
>               S2 = 2.0*S
>               X(1,J) = ((FDOT(1,J)*S + F(1,J))*S +X0DOT(1,J))*S +X0(1,J)
>               X(2,J) = ((FDOT(2,J)*S + F(2,J))*S +X0DOT(2,J))*S +X0(2,J)
>               X(3,J) = ((FDOT(3,J)*S + F(3,J))*S +X0DOT(3,J))*S +X0(3,J)
>               XDOT(1,J) = (FDOT(1,J)*S1 + F(1,J))*S2 + X0DOT(1,J)
>               XDOT(2,J) = (FDOT(2,J)*S1 + F(2,J))*S2 + X0DOT(2,J)
>               XDOT(3,J) = (FDOT(3,J)*S1 + F(3,J))*S2 + X0DOT(3,J)
>  811 CONTINUE
> * Resolve any KS coordinates & velocities using most recent c.m.
>       IF (NPAIRS.GT.0) THEN
>           JJ = -1
>           DO 86 JPAIR = 1,NPAIRS
>           JJ = JJ + 2
>           IF (LIST(1,JJ).GT.0) THEN
>               ZZ = 1.0
>               IZZ = -2
> * Distinguish between low and high-order prediction of U & UDOT.
>               IF (GAMMA(JPAIR).GT.1.0D-04) ZZ = 0.0
>               CALL KSRES2(JPAIR,J1,J2,ZZ,IZZ)
>           END IF
>    86 CONTINUE
275,277c411,464
< *       See whether the regular step is due.
<       IF (IR.GT.0) THEN
<           CALL REGINT(I,XI,XIDOT)
---
>           call cputim(tt8)
>           ttpre = ttpre + (tt8-tt7)*60.
> *
> * Block-Step Level Diagnostics (R.Sp. 29.Apr. 1993)
>           IF(KZ(33).GT.1)JHISTR(NREG) = JHISTR(NREG) + 1
> *
>           call cputim(tt1)
> *
> 
> 
> 
> *
>       DO 801 L = 1,NREG
>           I = IREG(L)
> *
>           DO 655 K = 1,LMAX
>  655 IMPI(K,L) = LIST(K,I)
> *
>           NBSUM = 0
> *
>        CALL REGINT(I,IMPI(1,L))
> *
>          DO 615 K = 1,3
>               F(K,I) = 0.5D0*(FI(K,I) + FR(K,I))
>               FDOT(K,I) = ONE6*(FIDOT(K,I) + FRDOT(K,I))
>   615 CONTINUE
>   801 CONTINUE
> *
>       call cputim(tt2)
>       ttreg = ttreg + (tt2-tt1)*60.
> # 768 "intgrt.F"
> *
>       NSTEPR = NSTEPR + NREG
>       NBLCKR = NBLCKR + 1
>       LSHRNK = .FALSE.
> *
>       DO 81 L = 1,NREG
>           I = IREG(L)
> *
>               DO 816 K = 1,LMAX
>  816 LIST(K,I) = IMPI(K,L)
> *
> * Check minimum neighbor sphere since last output
>               IF(LIST(1,I).GT.0)RSMIN = MIN(RSMIN,RS(I))
> *
>  81 CONTINUE
> *
> * OPEN(98,STATUS='OLD',ERR=123)
> * print*,' last reg block t=',time,' length=',nreg
> * print*,' first 10 =',(name(ireg(l)),l=1,min(nreg,10))
> * call flush(6)
> * CLOSE(98)
> *123 CONTINUE
> *
280,306c467,473
< *       Determine next block time (note STEP may shrink in REGINT).
<       TMIN = MIN(TIMENW(I),TMIN)
< * 
< *       Copy current coordinates & velocities from corrected values.
<       IF (LI.EQ.NXTLEN) THEN
<           DO 60 L = 1,NXTLEN
<               I = NXTLST(L)
<               DO 55 K = 1,3
<                   X(K,I) = X0(K,I)
<                   XDOT(K,I) = X0DOT(K,I)
<    55         CONTINUE
<    60     CONTINUE
< *
< *       Check integration of tidal tail members.
<           IF (NTAIL.GT.0) THEN
< *       Allow large quantized interval with internal iteration.
<               IF (DMOD(TIME,0.25D0).EQ.0.0D0) THEN
<                   DO 65 J = ITAIL0,NTTOT
<                       IF (TIMENW(J).LE.TIME) THEN
<                           CALL NTINT(J)
<                       END IF
<    65             CONTINUE
<               END IF
<           END IF
<       ELSE
< *       Continue until last member has been done (improves reproducibility).
<           GO TO 50
---
> * Copy all corrected coordinates & velocities (NB! only at the end).
>       DO 85 L = 1,NXTLEN
>           I = NXTLST(L)
> *
>       IF (I.GT.N) THEN
>           IPAIR = I - N
>           IF (LIST(1,2*IPAIR-1).GT.0) NSTEPB = NSTEPB + 1
309,310c476,490
< *       Exit on KS termination, new multiple regularization or merger.
<       IF (IQ.NE.0) THEN
---
>           IF(TIMENW(I).LT.TMIN)THEN
>               TMIN = TIMENW(I)
>               IMIN = I
>           END IF
> *
>           DO 82 K = 1,3
>               X0(K,I) = XN(K,I)
>               X0DOT(K,I) = XNDOT(K,I)
>               X(K,I) = XN(K,I)
>               XDOT(K,I) = XNDOT(K,I)
>    82 CONTINUE
>    85 CONTINUE
> *
> * Exit on KS termination, new multiple regularization or merger.
>       IF (IQ.GT.0) THEN
315c495
< *       Ensure correct KS index (KSPAIR may denote second termination).
---
> * Ensure correct KS index (KSPAIR may denote second termination).
322c502
< *       Perform optional check on high-velocity particles at major times.
---
> * Perform optional check on high-velocity particles at major times.
325c505
<               CALL SHRINK(TMIN)
---
>               CALL SHRINK
332c512
< *       Check optional mass loss time at end of block-step.
---
> * Check optional mass loss time.
334c514
< *       Delay until time commensurate with 100-year step (new polynomials).
---
> * Delay until time commensurate with 1000-year step (new polynomials).
345,348c525,527
< *       Advance counters and check timer & optional COMMON save (NSUB = 0).
<       NTIMER = NTIMER + 1
<       IF (NTIMER.LT.NMAX) GO TO 50
< 
---
> * Advance counters and check timer & optional COMMON save (NSUB = 0).
>       NTIMER = NTIMER + NXTLEN
>       IF (NTIMER.LT.NMAX) GO TO 1
357,358c536,537
< *       Check option for general binary search.
<       IF (KZ(4).GT.0.AND.TIME - TLASTS.GT.DELTAS) THEN  
---
> * Check option for general binary search.
>       IF (KZ(4).NE.0.AND.TIME - TLASTS.GT.DELTAS) THEN
362c541,542
< *       Include facility for termination of run (create dummy file STOP).
---
> * Include facility for termination of run (create dummy file STOP).
>       IF(rank.EQ.0)THEN
366,367c546,547
<           IF (NSUB.EQ.0)  WRITE (6,70)
<    70     FORMAT  (/,9X,'TERMINATION BY MANUAL INTERVENTION')
---
>           IF (NSUM.EQ.0.and.rank.eq.0) WRITE (6,90)
>    90 FORMAT (/,9X,'TERMINATION BY MANUAL INTERVENTION')
369a550
>       END IF
371c552
< *       Repeat cycle until elapsed computing time exceeds the limit.
---
> * Repeat cycle until elapsed computing time exceeds the limit.
373c554,556
<       IF (TCOMP.LT.CPU) GO TO 50
---
>           TCOMP = (TCOMP-TTOTA)*60.
> *
>       IF (TCOMP.LT.CPU) GO TO 1
375c558
< *       Do not terminate during triple, quad or chain regularization.
---
> * Do not terminate during triple, quad or chain regularization.
377,378c560,561
< *       Specify zero step to enforce termination.
<           DO 75 L = 1,NSUB
---
> * Specify zero step to enforce termination.
>           DO 95 L = 1,NSUB
380c563
<    75     CONTINUE
---
>    95 CONTINUE
382c565
<           GO TO 50
---
>           GO TO 1
385,386c568,569
< *       Terminate run with optional COMMON save.
<       IF (KZ(1).GT.0) THEN
---
> * Terminate run with optional COMMON save.
>       IF (KZ(1).NE.0) THEN
389,392c572,577
<           WRITE (6,80)  TIME+TOFF, TCOMP, CPUTOT/60.0, ERRTOT, DETOT
<    80     FORMAT (/,9X,'COMMON SAVED AT TIME =',F8.2,'  TCOMP =',F7.1,
<      &                 '  CPUTOT =',F6.1,'  ERRTOT =',F10.6,
<      &                 '  DETOT =',F10.6)
---
>           if(rank.eq.0)
>      & WRITE (6,98) TOFF, TIME, TIME+TOFF, TCOMP, CPUTOT/60.0,
>      & ERRTOT, DETOT
>    98 FORMAT (
>      & '  TCOMP =',F7.1,'  CPUTOT =',F6.1,
>      & '  ERRTOT =',F10.6,'  DETOT =',F10.6)
395c580,603
<       STOP
---
> * Determine time interval and step numbers per time unit
>       TIMINT = TIME + TOFF - TINIT
> *
> 
> 
> 
>       WRITE (6,195) rank,TIMINT,NSTEPI-NIR,NSTEPB-NIB,NSTEPR-NRGL,
>      & NSTEPU-NKS
>   195 FORMAT (
>      & ' NIRRB=',I11,' NREG=',I11,' NKS=',I11)
>       WRITE (6,196) (NSTEPI-NIR)/TIMINT,(NSTEPB-NIB)/TIMINT,
>      & (NSTEPR-NRGL)/TIMINT,(NSTEPU-NKS)/TIMINT
>   196 FORMAT (
>      & D12.5,' NREG=',D12.5,' NKS=',D12.5)
> 
> 
> 
> 
> 
> 
> 
>           STOP
> *
>  100 CONTINUE
397,398c605,633
< *       Set current global time.
<   100 TTOT = TIME + TOFF
---
> * Set current global time.
>           TTOT = TIME + TOFF
> * Full prediction at end of intgrt to preserve consistency after
> * parallel execution
>           DO 400 J = IFIRST,NTOT
>               S = TIME - T0(J)
>               S1 = 1.5*S
>               S2 = 2.0*S
>               X(1,J) = ((FDOT(1,J)*S + F(1,J))*S +X0DOT(1,J))*S +X0(1,J)
>               X(2,J) = ((FDOT(2,J)*S + F(2,J))*S +X0DOT(2,J))*S +X0(2,J)
>               X(3,J) = ((FDOT(3,J)*S + F(3,J))*S +X0DOT(3,J))*S +X0(3,J)
>               XDOT(1,J) = (FDOT(1,J)*S1 + F(1,J))*S2 + X0DOT(1,J)
>               XDOT(2,J) = (FDOT(2,J)*S1 + F(2,J))*S2 + X0DOT(2,J)
>               XDOT(3,J) = (FDOT(3,J)*S1 + F(3,J))*S2 + X0DOT(3,J)
>  400 CONTINUE
> * Resolve any KS coordinates & velocities using most recent c.m.
>       IF (NPAIRS.GT.0) THEN
>           JJ = -1
>           DO 88 JPAIR = 1,NPAIRS
>           JJ = JJ + 2
>           IF (LIST(1,JJ).GT.0) THEN
>               ZZ = 1.0
>               IZZ = -3
> * Distinguish between low and high-order prediction of U & UDOT.
>               IF (GAMMA(JPAIR).GT.1.0D-04) ZZ = 0.0
>               CALL KSRES2(JPAIR,J1,J2,ZZ,IZZ)
>           END IF
>    88 CONTINUE
>       END IF
400c635
<       RETURN
---
>        RETURN
1,2c1,2
< 1048 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/intide.f
< nbody6compare/intide.f
---
> 1062 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/intide.f
> nbody6++compare/intide.f
0a1,4
> # 1 "intide.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "intide.F"
4,5c8,9
< *       Input & scaling for tidal dissipation.
< *       --------------------------------------
---
> * Input & scaling for tidal dissipation.
> * --------------------------------------
8a13
> # 18 "intide.F"
10,11c15,24
< *       Read parameters for tidal capture simulation.
<       READ (5,*)  RSTAR, IMS, IEV, RMS, REV
---
> * Read parameters for tidal capture simulation.
> 
>       if(rank.eq.0)READ (5,*) RSTAR, IMS, IEV, RMS, REV
> 
> 
> 
> 
> 
> 
> 
13c26
< *       Convert radii from S.U. to internal units.
---
> * Convert radii from S.U. to internal units.
16c29
<       WRITE (6,10)  RSTAR, IMS, IEV, RMS, REV
---
>       WRITE (6,10) RSTAR, IMS, IEV, RMS, REV
18c31
<      &              '  IEV =',I4,'  RMS/R* =',F6.2,'  REV/R* =',F6.1)
---
>      & '  IEV =',I4,'  RMS/R* =',F6.2,'  REV/R* =',F6.1)
20c33
< *       Assign individual radii for main-sequence and evolved stars.
---
> * Assign individual radii for main-sequence and evolved stars.
22c35
< *       Adopt a primitive scheme in case of no stellar evolution.
---
> * Adopt a primitive scheme in case of no stellar evolution.
30,32c43,45
< *     WRITE (6,40)  BODY(1), BODY(N), RADIUS(1), RADIUS(N)
< *  40 FORMAT (/,12X,'SCALED RADII:    M(1) =',F8.4,'  M(N) =',F8.4,
< *    &                                '  R(1) =',1PE8.1,'  R(N) =',E8.1)
---
> * WRITE (6,40) BODY(1), BODY(N), RADIUS(1), RADIUS(N)
> * 40 FORMAT (/,12X,'SCALED RADII:    M(1) =',F8.4,'  M(N) =',F8.4,
> * & '  R(1) =',1PE8.1,'  R(N) =',E8.1)
1,2c1,2
< 8000 2005-10-26 18:43 /work/Umi2/spurzem/5/nbody6compare/invert.f
< nbody6compare/invert.f
---
> 8087 2003-06-25 19:51 /work/Umi2/spurzem/5/nbody6++compare/invert.f
> nbody6++compare/invert.f
32c32
< *       Obtain physical velocities (first absolute, then relative).
---
> *       Obtain physical two-body velocities.
48,59c48,54
< *       Determine the smallest two-body distance and chain index.
<       rm = 0.0
<       do i = 1,n-1
<           if (rinv(i).gt.rm) then
<               rm = rinv(i)
<               i1 = i
<           end if
<       end do
<       rm = 1.0/rm
< *
< *       Form semi-major axes for the two closest distances.
<       dm = 0.0
---
> *       Determine the two smallest two-body distances and chain indices.
>       R2M = 1.0
>       D2M = 1.0
>       DM = 1.0
>       i2 = 0
>       g2 = 1.0
>       V22 = 1.0
62c57,59
<           if (i.eq.i1) then
---
>           r2 = xc(L+1)**2 + xc(L+2)**2 + xc(L+3)**2
> *       Check the smallest distance and save basic parameters.
>           if (r2.lt.r2m) then
65c62,63
<               amax = 2.0*rinv(i) - w2/mb
---
>               r1 = sqrt(r2)
>               amax = 2.0/r1 - w2/mb
66a65,67
>               i1 = i
>               rm = r1
>               r2m = r2
78,79c79,80
< *       Treat the second smallest distance similarly.
<           else if (rinv(i).gt.dm) then
---
> *       Check the second distance (ignore two consecutive small distances).
>           else if (r2.lt.d2m) THEN
82c83,84
<               amax = 2.0*rinv(i) - w2/mb
---
>               r1b = sqrt(r2)
>               amax = 2.0/r1b - w2/mb
85c87,89
<               dm = rinv(i)
---
>               dm = r1b
>               d2m = r2
>               V22 = w2
97d100
<       dm = 1.0/dm
99,102c102,103
< *       Obtain reliable semi-major axis for small pericentre or large EB.
<       EB = -0.5*mc(i1)*mc(i1+1)/a1
<       EB1 = EB/ENERGY
<       IF (rm.lt.0.2*a1.or.EB1.gt.0.9) then
---
> *       Obtain reliable semi-major axis near small pericentres.
>       IF (rm.lt.0.2*a1.AND.NSTEP1.GT.0) THEN
124,125c125,126
<               WRITE (6,4)  NSTEP1, ZK, g1, RM, SEMI, ERR
<     4         FORMAT (' WARNING!    INVERT    # K g1 RM SEMI DA/A ',
---
>               if(rank.eq.0)WRITE (6,4)  NSTEP1, ZK, g1, RM, a1, ERR
>     4         FORMAT (' WARNING!    INVERT    # K g1 RM a1 DA/A ',
128c129,130
< *       Replace direct value by improved determination.
---
> *       Replace direct values by improved determination.
>           RM = 1.0/RINV(i1)
133c135
<       IF (a1.GT.0.0) THEN
---
>       IF (a1.GT.0.0.AND.RM.LT.DM) THEN
135,136c137,142
< *       Adopt upper limit of TKS/2 but allow genuine small DT.
<           DT = MIN(0.5*TKS,DT)
---
> *       Adopt upper limit of TKS/5 but allow genuine small DT.
>           IF (DT.GT.TKS) THEN
>               DT = 0.2*TKS
>           ELSE
>               DT = MIN(0.2*TKS,DT)
>           END IF
138,139c144,149
< *       Use crossing time for hyperbolic velocity (TPR compensates small R).
<           DT = MIN(rm/SQRT(V21),DT)
---
> *       Choose upper limit 1/20 of crossing time with hyperbolic velocity.
>           IF (a1.LT.0.0) THEN
>               DT = MIN(0.05*RSUM/SQRT(V21),DT)
>           ELSE
>               DT = MIN(0.05*RSUM/SQRT(V22),DT)
>           END IF
142,147d151
< *       Check second closest pair if bound (small period; a1 < 0 possible).
<       if (a2.gt.0.0) then
<           TKS = 6.28*KSCH(i2)*a2*SQRT(a2/(mc(i2) + mc(i2+1)))
<           DT = MIN(0.5*TKS,DT)
<       end if
< *
196d199
< *       Define the function Y0 and its derivatives (cf. Book eqns. 12.9).
200d202
< *       Adopt safety measure to avoid negative argument (Seppo Mikkola).
201a204
> *       Adopt safety measure to avoid negative argument (Seppo Mikkola).
210c213
<       IF (IT.GT.15.AND.IWARN.LT.500) THEN
---
>       IF (IT.GT.15.AND.IWARN.LT.50) THEN
213c216,217
<           WRITE (6,15)  IT, KSCH(i1), ECC, RM, a1, DT-DT1, DTAU
---
>           if(rank.eq.0)
>      &    WRITE (6,15)  IT, KSCH(i1), ECC, RM, a1, DT-DT1, DTAU
219c223
<       IF (i2.ne.i1.and.g2.lt.0.01) THEN
---
>       IF (i2.GT.0.AND.i2.NE.i1.AND.g2.LT.0.01) THEN
222c226
<           rm = dm
---
>           RM = DM
232,234c236,239
<               WRITE (6,16)  KSCH(i1), RM/a1, SUM1*DT0, SUM2, DTAU
<    16         FORMAT (' INVERT NEGATIVE!    KSCH R/A S1*DT0 S2 DTAU ',
<      &                                      F7.2,1P,4E10.2)
---
>               if(rank.eq.0)
>      &        WRITE (6,16)  KSCH(i1), RM/a1, SUM1*DT0, SUM2, DTAU
>    16         FORMAT (' DANGER!    INVERT    KSCH R/A S1*DT0 S2 DTAU ',
>      &                                       F7.2,1P,4E10.2)
243a249,250
> 
> 
1,2c1,2
< 1726 2001-04-07 13:23 /work/Umi2/spurzem/5/nbody6compare/kcpert.f
< nbody6compare/kcpert.f
---
> 1726 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/kcpert.f
> nbody6++compare/kcpert.f
1,2c1,2
< 2932 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/kepler.f
< nbody6compare/kepler.f
---
> 2934 2003-06-23 19:34 /work/Umi2/spurzem/5/nbody6++compare/kepler.f
> nbody6++compare/kepler.f
95a96,97
> 
> 
1,2c1,2
< 4700 2006-02-10 11:44 /work/Umi2/spurzem/5/nbody6compare/kick.f
< nbody6compare/kick.f
---
> 4942 2003-06-25 20:44 /work/Umi2/spurzem/5/nbody6++compare/kick.f
> nbody6++compare/kick.f
12a13,14
> * recover random number sequence from COMMON variable IDUM1.
>       KDUM = IDUM1
42c44,45
<           WRITE (6,1)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2), ZM1,
---
>           if(rank.eq.0)
>      &    WRITE (6,1)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2), ZM1,
54,55c57,58
< *   2 VT = VCUT/V0*RAN2(IDUM1)
< *     VP = VT*(2.0*RAN2(IDUM1) - 1.0)
---
> *   2 VT = VCUT/V0*RAN2(KDUM)
> *     VP = VT*(2.0*RAN2(KDUM) - 1.0)
58c61
< *     IF (FAC.LT.RAN2(IDUM1).AND.IT.LT.10) GO TO 2
---
> *     IF (FAC.LT.RAN2(KDUM).AND.IT.LT.10) GO TO 2
65,66c68,69
<           X1 = RAN2(IDUM1)
<           X2 = RAN2(IDUM1)
---
>           X1 = RAN2(KDUM)
>           X2 = RAN2(KDUM)
88c91
< *         A(K) = 2.0*RAN2(IDUM1) - 1.0
---
> *         A(K) = 2.0*RAN2(KDUM) - 1.0
124c127,128
<           WRITE (6,20)  I, NAME(I), KSTAR(I), KC, BODY0(I)*ZMBAR, ZM,
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  I, NAME(I), KSTAR(I), KC, BODY0(I)*ZMBAR, ZM,
127c131
<      &                                2I6,2I4,2F7.2,1P,3E9.1)
---
>      &                                2I6,2I4,2F7.2,3F7.1)
133,134c137,139
<           WRITE (6,25)  I, NAME(I), VKICK*VSTAR, SQRT(VF2)*VSTAR
<    25     FORMAT (' LOW KICK:    I NAM VK VF ',2I6,1P,2E9.1)
---
>           if(rank.eq.0)
>      &    WRITE (6,25)  I, NAME(I), VKICK*VSTAR, SQRT(VF2)*VSTAR
>    25     FORMAT (' LOW KICK:    I NAM VK VF ',2I6,2F6.2)
142c147,152
<    30 RETURN
---
>    30 CONTINUE
> *
> *       Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
> *
>       RETURN
144a155,156
> 
> 
1,2c1,2
< 1960 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ksapo.f
< nbody6compare/ksapo.f
---
> 2125 2003-06-25 20:49 /work/Umi2/spurzem/5/nbody6++compare/ksapo.f
> nbody6++compare/ksapo.f
9a10,11
> * recover random number sequence from COMMON variable IDUM1.
>       KDUM = IDUM1
59a62,64
> *       Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
> *
62a68,69
> 
> 
1,2c1,2
< 6846 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/kscorr.f
< nbody6compare/kscorr.f
---
> 6846 2001-08-24 22:40 /work/Umi2/spurzem/5/nbody6++compare/kscorr.f
> nbody6++compare/kscorr.f
1,2c1,2
< 7086 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ksin2.f
< nbody6compare/ksin2.f
---
> 7154 2003-08-01 21:49 /work/Umi2/spurzem/5/nbody6++compare/ksin2.f
> nbody6++compare/ksin2.f
157c157,158
<           WRITE (6,60)  WHICH1, TIME+TOFF, NAME(ICOMP), NAME(JCOMP),
---
>           if(rank.eq.0)
>      &    WRITE (6,60)  WHICH1, TIME+TOFF, NAME(ICOMP), NAME(JCOMP),
180c181
<       IF (KZ(8).GT.0.AND.K.EQ.0) THEN
---
>       IF ((KZ(8).GT.0 .OR. NBIN0.GT.0) .AND.K.EQ.0) THEN
187c188,189
<           WRITE (8,90)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP), K,
---
>           if(rank.eq.0)
>      &    WRITE (8,90)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP), K,
197a200
> 
1,2c1,2
< 8821 2006-02-12 18:04 /work/Umi2/spurzem/5/nbody6compare/ksinit.f
< nbody6compare/ksinit.f
---
> 8910 2003-07-04 19:04 /work/Umi2/spurzem/5/nbody6++compare/ksinit.f
> nbody6++compare/ksinit.f
53a54
> *
177c178,179
<           WRITE (6,60)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP),DTAU(IPAIR),
---
>           if (rank.eq.0)
>      &    WRITE (6,60)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP),DTAU(IPAIR),
180c182
<    60     FORMAT (/,' NEW KSREG    TIME =',F7.2,2I6,F12.3,1PE10.1,
---
>    60     FORMAT (/,' NEW KSREG    TIME =',1PE10.2,2I6,0PF12.3,1PE10.1,
187c189
<       IF (NPAIRS.EQ.KMAX) WRITE (6,70)  NPAIRS, TIME+TOFF
---
>       IF (NPAIRS.EQ.KMAX.and.rank.eq.0) WRITE (6,70)  NPAIRS, TIME+TOFF
223c225
<       IF (KZ(8).GT.0.AND.K.EQ.0) THEN
---
>       IF ((KZ(8).GT.0.OR.NBIN0.GT.0).AND.K.EQ.0) THEN
230,231c232,234
<           WRITE (8,90)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP), K,
<      &                  BODY(ICOMP),BODY(JCOMP), EB, SEMI, R(IPAIR),
---
>           if(rank.eq.0)
>      &    WRITE (8,90)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP), K,
>      &                  BODY(ICOMP), BODY(JCOMP), EB, SEMI, R(IPAIR),
240a244,245
> 
> 
1,2c1,2
< 17463 2006-09-02 13:14 /work/Umi2/spurzem/5/nbody6compare/ksint.f
< nbody6compare/ksint.f
---
> 15607 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/ksint.f
> nbody6++compare/ksint.f
0a1,4
> # 1 "ksint.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "ksint.F"
4,5c8,9
< *       Regularized integration.
< *       ------------------------
---
> * Regularized integration.
> * ------------------------
8,13c12,17
<       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
<       COMMON/SLOW0/  RANGE,ISLOW(10)
<       COMMON/GAMDOT/  DGAM
<       REAL*8  UI(4),UIDOT(4),XI(6),VI(6),FP(6),FD(6)
---
>       COMMON/BINARY/ CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
>      & HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      & NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       COMMON/SLOW0/ RANGE,ISLOW(10)
>       COMMON/GAMDOT/ DGAM
>       REAL*8 UI(4),UIDOT(4),XI(6),VI(6),FP(6),FD(6)
17c21
< *       Set second component, pair index & c.m. index.
---
> * Set second component, pair index & c.m. index.
22c26
< *       Define perturber membership & inverse c.m. mass.
---
> * Define perturber membership & inverse c.m. mass.
26c30
< *       Check for further unperturbed motion or dissipation at pericentre.
---
> * Check for further unperturbed motion or dissipation at pericentre.
32c36
< *       Perform KS prediction of U, UDOT & H.
---
> * Perform KS prediction of U, UDOT & H.
35c39
< *       Obtain the perturbing force & derivative.
---
> * Obtain the perturbing force & derivative.
38c42
< *       Save old radial velocity & relative perturbation and set new GAMMA.
---
> * Save old radial velocity & relative perturbation and set new GAMMA.
44c48
< *       Apply the Hermite corrector.
---
> * Apply the Hermite corrector.
47c51
< *       Increase regularization time-step counter and update the time.
---
> * Increase regularization time-step counter and update the time.
51c55
< *       Check for early return during termination (called from KSTERM).
---
> * Check for early return during termination (called from KSTERM).
54c58
< *       Define useful scalars.
---
> * Define useful scalars.
58c62
< *       Initialize termination indicator and check for large perturbation.
---
> * Initialize termination indicator and check for large perturbation.
67,71c71,72
< *       Delay chain regularization check until near end of block-step.
<           IF (TIME + STEP(I1).GT.TBLOCK) THEN
<               CALL IMPACT(I)
<               IF (IPHASE.GT.0) GO TO 100
<           END IF
---
>           CALL IMPACT(I)
>           IF (IPHASE.GT.0) GO TO 100
79c80
< *       Find the dominant body for large perturbations.
---
> * Find the dominant body for large perturbations.
82c83
< *       Initialize JCOMP for optional diagnostics in KSTERM.
---
> * Initialize JCOMP for optional diagnostics in KSTERM.
86c87
< *       Only search bodies within twice the c.m. time-step.
---
> * Only search bodies within twice the c.m. time-step.
88c89
< *       Compare strong perturber and either component with current pair.
---
> * Compare strong perturber and either component with current pair.
91c92
<      &                                      (X(3,J) - X(3,K))**2
---
>      & (X(3,J) - X(3,K))**2
93c94
<     5     CONTINUE
---
>     5 CONTINUE
96c97
< *       Set termination if strong perturber <= N forms dominant pair.
---
> * Set termination if strong perturber <= N forms dominant pair.
98c99
< *       Check optional binary search.
---
> * Check optional binary search.
104c105
<           IF (JCOMP.NE.0.OR.GI.GT.2.0) IQ = .TRUE.
---
>           IF (JCOMP.LE.N.OR.GI.GT.2.0) IQ = .TRUE.
107,108c108,109
< *       Check termination of hyperbolic encounter (R > R0 or R > RMIN).
<    20 IF (HI.GT.0.0D0.AND.NAME(I).GT.0) THEN
---
> * Check termination of hyperbolic encounter (R > R0 or R > RMIN).
>    20 IF (HI.GT.0.0D0) THEN
110,112c111,113
<      &        (GI.GT.0.5.AND.TD2.GT.0.0)) THEN
< *       Skip termination delay in case of velocity kick (cf. routine KSTERM).
<               IF (HI.LT.100.0.OR.GI.GT.0.1.OR.RI.GT.5.0*RMIN) THEN
---
>      & (GI.GT.0.5.AND.TD2.GT.0.0)) THEN
> * Skip termination delay in case of velocity kick (cf. routine KSTERM).
>               IF (HI.LT.100.0.OR.GI.GT.0.5) THEN
118c119
< *       Choose basic regularized step using binding energy or lower limit.
---
> * Choose basic regularized step using binding energy or lower limit.
125d125
< *       Modify maximum square step for soft binaries & weak hyperbolic pairs.
126a127
> * Modify maximum square step for soft binaries & weak hyperbolic pairs.
128c129
< *       Consider case of hard binary with massive components or merger.
---
> * Consider case of hard binary with massive components or merger.
131c132
<               IF (NAME(I).LT.0) W1 = W2 
---
>               IF (NAME(I).LT.0) W1 = W2
135c136
< *       Include perturbation factor in predicted step.
---
> * Include perturbation factor in predicted step.
137c138
< *       Use second-order expansion of cube root for small perturbations.
---
> * Use second-order expansion of cube root for small perturbations.
145c146
< *       Form new regularized step.
---
> * Form new regularized step.
149c150
< *       Reset reference energy and generate new Stumpff coefficients.
---
> * Reset reference energy and generate new Stumpff coefficients.
157c158
< *       Convert to physical time units modified by Stumpff coefficients.
---
> * Convert to physical time units modified by Stumpff coefficients.
159c160
<      &                     + TDOT3(IPAIR))*ONE6*DTU + TD2)*DTU + RI)*DTU
---
>      & + TDOT3(IPAIR))*ONE6*DTU + TD2)*DTU + RI)*DTU
161,162c162,163
< *       Ensure that regularized step is smaller than the c.m. step.
<       IF (STEP(I1).GT.STEP(I).AND.HI.LT.0.0) THEN
---
> * Ensure that regularized step is smaller than the c.m. step.
>       IF (STEP(I1).GT.STEP(I)) THEN
168c169
< *       See whether the KS slow-down procedure is activated. 
---
> * See whether the KS slow-down procedure is activated.
175c176
< *       Check diagnostic print option.
---
> * Check diagnostic print option.
177,179c178,181
<           WRITE (6,40)  IPAIR, TIME+TOFF, H(IPAIR), RI, DTAU(IPAIR),
<      &                  GI, STEP(I1), LIST(1,I1), IMOD
<    40     FORMAT (3X,'KS MOTION',I6,2F10.4,2F10.5,1P,2E10.2,2I4)
---
>           if(rank.eq.0)
>      & WRITE (6,40) IPAIR, TIME+TOFF, H(IPAIR), RI, DTAU(IPAIR),
>      & GI, STEP(I1), LIST(1,I1), IMOD
>    40 FORMAT (3X,'KS MOTION',I6,2F10.4,2F10.5,1P,2E10.2,2I4)
182c184
< *       Employ special termination criterion in merger case.
---
> * Employ special termination criterion in merger case.
184c186
< *       Terminate if apocentre perturbation > 0.25 (R' > 0) or GI > 0.25.
---
> * Terminate if apocentre perturbation > 0.25 (R > 0) or GI > 0.25.
188,189c190
<               ECC1 = SQRT(ECC2)
<               A0 = SEMI*(1.0 + ECC1)/RI
---
>               A0 = SEMI*(1.0 + SQRT(ECC2))/RI
194,200d194
< *       Perform pericentre test for significant perturbation (RDOT > 0 only).
<               IF (GI.GT.0.01.AND.TD2.GT.0.0) THEN
<                   RP = SEMI*(1.0 - ECC1)
<                   EB = BODY(I1)*BODY(I2)*HI*BODYIN
< *       Check binding energy is consist with 0.25*EBH/(1+r/R_h) in IMPACT.
<                   IF (EB.GT.0.2*EBH) IQ = .TRUE.
<               END IF
202c196
<               IF (TD2.GT.0.0.AND.(GI.GT.GMAX.OR.RI.GT.RMIN)) IQ = .TRUE.
---
>               IF (GI.GT.GMAX) IQ = .TRUE.
207c201
< *       Delay termination until end of block for large perturbation.
---
> * Delay termination until end of block for large perturbation.
210,212c204,207
< *         WRITE (6,45)  IPAIR, TIME+TOFF, GI, RI, DTR, STEP(I1)
< *  45     FORMAT (' TERM TEST    KS T G R DTR DT  ',
< *    &                           I4,F10.4,F7.3,1P,E10.2,2E9.1)
---
> * if(rank.eq.0)
> * & WRITE (6,45) IPAIR, TIME+TOFF, GI, RI, DTR, STEP(I1)
> * 45 FORMAT (' TERM TEST    KS T G R DTR DT  ',
> * & I4,F10.4,F7.3,1P,E10.2,2E9.1)
216c211
< *       Check standard termination criterion (suppress on IQ = .true.).
---
> * Check standard termination criterion (suppress on IQ = .true.).
219c214
< *       See whether termination can be delayed for intermediate energies.
---
> * See whether termination can be delayed for intermediate energies.
230c225
< *       Check updating of R0 for newly hardened binary orbit.
---
> * Check updating of R0 for newly hardened binary orbit.
246c241
<    55         CONTINUE
---
>    55 CONTINUE
252c247
< *       End integration cycle for hyperbolic motion.
---
> * End integration cycle for hyperbolic motion.
255c250
< *       Obtain pericentre by Mikkola's algorithm (GAMMA < 0.001).
---
> * Obtain pericentre by Mikkolas algorithm (GAMMA < 0.001).
263,275c258,298
< *       Check optional tidal interaction or stellar collision.
<               IF (KZ(19).GE.3) THEN
<                   IF (KZ(27).LE.2) THEN
<                       RX = 4.0*MAX(RADIUS(I1),RADIUS(I2))
<                       RCOLL = 0.75*(RADIUS(I1) + RADIUS(I2))
<                   ELSE
<                       DV = SQRT(2.0*HI)
<                       RX = RPMAX(BODY(I1),BODY(I2),VSTAR,DV,QPERI)
<                       RCOLL = RZ
<                   END IF
<                   IF (QPERI.LT.RX) THEN
<                       IF (QPERI.LT.RCOLL) THEN
< *       Obtain KS variables at pericentre before coalescence to one body.
---
>               IF (rank.eq.0.and.BK(4).EQ.1) THEN
> C Added Aug.1998 b P.Kroupa:
> * If BK(4)=1 then write out relevant data
> * into unit=15 (file=per.15) [see file_init.F]
> * for statistics of closest approaches & disk destruction during
> * hyperbolic encounters. (27.08.96, P.Kroupa in nb5)
> * write out: time in Myr, periastron distance in AU
> * names and masses (Msun) of involved stars
> * distance of centre of mass (!) from cluster centre in pc:
> *
>                  peri_pk=log10(QPERI*RBAR*206264.84)
>                  cldist_pk=SQRT((x(1,I)-rdens(1))**2 +
>      + (x(2,I)-rdens(2))**2+
>      + (x(3,I)-rdens(3))**2)*RBAR
> 
> 
> 
>                  write(15,'(2F8.3,2I5,2F8.3,F9.4,F13.4)')
>      + time*tscale,peri_pk,name(I1),name(I2),
>      + body(I1)*ZMBAR,body(I2)*ZMBAR,cldist_pk
>                  call flush(15)
> 
> 
> 
> C Also write the stuff into log-file:
> * write(6,*)
> * write(6,*)' Hyperbolic encounter: (see ksint.f)'
> * write(6,*)' time[Myr] log10(Rperi[AU]) star1 star2 ',
> * + 'mass1 mass2[Msun] Rcl[pc]'
> * write(6,'(2F8.3,2I5,2F8.3,F9.4)')
> * + time*tscale,peri_pk,name(I1),name(I2),
> * + body(I1)*ZMBAR,body(I2)*ZMBAR,cldist_pk
> * write(6,*)
> * call flush(6)
>               end if
> *
> * Check optional tidal interaction or stellar collision.
>               IF (KZ(27).GT.0) THEN
>                   IF (QPERI.LT.4.0*MAX(RADIUS(I1),RADIUS(I2))) THEN
>                       IF (QPERI.LT.0.75*(RADIUS(I1) + RADIUS(I2))) THEN
> * Obtain KS variables at pericentre before merging into one body.
279c302
<                       ELSE IF (KZ(27).GT.0) THEN
---
>                       ELSE
288c311
< *       Check perturbation threshold (H < 0 & GAMMA > GMAX).
---
> * Check perturbation threshold (H < 0 & GAMMA > GMAX).
300c323
< *       Estimate smallest permitted output interval at new level.
---
> * Estimate smallest permitted output interval at new level.
309,316c332,339
< *       Check for partial reflection during approach (NB! only IMOD = 1).
< *  70 IF (GI.LT.GMIN.AND.TD2.LT.0.0D0) THEN
< *       Skip apocentre position itself.
< *         IF (RDOT.LT.0.0D0.AND.IMOD.EQ.1) THEN
< *             IF (KZ(25).GT.0) CALL FREEZE(IPAIR)
< *             GO TO 100
< *         END IF
< *     END IF
---
> * Check for partial reflection during approach (NB! only IMOD = 1).
> * 70 IF (GI.LT.GMIN.AND.TD2.LT.0.0D0) THEN
> * Skip apocentre position itself.
> * IF (RDOT.LT.0.0D0.AND.IMOD.EQ.1) THEN
> * IF (KZ(25).GT.0) CALL FREEZE(IPAIR)
> * GO TO 100
> * END IF
> * END IF
318c341
< *       Determine new perturbers for binary at apocentre turning point.
---
> * Determine new perturbers for binary at apocentre turning point.
322c345
< *       Check minimum two-body separation just after pericentre.
---
> * Check minimum two-body separation just after pericentre.
324c347
< *       Obtain pericentre by Mikkola's algorithm (GAMMA < 0.001).
---
> * Obtain pericentre by Mikkolas algorithm (GAMMA < 0.001).
332,347c355,363
< *       Check optional tidal interaction or stellar collision (skip merger).
<           IF (KZ(19).GE.3.AND.NAME(I).GT.0) THEN
<               IF (KZ(27).LE.2) THEN
<                   ECC = 1.0 - QPERI/SEMI
<                   ZF = 4.0
<                   IF (ECC.GT.0.95.AND.KZ(27).EQ.1) ZF = 50.0
<                   RX = ZF*MAX(RADIUS(I1),RADIUS(I2))
<                   RCOLL = 0.75*(RADIUS(I1) + RADIUS(I2))
<               ELSE
<                   RX = RPMIN(BODY(I1),BODY(I2),VSTAR,HI,QPERI)
<                   RCOLL = RZ
< *       Replace by RCOLL = 6.0*BODY(I)/CLIGHT**2 for unequal masses.
<               END IF
<               IF (QPERI.LT.RX) THEN
<                   IF (QPERI.LT.RCOLL) THEN
< *       Obtain KS variables at pericentre before coalescence to one body.
---
> * Check optional tidal interaction or stellar collision (skip merger).
>           IF (KZ(27).GT.0) THEN
>               ECC = 1.0 - QPERI/SEMI
>               ZF = 4.0
>               IF (ECC.GT.0.95) ZF = 50.0
>               IF (QPERI.LT.ZF*MAX(RADIUS(I1),RADIUS(I2)).AND.
>      & NAME(I).GT.0) THEN
>                   IF (QPERI.LT.0.75*(RADIUS(I1) + RADIUS(I2))) THEN
> * Obtain KS variables at pericentre before merging into one body.
351,354c367,368
< *       Do not evolve synchronous orbit further but allow decay by GR.
<                   ELSE IF (KZ(27).EQ.1.AND.KSTAR(I).LT.19) THEN
<                       CALL KSTIDE(IPAIR,QPERI)
<                   ELSE IF (KZ(27).EQ.3) THEN
---
> * Do not evolve synchronous orbit further.
>                   ELSE IF (KSTAR(I).NE.20) THEN
362c376
< *       Save maximum separation of persistent binary.
---
> * Save maximum separation of persistent binary.
365c379
< *       Check binary reference radius or merger termination.
---
> * Check binary reference radius or merger termination.
367c381
< *       Update termination length scale of hard binary if enough perturbers.
---
> * Update termination length scale of hard binary if enough perturbers.
374,375c388,391
<       ELSE 
< *       Check pericentre stability criterion of merged binary (NAME < 0).
---
>       ELSE
> * Check pericentre stability criterion of merged binary (NAME < 0).
>           ECC2 = (1.0 - RI/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
>           ECC1 = SQRT(ECC2)
378d393
< *       Use the standard criterion for a provisional test.
381c396
<               DO 71 K = 1,NMERGE
---
>               DO 72 K = 1,NMERGE
383c398
<    71         CONTINUE
---
>    72 CONTINUE
386,412c401,404
<               E0 = 0.0
<               EMAX = 0.0
< *       Include inclination effect inside 1.5*RP for consistency.
<               IF (PCRIT.LT.1.5*RP.AND.NAME(I2).LE.NZERO) THEN
<                   RIM = 0.0
<                   TD2 = 0.0
< *       Form inner eccentricity from KS variables.
<                   DO 72 K = 1,4
<                       RIM = RIM + UM(K,IM)**2
<                       TD2 = TD2 + 2.0*UM(K,IM)*UMDOT(K,IM)
<    72             CONTINUE
<                   E02 = (1.0 - RIM/AIN)**2 + TD2**2/(BODY(I1)*AIN)
<                   E0 = SQRT(E02)
<                   CALL HIMAX(I1,IM,E0,AIN,EMAX,EMIN,ANGLE,TG,EDAV)
< *       Note: updating XREL & VREL in HMDOT should not affect inclination.
<                   YFAC = 1.0 - 0.6*ANGLE/TWOPI
<                   PCRIT = YFAC*PCRIT
< *       Save the revised stability boundary for later use.
<                   R0(IPAIR) = PCRIT
<               END IF
<               IF (RP*(1.0 - GI).LT.R0(IPAIR)) THEN
<                   WRITE (6,75)  NAME(I1), GI, E0, EMAX, ECC1, RP,
<      &                          R0(IPAIR), PCRIT, AIN
<    75             FORMAT (' BASIC INSTAB    NM GI E0 EX E1 RP R0 PCR ',
<      &                             'AIN ',I6,2F7.3,F8.4,F7.3,1P,4E10.2)
<                   GO TO 90
<               END IF
---
>               WRITE (6,73) GI, ECC1, RP, R0(IPAIR), PCRIT, AIN
>    73 FORMAT (' BASIC INSTAB    GI E1 RP R0 PCR AIN ',
>      & 2F7.3,1P,4E10.2)
>               GO TO 90
414c406
< *       Include safety check for outer eccentricity change (GI > 0.001).
---
> * Include safety check for outer eccentricity change (GI > 0.001).
418c410
<               DO 76 K = 1,NMERGE
---
>               DO 75 K = 1,NMERGE
420c412
<    76         CONTINUE
---
>    75 CONTINUE
423c415
< *       Adopt 60 % criterion to allow for marginally stable systems.
---
> * Adopt 60 % criterion to allow for marginally stable systems.
425,427c417,419
<               WRITE (6,78) GI, ECC1, RP, R0(IPAIR), PCRIT, AIN
<    78         FORMAT (' PERT INSTAB!    GI E1 RP R0 PCR AIN ',
<      &                                  2F7.3,1P,4E10.2)
---
>               WRITE (6,500) GI, ECC1, RP, R0(IPAIR), PCRIT, AIN
>   500 FORMAT (' PERT INSTAB!    GI E1 RP R0 PCR AIN ',
>      & 2F7.3,1P,4E10.2)
431c423
< *       Terminate merger if maximum perturber range > 2*RS & GI > GMAX.
---
> * Terminate merger if maximum perturber range > 2*RS & GI > GMAX.
435c427
< *       See whether KS slow-down procedure should be (re)-checked.
---
> * See whether KS slow-down procedure should be (re)-checked.
437c429
< *       Include case of tidal dissipation.
---
> * Include case of tidal dissipation.
442c434
< *       Skip modification if predicted pericentre < 5 tidal capture radii.
---
> * Skip modification if predicted pericentre < 5 tidal capture radii.
452c444
< *       Set approximate value of next period with perturbation included.
---
> * Set approximate value of next period with perturbation included.
458c450
< *       Use old perturber list if next apocentre is before the c.m. step.
---
> * Use old perturber list if next apocentre is before the c.m. step.
467c459
< *       Select new perturbers (adopt unperturbed period if none found).
---
> * Select new perturbers (adopt unperturbed period if none found).
470c462
< *       Perform rectification.
---
> * Perform rectification.
473c465
< *       Check optional search criterion for multiple encounter or merger.
---
> * Check optional search criterion for multiple encounter or merger.
479c471
< *       Terminate regularization of current pair (IPAIR set in KSPAIR).
---
> * Terminate regularization of current pair (IPAIR set in KSPAIR).
481c473
< *       Set indicator for calling KSTERM in MAIN (permits phase overlay).
---
> * Set indicator for calling KSTERM in MAIN (permits phase overlay).
483c475
< *       Check for rare case of merged binary component.
---
> * Check for rare case of merged binary component.
1,2c1,2
< 3831 2006-02-16 11:21 /work/Umi2/spurzem/5/nbody6compare/kslist.f
< nbody6compare/kslist.f
---
> 3827 2002-06-12 23:24 /work/Umi2/spurzem/5/nbody6++compare/kslist.f
> nbody6++compare/kslist.f
45c45
< *       Select new perturbers from the neighbour list.
---
> *       Select new perturbers from all particles.
70c70
<           ELSE IF (KZ(27).LE.1) THEN
---
>           ELSE IF (KZ(27).EQ.0) THEN
110a111
> 
1,2c1,2
< 3606 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ksmod.f
< nbody6compare/ksmod.f
---
> 3926 2001-08-04 17:07 /work/Umi2/spurzem/5/nbody6++compare/ksmod.f
> nbody6++compare/ksmod.f
60,61c60,61
< *       Determine the eccentric anomaly with respect to pericentre (-PI,PI).
<       THETA = ATAN2(PSI/SQRT(SEMI),ZETA)
---
> *       Determine the eccentric anomaly with respect to pericentre (0,PI).
>       THETA = ATAN2(ABS(PSI)/SQRT(SEMI),ZETA)
64,65c64,65
<       DT = SEMI*SQRT(SEMI/BODY(ICM))*(THETA - PSI/SQRT(SEMI))
<       DT = 0.5D0*TK + DT
---
>       DT = SEMI*SQRT(SEMI/BODY(ICM))*(THETA - ABS(PSI)/SQRT(SEMI))
>       DT = 0.5D0*TK - DT
68,69c68,76
< *       Evaluate regularized apocentre time (Baumgarte & Stiefel, 1974).
< *     DTU = -2.0D0*(H(IPAIR)*DT + TDOT2(IPAIR))/BODY(ICM)
---
> *       Evaluate regularized apocentre time (Stiefel & Scheifele, p. 85).
> *     DTU = -2.0D0*(H(IPAIR)*DT + 0.5D0*TDOT2(IPAIR))/BODY(ICM)
> *
> *       See whether the time interval should be modified by KSLOW procedure.
>       IF (IMOD.GT.1) THEN
>           ZMOD = FLOAT(ISLOW(IMOD))
>       ELSE
>           ZMOD = 1.0
>       END IF
73c80
<       DTU = DT/R(IPAIR)
---
>       DTU = DT/(R(IPAIR)*ZMOD)
75,76c82
< *       Note: explicit relation agrees with iterated value (bug fix 9/99).
<    40 Y0 = DT - ((ONE6*TDOT3(IPAIR)*DTU +
---
>    40 Y0 = DT - ZMOD*((ONE6*TDOT3(IPAIR)*DTU +
78a85
>       YPR = ZMOD*YPR
81a89
>       DT1 = ZMOD*DT1
96,97c104,110
< *       Predict current coordinates & velocities of ICM.
<       CALL XVPRED(ICM,0)
---
> *       Predict current coordinates & velocities for perturbers, ICM & IPAIR.
>       NNB2 = LIST(1,I1) + 2
>       LIST(NNB2,I1) = ICM
>       DO 60 L = 2,NNB2
>           J = LIST(L,I1)
>           CALL XVPRED(J,0)
>    60 CONTINUE
1,2c1,2
< 5876 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ksperi.f
< nbody6compare/ksperi.f
---
> 2705 2002-07-31 07:19 /work/Umi2/spurzem/5/nbody6++compare/ksperi.f
> nbody6++compare/ksperi.f
8d7
<       COMMON/SLOW0/  RANGE,ISLOW(10)
11,14c10
< *       Save current time and initialize integration indicator.
<       TIME0 = TIME
<       ITIME = 0
<       I1 = 2*IPAIR - 1
---
> *       Set c.m. index & semi-major axis.
16,22c12
< *
< *       Re-calculate TDOT2 which may have misleading value.
<     1 TD2 = 0.0D0
<       DO 5 K = 1,4
<           TD2 = TD2 + U0(K,IPAIR)*UDOT(K,IPAIR)
<     5 CONTINUE
<       TD2 = 2.0*TD2
---
>       SEMI = -0.5D0*BODY(ICM)/H(IPAIR)
25d14
<       SEMI = -0.5D0*BODY(ICM)/H(IPAIR)
27c16
<       PSI = TD2/SQRT(BODY(ICM))
---
>       PSI = TDOT2(IPAIR)/SQRT(BODY(ICM))
31c20
<       IF (ECC.LT.0.0001) GO TO 30
---
>       IF (ECC.LT.0.0001) GO TO 20
40c29
<           DO 8 IT = 1,10
---
>           DO 1 IT = 1,10
43c32
<     8     CONTINUE
---
>     1     CONTINUE
49a39
> *
52a43
> *       Hyperbolic case.
62,136c53,55
< *       Re-define current time (NB! not quantized; T0(I1) may be << TIME).
<       TIME = TIME - DT
< *
< *       Integrate backwards for perturbed motion (reflection gives errors).
<       IF (LIST(1,I1).GT.0.AND.ITIME.EQ.0.AND.DT.GT.STEP(I1)) THEN
<           TIME = TIME0
<           IMOD = KSLOW(IPAIR)
<           ZMOD = FLOAT(ISLOW(IMOD))
<           IPH = IPHASE
<           IPHASE = -1
< *
< *       Integrate step by step if interval is too large (note IPHASE < 0).
<    10     IF (DT.GT.STEP(I1)) THEN
<               TIME = TIME - STEP(I1)
<               DT = DT - STEP(I1)
<               H0(IPAIR) = H(IPAIR)
<               Z = -0.5D0*H(IPAIR)*DTAU(IPAIR)**2
<               CALL STUMPF(IPAIR,Z)
<               DTAU(IPAIR) = -ABS(DTAU(IPAIR))
<               CALL KSINT(I1)
<               DTU = DTAU(IPAIR)
< *       Use negative DTU and treat STEP as positive (not used elsewhere).
<               STEP(I1) = ((ONE6*TDOT3(IPAIR)*DTU + 0.5*TDOT2(IPAIR))*DTU
<      &                                                   + R(IPAIR))*DTU
<               STEP(I1) = -ZMOD*STEP(I1)
<               ITIME = ITIME + 1
<               IF (ITIME.LT.200) GO TO 10
<           END IF
< *
<           ITIME = ITIME + 1
<           DTU = DT/(R(IPAIR)*ZMOD)
<           DTU0 = DTAU(IPAIR)
<           ITER = 0
< *       Determine the regularized step by Newton-Raphson iteration (DT > 0).
<    20     Y0 = DT - ZMOD*((ONE6*TDOT3(IPAIR)*DTU +
<      &                             0.5*TDOT2(IPAIR))*DTU + R(IPAIR))*DTU
<           YPR = -((0.5*TDOT3(IPAIR)*DTU + TDOT2(IPAIR))*DTU + R(IPAIR))
<           YPR = ZMOD*YPR
<           DTU = DTU - Y0/YPR
<           DT1 = ((ONE6*TDOT3(IPAIR)*DTU + 0.5*TDOT2(IPAIR))*DTU +
<      &                                                     R(IPAIR))*DTU
<           DT1 = ZMOD*DT1
<           ITER = ITER + 1
<           IF (ABS(DT - DT1).GT.1.0D-10*STEP(I1).AND.ITER.LT.5) GO TO 20
< *
< *       Integrate back to pericentre using temporary indicator < 0 for exit.
<           TIME = TIME - DT
<           DTAU(IPAIR) = -DTU
< *       Re-initialize Stumpff functions.
<           H0(IPAIR) = H(IPAIR)
<           Z = -0.5D0*H(IPAIR)*DTAU(IPAIR)**2
<           CALL STUMPF(IPAIR,Z)
<           CALL KSINT(I1)
< *       Update energy and set positive step in case no KS initialization.
<           H0(IPAIR) = H(IPAIR)
<           DTAU(IPAIR) = ABS(DTU0)
<           STEP(I1) = ZMOD*DT
<           IPHASE = IPH
< *       Use reflection procedure to improve provisional pericentre.
<           GO TO 1
< *       Note: typically 2 iterations and final TDOT2 > 0.
<       END IF
< *
< *       Specify transformation coefficients (Seppo Mikkola's procedure).
<       IF (ZETA.GE.0.0) THEN
<           XC = SQRT(0.5D0 + 0.5D0*ZETA/ECC)
<           YS = PSI/(ECC*XC*SQRT(BODY(ICM)))
<       ELSE
< *       Employ well behaved expressions for R > A (SM 29/5/97).
<           XC = 0.5*ABS(PSI)/(SQRT(SEMI)*ECC)/SQRT(0.5D0-0.5D0*ZETA/ECC)
< *       Avoid division by small XC near apocentre (ZETA < 0 only).
<           YS = 2.0*SQRT(SEMI/BODY(ICM)*(0.5D0 - 0.5D0*ZETA/ECC))
<           IF (PSI.LT.0.0) YS = -YS
<       END IF
< *
---
> *       Specify transformation coefficients (Mikkola's procedure).
>       XC = SQRT(0.5D0 + 0.5D0*ZETA/ECC)
>       YS = PSI/(ECC*XC*SQRT(BODY(ICM)))
142,143c61
<       T0(I1) = TIME
<       DO 25 K = 1,4
---
>       DO 10 K = 1,4
149c67
<    25 CONTINUE
---
>    10 CONTINUE
156,159c74,76
< *       Predict c.m. coordinates & velocities.
<       IF (ABS(DT).LT.STEP(ICM).AND.TIME.GT.0.0) THEN
<           CALL XVPRED(ICM,0)
<       END IF
---
> *       Set pericentre time and predict c.m. coordinates & velocities.
>       TIME = TIME - DT
>       CALL XVPRED(ICM,0)
161c78
<    30 RETURN
---
>    20 RETURN
1,2c1,2
< 5931 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/kspert.f
< nbody6compare/kspert.f
---
> 5330 2001-08-24 13:46 /work/Umi2/spurzem/5/nbody6++compare/kspert.f
> nbody6++compare/kspert.f
88c88,89
<           CALL KSRES2(J,J1,J2,RIJ2)
---
>           IZZ = KVEC(I1)
>           CALL KSRES2(J,J1,J2,RIJ2,IZZ)
154,155c155,156
< *       See whether the linearized perturbation should be included.
<       IF (KZ(14).GT.0.AND.KZ(14).LT.3) THEN
---
> *       See whether the external perturbation should be included.
>       IF (KZ(14).GT.0) THEN
170,187d170
< *       Check optional Plummer potential.
<       IF (KZ(14).EQ.4.OR.KZ(14).EQ.3) THEN
<           RI2 = AP2
<           RRDOT = 0.0
< *       Form one central distance and scalar product of relative motion.
<           DO 65 K = 1,3
<               RI2 = RI2 + XI(K)**2
<               RRDOT = RRDOT + (XI(K) - XI(K+3))*(VI(K) - VI(K+3))
<    65     CONTINUE
<           FMP = MP/(RI2*SQRT(RI2))
<           DO 70 K = 1,3
<               XREL = XI(K) - XI(K+3)
<               VREL = VI(K) - VI(K+3)
<               FP(K) = FP(K) - XREL*FMP
<               FD(K) = FD(K) - (VREL - 3.0*RRDOT*XREL/RI2)*FMP
<    70     CONTINUE
<       END IF
< *
1,2c1,2
< 648 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6compare/ksphys.f
< nbody6compare/ksphys.f
---
> 648 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/ksphys.f
> nbody6++compare/ksphys.f
1,2c1,2
< 9375 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/kspoly.f
< nbody6compare/kspoly.f
---
> 9287 2003-06-22 19:44 /work/Umi2/spurzem/5/nbody6++compare/kspoly.f
> nbody6++compare/kspoly.f
18d17
<       SEMI = -0.5*BODY(I)/H(IPAIR)
80c79
<       IF (KZ(14).GT.0.AND.KZ(14).LT.3) THEN
---
>       IF (KZ(14).GT.0) THEN
200c199
<       IF (IMOD.GT.1.OR.H(IPAIR).GT.0.0) FAC = 1.0
---
>       IF (IMOD.GT.1) FAC = 1.0
235c234
<       IF (STEP(I1).GT.STEP(I).AND.H(IPAIR).LT.0.0) THEN
---
>       IF (STEP(I1).GT.STEP(I)) THEN
260a260,261
> 
> 
1,2c1,2
< 2841 2006-02-14 19:35 /work/Umi2/spurzem/5/nbody6compare/kspred.f
< nbody6compare/kspred.f
---
> 2858 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/kspred.f
> nbody6++compare/kspred.f
8c8
<       PARAMETER  (ONE24=1.0/24.0D0,ONE120=1.0/120.0D0)
---
>       PARAMETER  (ONE18=1.0/18.0D0,ONE24=1.0/24.0D0,ONE120=1.0/120.0D0)
1,2c1,2
< 3465 2006-09-04 11:19 /work/Umi2/spurzem/5/nbody6compare/ksrect.f
< nbody6compare/ksrect.f
---
> 3564 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/ksrect.f
> nbody6++compare/ksrect.f
12c12
<       DO 1 K = 1,4
---
>       DO 5 K = 1,4
14,21c14
<     1 CONTINUE
< *
< *       Skip rectification for small eccentricity.
<       I = N + IPAIR
<       SEMI = -0.5*BODY(I)/H(IPAIR)
<       ECC2 = (1.0 - R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(SEMI*BODY(I))
<       ECC = SQRT(ECC2)
<       IF (ECC.LE.0.00001) GO TO 50
---
>     5 CONTINUE
23a17
>       EB = BODY(2*IPAIR-1)*BODY(2*IPAIR)*HI/BODY(N+IPAIR)
26a21,28
>       IF (ABS(ERR).GT.0.01) THEN
>       I1 = 2*IPAIR - 1
>       SEMI = -0.5*BODY(N+IPAIR)/H(IPAIR)
>       AF = -0.5*BODY(N+IPAIR)/HI
>       WRITE (6,4)  NAME(I1), LIST(1,I1), SEMI, AF, DB, ERR
>     4 FORMAT (' WARNING!   KSRECT    NM NP A0 AF DB DH/H  ',
>      &                               I5,I4,1P,4E10.2)
>       END IF
28,35c30,37
<           SEMI = -0.5*BODY(N+IPAIR)/H(IPAIR)
<           RA = R(IPAIR)/SEMI
<           IF (SEMI.LT.0.0) RA = R(IPAIR)
<           WRITE (16,3)  TIME+TOFF, IPAIR, RA, H(IPAIR), GAMMA(IPAIR),
<      &                  DB, ERR
<     3     FORMAT (' KSRECT:   T # R/A H G DB DH/H ',
<      &                        F8.2,I4,F8.4,F8.1,F7.3,1P,2E10.1)
<           CALL FLUSH(16)
---
>       SEMI = -0.5*BODY(N+IPAIR)/H(IPAIR)
>       RA = R(IPAIR)/SEMI
>       IF (SEMI.LT.0.0) RA = R(IPAIR)
>       WRITE (16,3)  TIME, IPAIR, RA, H(IPAIR),
>      &              GAMMA(IPAIR), DB, ERR
>     3 FORMAT (' KSRECT:   T # R/A H G DB DH/H ',
>      &                    F8.2,I4,F8.4,F7.1,F7.3,1P,2E10.1)
>       CALL FLUSH(16)
37d38
< *
103c104
<    50 RETURN
---
>       RETURN
1,2c1,2
< 4351 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ksreg.f
< nbody6compare/ksreg.f
---
> 4327 2001-09-08 19:14 /work/Umi2/spurzem/5/nbody6++compare/ksreg.f
> nbody6++compare/ksreg.f
136c136
< *       Copy neighbour list for second component & c.m. (NNB1 = LIST(1,I)+1).
---
> *       Copy neighbour list for second component & c.m.
141d140
< *
1,2c1,2
< 3105 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ksres2.f
< nbody6compare/ksres2.f
---
> 3121 2001-09-30 19:44 /work/Umi2/spurzem/5/nbody6++compare/ksres2.f
> nbody6++compare/ksres2.f
1c1
<       SUBROUTINE KSRES2(J,J1,J2,RIJ2)
---
>       SUBROUTINE KSRES2(J,J1,J2,RIJ2,IZZ)
45c45
<           DTU1 = DTU/24.0D0
---
>           DTU1 = 0.0416666666666667*DTU
1,2c1,2
< 2134 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ksres.f
< nbody6compare/ksres.f
---
> 2148 2003-06-23 19:32 /work/Umi2/spurzem/5/nbody6++compare/ksres.f
> nbody6++compare/ksres.f
42c42
<           DTU1 = DTU/24.0D0
---
>           DTU1 = 0.0416666666666667*DTU
68a69,70
> 
> 
1,2c1,2
< 12655 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ksterm.f
< nbody6compare/ksterm.f
---
> 12802 2003-06-25 21:13 /work/Umi2/spurzem/5/nbody6++compare/ksterm.f
> nbody6++compare/ksterm.f
68c68
<           IF (ABS(DT0 - DT1).GT.1.0E-10*STEP(I1).AND.ITER.LT.10) GO TO 2
---
>           IF (ABS(DT0 - DT1).GT.1.0E-06*STEP(I1).AND.ITER.LT.10) GO TO 2
118c118
<       IF (KZ(8).EQ.0) GO TO 10
---
>       IF (KZ(8).EQ.0.OR.NBIN0.GT.0) GO TO 10
132c132,133
<           WRITE (8,8)  TIME+TOFF, NAME(I1), NAME(I2), K, NAME(JCOMP),
---
>           if(rank.eq.0)
>      &    WRITE (8,8)  TIME+TOFF, NAME(I1), NAME(I2), K, NAME(JCOMP),
143c144,145
<           WRITE (6,15)  TIME+TOFF, BODY(I1), BODY(I1+1), DTAU(IPAIR),
---
>           if (rank.eq.0)
>      &    WRITE (6,15)  TIME+TOFF, BODY(I1), BODY(I1+1), DTAU(IPAIR),
146c148
<    15     FORMAT (/,' END KSREG    TIME =',F7.2,2F8.4,F8.3,1PE10.1,
---
>    15     FORMAT (/,' END KSREG    TIME =',1PE10.2,0P2F8.4,F8.3,1PE10.1,
155,157c157,161
< *       Add correction term with opposite sign for conservation.
< *     ECOLL = ECOLL + (POT2 - POT1)
< *     IF (ABS(POT1-POT2).GT.0.0001) WRITE (6,16)  POT1,BE(3),POT1-POT2
---
> *       Add correction to previous and current terms for conservation.
>       BE(3) = BE(3) + (POT1 - POT2)
>       ECOLL = ECOLL + (POT1 - POT2)
> *     IF (ABS(POT1-POT2).GT.0.0001.and.rank.eq.0) 
> *    &                WRITE (6,16)  POT1,BE(3),POT1-POT2
1,2c1,2
< 8978 2006-09-02 17:40 /work/Umi2/spurzem/5/nbody6compare/kstide.f
< nbody6compare/kstide.f
---
> 8746 2003-06-25 20:59 /work/Umi2/spurzem/5/nbody6++compare/kstide.f
> nbody6++compare/kstide.f
13c13
< *       Skip procedure if both stars have zero size.
---
> *       Skip procedure if |QP - 4*R| < 0.01*QP or both stars zero size.
18a19,21
>       ZF = 4.0
>       IF (ECC.GT.0.95) ZF = 50.0
>       IF (ABS(QPERI - ZF*RX).LT.0.01*QPERI) GO TO 50
20,33c23,27
<       IF (KZ(27).EQ.1) THEN
<           ZF = 4.0
<           IF (ECC.GT.0.95) ZF = 50.0
<           IF (ABS(QPERI - ZF*RX).LT.0.01*QPERI) GO TO 50
< *       Distinguish between Press-Teukolsky and GR energy loss.
<       ELSE IF (KZ(27).EQ.2) THEN
< *       Skip PT procedure for bound orbits.
<           IF (H(IPAIR).LT.0.0) GO TO 50
<           IS(1) = KSTAR(I1)
<           IS(2) = KSTAR(I2)
< *       Obtain kinetic energy loss due to tidal interaction (DE > 0).
<          CALL TIDES(QPERI,BODY(I1),BODY(I2),RADIUS(I1),RADIUS(I2),IS,DE)
<       ELSE IF (KZ(27).EQ.3) THEN
<           CALL TIDES2(QPERI,BODY(I1),BODY(I2),VSTAR,H(IPAIR),ECC,DE)
---
> *
>       IF (QPERI.LT.RADIUS(I1) + RADIUS(I2)) THEN
>           if(rank.eq.0)
>      &    WRITE (6,1)  NAME(I1), QPERI, RX
>     1     FORMAT (' COLLISION TEST!    NAM QP R*  ',I5,1P,2E10.2)
34a29,33
>       IS(1) = KSTAR(I1)
>       IS(2) = KSTAR(I2)
> *
> *       Obtain kinetic energy loss due to tidal interaction (DE > 0 here).
>       CALL TIDES(QPERI,BODY(I1),BODY(I2),RADIUS(I1),RADIUS(I2),IS,DE)
54,70c53,56
<       IF (KZ(27).EQ.1) THEN
< *       Accept circularized orbit if ACIRC < 4*RX (use maximum radius).
<           AM0 = SEMI*(1.0 - ECC**2)
<           ECC1 = SQRT(ECCM2)
<           ACIRC = AM0/(1.0 - ECCM2)
<           IF (ACIRC.LT.ZF*RX) THEN
<               SEMI1 = ACIRC
<           ELSE
< *       Obtain E1 from A1*(1 - E1**2) = AM0 using A1*(1 - E1) = 4*RX.
<               ECC1 = AM0/(ZF*RX) - 1.0
<               ECC1 = MAX(ECC1,ECCM)
<               ECC1 = MAX(ECC1,0.9*ECC)
< *       Set new semi-major axis from angular momentum conservation.
<               SEMI1 = AM0/(1.0 - ECC1**2)
<           END IF
< *       Form the corresponding energy change.
<           DH = 0.5*BODY(I)*(1.0/SEMI - 1.0/SEMI1)
---
> *       Include safety check on energy loss to prevent new SEMI < R.
>       DH = -(DE(1) + DE(2))/ZMU
>       IF (H(IPAIR) + DH.LT.-0.5*BODY(I)/R(IPAIR)) THEN
>           DH = -0.5*BODY(I)/R(IPAIR) - H(IPAIR)
73,81d58
<       ELSE
< *       Include safety check on energy loss to prevent new SEMI < R.
<           DH = -(DE(1) + DE(2))/ZMU
<           IF (H(IPAIR) + DH.LT.-0.5*BODY(I)/R(IPAIR)) THEN
<               DH = -0.5*BODY(I)/R(IPAIR) - H(IPAIR)
<               DE(1) = -ZMU*DH
<               DE(2) = 0.0
<           END IF
<           SEMI1 = -0.5*BODY(I)/(H(IPAIR) + DH)
84,85c61,71
< *       Skip hyperbolic final orbit without corrections.
<       IF (H(IPAIR) + DH.GT.0.0) GO TO 50
---
> *       Obtain the new eccentricity from angular momentum conservation.
>       AM0 = SEMI*(1.0D0 - ECC**2)
> *       Suppress the old instantaneous PT procedure.
> *     ECC2 = ECC**2 + 2.0D0*AM0*DH/BODY(I)
> *     ECC2 = MAX(ECC2,ECCM2)
> *
> *       Adopt sequential circularization instead of standard PT.
>       ECC2 = ECCM2
>       ACIRC = AM0/(1.0 - ECC2)
>       SEMI1 = AM0/(1.0 - ECC2)
>       ECC1 = SQRT(ECC2)
88,91c74,77
< *     Q1 = BODY(I1)/BODY(I2)
< *     RL1 = 0.49*SEMI1/(0.6 + LOG(1.0 + Q1**0.333)/Q1**0.667)
< *     Q2 = 1.0/Q1
< *     RL2 = 0.49*SEMI1/(0.6 + LOG(1.0 + Q2**0.333)/Q2**0.667)
---
>       Q1 = BODY(I1)/BODY(I2)
>       RL1 = 0.49*SEMI1/(0.6 + LOG(1.0 + Q1**0.333)/Q1**0.667)
>       Q2 = 1.0/Q1
>       RL2 = 0.49*SEMI1/(0.6 + LOG(1.0 + Q2**0.333)/Q2**0.667)
94,99c80,107
< *     IF (RADIUS(I1)/RL1.GE.RADIUS(I2)/RL2) THEN
< *         RL = RADIUS(I1)
< *     ELSE
< *         RL = RADIUS(I2)
< *         RL1 = RL2
< *     END IF
---
>       IF (RADIUS(I1)/RL1.GE.RADIUS(I2)/RL2) THEN
>           RL = RADIUS(I1)
>       ELSE
>           RL = RADIUS(I2)
>           RL1 = RL2
>       END IF
> *
> *       Accept circularized orbit if ACIRC < 4*R1 (use maximum radius).
>       R1 = RX
>       IF (ACIRC.LT.ZF*R1) THEN
>           SEMI1 = ACIRC
>       ELSE
> *       Obtain E1 from A1*(1 - E1**2) = AM0 using A1*(1 - E1) = 4*R1.
>           ECC1 = AM0/(ZF*R1) - 1.0
>           ECC1 = MAX(ECC1,ECCM)
>           ECC1 = MAX(ECC1,0.9*ECC)
> *       Set new semi-major axis from angular momentum conservation.
>           SEMI1 = AM0/(1.0 - ECC1**2)
>       END IF
> *
> *       Form the corresponding energy change.
>       DH = 0.5*BODY(I)*(1.0/SEMI - 1.0/SEMI1)
> *     DH = (ECC2 - ECC**2)*BODY(I)/(2.0D0*AM0)
>       DE(1) = -ZMU*DH
>       DE(2) = 0.0
> *
> *       Skip possible hyperbolic case.
>       IF (H(IPAIR) + DH.GT.0.0) GO TO 50
106c114
< *       Set new energy, eccentricity and pericentre.
---
> *       Set new energy and pericentre.
109,112d116
<       IF (KZ(27).GT.1) THEN
<           ECC1 = 1.0 - PERI/SEMI1
<           ECC1 = MAX(ECC1,ECCM)
<       END IF
115,116c119,120
< *       Print first energy change and activate capture indicator.
<       IF (KSTAR(I).EQ.0.AND.HI.GT.0.0) THEN
---
> *       Print first energy change and activate indicator.
>       IF (KSTAR(I).EQ.0) THEN
118,123c122,126
<           APO = SEMI1*(1.0 + ECC1)
<           WRITE (6,5)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
<      &                 TIME+TOFF, ECC, ECC1, P, SEMI1, RX, APO
<     5     FORMAT (' CAPTURE     NAM K* T E0 EF P AF R* APO ',
<      &                          2I6,2I4,F9.2,2F8.3,1P,4E10.2)
<           TEV(I) = TIME + STEP(I)
---
>           if(rank.eq.0)
>      &    WRITE (6,5)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
>      &                 TIME+TOFF, ECC, ECC1, P, SEMI1, RX
>     5     FORMAT (' NEW CIRC    NAM K* T E0 EF P AF R* ',
>      &                          2I6,2I4,F9.2,2F8.3,F7.1,1P,2E10.2)
127,136c130,137
< *       Specify KS coordinate & velocity scaling factors at new pericentre.
<       IF (KZ(27).EQ.1) THEN
<           C1 = SQRT(PERI1/PERI)
< *       Obtain KS velocity scaling from angular momentum conservation.
<           C2 = 1.0/C1
<       ELSE
< *       Note pericentre should not change (hence C1 = 1).
<           C1 = SQRT(PERI1/PERI)
<           C2 = SQRT((BODY(I) + H(IPAIR)*PERI)/(BODY(I) + HI*PERI))
<       END IF
---
> *       Form KS coordinate scaling factor from pericentre ratio.
>       C1 = SQRT(PERI1/PERI)
> *       Specify KS velocity scaling from angular momentum conservation.
>       C2 = 1.0/C1
> *
> *       See whether circular orbit condition applies.
> *     AM = SEMI1*(1.0D0 - ECC1**2)
> *     IF (ECC1.LE.ECCM) C2 = SQRT(AM/AM0)/C1
146d146
<       TDOT2(IPAIR) = 0.0
149c149
< *     CALL KSRECT(IPAIR)
---
>       CALL KSRECT(IPAIR)
155,160d154
< *       Ensure that single perturber differs from #I itself.
<           IF (NP0.EQ.0.AND.LIST(1,I1).EQ.1) THEN
<               IF (LIST(2,I1).EQ.I) THEN
<                   LIST(2,I1) = IFIRST
<               END IF
<           END IF
165c159
<       IF (NP0.GT.0.OR.ECC1.LE.ECCM) THEN
---
>       IF (NP0.GT.0) THEN
172c166
<       IF (ECC.GT.0.9.AND.HI.LT.0.0) THEN
---
>       IF (ECC.GT.0.99.AND.HI.LT.0.0) THEN
193c187,188
<                   WRITE (6,28)  IPAIR, H(IPAIR), SEMI, A1, RP,
---
>                   if(rank.eq.0)
>      &            WRITE (6,28)  IPAIR, H(IPAIR), SEMI, A1, RP,
200a196
> *       Specify one unperturbed period for small apocentre perturbation.
216c212,213
<           WRITE (6,35)  TIME+TOFF, NAME(I1), NAME(I2), ECC, ECC1, QPS
---
>           if(rank.eq.0)
>      &    WRITE (6,35)  TIME+TOFF, NAME(I1), NAME(I2), ECC, ECC1, QPS
218c215
<      &                             F9.2,2I6,F9.4,F6.2,1P,E10.2)
---
>      &                             F9.2,2I6,F9.4,2F6.2)
226,227c223,225
< *       Set look-up time.
<           TEV(I) = TIME + STEP(I)
---
> *       Set look-up time and use KZ(34) to prevent large value in MDOT.
>           TEV(I) = TIME
>           KZ(34) = 1
230,231c228,230
<           WRITE (6,40)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
<      &                  TIME+TOFF, ECC, ECC1, P, SEMI2, RX
---
>           if(rank.eq.0)
>      &    WRITE (6,40)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
>      &                  TIME+TOFF, ECC, ECC1, P, SEMI1, RX
239c238,239
<               WRITE (6,45)  ECC1, SEMI1, R(IPAIR), RCOLL
---
>               if(rank.eq.0)
>      &        WRITE (6,45)  ECC1, SEMI1, R(IPAIR), RCOLL
246,247c246,248
<       IF (KZ(27).EQ.1.AND.ECC2.GT.MAX(ECC,ECCM)+1.0D-04) THEN
<           WRITE (6,48)  TIME+TOFF, IPAIR, ECC2, ECC, R(IPAIR), SEMI1
---
>       IF (ECC2.GT.MAX(ECC,ECCM)) THEN
>           if(rank.eq.0)
>      &    WRITE (12,48)  TIME+TOFF, IPAIR, ECC2, ECC, R(IPAIR), SEMI1
249a251
>           CALL FLUSH(12)
254a257
> 
file /work/Umi2/spurzem/5/nbody6++compare/lagr2.f does not exist
1,2c1,2
< 3861 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/lagr.f
< nbody6compare/lagr.f
---
> 6730 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/lagr.f
> nbody6++compare/lagr.f
0a1,4
> # 1 "lagr.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "lagr.F"
4,5c8,9
< *       Lagrangian radii.
< *       -----------------
---
> * Lagrangian radii.
> * -----------------
8,15c12,23
<       REAL*8 R2,MRT,RT
<       COMMON/WORK1/ R2(NMAX)
<       PARAMETER (LX=11)
<       REAL*8 C(3),FLAGR(LX),RLAGR(LX),RM(LX),DENS(LX),VR(LX)
< *     DATA FLAGR/-1.9,-1.7,-1.5,-1.3,-1.1,-.9,-.7,-.5,-.3,-.1/
< *     DATA FLAGR/0.001,0.002,0.005,0.01,0.02,0.05,0.1,0.2,0.3,0.4,0.5,
< *    &           0.75,0.9/
<       DATA FLAGR/0.01,0.02,0.05,0.1,0.2,0.3,0.4,0.5,0.625,0.75,0.9/
---
>       INTEGER NPARTC(11), NCORE
>       REAL*8 R2(NMAX),RSNGL(NMAX),RBIN(NMAX)
>       REAL*8 C(3), FLAGR(11), RLAGR(11), AVMASS(11), AVMRC,VROTC
>       REAL*8 RSLAGR(11),RBLAGR(11),SIGR2(11),SIGT2(11),VROT(11)
>       INTEGER ISLIST(NMAX),IBLIST(NMAX)
>       LOGICAL FIRST
>       SAVE FIRST
>       DATA FIRST /.TRUE./
> *
> * Lagrangian radii at 1,2,5,7.5,10,15,20,50,70,90,100 % of total mass.
>       DATA FLAGR/0.01,0.02,0.05,0.10,0.20,0.30,0.40,0.50,0.70,0.90,1.00/
> * correspond to: 1%, 2% , 5% , 10%, 20%, 30%, 40%, 50%, 70%, 90%, 100%
16a25,26
> * All quantities refer to initial mass/particle distribution
>       IF(FIRST) ZMASS0 = ZMASS
18c28
< *       Set square radii of single particles & c.m. bodies.
---
> * Set square radii of all single particles & c.m. bodies.
20c30
<       DO 10 I = IFIRST,NTOT
---
>       DO 10 I = 1,N
23c33
<      &                                  (X(3,I) - C(3))**2
---
>      & (X(3,I) - C(3))**2
26,27c36
< *
< *       Sort square distances with respect to the centre C.
---
> * Sort square distances with respect to the centre C.
29,59c38,48
< 
< *       Determine Lagrangian radii for specified mass fractions.
<       ZM = 0.0
<       DO 20 IL = 1,LX
<           ZM1 = ZM
<           ZM = 0.0
<           ZMH = FLAGR(IL)*ZMASS
<           VM2 = 0.0
<           IF (IL.GT.1) THEN
<               R1 = SQRT(R2(I))
<           ELSE
<               R1 = 0.0
<           END IF
<           I = 0
<    15     I = I + 1
<           IM = JLIST(I)
<           ZM = ZM + BODY(IM)
< *       Sum mass-weighted square velocity in current shell.
<           IF (ZM.GT.ZM1) THEN
<               VM2 = VM2 + BODY(IM)*(XDOT(1,IM)**2 + XDOT(2,IM)**2 +
<      &                                              XDOT(3,IM)**2)
<           END IF
<           IF (ZM.LT.ZMH) GO TO 15
<           RLAGR(IL) = SQRT(R2(I))
<           IF (KZ(7).LT.5) GO TO 20
< *       Form mean square velocity and density (print outer shell radii).
<           DM = ZM - ZM1
<           IF (ABS(DM).LT.1.0D-10) THEN
<               VR(IL) = 0.0
<           ELSE
<               VR(IL) = SQRT(VM2/DM)
---
> *
> * Set square radii of singles and binaries for primordial binaries
>       IF (KZ(8).GT.0 .OR. NBIN0.GT.0) THEN
> *
>           IF (FIRST) THEN
>           ZMB0 = 0.0D0
>           ZMS0 = 0.0D0
>               DO 101 I = IFIRST,N
>  101 ZMS0 = ZMS0 + BODY(I)
>               DO 102 I = N+1,NTOT
>  102 ZMB0 = ZMB0 + BODY(I)
61,65d49
<           DV = 2.0*TWOPI/3.0*(R2(I)**1.5 - R1**3)
<           DENS(IL) = DM/DV
<           IF (DENS(IL).LE.0.0D0) DENS(IL) = 1.0
<           RM(IL) = 0.5*(R1 + RLAGR(IL))
<    20 CONTINUE
67c51,157
< *       Obtain half-mass radius separately.
---
>           NSNGL = 0
>           DO 103 I = IFIRST,N
>               NSNGL = NSNGL + 1
>               RSNGL(NSNGL) = (X(1,I) - C(1))**2 + (X(2,I) - C(2))**2 +
>      & (X(3,I) - C(3))**2
>               ISLIST(NSNGL) = I
>  103 CONTINUE
> * Sort square distances with respect to the centre C.
>       CALL SORT1(NSNGL,RSNGL,ISLIST)
> *
>           NBIN = 0
>           DO 104 I = N+1, NTOT
>               NBIN = NBIN + 1
>               RBIN(NBIN) = (X(1,I) - C(1))**2 + (X(2,I) - C(2))**2 +
>      & (X(3,I) - C(3))**2
>               IBLIST(NBIN) = I
>  104 CONTINUE
> * Sort square distances with respect to the centre C.
>       CALL SORT1(NBIN,RBIN,IBLIST)
> *
>       END IF
> *
> * Determine the Lagrangian radii for specified mass fractions.
> * RLAGR = Lagrangian radius
> * AVMASS = average mass of a spherical shell with radius R2(I)
> * AVMRC = average mass inside of core radius RC
> * NPARTC = particle counter within a shell
> * NCORE = particle counter for the core
> * RC = Core radius (calculated in core.f)
>       SIGR2C = 0.0D0
>       SIGT2C = 0.0D0
>       VROTC = 0.0D0
>       AVMRC = 0.D0
>       RC2 = RC*RC
>       NCORE = 0
>       ZM = 0.0D0
>       ZMH = 0.5D0*ZMASS0
>       I = 0
> *
>       DO 15 J = 1,11
>          SIGR2(J) = 0.0D0
>          SIGT2(J) = 0.0D0
>          VROT(J) = 0.0D0
>          AVMASS(J) = 0.0D0
>          NPARTC(J) = 0
> *
>  20 I = I + 1
>          IM = JLIST(I)
>          ZM = ZM + BODY(IM)
> *
>          VRI = 0.D0
>          DO 25 K = 1,3
>  25 VRI = VRI + XDOT(K,IM)*(X(K,IM)-C(K))/DSQRT(R2(I))
>          VR2I = 0.D0
>          VT2I = 0.D0
>          DO 26 K = 1,3
>          VRADK = VRI*(X(K,IM)-C(K))/DSQRT(R2(I))
>          VR2I = VR2I + VRADK**2
>  26 VT2I = VT2I + (XDOT(K,IM) - VRADK)**2
> *
>          SIGR2(J) = SIGR2(J) + BODY(IM)*VR2I
>          SIGT2(J) = SIGT2(J) + BODY(IM)*VT2I/2.D0
> *
>          RR12 = X(1,IM)**2 + X(2,IM)**2
>          XR12 = 0.D0
>          DO 27 K = 1,2
>  27 XR12 = XR12 + XDOT(K,IM)*(X(K,IM)-C(K))
> *
>          VROT1 = XDOT(1,IM) - XR12/RR12*X(1,IM)
>          VROT2 = XDOT(2,IM) - XR12/RR12*X(2,IM)
> *
>          XSIGN = VROT1*X(2,IM)/DSQRT(RR12) - VROT2*X(1,IM)/DSQRT(RR12)
>          VROTM = DSQRT(VROT1**2+VROT2**2)
> *
>          IF(XSIGN.GT.0.D0) THEN
>          VROT(J) = VROT(J) + BODY(IM)*VROTM
>          ELSE
>          VROT(J) = VROT(J) - BODY(IM)*VROTM
>          END IF
> *
>          AVMASS(J) = AVMASS(J) + BODY(IM)
>          NPARTC(J) = NPARTC(J) + 1
> *
> * Independent determination of mass in core radius.
>          IF (R2(I) .LT. RC2) THEN
>             SIGR2C = SIGR2C + BODY(IM)*VR2I
>             SIGT2C = SIGT2C + BODY(IM)*VT2I/2.D0
>             VROTC = VROTC + BODY(IM)*VROTM
>             AVMRC = AVMRC + BODY(IM)
>             NCORE = NCORE + 1
>          END IF
> *
> * Check whether mass within Langrangian radius is complete.
>          IF (I.LT.N.AND.ZM.LT.FLAGR(J)*ZMASS0) GOTO 20
> *
>          RLAGR(J) = SQRT(R2(I))
>          SIGR2(J) = SIGR2(J)/AVMASS(J)
>          SIGT2(J) = SIGT2(J)/AVMASS(J)
>          VROT(J) = VROT(J)/AVMASS(J)
>          AVMASS(J) = AVMASS(J)/NPARTC(J)
>  15 CONTINUE
>       SIGR2C = SIGR2C/AVMRC
>       SIGT2C = SIGT2C/AVMRC
>       VROTC = VROTC/AVMRC
>       AVMRC = AVMRC/NCORE
> *
> * Determine half-mass radius separately.
69c159
<       ZMH = 0.5*ZMASS
---
>       ZMH = 0.5D0*ZMASS0
71c161
<    25 I = I + 1
---
>  30 I = I + 1
74,76c164,165
<       IF (ZM.LT.ZMH) GO TO 25
< *
< *       Replace approximate half-mass radius by actual value.
---
>       IF (ZM.LT.ZMH) GO TO 30
> * Replace approximate half-mass radius by actual value.
79,99c168,171
< *       Determine tidal radius and mass if kz(14) = 2.
<       if (kz(14).eq.2.and.tidal(1).ne.0.) then
<       I = np
<       mrt = zmass
<    30 continue
<       if (mrt.gt.0.) then
<          rt = (mrt/tidal(1))**(1./3.)
<       else
<          rt = 0.0
<       endif
<       IF (sqrt(r2(i)).gt.rt.and.rt.gt.0.and.i.gt.1) then
<          IM = JLIST(I)
<          Mrt = Mrt - BODY(IM)
<          i = i - 1
<          GO TO 30
<       endif
<       endif
< 
<       IF ((KZ(7).EQ.2.OR.KZ(7).EQ.4).AND.TTOT.GE.TPRINT) THEN
<           IF (KZ(14).EQ.2) WRITE (6,*)  tphys,mrt,rt
<       END IF
---
>       IF (KZ(8).GT.0 .OR. NBIN0.GT.0) THEN
> * Determine the Lagrangian radii for singles and binaries separately.
>       ZMS = 0.0D0
>       I = 0
101,104c173,179
<       IF (KZ(7).GE.3.AND.TTOT.GE.TPRINT) THEN
<           IF (KZ(14).EQ.2) WRITE (14,*)  tphys, mrt, rt
<    35     FORMAT (3X,'TIDAL RADIUS    TPHYS MRT RT ',F8.1,1P,2E10.2)
<       END IF
---
>       DO 251 J = 1, 11
>  201 I = I + 1
>          IM = ISLIST(I)
>          ZMS = ZMS + BODY(IM)
>          IF (I.LT.N-2*NPAIRS.AND.ZMS.LT.FLAGR(J)*ZMS0) GOTO 201
>          RSLAGR(J) = SQRT(RSNGL(I))
>  251 CONTINUE
106,110c181,182
< *       Check output options (line printer or unit 7 or both).
<       IF (KZ(7).EQ.2.OR.KZ(7).EQ.4.AND.TTOT.GE.TPRINT) THEN
<           WRITE (6,40)  (LOG10(RLAGR(K)),K=1,LX)
<    40     FORMAT (/,3X,'LAGR:  ',13F7.3)
<       END IF
---
>       ZMB = 0.0D0
>       I = 0
112,116c184,190
<       IF (KZ(7).GE.3.AND.TTOT.GE.TPRINT) THEN
<           WRITE (12,50)  TTOT, (LOG10(RLAGR(K)),K=1,LX)
<    50     FORMAT ('  LAGR:  ',F7.1,13F7.3)
<           CALL FLUSH(12)
<       END IF
---
>       DO 351 J = 1, 11
>  301 I = I + 1
>          IM = IBLIST(I)
>          ZMB = ZMB + BODY(IM)
>          IF (I.LT.NPAIRS.AND.ZMB.LT.FLAGR(J)*ZMB0) GOTO 301
>          RBLAGR(J) = SQRT(RBIN(I))
>  351 CONTINUE
118,125d191
<       IF (KZ(7).EQ.5.AND.TTOT.GE.TPRINT) THEN
<           WRITE (26,60)  TTOT, (DENS(K),K=1,LX)
<    60     FORMAT ('  DENSITY (T =',F6.1,'): ',1P,13E10.2)
<           WRITE (26,65)  (RM(K),K=1,LX)
<    65     FORMAT ('  DISTANCE:  ',1P,13E10.2)
<           WRITE (27,70)  TTOT, (VR(K),K=1,LX)
<    70     FORMAT ('  VELOCITY (T =',F6.1,'): ',1P,13E10.2)
<           WRITE (27,65)  (RM(K),K=1,LX)
127a194,236
>       if(rank.eq.0)then
> * Write on diagnostics (only until r_h).
>          IF (KZ(7).EQ.2 .OR. KZ(7).EQ.4) THEN
>           WRITE (6,40) ' TIME ',(FLAGR(K),K=1,11),' <RC'
>    40 FORMAT (/,3X,A6,' M/MT:  ',1P,11(1X,D9.2),A4)
>           WRITE (6,41) TTOT, (RLAGR(K),K=1,11),RC
>    41 FORMAT (3X,F6.1,' RLAGR: ',1P,12(1X,D9.2))
> *
>          IF (KZ(8).GT.0 .OR. NBIN0.GT.0) THEN
>           WRITE (6,401) TTOT, (RSLAGR(K),K=1,11)
>   401 FORMAT (3X,F6.1,' RSLAGR: ',1P,11(1X,D9.2))
>           WRITE (6,402) TTOT, (RBLAGR(K),K=1,11)
>   402 FORMAT (3X,F6.1,' RBLAGR: ',1P,11(1X,D9.2))
>          END IF
> *
>           WRITE (6,42) TTOT, (AVMASS(K),K=1,11),AVMRC
>    42 FORMAT (3X,F6.1,' AVMASS:',1P,12(1X,D9.2))
>           WRITE (6,43) TTOT, (NPARTC(K),K=1,11),NCORE
>    43 FORMAT (3X,F6.1,' NPARTC:',12I10)
>           WRITE (6,45) TTOT, (SIGR2(K),K=1,11),SIGR2C
>    45 FORMAT (3X,F6.1,' SIGR2: ',1P,12(1X,D9.2))
>           WRITE (6,46) TTOT, (SIGT2(K),K=1,11),SIGT2C
>    46 FORMAT (3X,F6.1,' SIGT2: ',1P,12(1X,D9.2))
>           WRITE (6,47) TTOT, (VROT(K),K=1,11),VROTC
>    47 FORMAT (3X,F6.1,' VROT:  ',1P,12(1X,D9.2))
> 
> 
>          END IF
>       end if
> * Write all data in binary format on unit 7.
> *
> 
> 
> 
>          IF (KZ(7).GE.3) THEN
>             WRITE (7) TTOT, (RLAGR(K),K=1,11),
>      & (AVMASS(K),K=1,11),(NPARTC(K),K=1,11),RC,AVMRC,NCORE
>          CALL FLUSH(7)
>          END IF
> 
> 
> 
> *
1,2c1,2
< 1074 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/levels.f
< nbody6compare/levels.f
---
> 4095 2003-06-23 21:03 /work/Umi2/spurzem/5/nbody6++compare/levels.f
> nbody6++compare/levels.f
5a6
> *       plus estimation of parallel speed-up (R.Sp.)
8c9,14
<       INTEGER  IHIST(32),IHISTR(32)
---
>       INTEGER JHIST,JHISTR,JHISTU
>       COMMON/BLKLVL/JHIST(0:NMAX),JHISTR(0:NMAX),JHISTU(0:NMAX)
>       INTEGER  IHIST(NMAX),IHISTR(NMAX),IHISTU(NMAX)
>       INTEGER IPES,IPROC(9),IY(1024),IYR(1024)
>       REAL*8 XSPEED(9),XSPEDR(9)
>       DATA IPROC/4,8,16,32,64,128,256,512,1024/
12c18
<       DO 10 J = 1,32
---
>       DO 10 J = 1,NMAX
14a21
>           IHISTU(J) = 0
18c25
<       JMAX = 0
---
>       JMAXI = 0
22d28
<           IF (BODY(I).EQ.0.0D0) GO TO 20
23a30
>           IF(J.GT.NMAX)J = NMAX
25c32
<           JMAX = MAX(J,JMAX)
---
>           JMAXI = MAX(J,JMAXI)
26a34
>           IF(J.GT.NMAX)J = NMAX
30a39,48
>       JMAXU = 0
> *       Loop over KS binaries
>       DO 25 IPAIR = 1,NPAIRS
>           I1 = 2*IPAIR - 1
>           J = 1 - LOG(STEP(I1))*FAC
>           IF(J.GT.NMAX)J = NMAX
>           IHISTU(J) = IHISTU(J) + 1
>           JMAXU = MAX(J,JMAXU)
>    25 CONTINUE
> *
32,40c50,131
<       JMAX = MIN(JMAX,27)
<       WRITE (6,30)  (IHIST(J),J=1,JMAX)
<    30 FORMAT (' #6  STEP   ',12I5,15I4)
< *
<       IF (KZ(33).GT.1) THEN
<           JMAXR = MIN(JMAXR,27)
<           WRITE (6,35)  (IHISTR(J),J=1,JMAXR)
<    35     FORMAT (' #7  STEPR  ',12I5,15I4)
<       END IF
---
>       JMAXI=MIN(JMAXI,NMAX)
>       JMAXR=MIN(JMAXR,NMAX)
>       JMAXU=MIN(JMAXU,NMAX)
>       if(rank.eq.0)then
> 	  WRITE (6,30)  (IHIST(J),J=1,JMAXI)
>    30 FORMAT (' STEP I ',22I5,(/,24I5))
>       IF (KZ(33).GT.1)WRITE (6,301)  (IHISTR(J),J=1,JMAXR)
>   301 FORMAT (' STEP R ',50I5,(/,24I5))
>       IF (KZ(8).GT.0 .OR. NBIN0.GT.0 )WRITE (6,3001)
>      *     (IHISTU(J),J=1,JMAXU)
>  3001 FORMAT (' STEP U ',50I5,(/,24I5))
>       end if
> *
> *       IPROC contains a list of possible processor numbers,
> *       presently   4 to 1024 in powers of 2.
> *
>       DO 35 NN = 1,9
>       IPES = IPROC(NN)
>       DO 36 I = 1,IPES
>       IY(I) = 0
>  36   IYR(I) = 0
> *
> *       JHIST contains accumulated frequencies from INTGRT for irr. steps. 
> *       JHIST(80) = 5 e.g. means that it occurred 5 times since the last
> *                   call of LEVELS that 80 force calculations had
> *                   to be done in parallel
> *       IY maps this information to a certain number of processors,
> *       e.g. in the above case for 64 processors it would mean that
> *       five times 64 processors could be fully used, and five times
> *       only 16 processors (to get the remaining forces).
> *       JHIST(80) = 5 results in incrementing IY(64) and IY(16) by 5.
> *
> *       (IYE, JHISTR do the same for the regular steps)
> *
>       DO 37 I = 1,NMAX
>       IF(JHIST(I).EQ.0)GOTO 37
>       J = MOD(I,IPES)
>       K = I/IPES
>       IF(J.GT.0)IY(J)=IY(J)+JHIST(I)
>       IF(K.GT.0)IY(IPES)=IY(IPES)+K*JHIST(I)
>  37   CONTINUE
> *
>       DO 371 I = 1,NMAX
>       IF(JHISTR(I).EQ.0)GOTO 371
>       J = MOD(I,IPES)
>       K = I/IPES
>       IF(J.GT.0)IYR(J)=IYR(J)+JHISTR(I)
>       IF(K.GT.0)IYR(IPES)=IYR(IPES)+K*JHISTR(I)
>  371  CONTINUE
> *
>       ISPEED = 0
>       ISPEDR = 0
>       ITOT = 0
>       ITOTR = 0
>       DO 38 I = 1,IPES
>       ISPEED = ISPEED + I*IY(I)
>       ISPEDR = ISPEDR + I*IYR(I)
>       ITOT = ITOT + IY(I)
>       ITOTR = ITOTR + IYR(I)
>  38   CONTINUE
> *
> *       Estimate theoretical speedup by (sum I*IY) / (sum IY);
> *       enumerator is the total number of force calculations necessary;
> *       denominator is the number of force calculation `cycles' necessary
> *       on a parallel machine. Separately done for regular/irregular
> *       steps. Communication not yet included in any way.
> *
>       IF(ITOT.NE.0)XSPEED(NN) = REAL(ISPEED)/REAL(ITOT)
>       IF(ITOTR.NE.0)XSPEDR(NN) = REAL(ISPEDR)/REAL(ITOTR)
>  35   CONTINUE
> *
> 	  if(rank.eq.0)then
>       WRITE (6,40)  (IPROC(J),XSPEED(J),J=1,9)
>  40   FORMAT (' Max Speedup Irr: ',1P,9(I5,D9.2))
>       WRITE (6,41)  (IPROC(J),XSPEDR(J),J=1,9)
>  41   FORMAT (' Max Speedup Reg: ',1P,9(I5,D9.2))
>       end if
> *
>       DO 50 J = 1,NMAX
>           JHIST(J) = 0
>           JHISTR(J) = 0
>    50 CONTINUE
1,2c1,2
< 443 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/matrix.f
< nbody6compare/matrix.f
---
> 443 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/matrix.f
> nbody6++compare/matrix.f
1,2c1,2
< 19782 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/mdot.f
< nbody6compare/mdot.f
---
> 19504 2006-06-18 08:32 /work/Umi2/spurzem/5/nbody6++compare/mdot.f
> nbody6++compare/mdot.f
1d0
< 
48,49c47
<           IF ((BODY(I).GT.BODY1.AND.NAME(I).GE.0).OR.NAME(I).EQ.0.OR.
<      &        BODY(I).LE.0.0) THEN
---
>           IF (BODY(I).GT.BODY1.OR.NAME(I).EQ.0.OR.BODY(I).LE.0.0) THEN
96c94,95
<                   WRITE (6,22)  IGHOST, I0, I, NAME(I), KSTAR(I), TEV(I)
---
>                   if(rank.eq.0)
>      &            WRITE (6,22)  IGHOST, I0, I, NAME(I), KSTAR(I), TEV(I)
150c149,150
<               WRITE (6,30)  I, NAME(I), KSTAR(I1), KSTAR(I2), KSTAR(I),
---
>               if(rank.eq.0)
>      &        WRITE (6,30)  I, NAME(I), KSTAR(I1), KSTAR(I2), KSTAR(I),
218,228d217
< *       Check that mass loss does not exceed the envelope mass.
<          IF (KSTAR(I).LT.10) THEN
<             DML = MAX(M1 - MC,1.0D-07)
<             IF (DML.LT.DM) THEN
<                DT = (DML/DM)*DT
<                DM = DML
< *       Ensure correction for the last small mass loss (avoids looping).
<                DMR = 0.011
<             END IF
<          END IF
< *
252,254c241,243
<           WRITE (6,35)  NAME(I), KW, DM, AGE, AGE - TN
<    35     FORMAT (' WARNING!    AGE > TN    NM KW DMS AGE AGE-TN ',
<      &                                      I6,I4,F7.3,1P,2E10.2)
---
> *         if(rank.eq.0) WRITE (6,35)  NAME(I), KW, DM, AGE, TN
> *  35     FORMAT (' WARNING!    AGE > TN    NM KW DMS AGE TN ',
> *    &                                      I6,I4,F7.3,1P,2E9.1)
418c407,408
<               WRITE (6,40)  I, NAME(I), KW, KSTAR(I), BODY(I)*ZMBAR,
---
>               if(rank.eq.0)
>      &        WRITE (6,40)  I, NAME(I), KW, KSTAR(I), BODY(I)*ZMBAR,
521c511
<       TEV(I) = TEV(I) + DTM
---
>       TEV(I) = TEVK + DTM
524,525c514,515
< *       Update epoch at every new look-up time (prevents AGE > TPHYS).
< *     IF (KW.NE.KW0) THEN
---
> *       Update epoch on transition to new type.
>       IF (KW.NE.KW0) THEN
527c517
< *     END IF
---
>       END IF
543,544c533,535
<           WRITE (6,65)  WHICH1, TPHYS, I, NAME(I), DMR, KW0, KW,
<      &                  M0, M1, RADIUS(I)*SU, EMDOT
---
>           if(rank.eq.0)
>      &    WRITE (6,65)  WHICH1, TPHYS, I, NAME(I), DMR, KW0, KW,
>      &                  M0, M1, RADIUS(I)/SU, EMDOT
546c537
<      &                        F7.1,2I5,F6.2,2I3,2F6.1,1P,E9.1,0P,F10.5)
---
>      &            F7.1,2I8,1P,E10.2,2I3,0P,2F6.1,1P,E9.1,0P,F10.5)
565c556,557
<                   WRITE (6,66)  KW, SQRT(ECC2), RA, SEMI*SU, STEP(J),
---
>                   if(rank.eq.0)
>      &            WRITE (6,66)  KW, SQRT(ECC2), RA, SEMI*SU, STEP(J),
605a598,599
> 
> 
1,2c1,2
< 9649 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/merge2.f
< nbody6compare/merge2.f
---
> 9317 2003-06-25 21:22 /work/Umi2/spurzem/5/nbody6++compare/merge2.f
> nbody6++compare/merge2.f
39,48d38
< *       Select deepest level as primary in case of two hierarchies.
<       IF (NAME(N+KSPAIR).LT.0.AND.NAME(JCOMP).LT.0) THEN
< *       Note possibility of a quartet (or even quintet) and triple.
<           IF (NAME(JCOMP).LT.NAME(N+KSPAIR)) THEN
<               K = KSPAIR
<               KSPAIR = JCOMP - N
<               JCOMP = N + K
<           END IF
<       END IF
< *
57,58d46
<       ECC2 = (1.0 - R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
<       ECC = SQRT(ECC2)
60c48
< *       Produce diagnostics for [[B,S],B] quintuplet or sextuplet system.
---
> *       Produce diagnostics for quintuplet or sextuplet system.
65a54,55
>           E2 = (1.0 - R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
>           ECC = SQRT(E2)
74c64,65
<           WRITE (6,5)  WHICH1, TIME+TOFF, ZM, NAME(I1), NAME(I2),
---
>           if(rank.eq.0)
>      &    WRITE (6,5)  WHICH1, TIME+TOFF, ZM, NAME(I1), NAME(I2),
80c71
< *       Check formation of [[B,S],S] quartet or [[B,B],S] quintuplet.
---
> *       Check formation of [[B,S],S} quartet or [[B,B],S] quintuplet.
85,88c76,80
<               WRITE (6,7)  TIME+TOFF, ZM, NAME(I1), NAME(I2),
<      &                     NAME(JCOMP), ECC, SEMI, PCRIT, GAMMA(IPAIR)
<     7         FORMAT (/,' NEW QUARTET    T MT NM1 NMG NM3 E0 A0 PC G0 ',
<      &                                   F9.2,F6.2,3I6,F6.2,1P,3E10.2)
---
>               if(rank.eq.0)
>      &        WRITE (6,7)  TIME+TOFF, ZM, NAME(I2), NAME(JG),
>      &                     NAME(JCOMP), SEMI, PCRIT, GAMMA(IPAIR)
>     7         FORMAT (/,' NEW QUARTET    T MT NM1 NMG NM3 A0 PC G0 ',
>      &                                   F9.2,F6.2,3I6,1P,3E10.2)
90,93c82,86
<               WRITE (6,8)  TIME+TOFF, ZM, NAME(I1), NAME(I2),
<      &                     NAME(JCOMP), ECC, SEMI, PCRIT, GAMMA(IPAIR)
<     8         FORMAT (/,' NEW QUINTUP2    T MT NM1 NMG NM3 E0 A0 PC G0',
<      &                                    F10.2,F6.2,3I6,F6.2,1P,3E10.2)
---
>               if(rank.eq.0)
>      &        WRITE (6,8)  TIME+TOFF, ZM, NAME(I2), NAME(JG),
>      &                     NAME(JCOMP), SEMI, PCRIT, GAMMA(IPAIR)
>     8         FORMAT (/,' NEW QUINTUP2    T MT NM1 NMG NM3 A0 PC G0 ',
>      &                                    F9.2,F6.2,3I6,1P,3E10.2)
97c90
< *       Include diagnostics for double triple as [[B,S],[B,S]].
---
> *       Include diagnostics for double triple ([[B,S],[B,S]]).
107,108c100,102
<           WRITE (6,10)  TIME+TOFF, ZM, NAME(I1), NAME(I2), NAME(J1),
<      &                  NAME(2*JPAIR), ECC, AI, AJ, R(IPAIR), R(JPAIR),
---
>           if(rank.eq.0)
>      &    WRITE (6,10)  TIME+TOFF, ZM, NAME(I1), NAME(I2), NAME(J1),
>      &                  NAME(2*JPAIR), AI, AJ, R(IPAIR), R(JPAIR),
110,111c104,105
<    10     FORMAT (/,' NEW HITRIP    T MT NM E0 AI AJ RI RJ PC GX ',
<      &                              F9.2,F6.2,4I6,F6.2,1P,6E10.2)
---
>    10     FORMAT (/,' NEW HITRIP    T MT NM AI AJ RI RJ PC GX ',
>      &                              F9.2,F6.2,4I6,1P,6E10.2)
145a140,144
> *       Update the primary velocity of body #JCOMP.
>       DO 15 K = 1,3
>           X0DOT(K,JCOMP) = XDOT(K,JCOMP)
>    15 CONTINUE
> *
163,167d161
< *       Predict outer component to highest order if not on the block.
<       IF (TIME - T0(JCOMP1).GT.0.0D0) THEN
<           CALL XVPRED(JCOMP1,-1)
<       END IF
< *
279a274,275
> 
> 
1,2c1,2
< 9126 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/merge.f
< nbody6compare/merge.f
---
> 9106 2003-06-25 17:29 /work/Umi2/spurzem/5/nbody6++compare/merge.f
> nbody6++compare/merge.f
232,233c232
<           FAC = NNBMAX/NNB
<           FAC = MIN(FAC,4.0D0)
---
>           FAC = FLOAT(NNBMAX)/FLOAT(NNB)
250d248
< 
255d252
< *
1,2c1,2
< 6352 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/mloss.f
< nbody6compare/mloss.f
---
> 6392 2005-03-09 16:25 /work/Umi2/spurzem/5/nbody6++compare/mloss.f
> nbody6++compare/mloss.f
154c154,155
<       WRITE (6,30)  NAME(IMAX), BMAX, BMAX*ZMBAR, ZMDOT, DE, BE(3),
---
>       if(rank.eq.0)
>      &WRITE (6,30)  NAME(IMAX), BMAX, BMAX*ZMBAR, ZMDOT, DE, BE(3),
167c168,169
<       WRITE (6,45)  IMAX, DE, TEV1, A0, SQRT(VI2), BE(3)
---
>       if(rank.eq.0)
>      &WRITE (6,45)  IMAX, DE, TEV1, A0, SQRT(VI2), BE(3)
1,2c1,2
< 1818 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/mlwind.f
< nbody6compare/mlwind.f
---
> 1785 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/mlwind.f
> nbody6++compare/mlwind.f
29d28
<             p0 = MIN(p0,2000.d0)
1,2c1,2
< 2410 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/modify.f
< nbody6compare/modify.f
---
> 2120 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/modify.f
> nbody6++compare/modify.f
0a1,4
> # 1 "modify.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "modify.F"
4,5c8,9
< *       Parameter modification at restart.
< *       ----------------------------------
---
> * Parameter modification at restart.
> * ----------------------------------
9a14
> # 19 "modify.F"
11c16
< *       Read first, second or both lines (KSTART = 3, 4, 5).
---
> * Read first, second or both lines (KSTART = 3, 4, 5).
14,15c19,22
< *       Read new DTADJ, DELTAT, TADJ, TNEXT, TCRIT, QE & KZ(J) (if > 0).
<       READ (5,*)  DTA, DT, TA, TN, TC, QE1, J, K
---
> * Read new DTADJ, DELTAT, TADJ, TNEXT, TCRIT, QE & KZ(J) (if > 0).
>       if(rank.eq.0)then
>       READ (5,*) DTA, DT, TA, TN, TC, QE1, J, K
>       end if
17c24,26
< *       Copy old parameters if corresponding input is zero.
---
> # 38 "modify.F"
> *
> * Set new parameters if corresponding input is non-zero.
19a29,30
>       ELSE
>           DTA = DTA
23a35,36
>       ELSE
>           DT = DT
43c56
< *       See whether any options should be changed.
---
> * See whether any options should be changed.
46,49c59,60
<       WRITE (6,5)  DTADJ, DELTAT, TCRIT, QE, J, K
<     5 FORMAT (///,7X,'RESTART PARAMETERS:   DTADJ =',F7.3,'  DELTAT =',
<      &                            F7.3,'  TCRIT =',F7.1,'  QE =',1PE9.1,
<      &                                            '  KZ(',I2,') =',I2,/)
---
>       if(rank.eq.0)WRITE (6,5) J, K
>     5 FORMAT (
51c62
< *       Read new ETAI, ETAR, ETAU, DTMIN, RMIN, NCRIT (if > 0 & KSTART >= 4).
---
> * Read new ETAI, ETAR, ETAU, DTMIN, RMIN (IF > 0 & KSTART = 4 or 5).
53c64,67
<           READ (5,*)  ETA1, ETA2, ETA3, DTM, RM, NEWCR
---
>           if(rank.eq.0)then
>           READ (5,*) ETA1, ETA2, ETA3, DTM, RM, NNBO
>           end if
> # 88 "modify.F"
55c69
< *       Check modification of integration parameters.
---
> * Check modification of integration parameters.
68c82
<           IF (NEWCR.GT.0) NCRIT = NEWCR
---
>           IF (NNBO.GT.0) NNBOPT = NNBO
70,73d83
<           WRITE (6,15)  ETAI, ETAR, ETAU, DTMIN, RMIN, NCRIT
<    15     FORMAT (/,7X,'RESTART PARAMETERS:   ETAI =',F7.3,'  ETAR =',
<      &                        F7.3,'  ETAU =',F7.3,'  DTMIN =',1P,E9.1,
<      &                             '  RMIN =',E9.1,'  NCRIT =',0P,I5,/)
76c86
< *       Perform a simple validation check on main input parameters.
---
> * Perform a simple validation check on main input parameters.
79c89
< *       Save the new parameters on tape/disc unit #1 just in case.
---
> * Save the new parameters on tape/disc in case a restart is needed.
1,2c1,2
< 1179 2006-09-02 12:38 /work/Umi2/spurzem/5/nbody6compare/mydump.f
< nbody6compare/mydump.f
---
> 1773 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/mydump.f
> nbody6++compare/mydump.f
0a1,4
> # 1 "mydump.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "mydump.F"
4,5c8,9
< *       COMMON save or read.
< *       --------------------
---
> * COMMON save or read.
> * --------------------
8,20c12,28
<       PARAMETER  (NA=96*NMAX,NB=111*KMAX+7,
<      &            NC=(LMAX+2)*NMAX+3*KMAX+MLR+MLD+MLV+64,
<      &            NF=41*MMAX,NG=11*NMAX+126,NH=20*MCL+16,
<      &            NO=24*NMAX,NP=2*NMAX+84)
<       REAL*4  A,B,E,F,G,H,O,P,Q,PL
<       INTEGER  IC,ID,IR
< *
< *
<       COMMON/NBODY/  A(NA)
<       COMMON/PAIRS/  B(NB)
<       COMMON/NAMES/  IC(NC)
<       COMMON/COUNTS/ ID(60)
<       COMMON/PARAMS/ E(330)
---
>       IMPLICIT REAL*8 (A-H,O-Z)
>       PARAMETER (NA=(16*ID+6)*NMAX,NB=65*KMAX+4,
>      & NC=(LMAX+3)*NMAX+3*KMAX+MLR+MLD+MLV+75,ND=71,
>      & NE=163,NF=21*MMAX,NG=5*NMAX+NMAX/2+63,NH=10*MCL+8,
>      & NO=(4*ID+1)*NMAX,NP=66,NQ=2*NMAX+5*LMAX,
>      & NR=3*NMAX,NS=17)
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
>       REAL*8 A,B,E,F,G,H,O,P,R,S
>       INTEGER IC,IDD,IR,IQ
> *
>       COMMON/NBODY/ A(NA)
>       COMMON/PAIRS/ B(NB)
>       COMMON/NAMES/ IC(NC)
>       COMMON/COUNTS/ IDD(ND)
>       COMMON/PARAMS/ E(NE)
22c30,32
<       COMMON/STARS/  G(NG)
---
> C Take note that G=real*8, and some members of it (in common6.h)
> C are integer, is. these only add as half words.
>       COMMON/STARS/ G(NG)
24c34
<       COMMON/RAND2/  IR(99)
---
>       COMMON/RAND/ IR(99)
27,28c37,52
<       COMMON/GALAXY/ Q(40)
<       COMMON/PLPOT/  PL(24)
---
>       COMMON/LISTS/ IQ(NQ)
>       COMMON/WORK2/ R(NR)
>       COMMON/TIMING/ S(NS)
> *
> * Open unit #J by reading dummy and rewinding.
> C GLOBAL_UNIT = J
> 
> 
> 
>          CALL FILE_INIT(J)
>          REWIND J
>          READ (J,ERR=10,END=10) DUMMY
>  10 REWIND J
> 
> 
> 
29a54,55
> * Read or save all COMMON variables (valid for tape or disc).
>       IF (I.EQ.0) THEN
31,34c57,61
< *       Open unit #J by reading dummy and rewinding.
<       REWIND J
<       READ (J,ERR=10,END=10)  DUMMY
<    10 REWIND J
---
> 
> 
> 
>             READ (J) A, B, IC, IDD, E, F, G, H, IR, O, P, IQ, R, S
> # 83 "mydump.F"
36,38d62
< *       Read or save all COMMON variables (valid for tape or disc).
<       IF (I.EQ.0) THEN
<           READ (J)   A, B, IC, ID, E, F, G, H, IR, O, P, Q, PL
40c64,68
<           WRITE (J)  A, B, IC, ID, E, F, G, H, IR, O, P, Q, PL
---
> *
> 
> 
> 
>           WRITE (J) A, B, IC, IDD, E, F, G, H, IR, O, P, IQ, R, S
42a71,74
> 
> 
> 
> *
43a76,82
> * Write transition data IC(62) = KZ(39)
> * IF(IC(62).EQ.1)THEN
> * IARG = 1
> * CALL WTRANS(IARG)
> * IARG = 2
> * CALL WTRANS(IARG)
> * END IF
1,2c1,2
< 10229 2006-09-02 17:02 /work/Umi2/spurzem/5/nbody6compare/nbint.f
< nbody6compare/nbint.f
---
> 8753 2005-03-09 18:57 /work/Umi2/spurzem/5/nbody6++compare/nbint.f
> nbody6++compare/nbint.f
1c1
<       SUBROUTINE NBINT(I,IKS,IR,XI,XIDOT)
---
>       SUBROUTINE NBINT(I,NBFLAG)
9a10,11
> *       Calculate potential with little extra cost.
>       COMMON/POTENT/PHII(NMAX),PHIR(NMAX),PHIR1(NMAX)
11a14,35
>           IF(NBFLAG.EQ.0)THEN
> *       Predict current state vector of body #I to order FDOT.
>           S = TIME - T0(I)
>           DO 11 K = 1,3
>            X(K,I) = ((FDOT(K,I)*S + F(K,I))*S + X0DOT(K,I))*S + X0(K,I)
>            XDOT(K,I) = (3.0*FDOT(K,I)*S + 2.0*F(K,I))*S + X0DOT(K,I)
>    11     CONTINUE
> *       Predict coordinates & velocities of neighbours to order FDOT (R.Sp.).
>           NNB1 = LIST(1,I) + 1
> *
>           DO 1 L = 2,NNB1
>               J = LIST(L,I)
>               S = TIME - T0(J)
>               S1 = 1.5*S
>               S2 = 2.0*S
>               X(1,J) = ((FDOT(1,J)*S + F(1,J))*S +X0DOT(1,J))*S +X0(1,J)
>               X(2,J) = ((FDOT(2,J)*S + F(2,J))*S +X0DOT(2,J))*S +X0(2,J)
>               X(3,J) = ((FDOT(3,J)*S + F(3,J))*S +X0DOT(3,J))*S +X0(3,J)
>               XDOT(1,J) = (FDOT(1,J)*S1 + F(1,J))*S2 + X0DOT(1,J)
>               XDOT(2,J) = (FDOT(2,J)*S1 + F(2,J))*S2 + X0DOT(2,J)
>               XDOT(3,J) = (FDOT(3,J)*S1 + F(3,J))*S2 + X0DOT(3,J)
>    1      CONTINUE
13,17d36
< *       Check regularization criterion for single particles.
<       IF (STEP(I).LT.DTMIN.AND.I.LE.N) THEN
< *       See whether dominant body can be regularized.
<           IF (IKS.EQ.0) THEN
<               CALL SEARCH(I,IKS)
19c38,40
<       END IF
---
> *         call cputim(tt2)
> *         ttpre = ttpre + (tt2-tt1)*60.
> *         ttnbp = ttnbp + (tt2-tt1)*60.
21,46c42
< *       Include close encounter search for low-eccentric massive binaries.
<       IF (IKS.EQ.0.AND.STEP(I).LT.4.0*DTMIN) THEN
< *       Consider massive single bodies in absence of subsystems. 
<           IF (I.LE.N.AND.BODY(I).GT.2.0*BODYM.AND.NSUB.EQ.0) THEN
< *
< *       Obtain two-body elements and relative perturbation.
<               JMIN = 0
<               CALL ORBIT(I,JMIN,SEMI,ECC,GI)
< *
<               EB = -0.5*BODY(I)*BODY(JMIN)/SEMI
<               IF (EB.LT.EBH.AND.GI.LT.0.25.AND.JMIN.GE.IFIRST) THEN
<                   APO = SEMI*(1.0 + ECC)
< *       Check eccentricity (cf. max perturbation) and neighbour radius.
<                   IF (ECC.LT.0.5.AND.APO.LT.0.02*RS(I)) THEN
< *                     WRITE (6,3)  NAME(I), NAME(JMIN), ECC, SEMI, EB
< *   3                 FORMAT (' KS TRY:    NAM E A EB ',
< *    &                                     2I6,F7.3,1P,2E10.2)
<                       IKS = IKS + 1
<                       ICOMP = I
<                       JCOMP = JMIN
<                   END IF
<               END IF
<           END IF
<       END IF
< *
< *       Obtain total force & first derivative.
---
> *       Obtain irregular force & first derivative.
52a49,50
>           PHII(I) = 0.D0
>           NNB0 = LIST(1,I)
55d52
<       NNB0 = LIST(1,I)
74,75d70
<       I2 = 2*IPAIR
<       I1 = I2 - 1
78c73
<       IF (LIST(1,I1).GT.0) THEN
---
>       IF (GAMMA(IPAIR).GE.GMIN) THEN
84,91d78
< *       Copy c.m. coordinates & velocities for rare unperturbed intruder.
<       DO 15 K = 1,3
<           X(K,I1) = XI(K)
<           X(K,I2) = XI(K)
<           XDOT(K,I1) = XIDOT(K)
<           XDOT(K,I2) = XIDOT(K)
<    15 CONTINUE
< *
115d101
< *
118a105
>           PHII(I) = PHII(I) - DR3I*RIJ2
147d133
< *         KDUM = 2*J - 1
177a164,165
> *       Note: in NBODY6++ CHFIRR and FCHAIN are called with IR=1 since
> *             chain prediction and perturber list are updated in integrator.
179c167
<               CALL CHFIRR(I,0,XI,XIDOT,FIRR,FD)
---
>               CALL CHFIRR(I,1,XI,XIDOT,FIRR,FD)
186c174
<                       CALL FCHAIN(I,0,XI,XIDOT,FIRR,FD)
---
>                       CALL FCHAIN(I,1,XI,XIDOT,FIRR,FD)
190c178
<       END IF 
---
>       END IF
197c185
<           CALL XTRNLF(XI,XIDOT,FIRR,FREG,FD,FDUM,0)
---
>           CALL XTRNLF(I,XI,XIDOT,FIRR,FREG,FD,FDUM,0)
200c188
< *       Include the corrector and set new T0, F, FDOT, D1, D2 & D3.
---
> *       Include the corrector and set new F, FDOT, D1, D2 & D3.
203,204c191,192
<       DT6 = 6.0D0/(DT*DTSQ)
<       DT2 = 2.0D0/DTSQ
---
>       DT6 = 6.0/(DT*DTSQ)
>       DT2 = 2.0/DTSQ
207d194
<       T0(I) = TIME
213,220c200,204
< 	  AT3 = 2.0D0*DF + DT*SUM
< 	  BT2 = -3.0D0*DF - DT*(SUM + FID)
< *
< 	  X0(K,I) = XI(K) + (0.6D0*AT3 + BT2)*DTSQ12
< 	  X0DOT(K,I) = XIDOT(K) + (0.75D0*AT3 + BT2)*DT13
< *
< *         X0(K,I) = X(K,I)
< *         X0DOT(K,I) = XDOT(K,I)
---
> 	  AT3 = 2.0*DF + DT*SUM
> 	  BT2 = -3.0*DF - DT*(SUM + FID)
> *       Use here new variables for consistency in parallel execution (R.Sp.)
>           XN(K,I) = XI(K) + (0.6*AT3 + BT2)*DTSQ12
>           XNDOT(K,I) = XIDOT(K) + (0.75*AT3 + BT2)*DT13
222,223c206,207
< 	  FI(K,I) = FIRR(K)
< 	  FIDOT(K,I) = FD(K)
---
>       FI(K,I) = FIRR(K)
>       FIDOT(K,I) = FD(K)
227,230c211,212
<           D0(K,I) = FIRR(K)
<           D1(K,I) = FD(K)
< 	  D2(K,I) = (3.0D0*AT3 + BT2)*DT2
< 	  D3(K,I) = AT3*DT6
---
>           D2(K,I) = (3.0*AT3 + BT2)*DT2
>           D3(K,I) = AT3*DT6
232c214
<    80 CONTINUE
---
>    80 continue
235c217
<       IF (KZ(37).EQ.0) THEN
---
>         IF (KZ(37).EQ.0) THEN
237c219
<       ELSE
---
>         ELSE
239,244c221
<       END IF
< *
< *       Check reduction by 1/sqrt(2) for soft binaries (including triples).
<       IF (TTMP.LT.10.0*DTMIN.AND.TTMP.GT.DTMIN) THEN
<           TTMP = 0.707*TTMP
<       END IF
---
>         END IF
246a224,243
> *       Winston Sweatman's suggestion
> *     DVV = (XDOT(1,I)-X0DOT(1,I))**2 + (XDOT(2,I)-X0DOT(2,I))**2 +
> *    &     (XDOT(3,I)-X0DOT(3,I))**2
> *     FFD = FIRR(1)**2 + FIRR(2)**2 + FIRR(3)**2
> *     ETAIW = ETAI
> *     TTMPW = ETAIW*DVV*BODY(I)/FFD
> *
> *     PRINT*,' irr I=',I,' TTMP,TTMPW,RATIO=',
> *    &  TTMP,TTMPW,TTMP/TTMPW
> *
> *     IF(TTMP.GT.TTMPW)THEN
> *     IGT = IGT + 1
> *     ELSE
> *     ILE = ILE + 1
> *     END IF
> *     IF(MOD(IGT+ILE,100).EQ.0)PRINT*,' irr IGT,ILE=',IGT,ILE
> *
> *     TTMP = MAX(TTMPW,TTMP)
> *     DT0 = TTMP
> *
257,269d253
< *       Include convergence test for large step (cf. Makino, Ap.J. 369, 200).
<       IF (TTMP.GT.STEPJ.AND.N.GT.1000) THEN
<          DV2 = 0.0
<          F2 = 0.0
<          DO 85 K = 1,3
<             DV2 = DV2 + (XDOT(K,I) - X0DOT(K,I))**2
<             F2 = F2 + FIRR(K)**2
<    85    CONTINUE
< *       Employ Jun's criterion to avoid over-shooting (cf. Book, 2.16).
<          DTJ = STEP(I)*(1.0D-06*STEP(I)**2*F2/DV2)**0.1
<          TTMP = MIN(TTMP,DTJ)
<       END IF
< *
272,273c256,257
<           IF (DMOD(TIME,2.0*STEP(I)).EQ.0.0D0) THEN 
<               TTMP = MIN(2.0*STEP(I),1.0D0)
---
>           IF (DMOD(TIME,2.0*STEP(I)).EQ.0.0D0) THEN
>               TTMP = MIN(2.0*STEP(I),1.D0)
275c259
<               TTMP = STEP(I) 
---
>               TTMP = STEP(I)
279,280c263,264
<           IF (TTMP.GT.DT0) THEN
<               TTMP = 0.5*TTMP
---
>             IF (TTMP.GT.DT0) THEN
>                 TTMP = 0.5*TTMP
286d269
< *       Set new block step and update next time.
288,319d270
<       TIMENW(I) = STEP(I) + T0(I)
< *
< *       See whether any KS candidates are in the same block as body #I.
<       IF (IKS.GT.0.AND.I.EQ.ICOMP) THEN
< *       Accept same time, otherwise reduce STEP(ICOMP) and/or delay.
<           IF (T0(JCOMP).EQ.T0(ICOMP)) THEN
<               ICOMP = MIN(ICOMP,JCOMP)
<               JCOMP = MAX(I,JCOMP)
<           ELSE IF (T0(JCOMP) + STEP(JCOMP).LT.T0(ICOMP)) THEN
<               STEP(ICOMP) = 0.5D0*STEP(ICOMP)
<               TIMENW(ICOMP) = STEP(ICOMP) + T0(ICOMP)
<               IKS = 0
<           ELSE
<               IKS = 0
<           END IF
<       END IF
< *
< *       See whether total force & derivative needs updating.
<       IF (IR.EQ.0) THEN
< *       Extrapolate regular force & first derivatives to obtain F & FDOT.
<           DTR = TIME - T0R(I)
<           DO 90 K = 1,3
<               F(K,I) = 0.5D0*(FRDOT(K,I)*DTR + FR(K,I) + FIRR(K))
<               FDOT(K,I) = ONE6*(FRDOT(K,I) + FD(K))
<    90     CONTINUE
<       END IF
< *
< *       Increase step counter and count perturbed c.m. steps.
<       NSTEPI = NSTEPI + 1
<       IF (I.GT.N) THEN
<           IF (LIST(1,2*IPAIR-1).GT.0) NSTEPB = NSTEPB + 1
<       END IF
1,2c1,2
< 3307 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/nblist.f
< nbody6compare/nblist.f
---
> 3173 2003-06-24 03:52 /work/Umi2/spurzem/5/nbody6++compare/nblist.f
> nbody6++compare/nblist.f
18,23c18
< *       Note possible large RS0 set in routine MERGE at later times.
<           IF (TIME.EQ.0.0D0) THEN
<               RS2 = RS2*(1.0 + RI2)
<           ELSE
<               RS2 = (0.3*RSCALE)**2*(1.0 + RI2)
<           END IF
---
>           RS2 = RS2*(1.0 + RI2)
44c39,40
<               IF (TIME.LE.0.0D0.AND.J.LE.2*NBIN0) GO TO 6
---
>               IF (TIME.LE.0.0D0.AND.(KZ(8).GT.0 .OR. NBIN0.GT.0).AND.
>      &            J.LE.2*NBIN0) GO TO 6
105a102
> 
1,2c1,2
< 2624 2006-09-08 12:44 /work/Umi2/spurzem/5/nbody6compare/nbody6.f
< nbody6compare/nbody6.f
---
> 4712 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/nbody6.f
> nbody6++compare/nbody6.f
1,14c1,19
< *
< *             N B O D Y 6
< *             ***********
< *
< *       Regularized AC N-body code with triple & binary collisions.
< *       -----------------------------------------------------------
< *
< *       Hermite integration scheme with block-steps (V 6.1.0 Sep/06).
< *       -------------------------------------------------------------
< *
< *       Developed by Sverre Aarseth, IOA, Cambridge.
< *       ............................................
< *
<       PROGRAM NBODY6
---
> # 1 "nbody6.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "nbody6.F"
>         PROGRAM NBODY6
> *
> * N B O D Y 6++
> * *************
> *
> * Regularized AC N-body code with triple & binary collisions.
> * --------------------------------------------------------
> *
> * Hermite integration scheme with block-steps (V 4.0.0 April/99).
> * ------------------------------------------------------------------
> *
> * Developed by Sverre Aarseth, IOA, Cambridge.
> * ............................................
> * Message Passing Version NBODY6++ for Massively Parallel Systems
> * Developed by Rainer Spurzem, ARI, Heidelberg
16a22
>       COMMON/STSTAT/ TINIT,NIR,NIB,NRGL,NKS
18a25,28
> # 39 "nbody6.F"
> *
> * Initialize the timer.
>       CALL CPUTIM(ttota)
20,21c30,32
< *       Initialize the timer.
<       CALL CPUTIM(CPU0)
---
> * Read start/restart indicator & CPU time.
>       IF(rank.eq.0)READ (5,*) KSTART, TCOMP, TCRITp,
>      * isernb,iserreg
23,24c34
< *       Read start/restart indicator & CPU time.
<       READ (5,*)  KSTART, TCOMP
---
> # 58 "nbody6.F"
28c38
< *       Read input parameters, perform initial setup and obtain output.
---
> * Read input parameters, perform initial setup and obtain output.
30a41
>           call cputim(tt7)
31a43,44
>           call cputim(tt8)
>           ttadj = ttadj + (tt8-tt7)*60.
34c47
< *       Read previously saved COMMON variables from tape/disc on unit 1.
---
> * Read previously saved COMMON variables from tape/disc on unit 1.
35a49
> *
37c51
< *       Safety indicator preventing repeated restarts set in routine CHECK.
---
> * Safety indicator preventing repeated restarts set in routine CHECK.
40c54
< *       Set IPHASE = -1 for new NLIST in routine INTGRT (Hermite version).
---
> * Set IPHASE = -1 for new NLIST in routine INTGRT (Hermite version).
43,46c57,58
< *       Initialize evolution parameters which depend on metallicity.
<           IF (KZ(19).GE.3) THEN
<               CALL ZCNSTS(ZMET,ZPARS)
<           END IF
---
> * Initialize evolution parameters which depend on metallicity.
>           CALL ZCNSTS(ZMET,ZPARS)
48c60
< *       Check reading modified restart parameters (KSTART = 3, 4 or 5).
---
> * Check reading modified restart parameters (KSTART = 3, 4 or 5).
51a64,85
> *
> * Open all other files.
>           CALL FILE_INIT(0)
> *
> * If no explicit new TCRIT given just go for another TCRIT of common block.
>       TTOT = TIME + TOFF
>       TCRIT = TTOT + TCRIT
>       if(rank.eq.0)then
>       WRITE (6,10) TTOT/TCR0, TIME/TCR0, TCRIT/TCR0, TTOT, TIME, TCRIT
>       WRITE (6,20) DTADJ, DELTAT, TADJ, TNEXT, TCRIT, QE
>       WRITE (6,30) ETAI, ETAR, ETAU, DTMIN, RMIN, NNBOPT
>    10 FORMAT (' START AT TTOT/TIME ',2F16.8,' STOP INTENDED AT ',
>      & F16.8,' TCR0',/,' START AT TTOT/TIME ',2F16.8,
>      & ' STOP INTENDED AT ',F16.8,' NBODY-UNITS ',/)
>    20 FORMAT (/,7X,'RESTART PARAMETERS:   DTADJ =',F7.3,'  DELTAT =',
>      & F7.3,'   TADJ =',F7.3,'   TNEXT =',
>      & F7.3,'  TCRIT =',F7.1,'  QE =',1PE9.1)
>    30 FORMAT (/,7X,'                      ETAI =',F7.3,'  ETAR =',
>      & F7.3,'  ETAU =',F7.3,'  DTMIN =',1PE9.1,
>      & '  RMIN =',E9.1,' NNBOPT =',I5,/)
>       end if
> *
54,55c88,104
< *       Advance solutions until next output or change of procedure.
<     1 CALL INTGRT
---
> * (R.Sp.)Set time flag and step number flags for beginning of run
>       TINIT = TTOT
>       NIR = NSTEPI
>       NIB = NSTEPB
>       NRGL = NSTEPR
>       NKS = NSTEPU
> *
>       call cputim(tt2)
>       ttinit = ttinit + (tt2-ttota)*60.
> * Advance solutions until next output or change of procedure.
>     1 CONTINUE
>       call cputim(tt1)
> *
>       CALL INTGRT
> *
>       call cputim(tt2)
>       ttint = ttint + (tt2-tt1)*60.
58c107,108
< *       Prepare new KS regularization.
---
> * Prepare new KS regularization.
>       call cputim(tt1)
59a110,112
>           CALL FLUSH(6)
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
62c115,116
< *       Terminate KS regularization.
---
> * Terminate KS regularization.
>       call cputim(tt1)
63a118,119
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
66c122,123
< *       Perform energy check & parameter adjustments and print diagnostics.
---
> * Perform energy check & parameter adjustments and print diagnostics.
>           call cputim(tt7)
67a125,126
>           call cputim(tt8)
>           ttadj = ttadj + (tt8-tt7)*60.
70c129,130
< *       Switch to unperturbed three-body regularization.
---
> * Switch to unperturbed three-body regularization.
>       call cputim(tt1)
72a133,134
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
75c137,138
< *       Switch to unperturbed four-body regularization.
---
> * Switch to unperturbed four-body regularization.
>       call cputim(tt1)
77a141,142
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
79c144
< *       Adopt c.m. approximation for inner binary in hierarchical triple.
---
> * Adopt c.m. approximation for inner binary in hierarchical triple.
80a146
>       call cputim(tt1)
81a148,149
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
84c152,153
< *       Restore old binary in hierarchical configuration.
---
> * Restore old binary in hierarchical configuration.
>       call cputim(tt1)
85a155,156
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
87c158
< *       Begin chain regularization.
---
> * Begin chain regularization.
88a160
>       call cputim(tt1)
90a163,164
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
93c167
< *       Continue integration.
---
> * Continue integration.
1,2c1,2
< 1565 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/nbpot.f
< nbody6compare/nbpot.f
---
> 1565 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/nbpot.f
> nbody6++compare/nbpot.f
1,2c1,2
< 1773 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/nbrem.f
< nbody6compare/nbrem.f
---
> 1772 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/nbrem.f
> nbody6++compare/nbrem.f
12c12
<           I = JPERT(LL) 
---
>           I = JPERT(LL)
1,2c1,2
< 1734 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/nbrest.f
< nbody6compare/nbrest.f
---
> 1698 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/nbrest.f
> nbody6++compare/nbrest.f
12c12
<           I = JPERT(LL) 
---
>           I = JPERT(LL)
14d13
<           IF (NNB1.EQ.1) GO TO 100
1,2c1,2
< 3451 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/nbsort.f
< nbody6compare/nbsort.f
---
> 3689 2000-08-01 14:02 /work/Umi2/spurzem/5/nbody6++compare/nbsort.f
> nbody6++compare/nbsort.f
8c8
<       INTEGER  IBL(LMAX),NBLIST(NMAX),LP(NMAX)
---
>       INTEGER  IBL(NMAX),NBLIST(NMAX),LP(NMAX)
53a54,59
> *     IF(NNB.EQ.0)THEN
> *     PRINT*,' NBLIST L, IBL(1), IBL(L), NBL=',
> *    *   L, IBL(1), IBL(L), NBL
> *     PRINT*,' IFIRST,N,LIST(1,I),STEP=',IFIRST,N,LIST(1,I),STEP(I)
> *     PRINT*,' N,M,X=',NAME(I),BODY(I),(X(K,I),K=1,3)
> *     END IF
61c67
<           INC = (NBLIST(IG) - I)*FAC
---
> *         INC = (NBLIST(IG) - I)*FAC
1,2c1,2
< 3044 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/nbtide.f
< nbody6compare/nbtide.f
---
> 3044 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/nbtide.f
> nbody6++compare/nbtide.f
1,2c1,2
< 2957 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/newreg.f
< nbody6compare/newreg.f
---
> 2957 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/newreg.f
> nbody6++compare/newreg.f
1,2c1,2
< 891 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/newsys.f
< nbody6compare/newsys.f
---
> 891 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/newsys.f
> nbody6++compare/newsys.f
8c8
<       REAL*8  M(*),X(*),XD(*)
---
>       REAL*8  M(1),X(1),XD(1)
1,2c1,2
< 1311 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/nlmod.f
< nbody6compare/nlmod.f
---
> 1312 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/nlmod.f
> nbody6++compare/nlmod.f
0a1
> 
file /work/Umi2/spurzem/5/nbody6++compare/ntint.f does not exist
1,2c1,2
< 1400 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/offset.f
< nbody6compare/offset.f
---
> 1160 2001-08-23 22:24 /work/Umi2/spurzem/5/nbody6++compare/offset.f
> nbody6++compare/offset.f
39,46d38
< *       Check tidal tail members (note TIMENW also needs doing).
<       IF (NTAIL.GT.0) THEN
<           DO 30 I = ITAIL0,NTTOT
<               T0(I) = T0(I) - DTOFF
<               TIMENW(I) = TIMENW(I) - DTOFF
<    30     CONTINUE
<       END IF
< *
48c40
<       IF (TIME.GE.DTOFF) GO TO 1
---
>       IF (TIME.GE.TOFF) GO TO 1
1,2c1,2
< 1530 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/orbit.f
< nbody6compare/orbit.f
---
> 2422 2005-03-09 15:28 /work/Umi2/spurzem/5/nbody6++compare/orbit.f
> nbody6++compare/orbit.f
8a9,15
> *       Predict current state vector of body #I to order FDOT. (R.Sp.)
>           S = TIME - T0(I)
>           DO 11 K = 1,3
>               X(K,I) = ((FDOT(K,I)*S + F(K,I))*S + X0DOT(K,I))*S +
>      &                                                           X0(K,I)
>               XDOT(K,I) = (3.0*FDOT(K,I)*S + 2.0*F(K,I))*S + X0DOT(K,I)
>    11     CONTINUE
20a28,31
> *        Predict coordinate (R.Sp.)
>           S = TIME - T0(JJ)
>           X(K,JJ) = ((FDOT(K,JJ)*S + F(K,JJ))*S + X0DOT(K,JJ))*S +
>      &                                                         X0(K,JJ)
24c35
< *       Exclude any c.m. bodies from dominant motion.
---
> *       Exclude any c.m. bodies from dominant motion (
30,31d40
< *       Avoid rare case of halo orbit with zero neighbour number.
<           IF (JM.EQ.I) JM = I - 1
43a53,57
> *       Prediction (R.Sp.)
>           S = TIME - T0(J)
>           X(K,J) = ((FDOT(K,J)*S + F(K,J))*S + X0DOT(K,J))*S +
>      &                                                         X0(K,J)
>           XDOT(K,J) = (3.0*FDOT(K,J)*S + 2.0*F(K,J))*S + X0DOT(K,J)
53a68,72
>       IF (J.LT.IFIRST.AND.TIME.GT.0.D0) THEN
>       WRITE (6,10)  I,J,IFIRST,N,(LIST(K,I),K=2,NNB+1)
>    10 FORMAT (' DANGER!   I J I* N LIST   ',4I5,2X,20(15I5,/))
>       END IF
> *
56a76
> 
1,2c1,2
< 15465 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/output.f
< nbody6compare/output.f
---
> 12100 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/output.f
> nbody6++compare/output.f
0a1,4
> # 1 "output.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "output.F"
4,5c8,9
< *       Output and data save.
< *       ---------------------
---
> * Output and data save.
> * ---------------------
8,22c12,23
<       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
<       COMMON/GALAXY/  GMG,RG(3),VG(3),FG(3),FGD(3),TG,
<      &                OMEGA,DISK,A,B,V02,RL2
<       COMMON/ECHAIN/  ECH
<       REAL*8  X1(3,4),V1(3,4),UI(4),VI(4),XREL2(3),VREL2(3)
<       REAL*4  XS(3,NMAX),VS(3,NMAX),BODYS(NMAX),AS(20)
<       REAL*4  XJ(3,6),VJ(3,6),BODYJ(6)
<       LOGICAL  FIRST,SECOND,THIRD
<       SAVE  FIRST,SECOND,THIRD
<       DATA  FIRST,SECOND ,THIRD/.TRUE.,.TRUE.,.TRUE./
< *
< *
< *       Obtain energy error in case routine ADJUST not called recently.
---
>       COMMON/BINARY/ CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
>      & HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      & NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       COMMON/ECHAIN/ ECH
>       REAL*8 X1(3,4),V1(3,4),UI(4),VI(4),XREL2(3),VREL2(3)
>       REAL*4 XS(3,NMAX),VS(3,NMAX),BODYS(NMAX),RHOS(NMAX),AS(20)
>       REAL*4 XJ(3,6),VJ(3,6),BODYJ(6)
>       REAL*4 XNS(NMAX),PHI(NMAX)
> *
> * Call Computation of Moments of Inertia (with Chr. Theis)
>           IF(KZ(39).EQ.2)CALL ELLAN
> * Obtain energy error in case routine ADJUST not called recently.
25c26
< *       Predict X & XDOT for all particles (except unperturbed pairs).
---
> * Predict X & XDOT for all particles (except unperturbed pairs).
28c29,32
< *       Obtain the total energy at current time (resolve all KS pairs).
---
> * Obtain the total energy at current time (resolve all KS pairs).
> 
> 
> 
29a34
> 
31c36
< *       Include KS pairs, triple, quad, mergers, collisions & chain.
---
> * Include KS pairs, triple, quad, mergers, collisions & chain.
33c38
<      &                                                         + ECDOT
---
>      & + ECDOT
38c43
< *       Update energies and form the relative error (divide by ZKIN or ETOT).
---
> * Update energies and form the relative error (divide by ZKIN or ETOT).
44c49
< *       Save sum of relative energy error for main output and accumulate DE.
---
> * Save sum of relative energy error for main output and accumulate DE.
47c52
< *       Find density centre & core radius (Casertano & Hut, Ap.J. 298, 80).
---
> * Find density centre & core radius (Casertano & Hut, Ap.J. 298, 80).
52c57
< *       Check optional sorting of Lagrangian radii & half-mass radius.
---
> * Check optional sorting of Lagrangian radii & half-mass radius.
57c62
< *       Initialize diagnostic variables.
---
> * Initialize diagnostic variables.
63c68
< *       Find smallest semi-major axis and count unperturbed KS pairs.
---
> * Find smallest semi-major axis and count unperturbed KS pairs.
72c77
< *       Perform time-step & neighbour statistics (NS is # single stars).
---
> * Perform time-step & neighbour statistics (NS is # single stars).
84,85c89,90
<           RHO = LIST(1,I)/RS(I)**3
<           CMAX = MAX(CMAX,RHO)
---
>           RHON = LIST(1,I)/RS(I)**3
>           CMAX = MAX(CMAX,RHON)
92c97
< *       Estimate relative cost & effective neighbour number of AC scheme.
---
> * Estimate relative cost & effective neighbour number of AC scheme.
95c100
< *       Scale maximum particle density contrast by the mean value.
---
> * Scale maximum particle density contrast by the mean value.
98c103
< *       Set average neighbour number & density centre displacement.
---
> * Set average neighbour number & density centre displacement.
102c107
< *       Check print frequency indicator & optional model counter.
---
> * Check print frequency indicator & optional model counter.
109c114
< *       Form binary & merger energy ratios.
---
> * Form binary & merger energy ratios.
113c118
< *       Print main output diagnostics.
---
> * Print main output diagnostics.
116,121c121,128
<       WRITE (6,40)  TTOT, N, NNB, NPAIRS, NMERGE, MULT, NS, NSTEPI,
<      &              NSTEPB, NSTEPR, NSTEPU, ERROR, BE(3)
<    40 FORMAT (//,' T =',F7.1,'  N =',I6,'  <NB> =',I3,'  KS =',I5,
<      &           '  NM =',I3,'  MM =',I2,'  NS =',I6,
<      &           '  NSTEPS =',I11,2I10,I11,'  DE =',1P,E9.1,
<      &           '  E =',0P,F10.6)
---
>       IF(rank.EQ.0)THEN
>       WRITE (6,40) rank,
>      & TTOT, N, NNB, NPAIRS, NMERGE, MULT, NS, NSTEPI, NSTEPB,
>      & NSTEPR, NSTEPU, ERROR, BE(3)
>    40 FORMAT (
>      & '  NM =',I2,' MM =',I2,' NS =',I6,' NSTEPS =',
>      & I11,2I10,I11,'  DE =',E15.6,'  E =',F17.6)
>       END IF
124c131,132
<           CALL CPUTIM(TCOMP)
---
>           CALL CPUTIM(ttotb)
>                   TCOMP = ttotb-ttota
130,134c138,144
<           WRITE (6,45)  NRUN, MODEL, TCOMP, TRC, DMIN1, DMIN2, DMIN3,
<      &                  DMIN4, AMIN, RMAX, RSMIN, NEFF
<    45     FORMAT (/,' NRUN =',I3,'  M# =',I3,'  CPU =',F8.1,'  TRC =',
<      &                        F5.1, '  DMIN =',1P,4E8.1,'  AMIN =',E8.1,
<      &                '  RMAX =',E8.1,'  RSMIN =',0P,F5.2,'  NEFF =',I6)
---
>       IF(rank.EQ.0)THEN
>           WRITE (6,45) NRUN, MODEL, TCOMP, TRC, DMIN1, DMIN2, DMIN3,
>      & DMIN4, AMIN, RMAX, RSMIN, NEFF
>    45 FORMAT (/,' NRUN =',I3,'  M# =',I3,'  CPU =',1P,E12.5,0P,
>      & '  TRC =',F5.1, '  DMIN =',1P,4E8.1,'  AMIN =',E8.1,
>      & '  RMAX =',E8.1,'  RSMIN =',0P,F5.2,'  NEFF =',I6)
>       END IF
136a147
>       IF(rank.EQ.0)THEN
138,146c149,157
<    50 FORMAT (/,'    <R>  RTIDE  RDENS   RC    NC   MC   RHOD   RHOM',
<      &                    '  CMAX   <Cn>  Ir/R   UN   NP    RCM    VCM',
<      &                       '         AZ     EB/E   EM/E   TCR     T6')
< *
<       WRITE (6,55)  RSCALE, RTIDE, RD, RC, NC, ZMC, RHOD, RHOM, CMAX,
<      &              CNNB, COST, IUNP, NP, CMR(4), CMRDOT(4), AZ, EB, EM,
<      &              TCR, I6
<    55 FORMAT (' #1',F5.2,F6.1,F7.2,F6.2,I5,F7.3,F6.0,F7.0,F6.0,F6.1,
<      &                           F6.2,2I5,F9.3,F8.4,F11.6,2F7.2,F6.2,I6)
---
>    50 FORMAT (/,'    <R>  RTIDE  RDENS   RC      NC   MC   RHOD   RHOM',
>      & '  CMAX   <Cn>  Ir/R    UN    NP    RCM    VCM',
>      & '         AZ     EB/E   EM/E   TCR     T6')
> *
>       WRITE (6,55) RSCALE, RTIDE, RD, RC, NC, ZMC, RHOD, RHOM, CMAX,
>      & CNNB, COST, IUNP, NP, CMR(4), CMRDOT(4), AZ, EB, EM,
>      & TCR, I6
>    55 FORMAT (' #1',F5.2,F6.1,F7.2,F6.2,I7,F7.3,F6.0,F7.0,F6.0,F6.1,
>      & F6.2,2I6,F9.3,F8.4,F11.6,2F7.3,F6.2,I6)
150,155c161,166
<      &         '    NICONV  NBSMIN  NBDIS  NBDIS2  NCMDER  NBDER',
<      &           '  NFAST  NBFAST    NBLOCK     NBPRED     NBFLUX')
<       WRITE (6,65)  NNPRED, NBCORR, NBFULL, NBVOID, NRCONV, NICONV,
<      &              NBSMIN, NBDIS, NBDIS2, NCMDER, NBDER, NFAST,
<      &              NBFAST, NBLOCK, NBPRED, NBFLUX
<    65 FORMAT (' #2',I10,I10,3I8,I10,I8,I7,2I8,2I7,I8,I10,2I11)
---
>      & '    NICONV  NBSMIN  NBDIS  NBDIS2  NCMDER  NBDER',
>      & '  NFAST  NBFAST    NBLOCK     NBPRED')
>       WRITE (6,65) NNPRED, NBCORR, NBFULL, NBVOID, NRCONV, NICONV,
>      & NBSMIN, NBDIS, NBDIS2, NCMDER, NBDER, NFAST,
>      & NBFAST, NBLOCK, NBPRED
>    65 FORMAT (' #2',I10,I10,3I8,I10,I8,I7,2I8,2I7,I8,I10,I11)
158,164c169,176
<    70 FORMAT (/,5X,'NKSTRY  NKSREG  NKSHYP     NKSPER  NPRECT  NMARG ',
<      &           '  NKSMOD    NTTRY  NTRIP  NQUAD  NCHAIN  NMERG',
<      &           '  NEWHI  NSTEPT  NSTEPQ  NSTEPC')
<       WRITE (6,75)  NKSTRY, NKSREG,  NKSHYP, NKSPER, NPRECT, NMARG,
<      &              NKSMOD, NTTRY, NTRIP, NQUAD, NCHAIN, NMERG, NEWHI,
<      &              NSTEPT, NSTEPQ, NSTEPC
<    75 FORMAT (' #3',I9,I7,I8,I11,3I8,I9,2I7,I8,2I7,3I8)
---
>    70 FORMAT (/,5X,'NKSTRY  NKSREG  NKSHYP     NKSPER  NPRECT  NKSREF',
>      & '  NKSMOD  NTTRY  NTRIP  NQUAD  NCHAIN  NMERG',
>      & '  NSTEPT  NSTEPQ  NSTEPC    NBLCKR    NBFLUX')
>       WRITE (6,75) NKSTRY, NKSREG, NKSHYP, NKSPER, NPRECT, NKSREF,
>      & NKSMOD, NTTRY, NTRIP, NQUAD, NCHAIN, NMERG,
>      & NSTEPT, NSTEPQ, NSTEPC, NBLCKR, NBFLUX
>    75 FORMAT (' #3',3I8,I11,3I8,3I7,I8,I7,3I8,2I10)
>       END IF
166c178
< *       Check output for mass loss or tidal capture.
---
> * Check output for mass loss or tidal capture.
171,187c183
< *       Obtain half-mass radii for two groups (NAME <= NZERO/5 & > NZERO/5).
<       IF (KZ(7).EQ.6.AND.TTOT.GE.TCRIT.AND.BODY1.GT.2.0*BODYM) THEN
<           CALL LAGR2(RDENS)
<       END IF
< *
< *       Include diagnostics about cluster orbit in general external field.
<       IF (KZ(14).EQ.3) THEN
<           GZ = RG(1)*VG(2) - RG(2)*VG(1)
<           SX = RBAR/1000.0
<           WRITE (6,80)  NTAIL, NSTAIL, (RG(K)*SX,K=1,3),
<      &                                 (VG(K)*VSTAR,K=1,3),
<      &                  GZ, ETIDE
<    80     FORMAT (/,5X,'CLUSTER ORBIT    NT NST RG VG JZ ET ',
<      &                              I5,I8,3F7.2,2X,3F7.1,1P,E16.8,E10.2)
<       END IF
< *
< *       Reset minimum encounter distances & maximum apocentre separation.
---
> * Reset minimum encounter distances & maximum apocentre separation.
195,196c191,192
< *       Check integer overflows (2^{32} or 2.1 billion).
<       IF (NSTEPI.GT.2000000000.OR.NSTEPI.LT.0) THEN
---
> * Check integer overflows (2^{32} or 2.1 billion).
>       IF (NSTEPI.GT.2000000000) THEN
199c195
<       IF (NSTEPU.GT.2000000000.OR.NSTEPU.LT.0) THEN
---
>       IF (NSTEPU.GT.2000000000) THEN
202c198
<       IF (NBPRED.GT.2000000000.OR.NBPRED.LT.0) THEN
---
>       IF (NBPRED.GT.2000000000) THEN
205,207d200
<       IF (NBFLUX.GT.2000000000.OR.NBFLUX.LT.0) THEN
<           NBFLUX = 0
<       END IF
209c202
< *       Ensure NLIST does not become large for block-step version.
---
> * Ensure NLIST does not become large for block-step version.
212c205
< *       Exit if error exceeds restart tolerance (TIME < TADJ means no CHECK).
---
> * Exit if error exceeds restart tolerance (TIME < TADJ means no CHECK).
215,216c208,209
< *       Check optional analysis & output of KS binaries.
<       IF (KZ(8).GT.0.AND.NPAIRS.GT.0) THEN
---
> * Check optional analysis & output of KS binaries.
>       IF ((KZ(8).GT.0 .OR. NBIN0.GT.0) .AND.NPAIRS.GT.0) THEN
220c213
< *       Include optional diagnostics of block-steps.
---
> * Include optional diagnostics of block-steps.
225c218
< *       Check optional output of single bodies & binaries.
---
> * Check optional output of single bodies & binaries.
228,229c221,222
< *       See whether to write data bank of binary diagnostics on unit 9.
<       IF (KZ(8).GE.2.AND.NPAIRS.GT.0) THEN
---
> * See whether to write data bank of binary diagnostics on unit 9.
>       IF ((KZ(8).GE.2 .OR. NBIN0.GT.0) .AND.NPAIRS.GT.0) THEN
236c229
< *       Check optional diagnostics of evolving stars.
---
> * Check optional diagnostics of evolving stars.
237a231,237
> * Update stellar evolution
>               IF (KZ(19).GE.3) THEN
>                   CALL MDOT
>               ELSE
>                   CALL MLOSS
>               END IF
> *
238a239,240
> * Update next output time.
>           TPLOT = TPLOT + DTPLOT
241c243
< *       Check optional writing of data on unit 3 (frequency NFIX). 
---
> * Check optional writing of data on unit 3 (frequency NFIX).
243d244
<       IF (KZ(3).GT.2.AND.KZ(3).NE.5) GO TO 99
245,264c246,249
<       AS(1) = TTOT
<       AS(2) = FLOAT(NPAIRS)
<       AS(3) = RBAR
<       AS(4) = ZMBAR
<       AS(5) = RTIDE
<       AS(6) = TIDAL(4)
<       AS(7) = RDENS(1)
<       AS(8) = RDENS(2)
<       AS(9) = RDENS(3)
<       AS(10) = TTOT/TCR
<       AS(11) = TSCALE
<       AS(12) = VSTAR
<       AS(13) = RC
<       AS(14) = NC
<       AS(15) = VC
<       AS(16) = RHOM
<       AS(17) = CMAX
<       AS(18) = RSCALE
<       AS(19) = RSMIN
<       AS(20) = DMIN1
---
>       DO 80 IPAIR = 1,NPAIRS
>           RHO(2*IPAIR-1) = RHO(N+IPAIR)
>           RHO(2*IPAIR) = RHO(N+IPAIR)
>  80 CONTINUE
266c251
< *       Convert masses, coordinates & velocities to single precision.
---
> * Convert masses, coordinates & velocities to single precision.
268a254,256
>           RHOS(I) = RHO(I)
>           XNS(I) = XNDBL(I)
>           PHI(I) = PHIDBL(I)
272c260
<    85     CONTINUE
---
>    85 CONTINUE
275c263
< *       Replace any ghosts by actual M, R & V (including 2 binaries).
---
> * Replace any ghosts by actual M, R & V (including 2 binaries).
280c268
< *       Determine merger & ghost index for negative c.m. name.
---
> * Determine merger & ghost index for negative c.m. name.
283c271
< *       Note: J is ghost index and IM is merger index.
---
> * Note: J is ghost index and IM is merger index.
288c276
< *       Form global coordinates and velocities from c.m. with XREL & VREL.
---
> * Form global coordinates and velocities from c.m. with XREL & VREL.
296c284
<                   XS(K,J)  = X1(K,2)
---
>                   XS(K,J) = X1(K,2)
298c286
<                   VS(K,J)  = V1(K,2)
---
>                   VS(K,J) = V1(K,2)
300,301c288,289
< *       Look for ghosts of possible second (i.e. outer) merged binary.
<               IF (NAME(J).GT.NZERO) THEN
---
> * Look for ghosts of possible second (i.e. outer) merged binary.
>               IF (NAMEG(J).GT.NZERO) THEN
303,304c291,292
<                   DO  JJ = N+1,NTOT 
<                       IF (NAME(JJ).EQ.NAME(J)) ICM2 = JJ
---
>                   DO JJ = N+1,NTOT
>                       IF (NAME(JJ).EQ.NAMEG(J)) ICM2 = JJ
306c294
< *       Treat the second binary using inactive KS variables.
---
> * Treat the second binary using inactive KS variables.
313c301
< *       Copy KS variables to local scalars.
---
> * Copy KS variables to local scalars.
318c306
< *       Transform to physical variables and multiply by 4 (momentum formula).
---
> * Transform to physical variables and multiply by 4 (momentum formula).
329c317
<                           XS(K,I2)  = X1(K,4)
---
>                           XS(K,I2) = X1(K,4)
331c319
<                           VS(K,I2)  = V1(K,4)
---
>                           VS(K,I2) = V1(K,4)
340c328
< *       Check modification for chain regularization (case NAME(ICM) = 0).
---
> * Check modification for chain regularization (case NAME(ICM) = 0).
344c332
< *       Copy global address from common JLIST (set in CHDATA).
---
> * Copy global address from common JLIST (set in CHDATA).
350,351c338,339
<    97         CONTINUE
<    98     CONTINUE
---
>    97 CONTINUE
>    98 CONTINUE
354,431c342,376
< *       Split into WRITE (3) NTOT & WRITE (3) ..  if disc instead of tape.
<       IF (FIRST) THEN
<           OPEN (UNIT=3,STATUS='NEW',FORM='UNFORMATTED',FILE='OUT3')
<           FIRST = .FALSE.
<       END IF
<       NK = 20
<       WRITE (3)  NTOT, MODEL, NRUN, NK
<       WRITE (3)  (AS(K),K=1,NK), (BODYS(J),J=1,NTOT),
<      &           ((XS(K,J),K=1,3),J=1,NTOT), ((VS(K,J),K=1,3),J=1,NTOT),
<      &           (NAME(J),J=1,NTOT)
< *     CLOSE (UNIT=3)
< *
< *       Produce output file for tidal tail members.
<    99 IF (KZ(3).LE.3.AND.NTAIL.GT.0) THEN
<           IF (SECOND) THEN
<              OPEN (UNIT=33,STATUS='NEW',FORM='UNFORMATTED',FILE='OUT33')
<              SECOND = .FALSE.
<           END IF
<           DO 110 I = ITAIL0,NTTOT
<               BODYS(I) = BODY(I)
<               DO 105 K = 1,3
<                   XS(K,I) = X(K,I) - RG(K)
<                   VS(K,I) = XDOT(K,I) - VG(K)
<   105         CONTINUE
<   110     CONTINUE
< *       Include cluster centre just in case.
<           DO 115 K = 1,3
<               AS(K) = RG(K)
<               AS(K+3) = VG(K)
<               AS(K+6) = RDENS(K)
<   115     CONTINUE
<           AS(10) = TTOT
<           AS(11) = RBAR
<           AS(12) = TSCALE
<           AS(13) = VSTAR
<           NK = 13
<           WRITE (33)  NTAIL, NK
<           WRITE (33)  (AS(K),K=1,NK), (BODYS(J),J=ITAIL0,NTTOT),
<      &                ((XS(K,J),K=1,3),J=ITAIL0,NTTOT),
<      &                ((VS(K,J),K=1,3),J=ITAIL0,NTTOT),
<      &                (NAME(J),J=ITAIL0,NTTOT)
<       END IF
< *
< *       Include all stars in same file (KZ(3) > 3; astrophysical units). 
<       IF (KZ(3).GT.3.AND.NTAIL.GT.0) THEN
<           IF (THIRD) THEN
<               OPEN (UNIT=34,STATUS='NEW',FORM='FORMATTED',FILE='OUT34')
<               THIRD = .FALSE.
<           END IF
<           NP = 0
< *       Copy cluster members with respect to density centre.
<           DO 120 I = IFIRST,NTOT
<               IF (BODY(I).LE.0.0D0) GO TO 120
<               NP = NP + 1
<               DO 118 K = 1,3
<                   XS(K,NP) = (X(K,I) - RDENS(K))*RBAR
<                   VS(K,NP) = XDOT(K,I)*VSTAR
<   118         CONTINUE
<               BODYS(NP) = BODY(I)*SMU
<   120     CONTINUE
<           N1 = NP
< *       Add tidal tail in the same frame.
<           DO 130 I = ITAIL0,NTTOT
<               NP = NP + 1
<               DO 125 K = 1,3
<                   XS(K,NP) = (X(K,I) - RG(K) - RDENS(K))*RBAR
<                   VS(K,NP) = (XDOT(K,I) - VG(K))*VSTAR
<   125         CONTINUE
<               BODYS(NP) = BODY(I)*SMU
<   130     CONTINUE
<           WRITE (34,140)  NP, N1, (TIME+TOFF)*TSCALE, RBAR, VSTAR,
<      &                    (RDENS(K),K=1,3), (RG(K),K=1,3), (VG(K),K=1,3)
<   140     FORMAT (' ',2I6,F8.1,2F6.2,3F7.3,1P,6E10.2)
<           DO 150 I = 1,NP
<               WRITE (34,145) (XS(K,I),K=1,3), (VS(K,I),K=1,3), BODYS(I)
<   145         FORMAT (' ',3F10.3,3F8.1,F7.2)
<   150     CONTINUE
<       END IF
---
>           AS(1) = TTOT
>           AS(2) = FLOAT(NPAIRS)
>           AS(3) = RBAR
>           AS(4) = ZMBAR
>           AS(5) = RTIDE
>           AS(6) = TIDAL(4)
>           AS(7) = RDENS(1)
>           AS(8) = RDENS(2)
>           AS(9) = RDENS(3)
>           AS(10) = TTOT/TCR0
>           AS(11) = I6
>           AS(12) = FLOAT(NZERO)
>           AS(13) = RC
>           AS(14) = NC
>           AS(15) = VC
>           AS(16) = RHOM
>           AS(17) = CMAX
>           AS(18) = RSCALE
>           AS(19) = RSMIN
>           AS(20) = DMIN1
>           NK = 20
> *
> * Write all data in binary format on unit 3 = conf.3.
> *
> 
> 
> 
>           WRITE (3) NTOT, MODEL, NRUN, NK
>           WRITE (3) (AS(K),K=1,NK),
>      & (BODYS(J),J=1,NTOT),(RHOS(J),J=1,NTOT),(XNS(J),J=1,NTOT),
>      & ((XS(K,J),K=1,3),J=1,NTOT), ((VS(K,J),K=1,3),J=1,NTOT),
>      & (PHI(J),J=1,NTOT),(NAME(J),J=1,NTOT)
> 
> 
> 
433c378
< *       Update next output interval and initialize the corresponding error.
---
> * Update next output interval and initialize the corresponding error.
1,2c1,2
< 815 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/params.h
< nbody6compare/params.h
---
> 1301 2005-03-09 17:47 /work/Umi2/spurzem/5/nbody6++compare/params.h
> nbody6++compare/params.h
4,5c4,13
<       PARAMETER  (NMAX=4010,KMAX=1010,LMAX=100,MMAX=10,
<      &            MLD=22,MLR=22,MLV=10,MCL=10,NCMAX=10)
---
>       PARAMETER  (NMAX=140000,KMAX=5000,LMAX=128,MMAX=60,
> *     PARAMETER  (NMAX=50000,KMAX=50,LMAX=64,MMAX=60,
> *     PARAMETER  (NMAX=25000,KMAX=5000,LMAX=128,MMAX=60,
> *     PARAMETER  (NMAX=16384,KMAX=50,LMAX=64,MMAX=60,
> *     PARAMETER  (NMAX=10100,KMAX=3000,LMAX=256,MMAX=60,
> *     PARAMETER  (NMAX=5100,KMAX=2000,LMAX=256,MMAX=60,
> *     PARAMETER  (NMAX=1010,KMAX=50,LMAX=60,MMAX=1,
>      &            MLD=60,MLR=60,MLV=60,MCL=1,NCMAX=10)
>       PARAMETER  (ID=3)
>       parameter (maxpe=1024)
9c17
< *       NMAX    Maximum number of single bodies + 3*NBIN + NHI.
---
> *       NMAX    Maximum number of single bodies & c.m.
17c25
< *       NCMAX   Maximum number of chain members (do not change).
---
> *       NCMAX   Maximum members of chain members.
19c27,28
< *
---
> *       ID      First dimension of 3d-vectors (usually = 3)
> *               Has to be set to 4 on CRAY T3D for hardware reasons
1,2c1,2
< 1893 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/peri.f
< nbody6compare/peri.f
---
> 1893 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/peri.f
> nbody6++compare/peri.f
1,2c1,2
< 1526 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/permit.f
< nbody6compare/permit.f
---
> 912 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/permit.f
> nbody6++compare/permit.f
1c1
<       SUBROUTINE PERMIT(PERIM,IGO)
---
>       SUBROUTINE PERMIT(RPERT,IGO)
4c4
< *       Check on existing multiple regularization.
---
> *       Permission for unperturbed triple or quad.
8,9d7
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
<       REAL*8  M,MASS,MC,MIJ,MKK
12,15d9
<       COMMON/CHAIN1/  XCH(NMX3),VCH(NMX3),M(NMX),
<      &                ZZ(NMX3),WC(NMX3),MC(NMX),
<      &                XI(NMX3),PI(NMX3),MASS,RINV(NMXm),RSUM,MKK(NMX),
<      &                MIJ(NMX,NMX),TKK(NMX),TK1(NMX),INAME(NMX),NN
18c12
< *       Search any existing subsystem.
---
> *       Search any existing subsystems.
20d13
<       ICHSUB = 1
22,28c15,19
< *       Identify chain pointer for possible reduction of STEPS.
<           IF (ISYS(L).EQ.3) ICHSUB = ISYS(L)
< *       Distinguish between triple & quad case (denoted ISUB = 1 or 2).
<           IF (JCOMP.LE.N.AND.NAMES(4,L).EQ.0) THEN
<               ISUB = 1
<       ELSE IF (JCOMP.GT.N.AND.NAMES(4,L).GT.0) THEN
<               ISUB = 2
---
> *       Distinguish between triple, quad & chain case.
>           IF (JCOMP.LE.N.AND.ISYS(L).EQ.1) THEN
>               ISUB = L
>           ELSE IF (JCOMP.GT.N.AND.ISYS(L).GE.2) THEN
>               ISUB = L
34,40c25,28
< *       See whether the case ISUB = 1 or 2 is used already.
<           DO 20 L = 1,NSUB
<               IF (ISUB.EQ.ISYS(L)) IGO = 1
<    20     CONTINUE
< *       Enforce chain termination at next extension if new system < RSUM/2.
<           IF (PERIM.LT.0.5*RSUM.AND.IGO.GT.0) THEN
<               STEPS(ICHSUB) = 0.0
---
>           IGO = 1
> *       Enforce termination at next extension if new system is smaller.
>           IF (RPERT.LT.RMAXS(ISUB)) THEN
>               STEPS(ISUB) = 0.0D0
1,2c1,2
< 1313 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/pfac.f
< nbody6compare/pfac.f
---
> 1313 1999-12-23 13:25 /work/Umi2/spurzem/5/nbody6++compare/pfac.f
> nbody6++compare/pfac.f
1,2c1,2
< 875 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6compare/physks.f
< nbody6compare/physks.f
---
> 875 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/physks.f
> nbody6++compare/physks.f
1,2c1,2
< 400 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6compare/qforce.f
< nbody6compare/qforce.f
---
> 400 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/qforce.f
> nbody6++compare/qforce.f
1,2c1,2
< 5176 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/qpmod3.f
< nbody6compare/qpmod3.f
---
> 5177 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/qpmod3.f
> nbody6++compare/qpmod3.f
143c143
<      &                              2I5,1P,E10.2,0P,2F8.3,F9.1,1P,E10.2)
---
>      &                                 2I5,1PE10.2,0P2F8.3,F9.1,1PE10.2)
149a150
> 
1,2c1,2
< 4205 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/qpmod4.f
< nbody6compare/qpmod4.f
---
> 4206 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/qpmod4.f
> nbody6++compare/qpmod4.f
127c127
<      &                              2I5,1P,E10.2,0P,2F8.3,F9.1,1P,E10.2)
---
>      &                                 2I5,1PE10.2,0P2F8.3,F9.1,1PE10.2)
132a133
> 
1,2c1,2
< 7554 2006-09-03 10:25 /work/Umi2/spurzem/5/nbody6compare/qpmod.f
< nbody6compare/qpmod.f
---
> 6999 2003-06-23 19:32 /work/Umi2/spurzem/5/nbody6++compare/qpmod.f
> nbody6++compare/qpmod.f
8a9,10
>       LOGICAL  KSLOW,KCOLL
>       REAL*8  KSCH
11a14
>       COMMON/SLOW1/   TK2(0:NMX),EJUMP,KSCH(NMX),KSLOW,KCOLL
18c21
< *       Skip for small dissipation (ISYNC > 0 delays further calls).
---
> *       Skip for small dissipation (ISYNC > 0 prevents further calls).
45a49
>       AM0 = SEMI*(1.0D0 - ECC**2)
48,74c52,53
< *       Treat sequential circularization as standard case (KZ27 = 1).
<       IF (KZ27.EQ.1) THEN
<           AM0 = SEMI*(1.0D0 - ECC**2)
<           ECC2 = ECCM2
<           ECC1 = SQRT(ECC2)
<           ACIRC = AM0/(1.0 - ECC2)
<           R1 = MAX(RADIUS(1),RADIUS(2))
< *       Accept circularized orbit directly if ACIRC < 4*R.
<           IF (ACIRC.LT.4.0*R1) THEN
<               SEMI1 = ACIRC
<           ELSE
< *       Obtain E1 by (1 + E1) = AM0/(4*R1) and A1 by A1*(1 - E1) = 4*R1.
<               ECC1 = 0.25*AM0/R1 - 1.0
<               ECC1 = MAX(ECC1,ECCM)
<               ECC1 = MAX(ECC1,0.9*ECC)
<               SEMI1 = AM0/(1.0 - ECC1**2)
<           END IF
< *       Form the corresponding energy change.
<           DH = 0.5*MB*(1.0/SEMI - 1.0/SEMI1)
<           DE(1) = -MU*DH
<           DE(2) = 0.0
< *       Obtain the tidal energy change for PT or GR.
<       ELSE IF (KZ27.EQ.2) THEN
<           CALL TIDES(QPERI,M(K1),M(K2),RADIUS(1),RADIUS(2),IS,DE)
<       ELSE
<           CALL TIDES2(QPERI,M(K1),M(K2),VSTAR1,H,ECC,DE)
<       END IF
---
> *       Obtain the tidal energy change for PT.
>       CALL TIDES(QPERI,M(K1),M(K2),RADIUS(1),RADIUS(2),IS,DE)
87,95c66,80
< *       Skip on final hyperbolic orbit.
<       IF (H + DH.GT.0.0) GO TO 90
< *
< *       Use alternative expression for PT & GR capture condition.
<       IF (KZ27.GE.2) THEN
<           SEMI1 = -0.5*MB/(H + DH)
<           ECC1 = 1.0 - PERI/SEMI1
<           ECC1 = MAX(ECC1,0.0D0)
< *         ECC1 = MAX(ECC1,ECCM)
---
> *       Adopt sequential circularization instead of standard PT.
>       ECC2 = ECCM2
>       ECC1 = SQRT(ECC2)
>       ACIRC = AM0/(1.0 - ECC2)
>       R1 = MAX(RADIUS(1),RADIUS(2))
> 
> *       Accept circularized orbit directly if ACIRC < 4*R.
>       IF (ACIRC.LT.4.0*R1) THEN
>           SEMI1 = ACIRC
>       ELSE
> *       Obtain E1 by (1 + E1) = AM0/(4*R1) and A1 by A1*(1 - E1) = 4*R1.
>           ECC1 = 0.25*AM0/R1 - 1.0
>           ECC1 = MAX(ECC1,ECCM)
>           ECC1 = MAX(ECC1,0.9*ECC)
>           SEMI1 = AM0/(1.0 - ECC1**2)
97a83,90
> *       Form the corresponding energy change.
>       DH = 0.5*MB*(1.0/SEMI - 1.0/SEMI1)
>       DE(1) = -MU*DH
>       DE(2) = 0.0
> *
> *       Skip on possible hyperbolic case.
>       IF (H + DH.GT.0.0) GO TO 90
> *
106,107d98
< *       Distinguish between circularization and GR capture.
<       IF (KZ27.EQ.1) THEN
109,112c100
<           C2 = 1.0/C1**2
<       ELSE
<           C2 = SQRT((MB + H*PERI)/(MB + HI*PERI))
<       END IF
---
>       C2 = 1.0/C1**2
115,118c103,106
<       IF (ECC1.LE.ECCM.AND.KZ27.EQ.1) THEN
<           AM = SEMI1*(1.0D0 - ECC1**2)
<           C2 = (AM/AM0)/C1**2
<       END IF
---
> *     IF (ECC1.LE.0.002) THEN
> *         AM = SEMI1*(1.0D0 - ECC1**2)
> *         C2 = (AM/AM0)/C1**2
> *     END IF
217d204
<           R1 = MAX(SIZE(K1),SIZE(K2))
234a222,223
> 
> 
1,2c1,2
< 11948 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/quad.f
< nbody6compare/quad.f
---
> 11909 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/quad.f
> nbody6++compare/quad.f
214d213
<               DMINC = MIN(RCOLL,DMINC)
1,2c1,2
< 652 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6compare/r2sort.f
< nbody6compare/r2sort.f
---
> 652 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/r2sort.f
> nbody6++compare/r2sort.f
1,2c1,2
< 749 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/ran2.f
< nbody6compare/ran2.f
---
> 1059 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/ran2.f
> nbody6++compare/ran2.f
1,32c1,34
<       FUNCTION RAN2(IDUM)
< *
< *
< *       Random number generator (Press p. 195).
< *       ---------------------------------------
< *
<       PARAMETER (M=714025,IA=1366,IC=150889,RM=1./M)
<       COMMON/RAND2/  IY,IFF,IR(97) 
< *     DATA  IFF /0/
< *
< *
<       IF (IDUM.LT.0.OR.IFF.EQ.0) THEN
<           IFF = 1
<           IDUM = MOD(IC-IDUM,M)
<           DO 11 J = 1,97
<               IDUM = MOD(IA*IDUM+IC,M)
<               IR(J) = IDUM
<    11     CONTINUE
<           IDUM = MOD(IA*IDUM+IC,M)
<           IY = IDUM
<       END IF
<       J = 1 + (97*IY)/M
<       IF (J.GT.97.OR.J.LT.1) WRITE (6,12)  J, IDUM
<    12 FORMAT (/,'  TROUBLES IN RAN2   J IDUM ',2I12)
<       IY = IR(J)
<       RAN2 = IY*RM
<       IDUM = MOD(IA*IDUM+IC,M)
<       IR(J) = IDUM
< *
<       RETURN
< *
<       END 
---
>       FUNCTION ran2(idum)
>       INTEGER idum,IM1,IM2,IMM1,IA1,IA2,IQ1,IQ2,IR1,IR2,NTAB,NDIV
>       REAL ran2,AM,EPS,RNMX
>       PARAMETER (IM1=2147483563,IM2=2147483399,AM=1./IM1,IMM1=IM1-1,
>      *IA1=40014,IA2=40692,IQ1=53668,IQ2=52774,IR1=12211,IR2=3791,
>      *NTAB=32,NDIV=1+IMM1/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
>       INTEGER idum2,j,k,iv(NTAB),iy
>       SAVE iv,iy,idum2
>       DATA idum2/123456789/, iv/NTAB*0/, iy/0/
>       if (idum.le.0) then
>         idum=max(-idum,1)
>         idum2=idum
>         do 11 j=NTAB+8,1,-1
>           k=idum/IQ1
>           idum=IA1*(idum-k*IQ1)-k*IR1
>           if (idum.lt.0) idum=idum+IM1
>           if (j.le.NTAB) iv(j)=idum
> 11      continue
>         iy=iv(1)
>       endif
>       k=idum/IQ1
>       idum=IA1*(idum-k*IQ1)-k*IR1
>       if (idum.lt.0) idum=idum+IM1
>       k=idum2/IQ2
>       idum2=IA2*(idum2-k*IQ2)-k*IR2
>       if (idum2.lt.0) idum2=idum2+IM2
>       j=1+iy/NDIV
>       iy=iv(j)-idum2
>       iv(j)=idum
>       if(iy.lt.1)iy=iy+IMM1
>       ran2=min(AM*iy,RNMX)
>       return
>       END
> C  (C) Copr. 1986-92 Numerical Recipes Software >).
1,2c1,2
< 4165 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/rchain.f
< nbody6compare/rchain.f
---
> 4190 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/rchain.f
> nbody6++compare/rchain.f
30d29
<       JC = 0
31a31
>       JC = 0
66a67
>               DTAU0 = DS
1,2c1,2
< 7881 2005-03-21 18:44 /work/Umi2/spurzem/5/nbody6compare/recoil.f
< nbody6compare/recoil.f
---
> 7755 2005-03-11 11:33 /work/Umi2/spurzem/5/nbody6++compare/recoil.f
> nbody6++compare/recoil.f
18a19,21
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
26a30,31
> *       Set redundant index for N = 3.
>       IF (N.EQ.3) I4 = I1
30,46d34
<       ELSE IF (N.EQ.3) THEN
<           I4 = I1
<       ELSE IF (N.GT.4) THEN
< *       Determine indices of second closest pair (avoid pair I1-I2).
<           RX1 = 1.0
<           RX0 = R2(I1,I2)
<           DO 2 J1 = 1,N
<               IF (J1.EQ.I1.OR.J1.EQ.I2) GO TO 2
<               DO 1 J2 = J1+1,N
<                   IF (J2.EQ.I1.OR.J2.EQ.I2) GO TO 1
<                   IF (R2(J1,J2).LT.RX1.AND.R2(J1,J2).GT.RX0) THEN
<                       RX1 = R2(J1,J2)
<                       I3 = J1
<                       I4 = J2
<                   END IF
<     1         CONTINUE
<     2     CONTINUE
48,49c36,45
<       K1 = I3
<       K2 = I4
---
> *
> *       Define indices (K1,K2) for the second closest distance.
>       IF (R2(I2,I3).LT.R2(I1,I3)) THEN
>           K1 = I2
>           K2 = I3
>           IF (N.EQ.2) K2 = I1
>       ELSE
>           K1 = I1
>           K2 = I3
>       END IF
175d170
<           IF (N.GT.4) RM = MAX(R13,R24)
195c190
<       IF (NAME1 + NAME2.NE.NAMEC(I1) + NAMEC(I2).AND.EB.LT.0.0) THEN
---
>       IF (NAME1 + NAME2.NE.NAMEC(I1) + NAMEC(I2)) THEN
198c193,194
<           WRITE (6,15)  TCH, NAME1, NAME2, NAMEC(I1), NAMEC(I2), ECC0,
---
>           if (rank.eq.0)
>      &    WRITE (6,15)  TCH, NAME1, NAME2, NAMEC(I1), NAMEC(I2), ECC0,
210c206,207
<           WRITE (6,20)  NAMEC(I1), NAMEC(I2), SEMI, ECC, EB, GB, G4,
---
>           if (rank.eq.0)
>      &    WRITE (6,20)  NAMEC(I1), NAMEC(I2), SEMI, ECC, EB, GB, G4,
219c216
<       IF (IEND.EQ.2.AND.PMIN.LT.2.0*SEMI.AND.DB.GT.0.1) THEN
---
>       IF (IEND.EQ.2.AND.PMIN.LT.3.0*SEMI.AND.ECC1.GT.1.0) THEN
221c218,219
<           WRITE (6,25)  NAMEC(I3), ECC, ECC1, PMIN/SEMI, RCDOT/RCP,
---
>           if (rank.eq.0)
>      &    WRITE (6,25)  NAMEC(I3), ECC, ECC1, PMIN/SEMI, RCDOT/RCP,
232c230,231
<           WRITE (6,30)  I1, I2, I3, I4, RB, R13, R24, DE, TC, NSTEP1,
---
>           if (rank.eq.0)
>      &    WRITE (6,30)  I1, I2, I3, I4, RB, R13, R24, DE, TC, NSTEP1,
234c233
<    30     FORMAT (/,' END CHAIN  ',4I3,'  RB =',1PE8.1,'  R13 =',E8.1,
---
>    30     FORMAT (/,' END CHAIN  ',4I3,'  RB =',1P,E8.1,'  R13 =',E8.1,
1,2c1,2
< 745 2003-11-08 14:43 /work/Umi2/spurzem/5/nbody6compare/redraw.f
< nbody6compare/redraw.f
---
> 742 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/redraw.f
> nbody6++compare/redraw.f
9c9
<       INTEGER IC(NMX2),ICC(2),IJ(NMXM,2)
---
>       INTEGER IC(1),ICC(2),IJ(NMXM,2)
1,2c1,2
< 8649 2004-05-21 12:19 /work/Umi2/spurzem/5/nbody6compare/reduce.f
< nbody6compare/reduce.f
---
> 8856 2002-08-12 22:10 /work/Umi2/spurzem/5/nbody6++compare/reduce.f
> nbody6++compare/reduce.f
35c35,38
<       IF (KZ(30).GT.2) THEN
---
> *       Enforce exit from SUBINT (new value set on return to INTGRT).
>       TBLOCK = TPREV
> *
>       IF (rank.eq.0.and.KZ(30).GT.2) THEN
94c97,98
<               IF (BODY(J).GT.0.0D0) WRITE (6,35)  I, IESC, NAMEC(IESC)
---
>               IF (rank.eq.0.and.BODY(J).GT.0.0D0) 
>      &            WRITE (6,35)  I, IESC, NAMEC(IESC)
117c121
<       WRITE (6,48)  IESC, NAMEC(NEW)
---
>       if(rank.eq.0)WRITE (6,48)  IESC, NAMEC(NEW)
134c138
<       IF (KZ(30).GT.1) THEN
---
>       IF (rank.eq.0.and.KZ(30).GT.1) THEN
232d235
<           CALL FPOLY2(I,I,0)
237a241,242
>           CALL FPOLY2(I,I,0)
>           CALL HIVEL(I)
276c281
<       IF (KZ(30).GT.2) THEN
---
>       IF (rank.eq.0.and.KZ(30).GT.2) THEN
286a292,293
> 
> 
1,2c1,2
< 1006 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/reflct.f
< nbody6compare/reflct.f
---
> 1039 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/reflct.f
> nbody6++compare/reflct.f
15c15
< *       Obtain radial velocity with respect to the inertial centre.
---
> *       Obtain radial velocity assuming small density centre displacement.
38a39,40
> *     NBREF = NBREF + 1
> *
1,2c1,2
< 21221 2006-02-14 19:04 /work/Umi2/spurzem/5/nbody6compare/regint.f
< nbody6compare/regint.f
---
> 21522 2005-04-13 16:11 /work/Umi2/spurzem/5/nbody6++compare/regint.f
> nbody6++compare/regint.f
1,2c1
<       SUBROUTINE REGINT(I,XI,XIDOT)
< *
---
>       SUBROUTINE REGINT(I,KLIST)
9a9,11
> *       Calculate potential with little extra cost.
>       COMMON/POTENT/PHII(NMAX),PHIR(NMAX),PHIR1(NMAX)
>       REAL*8  W0(4),W1(4),W2(4),W3(4)
11c13,15
<       REAL*8  FRX(3),FDX(3)
---
>       INTEGER ESCFLG(NMAX)
> *
>       INTEGER KLIST(LMAX)
12a17,20
>       DO 6 K = 1,3
>           XI(K) = X(K,I)
>           XIDOT(K) = XDOT(K,I)
>    6  CONTINUE
14,15c22,23
< *       Set neighbour number, time-step & choice of central distance.
<       NNB0 = LIST(1,I)
---
> *       Copy uncorrected X and set time-step & central distance.
>       NNB0 = KLIST(1)
18,25c26,28
<       IF (KZ(39).EQ.0) THEN
<           RI2 = (XI(1) - RDENS(1))**2 + (XI(2) - RDENS(2))**2 +
<      &                                  (XI(3) - RDENS(3))**2
<           RH2 = RSCALE**2
<       ELSE
<           RI2 = XI(1)**2 + XI(2)**2 + XI(3)**2
<           RH2 = 9.0*RSCALE**2
<       END IF
---
>       RI2 = (XI(1) - RDENS(1))**2 + (XI(2) - RDENS(2))**2 +
>      &                              (XI(3) - RDENS(3))**2
>       RH2 = RSCALE**2
42a46,48
>       PHII(I) = 0.D0
>       PHIR(I) = 0.D0
>       PHIR1(I) = 0.D0
46,48c52,53
< *       Treat unperturbed KS in the single particle approximation.
<          I1 = 2*(I - N) - 1
<          IF (LIST(1,I1).GT.0) THEN
---
> *       See whether perturbation allows single particle approximation.
>           IF (GAMMA(I-N).GE.GMIN) THEN
52c57
<          END IF
---
>           END IF
55a61
>           call cputim(tt1)
56a63,65
> *RSP
>           IF (J.EQ.I) GO TO 10
> *RSP
65a75,76
>           DR2I = 1.0/RIJ2
>           DR3I = BODY(J)*DR2I*SQRT(DR2I)
66a78
>           DRDP = 3.0*DRDV*DR2I
68c80
< *       First see whether the distance exceeds the outer shell radius.
---
> *       See whether the distance exceeds the outer shell radius.
75,76d86
<           ELSE
<               IF (J.EQ.I) GO TO 10
82,84d91
<           DR2I = 1.0/RIJ2
<           DRDV = 3.0*DRDV*DR2I
<           DR3I = BODY(J)*DR2I*SQRT(DR2I)
88,90c95,99
<           FD(1) = FD(1) + (DV(1) - A1*DRDV)*DR3I
<           FD(2) = FD(2) + (DV(2) - A2*DRDV)*DR3I
<           FD(3) = FD(3) + (DV(3) - A3*DRDV)*DR3I
---
>           FD(1) = FD(1) + (DV(1) - A1*DRDP)*DR3I
>           FD(2) = FD(2) + (DV(2) - A2*DRDP)*DR3I
>           FD(3) = FD(3) + (DV(3) - A3*DRDP)*DR3I
> *       Obtain potential.
>           PHII(I) = PHII(I) - DR3I*RIJ2
94,97c103
<     8     DR2I = 1.0/RIJ2
<           DRDV = 3.0*DRDV*DR2I
<           DR3I = BODY(J)*DR2I*SQRT(DR2I)
<           FREG(1) = FREG(1) + A1*DR3I
---
>     8     FREG(1) = FREG(1) + A1*DR3I
100,102c106,111
<           FDR(1) = FDR(1) + (DV(1) - A1*DRDV)*DR3I
<           FDR(2) = FDR(2) + (DV(2) - A2*DRDV)*DR3I
<           FDR(3) = FDR(3) + (DV(3) - A3*DRDV)*DR3I
---
>           FDR(1) = FDR(1) + (DV(1) - A1*DRDP)*DR3I
>           FDR(2) = FDR(2) + (DV(2) - A2*DRDP)*DR3I
>           FDR(3) = FDR(3) + (DV(3) - A3*DRDP)*DR3I
> *       Obtain potential and derivative.
>           PHIR(I) = PHIR(I) - DR3I*RIJ2
>           PHIR1(I) = PHIR1(I) + DRDV*DR3I
103a113,114
>           call cputim(tt2)
>           ttfrc = ttfrc + (tt2-tt1)*60.
104a116,127
> *       Check total energy
>           VI2 = XIDOT(1)**2 + XIDOT(2)**2 + XIDOT(3)**2
>           EI = VI2/2.D0 + PHIR(I) + PHII(I)
>           ETIDAL = -ZMASS/RTIDE
>           IF(EI.GT.ETIDAL)THEN
>               IF(ESCFLG(NAME(I)).NE.1)
>      *        WRITE(95,1001) TIME,I,NAME(I),BODY(I),DSQRT(RI2),
>      *                       DSQRT(VI2),EI,ETIDAL
>               ESCFLG(NAME(I)) = 1
>  1001     FORMAT(1X,' T=',1P,D15.7,' I,N=',2I6,' m,r,v=',3D15.7,
>      *        ' e,et=',2D15.7)
>           END IF
123,127d145
<       END IF 
< *
< *       Check optional interstellar clouds.
<    20 IF (KZ(13).GT.0) THEN
<           CALL FCLOUD(I,FREG,FDR,1)
131,138c149
<       IF (KZ(14).GT.0) THEN
< *       Save current values for deriving work done by tides (#14 = 3).
<           IF (KZ(14).EQ.3) THEN
<               DO 22 K = 1,3
<                   FRX(K) = FREG(K)
<                   FDX(K) = FDR(K)
<    22         CONTINUE
<           END IF
---
>    20 CONTINUE
140,141c151,153
< *       Obtain the tidal perturbation (force and first derivative).
<           CALL XTRNLF(XI,XIDOT,FIRR,FREG,FD,FDR,1)
---
>       IF (KZ(14).GT.0) THEN
>           CALL XTRNLF(I,XI,XIDOT,FIRR,FREG,FD,FDR,1)
>       END IF
143,154c155,157
< *       Form rate of tidal energy change during last regular step.
<           IF (KZ(14).EQ.3) THEN
<               WDOT = 0.0
<               W2DOT = 0.0
<               DO 24 K = 1,3
<                   PX = FREG(K) - FRX(K)
<                   DPX = FDR(K) - FDX(K)
<                   WDOT = WDOT + XIDOT(K)*PX
<                   W2DOT = W2DOT + (FREG(K) + FIRR(K))*PX + XIDOT(K)*DPX
<    24         CONTINUE
< *       Note: second-order term derived by Douglas Heggie (Aug/03).
<           END IF
---
> *       Check whether cloud forces should be included.
>       IF (KZ(13).GT.0) THEN
>           CALL FCLOUD(I,FREG,FDR,1)
161,162c164,165
< *       Double the neighbour sphere and try again unless RI > 10*RSCALE.
<           IF (RI2.GT.100.0*RH2.OR.LIST(1,I).EQ.0) THEN
---
> *       Double the neighbour sphere and try again unless RI > 30*RSCALE.
>           IF (RI2.GT.100.0*RH2.OR.KLIST(1).EQ.0) THEN
178,179c181,183
< *       Reduce neighbour sphere gradually but allow encounter detection.
<                   RS(I) = MAX(0.75*RS(I),0.1*RSCALE)
---
> *       Specify zero members and reduce neighbour sphere gradually (but > 0).
>                   KLIST(1) = 0
>                   RS(I) = MAX(0.75*RS(I),0.01*RSCALE)
187c191
<           IF (RS(I).GT.10.0*RSCALE.AND.KZ(39).EQ.0) IRSKIP = 1
---
>           IF (RS(I).GT.10.0*RSCALE) IRSKIP = 1
220a225
>           DRDP = 3.0*DRDV*DR2I
233,234c238
<    34     DRDV = 3.0*DRDV*DR2I
<           FIRR(1) = FIRR(1) - A1*DR3I
---
>    34     FIRR(1) = FIRR(1) - A1*DR3I
237,239c241,243
<           FD(1) = FD(1) - (DV(1) - A1*DRDV)*DR3I
<           FD(2) = FD(2) - (DV(2) - A2*DRDV)*DR3I
<           FD(3) = FD(3) - (DV(3) - A3*DRDV)*DR3I
---
>           FD(1) = FD(1) - (DV(1) - A1*DRDP)*DR3I
>           FD(2) = FD(2) - (DV(2) - A2*DRDP)*DR3I
>           FD(3) = FD(3) - (DV(3) - A3*DRDP)*DR3I
243,245c247,253
<           FDR(1) = FDR(1) + (DV(1) - A1*DRDV)*DR3I
<           FDR(2) = FDR(2) + (DV(2) - A2*DRDV)*DR3I
<           FDR(3) = FDR(3) + (DV(3) - A3*DRDV)*DR3I
---
>           FDR(1) = FDR(1) + (DV(1) - A1*DRDP)*DR3I
>           FDR(2) = FDR(2) + (DV(2) - A2*DRDP)*DR3I
>           FDR(3) = FDR(3) + (DV(3) - A3*DRDP)*DR3I
> *       Obtain potential and derivative.
>           PHII(I) = PHII(I) - DR3I*RIJ2
>           PHIR(I) = PHIR(I) - DR3I*RIJ2
>           PHIR1(I) = PHIR1(I) + DRDV*DR3I
257,259c265,278
<    40 A3 = ALPHA*SQRT(FLOAT(NNB)*RS(I))/RS2
<       NBP = A3
<       A3 = MIN(A3,ZNBMAX) 
---
> *       Include optional stabilization to increase neighbour number.
> *       Take input parameter NNBOPT as optimal neighbour number (R.Sp.)
> *       Note that it substitutes input parameter NNBMAX, which
> *       is now a parameter NNBMAX=LMAX-3
>    40 CONTINUE
> *
>       FAC = 1.D0
>       IF (KZ(40).GT.0) THEN
>           FAC = 1.0 + 0.1*(FLOAT(NNBOPT) - FLOAT(NNB))/FLOAT(NNB)
>       END IF
> *
> *     A3 = ALPHA*FAC*SQRT(FLOAT(NNB)*RS(I))/RS2
>       A3 = FLOAT(NNB)*FAC
>       A3 = MIN(A3,0.9*ZNBMAX)
266a286
> *
271c291
<       IF (RI2.GT.RC2.AND.KZ(39).EQ.0.AND.RI2.LT.9.0*RH2) THEN
---
>       IF (RI2.GT.RC2.AND.RI2.LT.100.0*RH2) THEN
306,309d325
< *       Prevent reduction of small NNB if predicted value exceeds ZNBMIN.
<           IF (NNB.LT.ZNBMIN.AND.NBP.GT.ZNBMIN) THEN
<               IF (A1.LT.1.0) A1 = 1.05
<           END IF
317c333
<       IF (NNB.LE.3.AND.RI2.LT.9.0*RH2) THEN
---
>       IF (NNB.LE.3.AND.RI2.LT.100.0*RH2) THEN
335,337d350
< *       Check minimum neighbour sphere since last output (skip NNB = 0).
<       IF (LIST(1,I).GT.0) RSMIN = MIN(RSMIN,RS(I))
< *
339,341c352,354
<       IF ((KZ(18).EQ.1.AND.LISTV(1).GT.0).OR.KZ(18).GT.1) THEN
<           CALL CHECKL(I,NNB,XI,XIDOT,RS2,FIRR,FREG,FD,FDR)
<       END IF
---
>       IF (KZ(18).EQ.0) GO TO 50
>       IF (KZ(18).EQ.1.AND.LISTV(1).EQ.0) GO TO 50
>       CALL CHECKL(I,NNB,XI,XIDOT,RS2,FIRR,FREG,FD,FDR)
347,354c360
< *       Accumulate tidal energy change for general galactic potential.
<       IF (KZ(14).EQ.3) THEN
< *       Note: Taylor series at end of interval with negative argument.
<           ETIDE = ETIDE + BODY(I)*(0.5*W2DOT*DTR - WDOT)*DTR
< *       Note: integral of Taylor series for V*P using final values.
<       END IF
< *
< *       Check case of zero old membership (NBGAIN = NNB specifies net gain).
---
> *       Check case of zero old or new membership (skip if both are zero).
356,357c362,363
<           NBGAIN = NNB
<           GO TO 70
---
>           IF (NNB.EQ.0) GO TO 70
>           KLIST(2) = 0
365c371
<       ILIST(1) = LIST(NNB0+1,I)
---
>       ILIST(1) = KLIST(NNB0+1)
368c374
<    56 IF (LIST(L,I).EQ.ILIST(LG)) GO TO 58
---
>    56 IF (KLIST(L).EQ.ILIST(LG)) GO TO 58
371c377
<       IF (LIST(L,I).GE.ILIST(LG)) THEN
---
>       IF (KLIST(L).GE.ILIST(LG)) THEN
379c385
<           J = LIST(L,I)
---
>           J = KLIST(L)
394c400
<           LIST(L,I) = NTOT + 1
---
>           KLIST(L) = NTOT + 1
410c416
<       IF (RIJ2.GT.4.0*RS2.OR.NAME(J).EQ.0) GO TO 68
---
>       IF (RIJ2.GT.4.0*RS2) GO TO 68
423c429
<       LIST(NNB0+1,I) = ILIST(1)
---
>       KLIST(NNB0+1) = ILIST(1)
437c443,444
<       DRDV = 3.0*(A1*DV(1) + A2*DV(2) + A3*DV(3))*DR2I
---
>       DRDV = A1*DV(1) + A2*DV(2) + A3*DV(3)
>       DRDP = 3.0*DRDV*DR2I
442,444c449,451
<       FD(1) = FD(1) + (DV(1) - A1*DRDV)*DR3I
<       FD(2) = FD(2) + (DV(2) - A2*DRDV)*DR3I
<       FD(3) = FD(3) + (DV(3) - A3*DRDV)*DR3I
---
>       FD(1) = FD(1) + (DV(1) - A1*DRDP)*DR3I
>       FD(2) = FD(2) + (DV(2) - A2*DRDP)*DR3I
>       FD(3) = FD(3) + (DV(3) - A3*DRDP)*DR3I
448,450c455,461
<       FDR(1) = FDR(1) - (DV(1) - A1*DRDV)*DR3I
<       FDR(2) = FDR(2) - (DV(2) - A2*DRDV)*DR3I
<       FDR(3) = FDR(3) - (DV(3) - A3*DRDV)*DR3I
---
>       FDR(1) = FDR(1) - (DV(1) - A1*DRDP)*DR3I
>       FDR(2) = FDR(2) - (DV(2) - A2*DRDP)*DR3I
>       FDR(3) = FDR(3) - (DV(3) - A3*DRDP)*DR3I
> *       Obtain potential and derivative.
>       PHII(I) = PHII(I) - DR3I*RIJ2
>       PHIR(I) = PHIR(I) - DR3I*RIJ2
>       PHIR1(I) = PHIR1(I) + DRDV*DR3I
465,467c476,480
<    70 DTSQ = DTR**2
<       DT6 = 6.0D0/(DTR*DTSQ)
<       DT2 = 2.0D0/DTSQ
---
>    70 CONTINUE
> *
>       DTSQ = DTR**2
>       DT6 = 6.0/(DTR*DTSQ)
>       DT2 = 2.0/DTSQ
473c486
<       IF (STEP(I).LT.5.0D0*DTMIN.AND.DTR.GT.50.0*STEP(I)) THEN
---
>       IF (DTR.GT.50.0*STEP(I)) THEN
486,493c499,503
< 	  AT3 = 2.0D0*DFR + DTR*SUM
< 	  BT2 = -3.0D0*DFR - DTR*(SUM + FRD)
< *
< 	  X0(K,I) = X0(K,I) + (0.6D0*AT3 + BT2)*DTSQ12
< 	  X0DOT(K,I) = X0DOT(K,I) + (0.75D0*AT3 + BT2)*DTR13
< *
< *         X0(K,I) = X(K,I)
< *         X0DOT(K,I) = XDOT(K,I)
---
> 	  AT3 = 2.0*DFR + DTR*SUM
> 	  BT2 = -3.0*DFR - DTR*(SUM + FRD)
> *       Use here new variables for consistency in parallel execution (R.Sp.)
>           XN(K,I) = X0(K,I) + (0.6*AT3 + BT2)*DTSQ12
>           XNDOT(K,I) = X0DOT(K,I) + (0.75*AT3 + BT2)*DTR13
496,497c506
< 	  FR(K,I) = FREG(K)
<           F(K,I) = 0.5D0*(FREG(K) + FIRR(K))
---
>           FR(K,I) = FREG(K)
499,500c508
< 	  FRDOT(K,I) = FDR(K)
<           FDOT(K,I) = ONE6*(FDR(K) + FD(K))
---
>           FRDOT(K,I) = FDR(K)
504,507d511
< *         D0R(K,I) = FREG(K) - (FI(K,I) - FIRR(K))
< *         D1R(K,I) = FDR0
< *       Use actual first derivatives (2nd derivs only consistent in FPCORR).
<           D1(K,I) = FD(K)
509,511c513,514
< *       Set second & third derivatives based on old neighbours (cf. FPCORR).
< 	  D2R(K,I) = (3.0D0*AT3 + BT2)*DT2
< 	  D3R(K,I) = AT3*DT6
---
>           D3R(K,I) = AT3*DT6
>           D2R(K,I) = (3.0*AT3 + BT2)*DT2
513a517
>       NBFLUX = NBFLUX + NBLOSS + NBGAIN
516c520
<           CALL FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT)
---
>           CALL FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT,FIRR,FREG,FD,FDR,KLIST)
519c523
<               CALL FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT)
---
>           CALL FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT,FIRR,FREG,FD,FDR,KLIST)
525c529
<           LIST(1,I) = NNB
---
>           KLIST(1) = NNB
527c531
<               LIST(L,I) = ILIST(L)
---
>               KLIST(L) = ILIST(L)
529d532
<           NBFLUX = NBFLUX + NBLOSS + NBGAIN
533,538c536,538
< *     IF (KZ(29).GT.0) THEN
< *         RI2 = X(1,I)**2 + X(2,I)**2 + X(3,I)**2
< *         IF (RI2.GT.RSPH2) THEN
< *             CALL REFLCT(I,RI2)
< *             IF (RI2.LT.0.0) GO TO 120 
< *         END IF
---
> *     IF (KZ(29).GT.0.AND.RI2.GT.RS2) THEN
> *         CALL REFLCT(I,RI2)
> *         IF (RI2.LT.0.0) GO TO 120
543,556c543,575
<       FR2 = FREG(1)**2 + FREG(2)**2 + FREG(3)**2
<       W1 = FDR(1)**2 + FDR(2)**2 + FDR(3)**2
<       W2 = D2R(1,I)**2 + D2R(2,I)**2 + D2R(3,I)**2
<       W3 = D3R(1,I)**2 + D3R(2,I)**2 + D3R(3,I)**2
< *
< *       Form new step by relative criterion.
<       W0 = (SQRT(FR2*W2) + W1)/(SQRT(W1*W3) + W2)
<       W0 = ETAR*W0
<       TTMP = SQRT(W0)
<       DT0 = TTMP
< *
< *       Determine new regular step (standard criterion or fast expression).
< *     IF (KZ(37).EQ.0) THEN
< *         TTMP = TSTEP(FREG,FDR,D2R(1,I),D3R(1,I),ETAR)
---
>       DO 100 K = 1,3
>           W1(K) = FDR(K)
>           W2(K) = D2R(K,I)
>           W3(K) = D3R(K,I)
>   100 CONTINUE
> *
>       W0(4) = FREG(1)**2 + FREG(2)**2 + FREG(3)**2
>       W1(4) = W1(1)**2 + W1(2)**2 + W1(3)**2
>       W2(4) = W2(1)**2 + W2(2)**2 + W2(3)**2
>       W3(4) = W3(1)**2 + W3(2)**2 + W3(3)**2
> *
> *       Form new step by relative criterion (extra SQRT for large F3DOT).
>       IF (W3(4).LT.1.0E+20) THEN
>           W0(1) = (SQRT(W0(4)*W2(4)) + W1(4))/
>      &                                       (SQRT(W1(4)*W3(4)) + W2(4))
>       ELSE
>           W0(1) = (SQRT(W0(4)*W2(4)) + W1(4))/
>      &                                 (SQRT(W1(4))*SQRT(W3(4)) + W2(4))
>       END IF
>       W0(1) = ETAR*W0(1)
>       TTMP = SQRT(W0(1))
> *       Winston Sweatman's suggestion
> *     DVV = (XDOT(1,I)-X0DOT(1,I))**2 + (XDOT(2,I)-X0DOT(2,I))**2 +
> *    &     (XDOT(3,I)-X0DOT(3,I))**2
> *     FFD = FREG(1)**2 + FREG(2)**2 + FREG(3)**2
> *     ETARW = ETAR
> *     TTMPW = ETARW*DVV*BODY(I)/FFD
> *
> *     PRINT*,' Reg I=',I,' TTMP,TTMPW,RATIO=',
> *    &  TTMP,TTMPW,TTMP/TTMPW
> *
> *     IF(TTMP.GT.TTMPW)THEN
> *     IGT = IGT + 1
558c577
< *         TTMP = STEPI(FREG,FDR,D2R(1,I),D3R(1,I),ETAR)
---
> *     ILE = ILE + 1
559a579,582
> *     IF(MOD(IGT+ILE,100).EQ.0)PRINT*,' irr IGT,ILE=',IGT,ILE
> *
> *     TTMP = MAX(TTMPW,TTMP)
> *     TTR = TSTEP(FREG,FDR,D2R(1,I),D3R(1,I),ETAR)
563c586
<       IF (KZ(14).EQ.0) THEN
---
>       IF (TIDAL(1).EQ.0.0D0) THEN
565,570c588
<           DF2 = FAC**2*MIN(FR2,FI2)
< *       Ignore irregular force criterion if no neighbours.
<           IF (NNB.EQ.0) DF2 = FAC**2*FR2
<       ELSE IF (KZ(14).EQ.1) THEN
<           W0 = (TIDAL(1)*XI(1))**2
<           DF2 = FAC**2*MAX(FR2,W0)
---
>           W0(4) = FAC**2*MIN(DBLE(W0(4)),FI2)
572c590,591
<           DF2 = FAC**2*FR2
---
>           W0(1) = (TIDAL(1)*XI(1))**2
>           W0(4) = FAC**2*MAX(W0(4),W0(1))
579c598
<       W0 = 0.0
---
>       W0(1) = 0.0
581,582c600,601
<           W2 = ((D3R(K,I)*S3 + D2R(K,I))*S2 + FDR(K))*DTC
<           W0 = W0 + W2**2
---
>           W0(2) = ((W3(K)*S3 + W2(K))*S2 + W1(K))*DTC
>           W0(1) = W0(1) + W0(2)**2
586c605
<       IF (W0.LT.DF2) THEN
---
>       IF (W0(1).LT.W0(4)) THEN
597,599c616,618
<       IF (TTMP.GT.2.0*STEPR(I)) THEN
<           IF (DMOD(TIME,2.0*STEPR(I)).EQ.0.0D0) THEN 
<               TTMP = MIN(2.0*STEPR(I),1.0D0)
---
> 		IF (TTMP .GT. 2.0*STEPR(I)) THEN
> 			IF (DMOD(TIME,2.0*STEPR(I)) .EQ. 0.0D0) THEN
>               TTMP = MIN(2.0*STEPR(I),1.D0)
601c620
<               TTMP = STEPR(I) 
---
>               TTMP = STEPR(I)
603c622
<       ELSE IF (TTMP.LT.STEPR(I)) THEN
---
>       ELSE IF (TTMP .LT. STEPR(I)) THEN
605,608d623
< *       Allow a second reduction to prevent spurious contributions.
<           IF (TTMP.GT.DT0) THEN
<               TTMP = 0.5*TTMP
<           END IF
613a629
> *     PRINT*,' New Step = ',TTMP,' Old ',STEPR(I),' Quot ',TTMP/STEPR(I)
614a631,632
> *     STEPR(I) = MIN(1.4*STEPR(I),DTR1)
> *
621d638
<       NSTEPR = NSTEPR + 1
623c640
<       RETURN
---
>   120 RETURN
1,2c1,2
< 1961 2004-05-13 10:29 /work/Umi2/spurzem/5/nbody6compare/reinit.f
< nbody6compare/reinit.f
---
> 2258 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/reinit.f
> nbody6++compare/reinit.f
8c8,9
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
51a53,60
> *       Set maximum integration interval equal to c.m. step.
>       TMAX = STEP(ICH)
> *
> *       Check next treatment time of perturbers & output time.
>       CALL TCHAIN(ISUB,TSMIN)
>       TMAX = MIN(TMAX,TSMIN)
>       TMAX = MIN(TMAX,TADJ - TIME)
> *
1,2c1,2
< 3645 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/remove.f
< nbody6compare/remove.f
---
> 3645 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/remove.f
> nbody6++compare/remove.f
1,2c1,2
< 7719 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/rename.f
< nbody6compare/rename.f
---
> 7720 2001-08-04 17:19 /work/Umi2/spurzem/5/nbody6++compare/rename.f
> nbody6++compare/rename.f
213a214
> 
1,2c1,2
< 2062 2001-04-07 13:23 /work/Umi2/spurzem/5/nbody6compare/renew.f
< nbody6compare/renew.f
---
> 2062 1998-08-15 14:47 /work/Umi2/spurzem/5/nbody6++compare/renew.f
> nbody6++compare/renew.f
1,2c1,2
< 13375 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/reset2.f
< nbody6compare/reset2.f
---
> 13553 2003-06-25 21:09 /work/Umi2/spurzem/5/nbody6++compare/reset2.f
> nbody6++compare/reset2.f
53c53,54
<           WRITE (6,5)  WHICH1, TIME+TOFF, ZM, NAME(2*IPAIR-1),
---
>           if(rank.eq.0)
>      &    WRITE (6,5)  WHICH1, TIME+TOFF, ZM, NAME(2*IPAIR-1),
67c68,69
<               WRITE (6,9)  TIME+TOFF, ZM, NAME(I1), NAME(I2), NAME(JG),
---
>               if(rank.eq.0)
>      &        WRITE (6,9)  TIME+TOFF, ZM, NAME(I1), NAME(JG), NAME(I2),
72c74,75
<               WRITE (6,11)  TIME+TOFF, ZM, NAME(I1), NAME(I2), NAME(JG),
---
>               if(rank.eq.0)
>      &        WRITE (6,11)  TIME+TOFF, ZM, NAME(I1), NAME(JG), NAME(I2),
96c99,100
<           WRITE (6,18)  TIME+TOFF, ZM, NAME(I1), NAMEG(IM), -NAMEM(JM),
---
>           if(rank.eq.0)
>      &    WRITE (6,18)  TIME+TOFF, ZM, NAME(I1), NAMEG(IM), -NAMEM(JM),
153c157,158
<           WRITE (6,12)  IMERGE, NAMEG(IMERGE), JCOMP
---
>           if(rank.eq.0)
>      &    WRITE (6,12)  IMERGE, NAMEG(IMERGE), JCOMP
327c332,333
<           WRITE (6,48)  JPAIR, H(JPAIR), BODY(2*JPAIR-1),
---
>           if(rank.eq.0)
>      &    WRITE (6,48)  JPAIR, H(JPAIR), BODY(2*JPAIR-1),
358c364,365
<           WRITE (6,65)  IMERGE, TIME+TOFF, BODY(2*IPAIR-1),
---
>           if(rank.eq.0)
>      &    WRITE (6,65)  IMERGE, TIME+TOFF, BODY(2*IPAIR-1),
403a411,412
> 
> 
1,2c1,2
< 10487 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/reset.f
< nbody6compare/reset.f
---
> 10592 2003-06-25 17:29 /work/Umi2/spurzem/5/nbody6++compare/reset.f
> nbody6++compare/reset.f
103c103,104
<           WRITE (6,12)  NAMEG(IMERGE)
---
>           if(rank.eq.0)
>      &    WRITE (6,12)  NAMEG(IMERGE)
213a215
> *
216a219
> *
225c228,229
<           WRITE (6,45)  JPAIR, H(JPAIR), BODY(2*JPAIR-1),
---
>           if(rank.eq.0)
>      &    WRITE (6,45)  JPAIR, H(JPAIR), BODY(2*JPAIR-1),
228c232
<    45     FORMAT (' END QUAD',I4,'  H =',F7.1,'  M =',2F7.4,
---
>    45     FORMAT (' END QUAD ',I4,'  H =',F7.1,'  M =',2F7.4,
257c261,262
<           WRITE (6,65)  IMERGE, TIME+TOFF, BODY(2*NPAIRS-1),
---
>           if(rank.eq.0)
>      &    WRITE (6,65)  IMERGE, TIME+TOFF, BODY(2*NPAIRS-1),
306c311,312
<               WRITE (6,95)  I, NAME(I), (NAMEM(L),L=1,NMERGE)
---
>               if(rank.eq.0)
>      &        WRITE (6,95)  I, NAME(I), (NAMEM(L),L=1,NMERGE)
1,2c1,2
< 4368 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/resolv.f
< nbody6compare/resolv.f
---
> 4310 2003-06-23 19:32 /work/Umi2/spurzem/5/nbody6++compare/resolv.f
> nbody6++compare/resolv.f
47c47
<       DTU2 = DTU/24.0D0
---
>       DTU2 = 0.0416666666666667*DTU
95d94
< *       Note: Update X0 for call from KSTERM after RESOLV call in MDOT.
127a127,128
> 
> 
file /work/Umi2/spurzem/5/nbody6++compare/rpmax.f does not exist
file /work/Umi2/spurzem/5/nbody6++compare/rpmin.f does not exist
1,2c1,2
< 607 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/rsort.f
< nbody6compare/rsort.f
---
> 607 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/rsort.f
> nbody6++compare/rsort.f
7c7
<       REAL*8  R(6)
---
>       REAL*8  R(1)
1,2c1,2
< 6201 2006-02-08 18:42 /work/Umi2/spurzem/5/nbody6compare/scale.f
< nbody6compare/scale.f
---
> 4601 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/scale.f
> nbody6++compare/scale.f
0a1,4
> # 1 "scale.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "scale.F"
4,5c8,9
< *       Scaling to new units.
< *       ---------------------
---
> * Scaling to new units.
> * ---------------------
8,13c12,28
< *
< *
< *       Read virial ratio, rotation scaling factors & tidal radius.
<       READ (5,*)  Q, VXROT, VZROT, RTIDE
<       RSPH2 = RTIDE
<       QVIR = Q
---
>       LOGICAL LSCALE
> * Scaling if initial model is constructed or King model is read
>       LSCALE = KZ(22).LT.2.OR.KZ(22).GE.6
> *
> # 21 "scale.F"
> *
> * Read virial ratio, rotation scaling factors & boundary radius.
>       if(rank.eq.0)then
>       READ (5,*) Q, VXROT, VZROT, RSPH2
>       end if
> 
> 
> 
> 
> 
> 
> 
21c36
< *       Form total mass and centre of mass displacements.
---
> * Form total mass and centre of mass displacements.
27c42
<    25     CONTINUE
---
>    25 CONTINUE
30c45,47
< *       Adjust coordinates and velocities to c.m. rest frame.
---
> * Adjust coordinates and velocities to c.m. rest frame.
> * (if start model data were read from other source do NOT scale)(R.Sp.)
>       IF (LSCALE) THEN
35c52
<    35     CONTINUE
---
>    35 CONTINUE
38,41c55
< *       Skip scaling of masses for unscaled upload or planetesimal disk.
<       IF (KZ(22).GT.2.OR.KZ(5).EQ.3) GO TO 52
< *
< *       Scale masses to standard units of <M> = 1/N and set total mass.
---
> * Scale masses to standard units of <M> = 1/N.
45d58
<       ZMASS = 1.0
47,48c60,69
< *       Obtain the total kinetic & potential energy.
<    52 CALL ENERGY
---
>       ZMASS = 1.D0
> *
>       END IF
> *
> * Obtain the total kinetic & potential energy.
> 
> 
> 
>       CALL ENERGY
> 
50,51c71,72
< *       Use generalized virial theorem for external tidal field.
<       IF (KZ(14).GT.0) THEN
---
> * Use generalized virial theorem for external tidal field.
>       IF (KZ(14).EQ.1) THEN
55,61c76,78
<    55     CONTINUE
<           IF (KZ(14).EQ.1) THEN
< *       Use Chandrasekhar eq. (5.535) for virial ratio (rotating frame only).
<               VIR = POT - 2.0*(ETIDE + 0.5*TIDAL(4)*AZ)
<           ELSE
<               VIR = POT - 2.0*ETIDE
<           END IF
---
>    55 CONTINUE
>           ZKIN1 = ZKIN + 0.5*TIDAL(4)*AZ
>           VIR = POT - 2.0*ETIDE
62a80
>           ZKIN1 = ZKIN
66,89c84,102
< *       Allow two optional ways of skipping standard velocity scaling.
<       IF (KZ(22).GT.2.OR.KZ(5).EQ.2.OR.KZ(5).EQ.3) THEN
<           QV = SQRT(Q*VIR/ZKIN)
<           E0 = ZKIN*QV**2 - POT + ETIDE
<           SX = 1.0
< *       Rescale velocities to new masses for two Plummer spheres.
<           IF (KZ(5).EQ.2) THEN
<               ZKIN = 0.0
<               DO 57 I = 1,N
<                   DO 56 K = 1,3
<                       XDOT(K,I) = XDOT(K,I)*QV
<                       ZKIN = ZKIN + 0.5*BODY(I)*XDOT(K,I)**2
<    56             CONTINUE
<    57         CONTINUE
<               E0 = ZKIN - POT + ETIDE
<               Q = ZKIN/POT
<               WRITE (6,59)  E0, ZKIN/POT
<    59         FORMAT (/,12X,'UNSCALED ENERGY    E =',F10.6,
<      &                                       '  Q =',F6.2)
<           ELSE
<               IF (KZ(5).EQ.3) E0 = ZKIN - POT
<               WRITE (6,54)  E0
<    54         FORMAT (/,12X,'UNSCALED ENERGY    E =',F10.6)
<           END IF
---
> * Scale non-zero velocities by virial theorem ratio.
> * (if start model data were read from other source do NOT scale)(R.Sp.)
>       IF (LSCALE) THEN
>       IF (ZKIN.GT.0.0D0) THEN
>           QV = SQRT(Q*VIR/ZKIN1)
>           DO 60 I = 1,N
>               DO 58 K = 1,3
>                   XDOT(K,I) = XDOT(K,I)*QV
>    58 CONTINUE
>    60 CONTINUE
>       END IF
> *
> * Scale total energy to standard units (E = -0.25 for Q < 1).
>       E0 = -0.25
>       ETOT = (Q - 1.0)*POT
> * Include case of hot system inside reflecting boundary.
>       IF (KZ(29).GT.0.AND.Q.GT.1.0) THEN
>           E0 = ETOT
>       END IF
91,132c104,128
< *       Scale non-zero velocities by virial theorem ratio.
<           IF (ZKIN.GT.0.0D0) THEN
<               QV = SQRT(Q*VIR/ZKIN)
<               DO 60 I = 1,N
<                   DO 58 K = 1,3
<                       XDOT(K,I) = XDOT(K,I)*QV
<    58             CONTINUE
<    60         CONTINUE
<           ELSE
<               QV = 1.0
<           END IF
< *
< *       Scale total energy to standard units (E = -0.25 for Q < 1).
<           E0 = -0.25
< *       Include case of hot system inside reflecting boundary.
<           IF (KZ(29).GT.0.AND.Q.GT.1.0) E0 = 0.25
< *         ETOT = (Q - 1.0)*POT
<           ETOT = ZKIN*QV**2 - POT + ETIDE
< *       Note that final ETOT will differ from -0.25 since ETIDE = 0.
<           IF (Q.LT.1.0) THEN
<               SX = E0/ETOT
<           ELSE
<               SX = 1.0
<           END IF
< *
<           WRITE (6,65)  SX, ETOT, BODY(1), BODY(N), ZMASS/FLOAT(N)
<    65     FORMAT (//,12X,'SCALING:    SX =',F6.2,'  E =',1PE10.2,
<      &                   '  M(1) =',E9.2,'  M(N) =',E9.2,'  <M> =',E9.2)
< *
< *       Scale coordinates & velocities to the new units.
<           RIJ2 = 0.0
<           DO 70 I = 1,N
<               RIJ = 0.0
<               DO 68 K = 1,3
<                   X(K,I) = X(K,I)/SX
<                   XDOT(K,I) = XDOT(K,I)*SQRT(SX)
<                   RIJ = RIJ + X(K,I)*X(K,I)
<    68         CONTINUE
<               RIJ2 = MAX(RIJ2,RIJ)
<    70     CONTINUE
<           RIJ2 = SQRT(RIJ2)
<       ENDIF
---
>       ETOT = ZKIN + POT
>       E0 = ETOT
>       END IF
> * Define scaling factor (set E0 = ETOT if energy scaling not desired).
>       SX = E0/ETOT
> *
>           if(rank.eq.0)
>      *WRITE (6,65) SX, ETOT, BODY(1), BODY(N), ZMASS/FLOAT(N)
>    65 FORMAT (
>      & '  M(1) =',E9.2,'  M(N) =',E9.2,'  <M> =',E9.2)
> *
> * Scale coordinates & velocities to the new units.
>       DO 70 I = 1,N
>           DO 68 K = 1,3
>               X(K,I) = X(K,I)/SX
>               XDOT(K,I) = XDOT(K,I)*SQRT(SX)
>    68 CONTINUE
>    70 CONTINUE
> * In case of no tidal field choose very large RTIDE (R.Sp.)
>       IF (TIDAL(1).EQ.0.0D0.AND.KZ(23).LE.2) RTIDE = 1.D8
> * In case of King model scale initial tidal radius
>       IF(KZ(23).GE.3)THEN
>       RTIDE = RTIDE/SX
>       if(rank.eq.0)PRINT*,' RTIDE =',RTIDE,' ETID=',ZMASS/RTIDE
>       END IF
134c130
< *       Check whether to include rotation (VXROT = 0 in standard case). 
---
> * Check whether to include rotation (VXROT = 0 in standard case).
137c133
< *       Set angular velocity for retrograde motion (i.e. star clusters).
---
> * Set angular velocity for retrograde motion (i.e. star clusters).
139,141c135,138
<           WRITE (6,75)  VXROT, VZROT, OMEGA
<    75     FORMAT (/,12X,'VXROT =',F6.2,'  VZROT =',F6.2,
<      &                                                 '  OMEGA =',F7.2)
---
>        if(rank.eq.0)
>      * WRITE (6,75) VXROT, VZROT, OMEGA
>    75 FORMAT (/,12X,'VXROT =',F6.2,'  VZROT =',F6.2,
>      & '  OMEGA =',F7.2)
143c140
< *       Add solid-body rotation about Z-axis (reduce random velocities).
---
> * Add solid-body rotation about Z-axis (reduce random velocities).
148,164c145
<    80     CONTINUE
<       END IF
< *
< *       Check option for writing the initial conditions on unit 10.
<       IF (KZ(22).EQ.1) THEN
<           DO 85 I = 1,N
<               WRITE (10,84)  BODY(I), (X(K,I),K=1,3), (XDOT(K,I),K=1,3)
<    84         FORMAT (1P,7E14.6)
<    85     CONTINUE
<       END IF
< *
< *       Check option for reading initial subsystems.
<       IF (KZ(24).GT.0) THEN
<           K = KZ(24)
<           DO 90 I = 1,K
<               READ (5,*)  (X(J,I),J=1,3), (XDOT(J,I),J=1,3)
<    90     CONTINUE
---
>    80 CONTINUE
167c148
< *       Set initial crossing time in scaled units.
---
> * Set initial crossing time in scaled units.
171c152
< *       Obtain approximate half-mass radius after scaling.
---
> * Obtain approximate half-mass radius after scaling.
173c154
< *       Set square radius of reflecting sphere (used with option 29).
---
> * Set square radius of reflecting sphere.
175c156
< *       Form equilibrium rms velocity (temporarily defined as VC).
---
> * Form equilibrium rms velocity (temporarily defined as VC).
178c159
< *       Check for general binary search of initial condition.
---
> * Check for general binary search of initial condition.
183c164
< *       Print half-mass relaxation time & equilibrium crossing time.
---
> * Print half-mass relaxation time & equilibrium crossing time.
186c167
<       WRITE (6,95)  TRH, TCR, 2.0*RSCALE/VC
---
>       if(rank.eq.0)WRITE (6,95) TRH, TCR, 2.0*RSCALE/VC
188c169
<      &                                            '  2<R>/<V> =',E8.1,/)
---
>      & '  2<R>/<V> =',E8.1,/)
1,2c1,2
< 4086 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/search.f
< nbody6compare/search.f
---
> 4334 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/search.f
> nbody6++compare/search.f
14a15,22
> *       Predict current state vector of body #I to order FDOT.
>           S = TIME - T0(I)
>           DO 1 K = 1,3
>               X(K,I) = ((FDOT(K,I)*S + F(K,I))*S + X0DOT(K,I))*S +
>      &                                                           X0(K,I)
>               XDOT(K,I) = (3.0*FDOT(K,I)*S + 2.0*F(K,I))*S + X0DOT(K,I)
>     1     CONTINUE
> *
26a35,41
> *       Prediction (R.Sp.)
>           S = TIME - T0(J)
>           DO 25 K = 1,3
>               X(K,J) = ((FDOT(K,J)*S + F(K,J))*S + X0DOT(K,J))*S +
>      &                                                           X0(K,J)
>               XDOT(K,J) = (3.0*FDOT(K,J)*S + 2.0*F(K,J))*S + X0DOT(K,J)
>    25     CONTINUE
49a65,71
> *       Prediction (R.Sp.)
>           S = TIME - T0(J)
>           DO 65 KK = 1,3
>           X(KK,J) = ((FDOT(KK,J)*S + F(KK,J))*S + X0DOT(KK,J))*S +
>      &                                                         X0(KK,J)
>           XDOT(KK,J) = (3.0*FDOT(KK,J)*S + 2.0*F(KK,J))*S + X0DOT(KK,J)
>    65     CONTINUE
78,103c100
<       IF (RDOT.GT.0.02*SQRT((BODY(I) + BODY(JCOMP))*RIJMIN)) GO TO 10
< *
< *       Ensure a massive neighbour is included in perturbation estimate.
<       BCM = BODY(I) + BODY(JCOMP)
<       IF (BODY1.GT.10.0*BCM) THEN
<           JBIG = 0
<           BIG = BCM
<           NNB1 = LIST(1,I) + 1
<           DO 20 L = 2,NNB1
<               J = LIST(L,I)
<               IF (BODY(J).GT.BIG) THEN
<                   JBIG = J
<                   BIG = BODY(J)
<               END IF
<    20     CONTINUE
< *       Check whether already present, otherwise add to JLIST.
<           DO 25 L = 1,NCLOSE
<               IF (JLIST(L).EQ.JBIG) THEN
<                   JBIG = 0
<               END IF
<    25     CONTINUE
<           IF (JBIG.GT.0) THEN
<               NCLOSE = NCLOSE + 1
<               JLIST(NCLOSE) = JBIG
<           END IF
<       END IF
---
>       IF (RDOT.GT.0.1*SQRT((BODY(I) + BODY(JCOMP))*RIJMIN)) GO TO 10
109c106
<       GI = PERT*RJMIN2/BCM
---
>       GI = PERT*RJMIN2/(BODY(I) + BODY(JCOMP))
111,112c108,109
< *         IF (KZ(4).GT.0.AND.TIME-TLASTT.GT.4.44*TCR/FLOAT(N))
< *    &                                             CALL EVOLVE(JCOMP,0)
---
>           IF (KZ(4).GT.0.AND.TIME-TLASTT.GT.4.44*TCR/FLOAT(N))
>      &                                             CALL EVOLVE(JCOMP,0)
1,2c1,2
< 1004 2004-06-17 18:58 /work/Umi2/spurzem/5/nbody6compare/select.f
< nbody6compare/select.f
---
> 993 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/select.f
> nbody6++compare/select.f
12d11
<       SAVE
1,2c1,2
< 7067 2005-03-28 11:29 /work/Umi2/spurzem/5/nbody6compare/setsys.f
< nbody6compare/setsys.f
---
> 5171 2003-06-25 20:04 /work/Umi2/spurzem/5/nbody6++compare/setsys.f
> nbody6++compare/setsys.f
8c8,9
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
17,21d17
<       COMMON/BINARY/  ZM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
<       SAVE JSAVE
<       INTEGER JSAVE(3)
74,98d69
< *
< *       Check for addition of binary (NCH < 4).
<       IF (JCMAX.GT.N.AND.NCH.LT.4) THEN
<           KSP2 = JCMAX - N
<           IF (KSP2.GT.KSPAIR) KSP2 = KSP2 - 1
<           KSPAIR = KSP2
<           JCOMP = 0
< *       Save current members to prevent over-writing in KSTERM.
<           DO 6 L = 1,NCH
<               JSAVE(L) = JLIST(L)
<     6     CONTINUE
<           CALL KSTERM
< *       Note that second binary will now come first in N-body arrays.
<           DO 7 L = 1,NCH
<               JLIST(L) = JSAVE(L)
<     7     CONTINUE
< *       Add terminated KS components to chain arrays.
<           DO 8 L = 1,2
<               NCH = NCH + 1
<               JLIST(NCH) = 2*NPAIRS + L
<               NAMEC(NCH) = NAME(2*NPAIRS+L)
<               BODYC(NCH) = BODY(2*NPAIRS+L)
<               M(NCH) = BODY(2*NPAIRS+L)
<     8     CONTINUE
<       END IF
136d106
<           JG = 0
138,152c108,110
< *       Identify merger index and ghost for addition to chain.
<               DO 12 K = 1,NMERGE
<                   IF (NAMEM(K).EQ.NAME(JCLOSE)) THEN
<                       IM = K
<                   END IF
<    12         CONTINUE
< *       Note ghost must be single for maximum chain membership of 6.
<               DO 14 J = 1,N
<                   IF (BODY(J).EQ.0.0D0.AND.NAME(J).EQ.NAMEG(IM)) THEN
<                       JG = J
<                   END IF
<    14         CONTINUE
<               WRITE (6,15)  NAME(JCLOSE), NAME(JG), RSUM,  R(JCLOSE-N)
<    15         FORMAT (' SETSYS HIARCH    NM NMG RSUM RB ',
<      &                                   I6,I5,1P,2E10.2)
---
>               WRITE (6,15)  JCLOSE, RSUM,  R(JCLOSE-N)
>    15         FORMAT (/,5X,'WARNING!    SETSYS    JCLOSE RSUM R ',
>      &                                            I5,1P,2E10.2)
174c132
< *       Terminate KS pair and copy components (JCOMP=0 excludes ghost).
---
> *       Terminate KS pair and copy components.
192,204d149
< *       See whether to include merger ghost.
<           IF (JG.GT.0) THEN
<               NCH = NCH + 1
<               JLIST(NCH) = JG
<               NAMEC(NCH) = NAME(JG)
<               BODYC(NCH) = BODY(JG)
<               M(NCH) = BODY(JG)
<           END IF
<           IF (NCH.GT.6) THEN
<               WRITE (6,30)  NCH
<    30         FORMAT (' DANGER!    NCH ',I4)
<               STOP
<           END IF
1,2c1,2
< 9125 2006-03-06 18:33 /work/Umi2/spurzem/5/nbody6compare/setup.f
< nbody6compare/setup.f
---
> 2801 2002-08-17 15:15 /work/Umi2/spurzem/5/nbody6++compare/setup.f
> nbody6++compare/setup.f
42c42
<       GO TO 90
---
>       GO TO 60
92,95d91
<           IF (KZ(22).EQ.1) THEN
<               WRITE (10,46)  BODY(I), (X(K,I),K=1,3), (XDOT(K,I),K=1,3)
<    46         FORMAT (1P,7E14.6)
<           END IF
97,269d92
<       IF(KZ(22).EQ.1) CALL FLUSH(10)
< *
< *       Check initial conditions for two orbiting Plummer spheres.
<       IF (KZ(5).LE.1) GO TO 90
< *
< *       Save membership of first system for colour plot (N2 = NZERO - N1).
<       N1 = N
<       IF (KZ(5).EQ.2) THEN
<       READ (5,*)  APO, ECC, N2, SCALE
<       N2 = MIN(N,N2)
<       SEMI = APO/(1.0 + ECC)
<       SEMI = MIN(SEMI,50.0D0)
<       SEMI = MAX(SEMI,2.0D0)
<       ECC = MIN(ECC,0.999D0)
<       ECC = MAX(ECC,0.0D0)
<       ZM2 = 0.0
<       KSKIP = N1/N2
<       DO 52 I = 1,N2
<           J = KSKIP*I
<           ZM2 = ZM2 + BODY(J)
<    52 CONTINUE
<       FAC1 = ZM2/(ZMASS + ZM2)
<       FAC2 = ZMASS/(ZMASS + ZM2)
< *       Restrict volume ratio to 125 (i.e. unreasonable density contrast).
<       IF (SCALE.LE.0.2D0) SCALE = 0.2
< *       Increase total mass (save in ZMTOT for possible use in XTRNL0).
<       ZMTOT = ZMTOT + ZMBAR*ZM2
<       ZMASS = ZMASS + ZM2
< *       Set apocentre velocity for new combined mass.
<       VAP = SQRT(ZMASS/SEMI)*SQRT((1.0 - ECC)/(1.0 + ECC))
<       DO 55 I = 1,N
<           IF (I.LE.N2) THEN
< *       Copy members from first system by uniform skipping (N2 <= N1).
<           J = KSKIP*I
<           BODY(I+N) = BODY(J)
<           X(1,I+N) = SCALE*X(1,J) + FAC2*APO
<           X(2,I+N) = SCALE*X(2,J)
<           X(3,I+N) = SCALE*X(3,J)
<           XDOT(1,I+N) = XDOT(1,J)/SQRT(SCALE)
<           XDOT(2,I+N) = XDOT(2,J)/SQRT(SCALE) + FAC2*VAP
<           XDOT(3,I+N) = XDOT(3,J)/SQRT(SCALE)
<           END IF
<           X(1,I) = X(1,I) - FAC1*APO
<           XDOT(2,I) = XDOT(2,I) - FAC1*VAP
<    55 CONTINUE
<       ELSE IF (KZ(5).EQ.3) THEN
< *       Prepare case of accretion disk with massive perturber.
<           READ (5,*)  APO, ECC, DMIN, SCALE
<           RIN = 0.5
<           ROUT = 1.0
<           ZMASS = 1.0
<           BODY(1) = ZMASS
<           DO 99 K = 1,3
<               X(K,1) = 0.0
<               XDOT(K,1) = 0.0
<    99     CONTINUE
< *       Generate a thin disk population in circular orbits.
<           DO 100 I = 2,N
<               BODY(I) = 1.0D-03/FLOAT(N)
<               SEMI = RIN + (ROUT - RIN)*FLOAT(I)/FLOAT(N)
<               VCIRC = SQRT((BODY(1) + BODY(I))/SEMI)
<               PHASE = TWOPI*RAN2(KDUM)
<               X(1,I) = SEMI*COS(PHASE)
<               X(2,I) = SEMI*SIN(PHASE)
<               X(3,I) = 0.01*(2.0*RAN2(KDUM) - 1.0)
<               XDOT(1,I) = -VCIRC*SIN(PHASE)
<               XDOT(2,I) = VCIRC*COS(PHASE)
<               XDOT(3,I) = 0.01*VCIRC*(2.0*RAN2(KDUM) - 1.0)
<   100     CONTINUE
< *       Define membership of perturber and ensure no external tide.
<           N2 = 1
<           KZ(14) = 0
< *       Redefine solar mass unit and astronomical length scale in AU.
<           ZMBAR = 1.0
<           RBAR = 1.0/2.05D+05
<           BODY(N+1) = SCALE*BODY(1)
<           ZMTOT = ZMASS + BODY(N+1)
< *       Set appropriate mass ratios for transforming to new c.m. frame.
<           FAC1 = BODY(N+1)/(ZMASS + BODY(N+1))
<           FAC2 = ZMASS/(ZMASS + BODY(N+1))
<           ZMASS = ZMASS + BODY(N+1)
< *       Form orbital elements for massive perturber (avoid ECC = 1).
<           IF (ABS(ECC - 1.0).GT.1.0D-05) THEN
<               SEMI = DMIN/(1.0 - ECC)
<           ELSE
<               SEMI = -1.0D+05
<           END IF
<           VM2 = ZMASS*(2.0/DMIN - 1.0/SEMI)
<           VAP2 = ZMASS*(2.0/APO - 1.0/SEMI)
< *       Determine initial y-velocity from angular momentum conservation.
<           VY = SQRT(VM2)*DMIN/APO
<           VX = SQRT(VAP2 - VY**2)
< *       Place perturber on the Y-axis with appropriate velocities.
<           X(1,N+1) = APO*FAC2
<           X(2,N+1) = 0.0
<           X(3,N+1) = 0.0
<           XDOT(1,N+1) = -VX*FAC2
<           XDOT(2,N+1) = VY*FAC2
<           XDOT(3,N+1) = 0.0
< *       Displace the disk members and include negative y-velocity.
<           DO 120 I = 1,N
<               X(1,I) = X(1,I) - FAC1*APO
<               XDOT(1,I) = XDOT(1,I) + FAC1*VX
<               XDOT(2,I) = XDOT(2,I) - FAC1*VY
<   120     CONTINUE
<       ELSE IF (KZ(5).EQ.4) THEN
< *       Include two massive bodies (ECC > 1: NAME = 1 & 2 free floating).
<           N2 = 0
<           READ (5,*)  SEMI, ECC, ZM1, ZM2
<           WRITE (6,125)  SEMI, ECC, ZM1, ZM2
<   125     FORMAT (/,12X,'MASSIVE BODIES    A =',1P,E9.1,
<      &            '  E =',0P,F6.2,'  M1/<M> =',F6.2,'  M2/<M> =',F6.2)
<           BODY(1) = ZM1
<           BODY(2) = ZM2
<           IF (ECC.LT.1.0) THEN
< *       Set apocentre velocity for new combined mass (using NAME = 1 & 2).
<               VAP = SQRT((ZM1 + ZM2)/SEMI)*SQRT((1.0 - ECC)/(1.0 + ECC))
<               FAC1 = ZM2/(ZM1 + ZM2)
<               FAC2 = ZM1/(ZM1 + ZM2)
<               DO 130 K = 1,3
<                   X(K,1) = 0.0
<                   X(K,2) = 0.0
<                   XDOT(K,2) = 0.0
<   130         CONTINUE
< *       Initialize binary with c.m. at rest (elements change in SCALE).
<               X(1,1) = -FAC1*SEMI*(1.0 + ECC)
<               X(1,2) = FAC2*SEMI*(1.0 + ECC)
<               XDOT(2,1) = -FAC1*VAP
<               XDOT(2,2) = FAC2*VAP
<           END IF
<       ELSE
<           GO TO 90
<       END IF
< *
< *       Specify new membership.
<       N = N + N2
<       NZERO = N
<       NTOT = N
<       IF (N.GE.NMAX-10) THEN
<           WRITE (6,56)  N, NMAX
<    56     FORMAT (' DANGER!    LIMIT EXCEEDED   N =',I6,'  NMAX =',I6)
<           STOP
<       END IF
< *
<       IF (KZ(5).EQ.2) THEN
<           WRITE (6,58)  SEMI, ECC, N1, N2, SCALE
<    58     FORMAT (/,12X,'PLUMMER BINARY    A =',F6.2,'  E =',F6.2,
<      &                  '  N1 =',I6,'  N2 =',I6,'  SCALE =',F6.2)
<       ELSE IF (KZ(5).EQ.3) THEN
<           WRITE (6,59)  APO, ECC, DMIN, SCALE
<    59     FORMAT (/,12X,'MASSIVE PERTURBER    APO =',F6.2,'  E =',F6.2,
<      &                  '  DMIN =',F6.2,'  MP/M1 =',F6.2)
<       END IF
< *
< *       Re-initialize centre of mass terms.
<       DO 60 K = 1,3
<           CMR(K) = 0.0D0
<           CMRDOT(K) = 0.0D0
<    60 CONTINUE
<       ZMASS = 0.0
<       DO 70 I = 1,N
<           ZMASS = ZMASS + BODY(I)
<           DO 65 K = 1,3
<               CMR(K) = CMR(K) + BODY(I)*X(K,I)
<               CMRDOT(K) = CMRDOT(K) + BODY(I)*XDOT(K,I)
<    65     CONTINUE
<    70 CONTINUE
<       DO 80 I = 1,N
<           DO 75 K = 1,3
<               X(K,I) = X(K,I) - CMR(K)/ZMASS
<               XDOT(K,I) = XDOT(K,I) - CMRDOT(K)/ZMASS
<    75     CONTINUE
<    80 CONTINUE
272c95
<    90 IDUM1 = KDUM
---
>    60 IDUM1 = KDUM
1,2c1,2
< 2422 2006-09-10 16:50 /work/Umi2/spurzem/5/nbody6compare/shrink.f
< nbody6compare/shrink.f
---
> 2407 2000-05-04 21:24 /work/Umi2/spurzem/5/nbody6++compare/shrink.f
> nbody6++compare/shrink.f
1c1
<       SUBROUTINE SHRINK(TMIN)
---
>       SUBROUTINE SHRINK
8c8
<       PARAMETER  (DTM = 0.03125D0)
---
>       PARAMETER  (DTM = 0.03125)
54,55c54,55
< *       See whether the regular time-step can be shortened to TMIN.
<               IF (T0R(J) + 0.5*STEPR(J).GE.TMIN.AND.IT.LT.5) THEN
---
> *       See whether the regular time-step can be shortened.
>               IF (T0R(J) + 0.5*STEPR(J).GT.TIME.AND.IT.LT.5) THEN
73a74
> 
1,2c1,2
< 12032 2005-10-26 16:11 /work/Umi2/spurzem/5/nbody6compare/slow.f
< nbody6compare/slow.f
---
> 5097 1999-12-13 11:35 /work/Umi2/spurzem/5/nbody6++compare/slow.f
> nbody6++compare/slow.f
9,10c9,10
<       LOGICAL  KSLOW,KCOLL,KCASE
<       REAL*8  KSCH,KSNEW,VI(NMX3),VC(NMX3),RC1(3),RC2(3)
---
>       LOGICAL  KSLOW,KCOLL
>       REAL*8  Y(NMX8),KSCH,KSNEW
16d15
<       COMMON/CHREG/  TIMEC,TMAX,RMAXC,CM(10),NAMEC(6),NSTEP1,KZ27,KZ30
20,29c19
< *       Check for switching off slow-down at start of iteration.
<       if (GCRIT.eq.0.0d0) then
<           ksnew = 1.0
<           go to 90
<       end if
< *
< *       Set logical variable to avoid multiple copies of QK & PK.
<       KCASE = .FALSE.
< *
< *       Perform perturbation check if slow-down not active.
---
> *       Perform fast perturbation check if slow-down not active.
33c23
<           DO 1 I = 1,N-1
---
>           DO I = 1,N-1
38c28
<     1     CONTINUE
---
>           END DO
40,80c30
< *       Check carefully two possible binaries (eccentricity effect).
<           IF (N.GT.3) THEN
<               KCASE = .TRUE.
< *       Save QK & PK and copy current configuration for EREL & TRANSK.
<               DO 5 I = 1,N-1
<                   KS = 4*(I - 1)
<                   DO 4 J = 1,4
<                       QK(KS+J) = Q(KS+J)
<                       PK(KS+J) = P(KS+J)
<     4             CONTINUE
<     5         CONTINUE
< *       Evaluate first semi-major axis from non-singular variables.
<               K1 = INAME(i1)
<               K2 = INAME(i1+1)
<               CALL EREL(i1,EB,SEMI)
< *       Determine index of second smallest separation.
<               RI2 = 0.0
<               DO 10 I = 1,N-1
<                   IF (I.NE.I1.AND.RINV(I).GT.RI2) THEN
<                       I2 = I
<                       RI2 = RINV(I)
<                   END IF
<    10         CONTINUE
< *       Obtain second semi-major axis (errors only affect decision-making).
<               K1 = INAME(i2)
<               K2 = INAME(i2+1)
<               CALL EREL(i2,EB,SEMI2)
< *       Switch to #I2 if second binary is smaller or first pair is not bound.
<               IF (SEMI2.GT.0.0) THEN
<                   IF (SEMI2.LT.SEMI.OR.SEMI.LT.0.0) THEN
<                       I1 = I2
<                       SEMI = SEMI2
<                       RM = RINV(I2)
<                   END IF
< *       Exit in case of two hyperbolic two-body motions.
<               ELSE IF (SEMI.LT.0.0) THEN
<                   GO TO 100
<               END IF
<           END IF
< *
< *       Sum the perturbing forces m/r^3 next to #i1 (two terms if i1 = 2).
---
> *       Sum the perturbating forces m/r^3 next to #i1.
82c32
<           do 15 i = 1,n-1
---
>           do i = 1,n-1
88,109c38
<    15     continue
< *
< *       Include one more contribution for two consecutive perturbers.
<           if (i1.eq.1) then
<               LJ = 3*i1
<               do k = 1,3
<                   RC2(k) = XC(k+LJ+3) + XC(k+LJ)
<               end do
< *       Add perturbation from second subsequent member (i = i1 + 2).
<               RJ = SQRT(RC2(1)**2 + RC2(2)**2 + RC2(3)**2)
<               j = i1 + 3
<               sum = sum + mc(j)/RJ**3
<           else if (i1.ge.3) then
<               LJ = 3*(i1 - 2)
<               do k = 1,3
<                   RC2(k) = XC(k+LJ-3) + XC(k+LJ)
<               end do
< *       Add the previous perturbation (neglected in do 15 loop).
<               RJ = SQRT(RC2(1)**2 + RC2(2)**2 + RC2(3)**2)
<               j = i1 - 2
<               sum = sum + mc(j)/RJ**3
<           end if
---
>           end do
115c44
<               GO TO 100
---
>               GO TO 50
118a48,50
> *       Save the current variables in common (RINV is OK after switching).
>       CALL YSAVE(Y)
> *
120,178c52,55
<       IF (KSLOW.AND.N.GT.3) THEN
<           DO 20 I = 1,N-1
<               IF (KSCH(I).GT.1.0D0) i1 = i
<    20     CONTINUE
< *       See whether a closer particle pair is present (factor of 2).
<           I2 = 0
<           R1 = 1.0/RINV(I1)
<           DO 60 I = 1,N-1
<               RI2 = 1.0/RINV(I)
<               IF (I.NE.I1.AND.R1.LT.0.5*RI2) THEN
<                   I2 = I
<                   IF (R1.LT.0.1*SEMI.AND.RI2.LT.0.1*SEMI) THEN
<                       GO TO 100
<                   END IF
< *       Compare closest separation with current slow-down binary.
<                   IF (RI2.LT.0.5*SEMI.AND.R1.GT.0.5*SEMI) THEN
< *       Evaluate semi-major axis directly (cf. small RI2 in EREL).
<                       L = 3*(N-2)
<                       DO 25 K = 1,3
<                           VI(K) = -WC(K)/MC(1)
<                           VI(L+K+3) = WC(L+K)/MC(N)
<    25                 CONTINUE
<                       DO 35 II = 2,N-1
<                           L = 3*(II-1)
<                           DO 30 K = 1,3
<                               VI(L+K) = (WC(L+K-3) - WC(L+K))/MC(II)
<    30                     CONTINUE
<    35                 CONTINUE
<                       DO 40 J = 1,3*(N-1)
<                           VC(J) = VI(J+3) - VI(J)
<    40                 CONTINUE
<                       L = 3*(I1-1)
<                       R2 = XC(L+1)**2 + XC(L+2)**2 + XC(L+3)**2
<                       W2 = VC(L+1)**2 + VC(L+2)**2 + VC(L+3)**2
<                       SEMI = 2.0D0/R1 - W2/(MC(I1) + MC(I1+1))
<                       SEMI = 1.0D0/SEMI
<                       GO TO 80
<                   ELSE IF (RI2.LT.MIN(SEMI,R1).AND.R1.GT.0.5*SEMI) THEN
< *       Determine second binary by regular expression (R1 not too small).
<                       DO 50 II = 1,N-1
<                           KS = 4*(II - 1)
<                           DO 45 J = 1,4
<                               QK(KS+J) = Q(KS+J)
<                               PK(KS+J) = P(KS+J)
<    45                     CONTINUE
<    50                 CONTINUE
<                       K1 = INAME(i2)
<                       K2 = INAME(i2+1)
<                       CALL EREL(i2,EB2,SEMI2)
<                       IF (SEMI2.GT.0.0.AND.SEMI2.LT.SEMI) THEN
<                           KSNEW = 1.0D0
<                           GO TO 90
<                       ELSE
< *       Continue with the current binary (ie. small change in perturbation).
<                           GO TO 80
<                       END IF
<                   END IF
<               END IF
<    60     CONTINUE
---
>       IF (KSLOW) THEN
>           DO I = 1,N-1
>               IF (KSCH(I).GT.1.0) i1 = i
>           END DO
181,182c58,63
< *       Obtain regular semi-major axis for missing cases (including N = 3).
<       IF (.NOT.KCASE) THEN
---
> *       Check for switching off slow-down at start of iteration.
>       if (GCRIT.eq.0.0d0) then
>           ksnew = 1.0
>           go to 30
>       end if
> *
184,190c65,71
<           DO 70 I = 1,N-1
<               KS = 4*(I - 1)
<               DO 65 J = 1,4
<                   QK(KS+J) = Q(KS+J)
<                   PK(KS+J) = P(KS+J)
<    65         CONTINUE
<    70     CONTINUE
---
>       DO 10 I = 1,N-1
>           KS = 4*(I - 1)
>           DO 5 J = 1,4
>               QK(KS+J) = Q(KS+J)
>               PK(KS+J) = P(KS+J)
>     5     CONTINUE
>    10 CONTINUE
193,202c74,76
<           K1 = INAME(i1)
<           K2 = INAME(i1+1)
<           CALL EREL(i1,EB,SEMI)
< *       Exit if no current binary (set KSLOW = .false. just in case).
<           IF (SEMI.LE.0.0d0) THEN
<               KSLOW = .false.
<               TK2(0) = 0.0
<               GO TO 100
<           END IF
<       END IF
---
>       K1 = INAME(i1)
>       K2 = INAME(i1+1)
>       CALL EREL(i1,EB,SEMI)
204,216c78,82
< *       Check for switching to smaller binary (exchange leads to escape).
<       IF (KSLOW.AND.N.GT.3) THEN
<           IF (I2.GT.0) THEN
< *       Evaluate second semi-major axis (K1 & K2 can be over-written).
<               K1 = INAME(i2)
<               K2 = INAME(i2+1)
<               CALL EREL(i2,EB2,SEMI2)
<               IF (SEMI2.GT.0.0.AND.SEMI2.LT.SEMI) THEN
< *       Switch off the present pair to prepare re-activation.
<                   ksnew = 1.0
<                   go to 90
<               END IF
<           END IF
---
> *       Exit if no current binary (set KSLOW = .false. just in case).
>       IF (SEMI.LE.0.0d0) THEN
>           KSLOW = .false.
>           TK2(0) = 0.0
>           GO TO 50
219,220c85,86
< *       Sum the perturbations (on either side and non-dominant terms).
<    80 IF (KSLOW) THEN
---
> *       Sum the perturbations next to #i1 (already known if KSLOW active).
>       IF (KSLOW) THEN
223,252d88
< *
< *       Include full perturbation (non-symmetrical i1 for n = 4 or n > 4).
<               if ((n.eq.4.and.i1.ne.2).or.n.gt.4) then
<                   do k = 1,3
<                       RC1(K) = 0.0
<                   end do
< *       Save vector sum on either side of #i1 excluding closest neighbour.
<                   if (i.lt.i1-1) then
<                       do j = i+1,i1-1
<                           LJ = 3*(j-1)
<                           do k = 1,3
<                               RC1(k) = RC1(k) + XC(k+LJ)
<                           end do
<                       end do
< *       Check alternative case of subsequent distant members (i > i1 + 1).
<                   else if (i.gt.i1+1) then
<                       do j = i1+1,i-1
<                           LJ = 3*(j-1)
<                           do k = 1,3
<                               RC1(k) = RC1(k) + XC(k+LJ)
<                           end do
<                       end do
<                   end if
<               end if
< *
< *       Set chain offset and mass reference index.
<               L = 3*(I-1)
<               j = i
<               if (i.gt.i1) j = i + 1
< *       Use actual separation if perturber is next to dominant binary.
253a90,91
>                   j = i
>                   if (i.gt.i1) j = i + 1
255,262d92
<               else if (i.ne.i1) then
< *       Include chain vector to yield full distance to binary.
<                   do k = 1,3
<                       RC2(k) = RC1(k) + XC(k+L)
<                   end do
< *       Add contribution from more distant member.
<                   RJ = SQRT(RC2(1)**2 + RC2(2)**2 + RC2(3)**2)
<                   sum = sum + mc(j)/RJ**3
300c130
<    90 if (ksnew.ne.ksch(i1)) then
---
>    30 if (ksnew.ne.ksch(i1)) then
343c173
<   100 RETURN
---
>    50 RETURN
1,2c1,2
< 798 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/sort1.f
< nbody6compare/sort1.f
---
> 817 2001-08-26 01:41 /work/Umi2/spurzem/5/nbody6++compare/sort1.f
> nbody6++compare/sort1.f
7,8c7,9
<       INTEGER  RB(N),RRB
<       REAL*8  RA(N),RRA
---
>       INTEGER  RB,RRB
>       REAL*8 RA(N),RRA
>       DIMENSION  RB(N)
1,2c1,2
< 3590 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/stabl3.f
< nbody6compare/stabl3.f
---
> 2855 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/stabl3.f
> nbody6++compare/stabl3.f
60,61c60,61
< *     AM = (2.65 + E)*(1.0 + M(I)/MB)**0.3333
< *     FM = (2.0*M(I) - MB)/(3.0*MB)
---
>       AM = (2.65 + E)*(1.0 + M(I)/MB)**0.3333
>       FM = (2.0*M(I) - MB)/(3.0*MB)
64,83c64,65
< *     IF (ABS(FM).LT.0.67) THEN
< *         BM = FM*(1.0 - (0.5 - ONE3*FM)*FM)
< *     ELSE
< *         BM = LOG(1.0D0 + FM)
< *     END IF
< *       Define mass dependent criterion of Harrington (A.J. 80) & Bailyn.
< *     PCRIT = AM*(1.0 + 0.7*BM)*SEMI
< *
< *       Form hierarchical stability ratio (Kiseleva & Eggleton 1995).
< *     Q0 = MB/M(I)
< *     Q1 = MAX(M(3)/M(IM),M(IM)/M(3))
< *     Q3 = Q0**0.33333
< *     Q13 = Q1**0.33333
< *     AR = 1.0 + 3.7/Q3 - 2.2/(1.0 + Q3) + 1.4/Q13*(Q3 - 1.0)/(Q3 + 1.0)
< *     PCRIT = AR*SEMI*(1.0D0 + E)
< *
< *       Adopt the semi-analytical stability criterion (MA 1997).
<       Q1 = M(I)/MB
<       IF (E1.LT.1.0) THEN
<           XFAC = (1.0 + Q1)*(1.0 + E1)/SQRT(1.0 - E1)
---
>       IF (ABS(FM).LT.0.67) THEN
>           BM = FM*(1.0 - (0.5 - 0.3333*FM)*FM)
85c67
<           XFAC = 40.0*(1.0 + Q1)
---
>           BM = LOG(1.0D0 + FM)
87c69,71
<       PCRIT = 2.8*XFAC**0.4*SEMI
---
> *
> *       Adopt mass dependent criterion of Harrington (A.J. 80) & Bailyn.
>       PCRIT = AM*(1.0 + 0.7*BM)*SEMI
90,91c74,81
< *       Set negative termination index if system is stable and RB > SEMI.
<       IF (PCRIT.LT.PMIN.AND.E1.LT.1.0.AND.RB.GT.SEMI) THEN
---
> *       Obtain stability parameter by Zare's method.
>       M1 = M(IM)
>       M2 = M(3)
>       M3 = M(I)
>       CALL STABLZ(M1,M2,M3,SP)
> *
> *       Set negative termination index if system is stable.
>       IF (PCRIT.LT.PMIN) THEN
93,97d82
< *       Obtain Zare's stability parameter (valid for small inclinations).
<           M1 = M(IM)
<           M2 = M(3)
<           M3 = M(I)
<           CALL STABLZ(M1,M2,M3,SP)
99c84
<    20     FORMAT ('  STABT:    A A1 E E1 RI RATIO SP PCR PM ',
---
>    20     FORMAT ('  STABT:  A A1 E E1 RI RATIO SP PCR PM ',
101,103d85
< *       Terminate if escaper is outside 3*SEMI.
<       ELSE IF (E1.GT.1.0.AND.RI.GT.3.0*SEMI) THEN
<           ITERM = -1
1,2c1,2
< 5439 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/stabl4.f
< nbody6compare/stabl4.f
---
> 3706 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/stabl4.f
> nbody6++compare/stabl4.f
38d37
<       RB2 = 0.0D0
41d39
<       RDOT2 = 0.0D0
45d42
<       VREL22 = 0.0D0
64d60
<           RB2 = RB2 + (RC0(K) - X(J3))**2
67d62
<           RDOT2 = RDOT2 + (RC0(K) - X(J3))*(VC0(K) - XD(J3))
71d65
<           VREL22 = VREL22 + (VC0(K) - XD(J3))**2
80c74
< *       Form semi-major axis & eccentricity of outer pair.
---
> *       Form semi-major axis & eccentricity of wide pair.
84c78
< *     E = SQRT((1.0D0 - RB/SEMI)**2 + RDOT**2/(SEMI*MB))
---
>       E = SQRT((1.0D0 - RB/SEMI)**2 + RDOT**2/(SEMI*MB))
92,98d85
< *       Consider the inner triple.
<       MB2 = MB0 + M(K3)
<       RB2 = SQRT(RB2)
<       SEMI2 = 2.0D0/RB2 - VREL22/MB2
<       SEMI2 = 1.0/SEMI2
<       E2 = SQRT((1.0D0 - RB2/SEMI2)**2 + RDOT2**2/(SEMI2*MB2))
< *
103,104c90,91
< *     AM = (2.65 + E0)*(1.0 + MB0/MB)**0.3333
< *     FM = (2.0*MB0 - MB)/(3.0*MB)
---
>       AM = (2.65 + E0)*(1.0 + MB0/MB)**0.3333
>       FM = (2.0*MB0 - MB)/(3.0*MB)
107,111c94,98
< *     IF (ABS(FM).LT.0.67) THEN
< *         BM = FM*(1.0 - (0.5 - 0.3333*FM)*FM)
< *     ELSE
< *         BM = LOG(1.0D0 + FM)
< *     END IF
---
>       IF (ABS(FM).LT.0.67) THEN
>           BM = FM*(1.0 - (0.5 - 0.3333*FM)*FM)
>       ELSE
>           BM = LOG(1.0D0 + FM)
>       END IF
114c101,102
< *     PCRIT = AM*(1.0 + 0.7*BM)*SEMI0
---
>       PCRIT = AM*(1.0 + 0.7*BM)*SEMI0
>       PMIN = SEMI1*(1.0D0 - E1)
116,158c104,112
< *       Form hierarchical stability ratio (Kiseleva & Eggleton 1995).
< *     Q0 = MB/MB0
< *     Q1 = MAX(M(K2)/M(K1),M(K1)/M(K2))
< *     Q3 = Q0**0.33333
< *     Q13 = Q1**0.33333
< *     AR = 1.0 + 3.7/Q3 - 2.2/(1.0 + Q3) + 1.4/Q13*(Q3 - 1.0)/(Q3 + 1.0)
< *     PCRIT = AR*SEMI0*(1.0D0 + E0)
< *
< *       Check stability (AM 1997; inner triple or well separated quadruple).
<       ITERM = 0
<       IF (RB1.GT.5.0*RB2.AND.E2.LT.1.0) THEN
<           Q1 = M(K3)/MB0
<           XFAC = (1.0 + Q1)*(1.0 + E2)/SQRT(1.0 - E2)
<           PCRIT = 2.8*XFAC**0.4*SEMI0
<           PMIN = SEMI2*(1.0 - E2)
<           IF (PCRIT.LT.PMIN) THEN
<               ITERM = -1
<               RATIO = SEMI2*(1.0D0 - E2)/(SEMI0*(1.0D0 + E0))
<               WRITE (6,15)  SEMI0, SEMI2, E0, E2, RATIO, RB0, RB2,
<      &                      PCRIT, PMIN
<    15         FORMAT ('  STABT:    A0 A2 E0 E2 RATIO R0 R2 PCR PM ',
<      &                             1P,2E10.2,0P,2F7.3,F6.2,1P,4E9.1)
<           END IF
<       ELSE IF (RB1.GT.5.0*MAX(RB0,RB).AND.E1.LT.1.0.AND.
<      &         MIN(SEMI0,SEMI).GT.0.0) THEN
< *       Choose smallest binary as third body and ignore fudge factor.
<           IF (SEMI.GT.SEMI0) THEN
<               Q1 = MB0/MB
<               AIN = SEMI
<           ELSE
<               Q1 = MB/MB0
<               AIN = SEMI0
<           END IF
<           XFAC = (1.0 + Q1)*(1.0 + E1)/SQRT(1.0 - E1)
<           PCRIT = 2.8*XFAC**0.4*AIN
<           PMIN = SEMI1*(1.0 - E1)
<           IF (PCRIT.LT.PMIN) THEN
<               ITERM = -1
<               WRITE (6,20)  AIN, SEMI1, E0, E1, RATIO, RB0, RB1,
<      &                      PCRIT, PMIN
<    20         FORMAT ('  STABQ:    AIN A1 E0 E1 RATIO R0 R1 PCR PM ',
<      &                             1P,2E10.2,0P,2F7.3,F6.2,1P,4E9.1)
<           END IF
---
> *       Set negative termination index if system is stable or SEMI < 0.
>       IF (PCRIT.LT.PMIN) THEN
>           ITERM = -1
>           WRITE (6,20)  SEMI, SEMI1, E, E1, RB1, RATIO, PCRIT, PMIN,
>      &                  SEMI0, RB0
>    20     FORMAT ('  STABQ:  A A1 E E1 R1 RATIO PCR PM A0 RB0 ',
>      &                            1P,2E10.2,0P,2F6.2,F9.5,F6.2,1P,4E9.1)
>       ELSE
>           ITERM = 0
1,2c1,2
< 5136 1999-12-17 10:14 /work/Umi2/spurzem/5/nbody6compare/stablc.f
< nbody6compare/stablc.f
---
> 5136 1999-12-17 10:14 /work/Umi2/spurzem/5/nbody6++compare/stablc.f
> nbody6++compare/stablc.f
1,2c1,2
< 2172 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/stablz.f
< nbody6compare/stablz.f
---
> 2172 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/stablz.f
> nbody6++compare/stablz.f
1,2c1,2
< 12011 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/star.f
< nbody6compare/star.f
---
> 12006 2006-06-18 03:51 /work/Umi2/spurzem/5/nbody6++compare/star.f
> nbody6++compare/star.f
13c13
<       real*8 tgb,tbagb,mch,mcmax,mc1,mc2,mcbagb,dx,am
---
>       real*8 tgb,tbagb,mch,mcmax,mc1,mc2,mcbagb,dx,me,am
57,60c57
<       if(kw.ge.10) then
<          tn = 1.d10
<          goto 95
<       endif
---
>       if(kw.ge.10) goto 95
124a122
>             me = MAX(mass - mc1,0.d0)
1,2c1,2
< 10764 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/start3.f
< nbody6compare/start3.f
---
> 10764 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/start3.f
> nbody6++compare/start3.f
1,2c1,2
< 11282 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/start4.f
< nbody6compare/start4.f
---
> 11282 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/start4.f
> nbody6++compare/start4.f
1,2c1,2
< 4470 2006-02-08 18:54 /work/Umi2/spurzem/5/nbody6compare/start.f
< nbody6compare/start.f
---
> 5678 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/start.f
> nbody6++compare/start.f
0a1,4
> # 1 "start.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "start.F"
4,5c8,9
< *       Initialization of data & polynomials.
< *       ------------------------------------
---
> * Initialization of data & polynomials.
> * ------------------------------------
8,9c12,13
<       EXTERNAL SCALE,MERGE
<       PARAMETER  (NS=12)
---
>       EXTERNAL SCALE
>       PARAMETER (NS=12)
12c16
< *       Initialize global scalars, counters & useful constants.
---
> * Initialize global scalars, counters & useful constants.
15c19
< *       Read input parameters.
---
> * Read input parameters.
18c22,25
< *       Set initial conditions: BODY(I), X(K,I), XDOT(K,I); I=1,N & K=1,3.
---
> * Open all Files.
>       CALL FILE_INIT(0)
> *
> * Set initial conditions: BODY(I), X(K,I), XDOT(K,I); I=1,N & K=1,3.
21c28
< *       Scale initial conditions to new units.
---
> * Scale initial conditions to new units.
24c31
< *       Set total mass in case routines DATA & SCALE are not used.
---
> * Set total mass in case routines DATA & SCALE are not used.
30c37
< *       Define mean mass in scaled units and solar mass conversion factor.
---
> * Define mean mass in scaled units and solar mass conversion factor.
32,34c39
<       IF (KZ(5).NE.3) THEN
<           ZMBAR = ZMBAR/BODYM
<       END IF
---
>       ZMBAR = ZMBAR/BODYM
36c41
< *       Introduce scaling factors DAYS, YRS, SU, RAU, SMU, TSTAR & VSTAR.
---
> * Introduce scaling factors DAYS, YRS, SU, RAU, SMU, TSTAR & VSTAR.
39,40c44,45
< *       Check option for external force.
<       IF (KZ(14).GT.0) THEN 
---
> * Check option for external force.
>       IF (KZ(14).GT.0) THEN
42c47
<       END IF 
---
>       END IF
44c49
< *       Check optional scaling to hot system.
---
> * Check optional scaling to hot system.
49c54
< *       Check option for initial binaries.
---
> * Check option for initial binaries.
54c59
< *       Include stable primordial triples.
---
> * Include stable primordial triples.
59c64
< *       Check optional initialization for tidal two-body capture.
---
> * Check optional initialization for tidal two-body capture.
64c69
< *       Set sequential name, maximum mass & primary velocity.
---
> * Set sequential name, maximum mass & primary velocity.
71c76
<    15     CONTINUE
---
>    15 CONTINUE
74c79
< *       Initialize fixed block steps (40 levels).
---
> * Initialize fixed block steps (64 levels).
77c82
< *       Create table of inverse Stumpff coefficients.
---
> * Create table of inverse Stumpff coefficients.
79c84
<           SCOEFF(I) = 1.0D0/((I + 1)*(I + 2))
---
>           SCOEFF(I) = 1.0/((I + 1)*(I + 2))
82c87
< *       Set optional stellar evolution parameters or define STEPX.
---
> * Set optional stellar evolution parameters.
85,88d89
<       ELSE IF (KZ(14).GT.1) THEN
<           DT = 1.0E-03/TSCALE
<           CALL STEPK(DT,DTN)
<           STEPX = DTN
91c92
< *       Initialize optional cloud parameters.
---
> * Initialize optional cloud parameters.
96c97
< *       Set initial neighbour list & corresponding radius.
---
> * Set initial neighbour list & corresponding radius.
98a100
> *
104c106,110
< *       Obtain force & first derivative.
---
> * Obtain force & first derivative.
>       call cputim(tt1)
> 
> 
> 
106,107c112,120
< *
< *       Obtain second & third force derivatives and set time-steps.
---
> 
>       call cputim(tt2)
>       if(rank.eq.0)print*,' fpoly1 time=',(tt2-tt1)*60.
> *
> * Obtain second & third force derivatives and set time-steps.
>       call cputim(tt1)
> 
> 
> 
108a122,124
> 
>       call cputim(tt2)
>       if(rank.eq.0)print*,' fpoly2 time=',(tt2-tt1)*60.
110c126
< *       Regularize any hard primordial binaries (assume sequential ordering).
---
> * Regularize any hard primordial binaries (assume sequential ordering).
111a128,134
>           SMMIN = 1.D30
>           SMMAX = 0.D0
>           XMMIN = 1.D30
>           XMMAX = 0.D0
>           TMMIN = 1.D30
>           TMMAX = 0.D0
> *
116c139
< *       Include standard distance criterion.
---
> * Include standard distance criterion.
119c142,150
<    45         CONTINUE
---
>    45 CONTINUE
>         IF(RIJ2.LT.SMMIN)SMMIN=RIJ2
>         IF(RIJ2.GT.SMMAX)SMMAX=RIJ2
>               XMBIN = BODY(ICOMP) + BODY(JCOMP)
>               PERIOD = RIJ2**0.75/DSQRT(XMBIN)
>         IF(XMBIN.LT.XMMIN)XMMIN=XMBIN
>         IF(XMBIN.GT.XMMAX)XMMAX=XMBIN
>         IF(PERIOD.LT.TMMIN)TMMIN=PERIOD
>         IF(PERIOD.GT.TMMAX)TMMAX=PERIOD
121c152,173
<                   CALL KSREG
---
>                  CALL KSREG
>               ELSE
>         if(rank.eq.0)PRINT*,' Pair ',IPAIR,' not regularised '
>               END IF
>         if(rank.eq.0)PRINT*,' rij/AU, tcross/YRS=',
>      * DSQRT(RIJ2)*RAU,PERIOD*YRS
>                   CALL FLUSH(6)
>    50 CONTINUE
> *
> * Adjust NNBMAX (R.Sp.)
>       NNBMAX = MIN(N/2,LMAX - 3)
>       ZNBMIN = MAX(0.01*FLOAT(NNBMAX),1.0)
>       ZNBMAX = 0.9*FLOAT(NNBMAX)
> *
> * Check initial neighbour lists again.
>           DO 55 I = IFIRST,NTOT
>               IF(I.GT.N)THEN
>               ICOMP = 2*IPAIR - 1
>               JCOMP = 2*IPAIR
>                   RS0 = RS(ICOMP)
>               ELSE
>                   RS0 = RC
123c175,177
<    50     CONTINUE
---
>                   CALL NBLIST(I,RS0)
>    55 CONTINUE
> *
126,150c180,195
< *       Include optional regularization of primordial triples.
<       IF (KZ(11).GT.1.AND.NHI0.GT.0) THEN
<           KSPAIR = 1
< *       Note that each KS pair will move to the top of the queue.
<    60     ICOMP = 2*KSPAIR - 1
<           ICM = KSPAIR + N
<           RX2 = 1.0
< *       Find index of closest outer component without any assumption.
<           DO 70 J = IFIRST,N
<               RIJ2 = 0.0
<               DO 65 K = 1,3
<                   RIJ2 = RIJ2 + (X(K,ICM) - X(K,J))**2
<    65         CONTINUE
<               IF (RIJ2.LT.RX2) THEN
<                   RX2 = RIJ2
<                   JCOMP = J
<               END IF
<    70     CONTINUE
< *       Evaluate PCRIT for R0(NPAIRS) in MERGE since IMPACT is bypassed.
<           CALL HISTAB(KSPAIR,JCOMP,PMIN,RSTAB)
< *       Initialize the triple (constructed to be stable in HIPOP).
<           IPHASE = 6
<           CALL MERGE
<           IF (NMERGE.LT.NHI0) THEN
<               GO TO 60
---
> * Initialize the time-step list used to find next body.
>       DTLIST = 100.0
>       DO 60 I = IFIRST,NTOT
>           DTLIST = MIN(DTLIST,STEP(I))
>    60 CONTINUE
> *
> * Set initial time-step list interval twice the smallest step.
>       DTLIST = 2.0*DTLIST
>    70 NNB = 1
>       TLIST = TLIST + DTLIST
> *
> * Select all members due in the interval (0,TLIST).
>       DO 80 J = IFIRST,NTOT
>           IF (T0(J) + STEP(J).LT.TLIST) THEN
>               NNB = NNB + 1
>               NLIST(NNB) = J
151a197,205
>    80 CONTINUE
> *
> * Check whether membership range is acceptable.
>       IF (NNB.EQ.1) GO TO 70
> *
>       IF (NNB.GT.LMAX) THEN
>           TLIST = TLIST - DTLIST
>           DTLIST = 0.66*DTLIST
>           GO TO 70
154c208,212
< *       Check the average neighbour number.
---
> * Reduce new DTLIST to prevent early crowding and set membership.
>       DTLIST = 0.2*DTLIST
>       NLIST(1) = NNB - 1
> *
> * Check the average neighbour number.
157,159c215,226
<           WRITE (6,90)  ZNB
<    90     FORMAT (/,12X,'WARNING!   SMALL NEIGHBOUR NUMBERS   <NNB> =',
<      &                                                             F5.1)
---
>           if(rank.eq.0)WRITE (6,90) ZNB
>    90 FORMAT (/,12X,'WARNING!   SMALL NEIGHBOUR NUMBERS   <NNB> =',
>      & F5.1)
>       END IF
> *
> * Check option for writing the initial conditions on unit 10.
>       if(rank.eq.0)then
>       IF (KZ(22).EQ.1) THEN
>           DO 85 I = 1,N
>              WRITE (10,100) BODY(I),(X(K,I),K=1,3),(XDOT(K,I),K=1,3)
>    85 CONTINUE
>   100 FORMAT(1X,1P,7(1X,D18.10))
160a228
>       end if
1,2c1,2
< 1768 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/status.f
< nbody6compare/status.f
---
> 1768 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/status.f
> nbody6++compare/status.f
1,2c1,2
< 773 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/stepi.f
< nbody6compare/stepi.f
---
> 762 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/stepi.f
> nbody6++compare/stepi.f
19c19
< *       Obtain time-step by simplified relative criterion.           
---
> *       Obtain time-step by simplified relative criterion.
1,2c1,2
< 780 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/stepk.f
< nbody6compare/stepk.f
---
> 752 2000-04-13 02:52 /work/Umi2/spurzem/5/nbody6++compare/stepk.f
> nbody6++compare/stepk.f
8,9c8
<       DATA  ONE32 /0.03125/
< *     DATA  ONE16,ONE32 /0.0625D0,0.03125/
---
>       DATA  ONE16,ONE32 /0.0625D0,0.03125/
1,2c1,2
< 3569 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/steps.f
< nbody6compare/steps.f
---
> 3325 2003-06-26 03:20 /work/Umi2/spurzem/5/nbody6++compare/steps.f
> nbody6++compare/steps.f
9d8
< *
16,17c15
< *       Include precaution for small force or velocity (i.e. DT = ETA*TCR0).
<           IF (FI2.LT.BODYM**2/RS(I)**4) FI2 = BODYM**2/RS(I)**4
---
> *       Include precaution for small velocities (i.e. DT = ETA*TCR0).
19c17
<           DT = 0.5*ETAI*SQRT(FI2/FD2)
---
>           DT = ETAI*SQRT(FI2/FD2)
21,29c19,21
<           FD2 = D1R(1,I)**2 + D1R(2,I)**2 + D1R(3,I)**2
<           IF (FD2.LT.FR2) FD2 = FR2/TCR0**2
< *       Prescribe safe value for small or zero regular force.
<           IF (FR2.LT.0.1*BODYM/RS(I)**2) THEN
<               DTR = ETAR*TCR0
<           ELSE
<               DTR = ETAR*SQRT(FR2/FD2)
<           END IF
<  
---
>           FDR2 = D1R(1,I)**2 + D1R(2,I)**2 + D1R(3,I)**2
>           IF (FDR2.LT.FR2) FDR2 = FR2/TCR0**2
>           DTR = ETAR*SQRT(FR2/FDR2)
43a36
> *
55,56c48
<                   IF (ITER.LT.16.OR.STEP(I).GT.DTK(40)) GO TO 10
<                   STEP(I) = DTK(40)
---
>                   IF (ITER.LT.40.OR.STEP(I).GT.DTK(40)) GO TO 10
59a52
>                   STEP(I) = DTK(40)
65,66c58
<                   IF (ITER.LT.16.OR.STEPR(I).GT.DTK(40)) GO TO 18
<                   STEPR(I) = DTK(40)
---
>                   IF (ITER.LT.40.OR.STEPR(I).GT.DTK(40)) GO TO 18
69a62
>                   STEPR(I) = DTK(40)
82c75
< *             WRITE (7,28)  I, NAME(I), TIME, DT, STEP(I), STEPR(I)
---
> *             WRITE (77,28)  I, NAME(I), TIME, DT, STEP(I), STEPR(I)
85c78
< *             CALL FLUSH(7)
---
> *             CALL FLUSH(77)
98a92
> 
1,2c1,2
< 1088 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/stumpf.f
< nbody6compare/stumpf.f
---
> 1088 2001-08-24 23:08 /work/Umi2/spurzem/5/nbody6++compare/stumpf.f
> nbody6++compare/stumpf.f
1,2c1,2
< 6207 2006-02-13 09:55 /work/Umi2/spurzem/5/nbody6compare/subint.f
< nbody6compare/subint.f
---
> 6216 2003-06-25 17:26 /work/Umi2/spurzem/5/nbody6++compare/subint.f
> nbody6++compare/subint.f
10c10
<       REAL*8  TSLIST(KMAX)
---
>       REAL*8  TSLIST(10*KMAX)
32,33d31
<           LI = LI - 1
<           DTB = 0.0
40c38
<               IF (DTB.EQ.0.0D0.OR.DTB.GT.1.0D+06) THEN
---
>               IF (DTB.EQ.0.0D0.OR.DTB.GT.1.0D0) THEN
43c41,43
<     2         TBLIST = TPREV + DTB
---
>     2         CONTINUE
> *
>               TBLIST = TPREV + DTB
55c55
<               IF (NNTB.EQ.0) THEN
---
>               IF (NNTB.EQ.0.AND.DTB.LT.1.0D0) THEN
98,99c98
<                   IF (NNTB.GE.KMAX-5) THEN
<                       TBLIST = TIME
---
>                   IF (NNTB.GE.10*(KMAX-5)) THEN
105a105
>                       TBLIST = TIME
189a190,192
> 
> 
> 
1,2c1,2
< 2591 2006-09-03 17:59 /work/Umi2/spurzem/5/nbody6compare/subsys.f
< nbody6compare/subsys.f
---
> 2591 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/subsys.f
> nbody6++compare/subsys.f
1,2c1,2
< 1302 2002-09-23 16:45 /work/Umi2/spurzem/5/nbody6compare/swcond.f
< nbody6compare/swcond.f
---
> 1289 1996-12-14 02:13 /work/Umi2/spurzem/5/nbody6++compare/swcond.f
> nbody6++compare/swcond.f
8d7
<       COMMON/SWCALL/ NCALL
10,11c9,10
<       SAVE NSW
<       DATA NSW/200/
---
>       SAVE NCALL,NSW
>       DATA NCALL,NSW/0,200/
1,2c1,2
< 4096 1999-11-15 14:57 /work/Umi2/spurzem/5/nbody6compare/switch.f
< nbody6compare/switch.f
---
> 4096 1999-11-15 14:57 /work/Umi2/spurzem/5/nbody6++compare/switch.f
> nbody6++compare/switch.f
file /work/Umi2/spurzem/5/nbody6++compare/tail0.f does not exist
1,2c1,2
< 1206 2005-03-05 12:53 /work/Umi2/spurzem/5/nbody6compare/tchain.f
< nbody6compare/tchain.f
---
> 1162 2003-06-23 19:33 /work/Umi2/spurzem/5/nbody6++compare/tchain.f
> nbody6++compare/tchain.f
30c30
< *       Include safety check for large c.m. step (TPREV = TBLOCK first time).
---
> *       Include safety check in case of large c.m. step (exclude first time).
33,34d32
<       ELSE
<           TSMIN = MIN(TSMIN,DTMIN)
44a43,44
> 
> 
1,2c1,2
< 2511 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/tcirc.f
< nbody6compare/tcirc.f
---
> 2511 1999-11-28 17:12 /work/Umi2/spurzem/5/nbody6++compare/tcirc.f
> nbody6++compare/tcirc.f
file /work/Umi2/spurzem/5/nbody6++compare/tides2.f does not exist
1,2c1,2
< 1469 2006-02-17 09:47 /work/Umi2/spurzem/5/nbody6compare/tides.f
< nbody6compare/tides.f
---
> 1460 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/tides.f
> nbody6++compare/tides.f
4,5c4,5
< *       Tidal energy loss for interacting stars.
< *       ----------------------------------------
---
> *       Tidal energy loss for interacting bodies.
> *       -----------------------------------------
21c21
<           IF (KST.EQ.3.OR.KST.EQ.5.OR.KST.EQ.6) THEN
---
>           IF (KST.EQ.3.OR.KST.EQ.5) THEN
54a55
> 
1,2c1,2
< 2436 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/tperi.f
< nbody6compare/tperi.f
---
> 2450 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/tperi.f
> nbody6++compare/tperi.f
13c13
< *       DT = pericentre time interval (DT < 0 before peri).
---
> *       DT = pericentre time interval (DT > 0 after peri).
51,52c51,53
< *       Determine the eccentric anomaly with respect to pericentre (-PI,PI).
<           THETA = DATAN2(PSI/SQRT(SEMI),ZETA)
---
> *       Determine the eccentric anomaly with respect to pericentre (0,PI).
>           THETA = DATAN2(ABS(PSI)/SQRT(SEMI),ZETA)
> *
54c55
<           DT = SEMI*SQRT(SEMI/MB)*(THETA - PSI/SQRT(SEMI))
---
>           DT = SEMI*SQRT(SEMI/MB)*(THETA - ABS(PSI)/SQRT(SEMI))
63c64
<           DT = A0*SQRT(A0/MB)*(PSI/SQRT(A0) - THETA)
---
>           DT = A0*SQRT(A0/MB)*(ABS(PSI)/SQRT(A0) - THETA)
1,2c1,2
< 2338 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/tpert.f
< nbody6compare/tpert.f
---
> 2315 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/tpert.f
> nbody6++compare/tpert.f
14d13
<       JCLOSE = 0
47c46
<               JCLOSE = J
---
>               JMIN = J
72c71
<       IF (JCRIT.NE.JCLOSE) THEN
---
>       IF (JCRIT.NE.JMIN) THEN
74c73
<           DR = SQRT(RJMIN2) - RI*(BODY(JCLOSE)*A1)**0.3333
---
>           DR = SQRT(RJMIN2) - RI*(BODY(JMIN)*A1)**0.3333
80c79
<       DT = MIN(DT,4.0D0*STEP(I))
---
>       DT = MIN(DT,2.0D0*STEP(I))
1,2c1,2
< 6353 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/trans3.f
< nbody6compare/trans3.f
---
> 6353 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/trans3.f
> nbody6++compare/trans3.f
1,2c1,2
< 2221 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/trans4.f
< nbody6compare/trans4.f
---
> 2221 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/trans4.f
> nbody6++compare/trans4.f
1,2c1,2
< 1864 1996-03-26 22:20 /work/Umi2/spurzem/5/nbody6compare/transk.f
< nbody6compare/transk.f
---
> 1864 1996-03-26 22:20 /work/Umi2/spurzem/5/nbody6++compare/transk.f
> nbody6++compare/transk.f
1,2c1,2
< 1799 2004-10-22 11:18 /work/Umi2/spurzem/5/nbody6compare/transq.f
< nbody6compare/transq.f
---
> 1701 1998-08-21 15:59 /work/Umi2/spurzem/5/nbody6++compare/transq.f
> nbody6++compare/transq.f
73,75d72
< *       Include artificial STOP to get round compiler bug.
<       IF (XI(4)-XI(1).EQ.0.0D0) STOP
< *
1,2c1,2
< 1167 1999-12-15 12:00 /work/Umi2/spurzem/5/nbody6compare/transx.f
< nbody6compare/transx.f
---
> 1167 1999-12-15 12:00 /work/Umi2/spurzem/5/nbody6++compare/transx.f
> nbody6++compare/transx.f
1,2c1,2
< 16762 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/triple.f
< nbody6compare/triple.f
---
> 16215 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/triple.f
> nbody6++compare/triple.f
16c16
<       COMMON/CLOSE/  RIJ(4,4),RCOLL,QPERI,SIZE(4),ECOLL3,IP(4)
---
>       COMMON/CLOSE/  RIJ(4,4),RCOLL,QPERI,SIZE(4),ECOLL3
19d18
<       COMMON/EBSAVE/  EBS
39d37
< *       IP      Polytropic index (=1: n = 3/2; =2: n = 2; =3: n = 3).
107a106
>       IQ = 0
144,154d142
< *       Determine the smallest two-body time-scale from parabolic orbit.
<       IM = 1
<       RM = R1
<       IF (R2.LT.R1) THEN
<           IM = 2
<           RM = R2
<       END IF
<       VP2 = 2.0*(M(IM) + M(3))/RM
<       TP = RM/SQRT(VP2)
<       TSTAR = MIN(TP,TSTAR)
< *
242c230
<       NEXT = NSTEP3 + 2 
---
>       NEXT = NSTEP3 + 2
247c235
<       IF (QPERI.LT.4.0*MAX(SIZE(IM),SIZE(3))) THEN
---
>       IF (QPERI.LT.2.7*MAX(SIZE(IM),SIZE(3))) THEN
262,265d249
< *       Evaluate the two-body energy for diagnostic purposes.
<               CALL EREL3(IM,EBS,SEMI)
<               DMINC = MIN(RCOLL,DMINC)
< *
316,318d299
<       I3 = IP(3)
<       IP(3) = IP(IMIN)
<       IP(IMIN) = I3
387,389c368,370
<           IM = 1
<           IF (R2.LT.R1) IM = 2
<           I = 3 - IM
---
>           IMIN = 1
>           IF (R2.LT.R1) IMIN = 2
>           I = 3 - IMIN
402c383
<           RDOT = RDOT + 
---
>           RDOT = RDOT +
1,2c1,2
< 678 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/tstep.f
< nbody6compare/tstep.f
---
> 678 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/tstep.f
> nbody6++compare/tstep.f
1,2c1,2
< 1981 2006-09-02 12:12 /work/Umi2/spurzem/5/nbody6compare/units.f
< nbody6compare/units.f
---
> 1786 2003-08-12 04:29 /work/Umi2/spurzem/5/nbody6++compare/units.f
> nbody6++compare/units.f
9c9
< *
---
>       
15a16
>       IF(ZMBAR.GT.0.D0)THEN
17a19,22
>       ELSE
>       YRS = 0.D0
>       DAYS = 0.D0
>       END IF
45,57c50,55
<       WRITE (6,10)  RBAR, ZMBAR, VSTAR, TSTAR, BODYM*ZMBAR, SU
<    10 FORMAT (/,12X,'PHYSICAL SCALING:    R* =',1P,E9.1,
<      &              '  M* =',0P,F8.1,'  V* =',1P,E10.2,'  T* =',E10.2,
<      &              '  <M> =',0P,F5.2,'  SU =',1P,E8.1)
< *
< *       Print relevant parameters for the GR case (RZ = 6*<m>/c^2).
<       IF (KZ(27).EQ.3) THEN
<           CLIGHT = 3.0D+05/VSTAR
<           RZ = 6.0*ZMASS/(FLOAT(N)*CLIGHT**2)
<           WRITE (6,20)  VSTAR, CLIGHT, RZ
<    20     FORMAT (/,12X,'GR SCALING:    V* =',1P,E10.2,'  C =',E10.2,
<      &                                  '  RZ =',E10.2)
<       END IF
---
>       if(rank.eq.0)then
>       WRITE (6,10) RBAR, ZMBAR, VSTAR, TSTAR, BODYM*ZMBAR, SU, RAU, YRS
>    10 FORMAT (/,5X,'PHYSICAL SCALING:    R* =',1PE11.4,'  M* =',E11.4,
>      &              '  V* =',E11.4,'  T* =',E11.4,'  <M> =',E11.4,/,
>      &           26X, 'SU =',E11.4,'  AU =',E11.4,'  YRS =',E11.4,/)
>       end if
1,2c1,2
< 6835 2006-02-11 13:18 /work/Umi2/spurzem/5/nbody6compare/unpert.f
< nbody6compare/unpert.f
---
> 6158 2003-06-23 19:33 /work/Umi2/spurzem/5/nbody6++compare/unpert.f
> nbody6++compare/unpert.f
8d7
<       REAL*8  UI(4),UIDOT(4)
18c17
<       IF (TIME - T0(I1).LT.2.0D+09*TK) THEN
---
>       IF (TIME - T0(I1).LT.2.0E+09*TK) THEN
58c57
<       IF (DT.LT.TK) THEN
---
>    10 IF (DT.LT.TK) THEN
80d78
<               BE(3) = BE(3) + (POT2 - POT1)
88c86
<      &    KSTAR(I).LT.19.AND.NAME(I).GT.0) THEN
---
>      &    KSTAR(I).NE.20.AND.NAME(I).GT.0) THEN
141,158d138
< *       Perform general two-body collision test.
<       IF (KZ(19).GE.3.AND.NAME(I).GT.0) THEN
<           RI = 0.0
<           DO 29 K = 1,4
<               UI(K) = U0(K,IPAIR)
<               UIDOT(K) = UDOT(K,IPAIR)
<               RI = RI + UI(K)**2
<    29     CONTINUE
<           CALL PERI(UI,UIDOT,RI,BODY(I1),BODY(I1+1),QPERI)
<           IF (QPERI.LT.0.75*(RADIUS(I1) + RADIUS(I1+1))) THEN
< *       Obtain KS variables at pericentre before coalescence to one body.
<               CALL KSPERI(IPAIR)
<               KSPAIR = IPAIR
<               CALL CMBODY(QPERI,2)
<               IF (IPHASE.LT.0) GO TO 30
<           END IF
<       END IF
< *
172c152
<       IF (KZ(28).GT.0.AND.KSTAR(I).GE.19) THEN
---
>       IF (KZ(28).GT.0.AND.SEMI*SU.LT.10.0.AND.KSTAR(I).GT.19) THEN
194a175,176
> 
> 
1,2c1,2
< 6687 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/update.f
< nbody6compare/update.f
---
> 6213 2002-02-20 20:28 /work/Umi2/spurzem/5/nbody6++compare/update.f
> nbody6++compare/update.f
69c69
<               LIST(L,J) = LIST(L+1,J) 
---
>               LIST(L,J) = LIST(L+1,J)
100c100
<           IF (KCASE.EQ.1) WRITE (6,78)  NNB, J, JCOMP
---
>           IF (rank.eq.0.and.KCASE.EQ.1) WRITE (6,78)  NNB, J, JCOMP
161c161,162
<       IF (IFLAG.NE.-1) WRITE (8,104)  IPAIR, IFLAG, JLIST(1), JLIST(2)
---
>       IF (rank.eq.0.and.IFLAG.NE.-1) 
>      &   WRITE (8,104)  IPAIR, IFLAG, JLIST(1), JLIST(2)
180,195d180
< *       Update list of high velocity particles containing c.m. members.
<       NNB = LISTV(1)
<       DO 130 L = 2,NNB+1
<           IF (LISTV(L).EQ.ICM) THEN
< *       Remove old c.m. and reduce the membership.
<               DO 125 K = L,NNB
<                   LISTV(K) = LISTV(K+1)
<   125         CONTINUE
<               LISTV(1) = LISTV(1) - 1
<           END IF
< *       Reduce higher particle locations by one.
<           IF (LISTV(L).GT.ICM) THEN
<               LISTV(L) = LISTV(L) - 1
<           END IF
<   130 CONTINUE
< *
1,2c1,2
< 462 1995-11-27 12:52 /work/Umi2/spurzem/5/nbody6compare/vector.f
< nbody6compare/vector.f
---
> 462 1995-11-27 12:52 /work/Umi2/spurzem/5/nbody6++compare/vector.f
> nbody6++compare/vector.f
1,2c1,2
< 1698 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/verify.f
< nbody6compare/verify.f
---
> 1732 2001-08-05 23:17 /work/Umi2/spurzem/5/nbody6++compare/verify.f
> nbody6++compare/verify.f
9d8
< *
11,14c10,13
<       IF (N.GE.NMAX - 2.OR.NNBMAX.GT.LMAX - 3) THEN
<           WRITE (6,10)  N, NNBMAX
<    10     FORMAT (/,5X,'FATAL ERROR!   BAD INPUT   N =',I5,
<      &                                                  '  NNBMAX =',I4)
---
>       IF (N.GE.NMAX - 2.OR.NNBMAX.GT.LMAX - 3.OR.NNBOPT.GT.NNBMAX) THEN
>           WRITE (6,10)  N, NNBMAX, NNBOPT
>    10     FORMAT (/,5X,'FATAL ERROR!   BAD INPUT   N =',I5,' NNBMAX =',
>      &                                           I5,'  NNBOPT =',I5)
33,34c32,33
<       IF (N.LE.0.OR.NNBMAX.LE.0.OR.ETAI.LE.0.0.OR.ETAR.LE.0.0) THEN
<           WRITE (6,40)  N, NNBMAX, ETAI, ETAR
---
>       IF (N.LE.0.OR.NNBOPT.LE.0.OR.ETAI.LE.0.0.OR.ETAR.LE.0.0) THEN
>           WRITE (6,40)  N, NNBOPT, ETAI, ETAR
36c35
<      &                  '  NNBMAX =',I4,'  ETAI =',F6.2,'  ETAR =',F6.2)
---
>      &                  '  NNBOPT =',I4,'  ETAI =',F6.2,'  ETAR =',F6.2)
1,2c1,2
< 1542 2004-05-13 10:31 /work/Umi2/spurzem/5/nbody6compare/xcpred.f
< nbody6compare/xcpred.f
---
> 1594 1999-10-09 12:04 /work/Umi2/spurzem/5/nbody6++compare/xcpred.f
> nbody6++compare/xcpred.f
9c9,10
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
1,2c1,2
< 1225 1999-01-24 11:05 /work/Umi2/spurzem/5/nbody6compare/xtf.f
< nbody6compare/xtf.f
---
> 1225 1999-01-24 11:05 /work/Umi2/spurzem/5/nbody6++compare/xtf.f
> nbody6++compare/xtf.f
1,2c1,2
< 2597 2004-05-13 10:32 /work/Umi2/spurzem/5/nbody6compare/xtpert.f
< nbody6compare/xtpert.f
---
> 2649 1999-10-02 15:07 /work/Umi2/spurzem/5/nbody6++compare/xtpert.f
> nbody6++compare/xtpert.f
9c9,10
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
1,2c1,2
< 8482 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/xtrnl0.f
< nbody6compare/xtrnl0.f
---
> 2042 2003-06-26 02:49 /work/Umi2/spurzem/5/nbody6++compare/xtrnl0.f
> nbody6++compare/xtrnl0.f
8,9d7
<       COMMON/GALAXY/ GMG,RG(3),VG(3),FG(3),FGD(3),TG,
<      &               OMEGA,DISK,A,B,V02,RL2
19c17
<       RHO = 0.11
---
>       RHON = 0.11
35,40c33
<       TIDAL(3) = -(2.0*TWOPI*RHO + 2.0*(A - B)*(A + B)*(PC/GM))
< *
<       FAC = 1.0E-10/(PC/GM)
<       WRITE (6,5)  ZMBAR*ZMASS, FAC*TIDAL(1), FAC*TIDAL(3), PC/GM
<     5 FORMAT (/,12X,'TOTAL MASS =',F7.1,'  TIDAL(1&3) =',1P,2E10.2,
<      &              '  PC/GM =',E10.2)
---
>       TIDAL(3) = -(2.0*TWOPI*RHON + 2.0*(A - B)*(A + B)*(PC/GM))
45c38,39
< *       Define time scale in seconds and velocity scale in km/sec.
---
> *       Define time scale in seconds using pc as length unit.
> *          and velocity scale in km/sec (Aug.1998, P.Kroupa)
47,48d40
<       VSTAR = 1.0E-05*SQRT(GM/PC)
< *
51a44,47
> *       Ensure ZMBAR & RBAR > 0 (=0: assume <M>/Sun = 1, RBAR = 1 pc).
>       IF (ZMBAR.LE.0.0D0) ZMBAR = FLOAT(N)/ZMASS
>       IF (RBAR.LE.0.0D0) RBAR = 1.0
> *
58d53
<       VSTAR = VSTAR*SQRT(ZMASS*ZMBAR/RBAR)
60,229c55,61
< *       Consider alternatives: circular point-mass orbit or 3D galaxy model.
<    20 ZMTOT = ZMASS*ZMBAR
<       IF (KZ(14).EQ.2) THEN
< *
< *       Read galaxy mass and central distance (solar units and kpc).
<           READ (5,*)  GMG, RG0
< *
< *       Set circular velocity in km/sec and angular velocity in cgs units.
<           VG0 = 1.0D-05*SQRT(GMG/(1000.0*RG0))*SQRT(GM/PC)
<           OMEGA = 100.0*VG0/RG0
< *
< *       Obtain King tidal radius in pc (eq. (9) of Fukushige & Heggie, 1995).
<           RT = (ZMTOT/(3.0*GMG))**0.3333*(1000.0*RG0)
< *
<           IF (RTIDE.GT.0.0) THEN
< *       Determine RBAR (N-body units) from RT (pc) and King model (see SCALE).
<               IF(KZ(22).EQ.2) RBAR = RT/RTIDE
<           ELSE
<               RTIDE = RT/RBAR
<           END IF
< *
< *       Convert from cgs to N-body units.
<           OMEGA = OMEGA*SQRT(PC/GM)*SQRT(RBAR**3/ZMBAR)
< *
< *       Specify the galactic parameters for equations of motion.
<           TIDAL(1) = 3.0*OMEGA**2
<           TIDAL(2) = 0.0D0
<           TIDAL(3) = -OMEGA**2
<           TIDAL(4) = 2.0*OMEGA
<           GMG = GMG/ZMTOT
< *
< *       Check re-scaling units to current RBAR (i.e. TSCALE, TSTAR & VSTAR).
<           IF (KZ(22).EQ.2) THEN
<               CALL UNITS
<           END IF
< *
<           WRITE (6,35)  GMG, RG0, OMEGA, RTIDE, RBAR
< *
< *       Treat the general case of 3D orbit for point-mass, disk and/or halo.
<       ELSE IF (KZ(14).EQ.3) THEN
< *
< *       Read all parameters (NB! Do not confuse with Oort's constants A, B).
<           READ (5,*)  GMG, DISK, A, B, VCIRC, RCIRC, (RG(K),K=1,3),
<      &                                               (VG(K),K=1,3)
< *
< *       Specify planar motion from SEMI & ECC for no disk & halo if VZ = 0.
<           IF (DISK + VCIRC.EQ.0.0.AND.VG(3).EQ.0.0D0) THEN
<               RAP = RG(1)
<               ECC = RG(2)
<               SEMI = RAP/(1.0 + ECC)
<               VG2 = GMG/(1000.0*SEMI)*(1.0 - ECC)/(1.0 + ECC)
<               DO 25 K = 1,3
<                   RG(K) = 0.0
<                   VG(K) = 0.0
<    25         CONTINUE
< *       Initialize 2D orbit with given eccentricity at apocentre.
<               RG(1) = RAP
<               VG(2) = 1.0D-05*SQRT(VG2)*SQRT(GM/PC)
<           END IF
< *
< *       Convert from kpc and km/sec to N-body units.
<           DO 30 K = 1,3
<               RG(K) = 1000.0*RG(K)/RBAR
<               VG(K) = VG(K)/VSTAR
<    30     CONTINUE
< *
< *       Define the angular velocity (z-component) and mass in N-body units.
<           R02 = RG(1)**2 + RG(2)**2
<           OMEGA = (RG(1)*VG(2) - RG(2)*VG(1))/R02
<           TIDAL(4) = 2.0*OMEGA
<           GMG = GMG/ZMTOT
< *       Adopt a tidal radius of 50 pc unless specified by routine SCALE.
<           IF (RTIDE.EQ.0.0D0) RTIDE = 50.0/RBAR
< *
<           WRITE (6,35)  GMG, SQRT(R02), OMEGA, RTIDE, RBAR
<    35     FORMAT (/,12X,'POINT-MASS MODEL:    MG =',1P,E9.1,
<      &                  '  RG =',E9.1,'  OMEGA =',E9.1,
<      &                  '  RT =',0P,F6.2,'  RBAR =',F6.2)
< *       Define disk and/or logarithmic halo parameters in N-body units.
<           IF (DISK.GT.0.0D0) THEN
<               DISK = DISK/ZMTOT
<               A = 1000.0*A/RBAR
<               B = 1000.0*B/RBAR
<               WRITE (6,40)  DISK, A, B
<    40         FORMAT (/,12X,'DISK MODEL:    MD =',1P,E9.1,
<      &                                   '  A =',E9.1,'  B =',E9.1)
<           END IF
< *
< *       Determine local halo velocity from total circular velocity.
<           IF (VCIRC.GT.0.0D0) THEN
<               VCIRC = VCIRC/VSTAR
<               RCIRC = 1000.0*RCIRC/RBAR
<               A2 = RCIRC**2 + (A + B)**2
<               V02 = VCIRC**2 - (GMG/RCIRC + DISK*RCIRC**2/A2**1.5)
<               IF (V02.LT.0.0D0) THEN
<                   WRITE (6,45)  V02, 0.001*RCIRC*RBAR
<    45             FORMAT (' ',' NEGATIVE HALO VELOCITY!    V02 RCIRC ',
<      &                                                     1P,2E10.2)
<                   STOP
<               END IF
< *       Specify the corresponding scale length of logarithmic halo.
<               RL2 = RCIRC**2*(VCIRC**2 - V02)/V02
< *       Define the asymptotic circular velocity due to halo.
<               V02 = VCIRC**2
< *
< *       Include table of circular velocity on unit #17 (km/sec & kpc).
<               RI = 1000.0/RBAR
<               DR = 1000.0/RBAR
<               DO 60 K = 1,30
<                   RI2 = RI**2
<                   A2 = RI2 + (A + B)**2
<                   VCIRC2 = GMG/SQRT(RI2) + DISK*RI2/A2**1.5 +
<      &                                     V02*RI2/(RL2 + RI2)
<                   WRITE (17,50)  SQRT(VCIRC2)*VSTAR, RI*RBAR/1000.0
<    50             FORMAT (' CIRCULAR VELOCITY:    VC R ',F7.1,F7.2)
<                   RI = RI + DR
<    60         CONTINUE
<               CALL FLUSH(17)
< *
<               A2 = R02 + (A + B)**2
<               VCIRC2 = GMG/SQRT(R02) + DISK*R02/A2**1.5 +
<      &                                 V02*R02/(RL2 + R02)
<               VCIRC = SQRT(VCIRC2)*VSTAR
<               WRITE (6,62)  VCIRC, SQRT(R02)/1000.0, SQRT(RL2)/1000.0
<    62         FORMAT (/,12X,'CIRCULAR VELOCITY:    VC RG RL',F7.1,2F7.2)
<           ELSE
<               V02 = 0.0
<           END IF
< *
< *       Initialize F & FDOT of reference frame (point-mass galaxy is OK).
<           CALL GCINIT
< *
<           WRITE (6,65)  (RG(K),K=1,3), (VG(K),K=1,3), SQRT(V02)
<    65     FORMAT (/,12X,'SCALED ORBIT:    RG =',1P,3E10.2,
<      &                                '  VG = ',3E10.2,'  V0 =',0P,F6.1)
<       END IF
< *
< *       Include Plummer potential for 2D and 3D (set MP = 0 if not needed).
<       IF (KZ(14).EQ.3.OR.KZ(14).EQ.4) THEN
< *       Check input for Plummer potential.
<           READ (5,*)  MP, AP2, MPDOT, TDELAY
<           WRITE (6,70)  MP, AP2, MPDOT, TDELAY
<    70     FORMAT (/,12X,'PLUMMER POTENTIAL:    MP =',F7.1,'  AP =',F6.2,
<      &                  '  MPDOT =',F7.3,'  TDELAY =',F6.1)
<           MP0 = MP
<           AP2 = AP2**2
< *       Rescale velocities by including the Plummer virial energy.
<           CALL ENERGY
<           IF (ZKIN.GT.0.0D0) THEN
< *       Note that QVIR = Q is saved in routine SCALE and VIR < 0.
<               VIR = POT - VIR
<               QV = SQRT(QVIR*VIR/ZKIN)
<               DO 74 I = 1,N
<                   DO 72 K = 1,3
<                       XDOT(K,I) = XDOT(K,I)*QV
<    72             CONTINUE
<    74         CONTINUE
<           END IF
<       ELSE
<           MP = 0.0
<       END IF
<       RTIDE0 = RTIDE
< *
< *       Define tidal radius in scaled units for linearized field.
<       IF (KZ(14).LE.2) THEN
<           RTIDE = (ZMASS/TIDAL(1))**0.3333
<           WRITE (6,75)  (TIDAL(K),K=1,4), TSCALE, RTIDE
<    75     FORMAT (/,12X,'TIDAL PARAMETERS:  ',1P,4E10.2,
<      &                  '  TSCALE =',E9.2,'  RTIDE =',0P,F6.2,/)
<       END IF
---
> *       Define tidal radius in scaled units.
>       RTIDE = (ZMASS/TIDAL(1))**0.3333
> *
>       if(rank.eq.0) WRITE (6,15)  (TIDAL(K),K=1,4), TSCALE, RTIDE
>    15 FORMAT (/,12X,'TIDAL PARAMETERS:  ',1P4E10.2,'  TSCALE =',E9.2,
>      &                               ' (10**6 YRS)','  RTIDE =',
>      &                                  0PF6.2,/)
231c63
<       RETURN
---
>    20 RETURN
1,2c1,2
< 2233 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/xtrnld.f
< nbody6compare/xtrnld.f
---
> 1478 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/xtrnld.f
> nbody6++compare/xtrnld.f
8d7
<       REAL*8  XI(3),XIDOT(3),FIRR(3),FREG(3),FD(3),FDR(3)
11,12c10,11
< *       See whether to include the standard or point-mass tidal force.
<       IF (KZ(14).LE.2.AND.KCASE.EQ.1) THEN
---
> *       See whether to include the galactic tidal force.
>       IF (TIDAL(1).GT.0.0.AND.KCASE.EQ.1) THEN
26c25
<       IF (KZ(14).LE.2.AND.KCASE.EQ.2) THEN
---
>       IF (TIDAL(1).GT.0.0.AND.KCASE.EQ.2) THEN
40,60d38
< *       Check options for galactic potential (called from FPOLY1).
<       IF (KZ(14).GE.3.AND.KCASE.EQ.1) THEN
< *       Obtain regular force components for 3D galaxy or Plummer model.
<           DO 30 I = I1,I2
<               DO 25 K = 1,3
<                   XI(K) = X(K,I)
<                   XIDOT(K) = XDOT(K,I)
<                   FIRR(K) = 0.0
<                   FD(K) = 0.0
<                   FREG(K) = 0.0
<                   FDR(K) = 0.0
<    25         CONTINUE
<               CALL XTRNLF(XI,XIDOT,FIRR,FREG,FD,FDR,1)
<               DO 28 K = 1,3
<                   FR(K,I) = FR(K,I) + FREG(K)
<                   D1R(K,I) = D1R(K,I) + FDR(K)
<    28         CONTINUE
<    30     CONTINUE
< *
<       END IF
< *
1,2c1,2
< 2876 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/xtrnlf.f
< nbody6compare/xtrnlf.f
---
> 893 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/xtrnlf.f
> nbody6++compare/xtrnlf.f
1c1
<       SUBROUTINE XTRNLF(XI,XIDOT,FIRR,FREG,FD,FDR,KCASE)
---
>       SUBROUTINE XTRNLF(I,XI,XIDOT,FIRR,FREG,FD,FDR,KCASE)
8,11c8
<       COMMON/GALAXY/ GMG,RG(3),VG(3),FG(3),FGD(3),TG,
<      &               OMEGA,DISK,A,B,V02,RL2
<       REAL*8  XI(3),XIDOT(3),FIRR(3),FREG(3),FD(3),FDR(3),
<      &        XG(3),XGDOT(3),FM(3),FMD(3),FS(3),FSD(3)
---
>       REAL*8  XI(3),XIDOT(3),FIRR(3),FREG(3),FD(3),FDR(3)
14,15c11,12
< *       See whether to include a linearized galactic tidal force (two cases).
<       IF (KZ(14).LE.2) THEN
---
> *       See whether to include the galactic tidal force.
>       IF (TIDAL(1).GT.0.0) THEN
29,80d25
< *       Consider point-mass, disk and/or logarithmic halo model.
<       IF (KZ(14).EQ.3.AND.KCASE.GT.0) THEN
<           DO 5 K = 1,3
<               XG(K) = RG(K) + XI(K)
<               XGDOT(K) = VG(K) + XIDOT(K)
<     5     CONTINUE
< *       Employ differential instead of linearized forms for better accuracy.
<           IF (GMG.GT.0.0D0) THEN
<               CALL FNUC(RG,VG,FS,FSD)
<               CALL FNUC(XG,XGDOT,FM,FMD)
<               DO 10 K = 1,3
<                   FREG(K) = FREG(K) + (FM(K) - FS(K))
<                   FDR(K) = FDR(K) + (FMD(K) - FSD(K))
<    10         CONTINUE
<           END IF
< *
< *       Include Miyamoto disk for positive disk mass.
<           IF (DISK.GT.0.0D0) THEN
<               CALL FDISK(RG,VG,FS,FSD)
<               CALL FDISK(XG,XGDOT,FM,FMD)
<               DO 20 K = 1,3
<                   FREG(K) = FREG(K) + (FM(K) - FS(K))
<                   FDR(K) = FDR(K) + (FMD(K) - FSD(K))
<    20         CONTINUE
<           END IF
< *
< *       Check addition of logarithmic halo potential to regular force.
<           IF (V02.GT.0.0D0) THEN
<               CALL FHALO(RG,VG,FS,FSD)
<               CALL FHALO(XG,XGDOT,FM,FMD)
<               DO 30 K = 1,3
<                   FREG(K) = FREG(K) + (FM(K) - FS(K))
<                   FDR(K) = FDR(K) + (FMD(K) - FSD(K))
<    30         CONTINUE
<           END IF
<       END IF
< *
< *       Include optional Plummer potential in the regular force.
<       IF ((KZ(14).EQ.4.OR.MP.GT.0.0D0).AND.KCASE.GT.0) THEN
<           RI2 = AP2
<           RRDOT = 0.0
<           DO 40 K = 1,3
<               RI2 = RI2 + XI(K)**2
<               RRDOT = RRDOT + XI(K)*XIDOT(K)
<    40     CONTINUE
<           FMP = MP/(RI2*SQRT(RI2))
<           DO 50 K = 1,3
<               FREG(K) = FREG(K) - XI(K)*FMP
<               FDR(K) = FDR(K) - (XIDOT(K) - 3.0*RRDOT*XI(K)/RI2)*FMP
<    50     CONTINUE
<       END IF
< *
1,2c1,2
< 501 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/xtrnlp.f
< nbody6compare/xtrnlp.f
---
> 501 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/xtrnlp.f
> nbody6++compare/xtrnlp.f
file /work/Umi2/spurzem/5/nbody6++compare/xtrnlt.f does not exist
1,2c1,2
< 314 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6compare/xtrnlu.f
< nbody6compare/xtrnlu.f
---
> 314 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/xtrnlu.f
> nbody6++compare/xtrnlu.f
1,2c1,2
< 2163 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/xtrnlv.f
< nbody6compare/xtrnlv.f
---
> 590 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/xtrnlv.f
> nbody6++compare/xtrnlv.f
4,5c4,5
< *       External potential energy.
< *       --------------------------
---
> *       External potential.
> *       -------------------
8,13d7
<       COMMON/GALAXY/ GMG,RG(3),VG(3),FG(3),FGD(3),TG,
<      &               OMEGA,DISK,A,B,V02,RL2
<       REAL*8 XI(3)
<       SAVE FIRST
<       LOGICAL FIRST
<       DATA FIRST /.TRUE./
15a10
> *       See whether to include the galactic tidal force.
17,27c12
< *       Skip external potential during scaling (parameters not defined).
<       IF (FIRST.AND.TIME.EQ.0.0D0) THEN
<           FIRST = .FALSE.
<           GO TO 30
<       ELSE IF (KZ(14).GT.2) THEN
< *       Ignore the general case for now.
<           GO TO 30
<       END IF
< *
< *       See whether to include a linearized galactic tidal force.
<       IF (KZ(14).LE.2) THEN
---
>       IF (TIDAL(1).GT.0.0) THEN
32,63d16
<       ELSE IF (KZ(14).EQ.3) THEN
<           I = I1
<           RG2 = 0.0
<           RI2 = 0.0
<           DO 20 K = 1,3
<               XI(K) = X(K,I)
<               RG2 = RG2 + RG(K)**2
<               RI2 = RI2 + (RG(K) + XI(K))**2
<    20     CONTINUE
< *
< *       Include galaxy point mass term for body #I in differential form.
<           IF (GMG.GT.0.0D0) THEN
<               ET = ET + GMG*(1.0/SQRT(RI2) - 1.0/SQRT(RG2))
<           END IF
< *
< *       Add optional Miyamoto disk potential.
<           IF (DISK.GT.0.0D0) THEN
<               R2 = (RG(1) + XI(1))**2 + (RG(2) + XI(2))**2
<               BZ = SQRT(B**2 + (RG(3) + XI(3))**2)
<               AZ = SQRT(R2 + (A + BZ)**2)
<               R20 = RG(1)**2 + RG(2)**2
<               BZ0 = SQRT(B**2 + RG(3)**2)
<               AZ0 = SQRT(R20 + (A + BZ0)**2)
<               ET = ET + DISK*(1.0/AZ - 1.0/AZ0)
<           END IF
< *
< *       Check addition of differential logarithmic potential.
<           IF (V02.GT.0.0D0) THEN
<               ET = ET + 0.5*V02*(LOG(RI2) - LOG(RG2))
<           END IF
< *       Form the differential potential energy due to tides.
<           ET = BODY(I)*ET
67c20
<    30 IF (I2.GT.I1) THEN
---
>       IF (I2.GT.I1) THEN
1,2c1,2
< 3364 2006-09-02 16:54 /work/Umi2/spurzem/5/nbody6compare/xvpred.f
< nbody6compare/xvpred.f
---
> 3375 2000-04-14 16:35 /work/Umi2/spurzem/5/nbody6++compare/xvpred.f
> nbody6++compare/xvpred.f
9d8
< *
63c62
<       IF ((DT.EQ.0.0D0.AND.IPHASE.LT.4).OR.BODY(I).EQ.0.0D0) GO TO 35
---
>       IF (DT.EQ.0.0D0.OR.BODY(I).EQ.0.0D0) GO TO 35
77c76
<      &                   X0(K,I)
---
>      &                                                  X0(K,I)
1,2c1,2
< 519 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6compare/ycopy.f
< nbody6compare/ycopy.f
---
> 519 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/ycopy.f
> nbody6++compare/ycopy.f
1,2c1,2
< 515 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6compare/ysave.f
< nbody6compare/ysave.f
---
> 515 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/ysave.f
> nbody6++compare/ysave.f
1,2c1,2
< 3427 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/zare.f
< nbody6compare/zare.f
---
> 3317 1999-12-15 16:43 /work/Umi2/spurzem/5/nbody6++compare/zare.f
> nbody6++compare/zare.f
27a28,33
> *       Predict unperturbed KS to avoid identical coordinates (cf. NBINT).
> *     IF (LIST(1,I1).EQ.0) THEN
> *         IPAIR = KVEC(I1)
> *         CALL KSRES(IPAIR,J1,J2,0.0D0)
> *     END IF
> *
76,78c82
< *     A(4) = - A(3)
< *       Note bug fix by Douglas Heggie 1/11/2000.
<       A(4) = - (3.0D0*M2 + M1)
---
>       A(4) = - A(3)
85,94c89,94
< *  50 F1 = A(1)
< *     FP1 = F1*5.0D0
< *     DO 60 I = 2,5
< *         F1 = F1*S + A(I)
< *         FP1 = FP1*S + (6-I)*A(I)
< *  60 CONTINUE
< *
< *       Replace by iteration of f(s)/s**2 = 0 for faster convergence (DCH).
<    50 F1 = ((A(1)*S + A(2))*S + A(3))*S + A(4) + A(5)/S + A(6)/S**2
<       FP1 = (3.0*A(1)*S + 2.0*A(2))*S + A(3) - (2.0*A(6)/S + A(5))/S**2
---
>    50 F1 = A(1)
>       FP1 = F1*5.0D0
>       DO 60 I = 2,5
>           F1 = F1*S + A(I)
>           FP1 = FP1*S + (6-I)*A(I)
>    60 CONTINUE
96c96
< *     F1 = F1*S + A(6)
---
>       F1 = F1*S + A(6)
1,2c1,2
< 16217 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/zcnsts.f
< nbody6compare/zcnsts.f
---
> 16217 2006-06-20 02:34 /work/Umi2/spurzem/5/nbody6++compare/zcnsts.f
> nbody6++compare/zcnsts.f
1,2c1,2
< 10298 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/zdata.f
< nbody6compare/zdata.f
---
> 10298 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/zdata.f
> nbody6++compare/zdata.f
1,2c1,2
< 2138 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/zero.f
< nbody6compare/zero.f
---
> 2222 2003-06-25 21:20 /work/Umi2/spurzem/5/nbody6++compare/zero.f
> nbody6++compare/zero.f
46d45
<       ETIDE = 0.0D0
51,52d49
<       NBPREV = 0
<       NNTB = 0
58a56,57
>       NBPREV = 0
>       NNTB = 0
75,76c74,75
<       NTAIL = 0
< *
---
> *         small value should be smaller than 1/(4*KMAX), plus security (RS)
>       TINY = MIN(1.D-4,0.01D0/FLOAT(KMAX))
79c78
<           KVEC(J) = 0.50001*FLOAT(J + 1)
---
>           KVEC(J) = (0.5+TINY)*FLOAT(J + 1)
1,2c1,2
< 23212 2006-02-08 15:49 /work/Umi2/spurzem/5/nbody6compare/zfuncs.f
< nbody6compare/zfuncs.f
---
> 21334 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/zfuncs.f
> nbody6++compare/zfuncs.f
1d0
< 
5c4
<       real*8 m,a(200)
---
>       real*8 m,a(100)
20c19
<       real*8 m,a(200)
---
>       real*8 m,a(100)
36c35
<       real*8 m,a(200)
---
>       real*8 m,a(100)
51c50
<       real*8 m,f,df,g,dg,a(200)
---
>       real*8 m,f,df,g,dg,a(100)
54,55c53,54
< * A function to evaluate the derivative of the lifetime to the BGB
< * (or to Helium ignition if no FGB exists) wrt mass.
---
> * A function to evaluate the derivitive lifetime to the BGB
> * or to Helium ignition if no FGB exists.
67,84d65
<       real*8 FUNCTION tbgdzf(m)
<       implicit none
<       real*8 m,f,df,g,dg,a(200)
<       common /MSCFF/ a
< *
< * A function to evaluate the derivative of the lifetime to the BGB
< * (or to Helium ignition if no FGB exists) wrt Z.
< * (JH 14/12/98)
< *
<       f = a(17) + a(18)*m**4 + a(19)*m**5.5 + m**7
<       df = a(117) + a(118)*m**4 + a(119)*m**5.5
<       g = a(20)*m**2 + a(21)*m**7
<       dg = a(120)*m**2
<       tbgdzf = (df*g - f*dg)/(g*g)
< *
<       return
<       end
< ***
87c68
<       real*8 m,a(200)
---
>       real*8 m,a(100)
104c85
<       real*8 m,a(200)
---
>       real*8 m,a(100)
118c99
<       real*8 m,mcut,a(200)
---
>       real*8 m,mcut,a(100)
146c127
<       real*8 m,a1,a(200)
---
>       real*8 m,a1,a(100)
165c146
<       real*8 m,a(200)
---
>       real*8 m,a(100)
185c166
<       real*8 m,mhook,a2,a(200)
---
>       real*8 m,mhook,a2,a(100)
207c188
<       real*8 m,m2,rchk,a(200)
---
>       real*8 m,m2,a(100)
209,210d189
<       real*8 rzamsf
<       external rzamsf
213,214d191
< * Note that a safety check is added to ensure Rtms > Rzams
< * when extrapolating the function to low masses. 
219,220c196
<          rchk = 1.5d0*rzamsf(m)
<          rtmsf = MAX(rchk,(a(52) + a(53)*m**a(55))/(a(54) + m**a(56)))
---
>          rtmsf = (a(52) + a(53)*m**a(55))/(a(54) + m**a(56))
233c209
<       real*8 m,a5,a(200)
---
>       real*8 m,a5,xx,a(100)
251c227,228
<          ralphf = a5 + a(69)*(m - a(72))
---
>          xx = a5 - a(69)*a(72)
>          ralphf = xx + a(69)*m
259c236
<       real*8 m,m2,m3,b2,b3,a(200)
---
>       real*8 m,m2,m3,b2,b3,xx,a(100)
278c255,256
<          rbetaf = b3 + a(80)*(m - m3)
---
>          xx = b3 - a(80)*m3
>          rbetaf = xx + a(80)*m
287c265
<       real*8 m,m1,b1,a(200)
---
>       real*8 m,m1,b1,a(100)
314c292
<       real*8 m,mhook,m2,b2,a(200)
---
>       real*8 m,mhook,m2,b2,a(100)
338c316
<       real*8 m,a(200)
---
>       real*8 m,a(100)
353c331
<       real*8 m,a(200)
---
>       real*8 m,a(100)
357c335
< * A function to evaluate the derivative of the Lbgb function.
---
> * A function to evaluate the derivitive of the Lbgb function.
373c351
<       real*8 m,mhefl,a4,a(200)
---
>       real*8 m,mhefl,a4,a(100)
393c371
<       real*8 m,lum,a1,a(200)
---
>       real*8 m,lum,a1,a(100)
405,419d382
<       real*8 FUNCTION rgbdf(m,lum)
<       implicit none
<       real*8 m,lum,a1,a(200)
<       common /GBCFF/ a
< *
< * A function to evaluate radius derivative on the GB (as f(L)).
< * (JH 24/11/97)
< *
<       a1 = MIN(a(20)/m**a(21),a(22)/m**a(23))
<       rgbdf = a1*(a(18)*lum**(a(18)-1.d0) + 
<      &            a(17)*a(19)*lum**(a(19)-1.d0))
< *
<       return
<       end
< ***
422c385
<       real*8 m,lum,mhelf,m1,a1,a4,xx,a(200)
---
>       real*8 m,lum,mhelf,m1,a1,a4,xx,a(100)
450,480d412
<       real*8 FUNCTION ragbdf(m,lum,mhelf)
<       implicit none
<       real*8 m,lum,mhelf,m1,a1,a4,xx,a(200)
<       common /GBCFF/ a
< *
< * A function to evaluate radius derivative on the AGB (as f(L)).
< * (JH 24/11/97)
< *
<       m1 = mhelf - 0.2d0
<       if(m.ge.mhelf)then
<          xx = a(24)
<       elseif(m.ge.m1)then
<          xx = 1.d0 + 5.d0*(a(24)-1.d0)*(m-m1)
<       else
<          xx = 1.d0
<       endif
<       a4 = xx*a(19)
<       if(m.le.m1)then
<          a1 = a(29) + a(30)*m
<       elseif(m.ge.mhelf)then
<          a1 = MIN(a(25)/m**a(26),a(27)/m**a(28))
<       else
<          a1 = a(31) + 5.d0*(a(32)-a(31))*(m-m1)
<       endif
< *
<       ragbdf = a1*(a(18)*lum**(a(18)-1.d0) + 
<      &             a(17)*a4*lum**(a4-1.d0))
< *
<       return
<       end
< ***
483c415
<       real*8 m,mhefl,mchefl,mcbagb,a3,a(200)
---
>       real*8 m,mhefl,mchefl,mcbagb,a3,a(100)
500c432
<       real*8 mc,mhefl,mchefl,m1,m2,a3,a(200)
---
>       real*8 mc,mhefl,mchefl,m1,m2,a3,a(100)
519c451
<       real*8 m,a(200)
---
>       real*8 m,a(100)
531c463
<       real*8 mc,mc4,a(200)
---
>       real*8 mc,mc4,a(100)
612c544
<       real*8 m,mhefl,a(200)
---
>       real*8 m,mhefl,a(100)
630c562
<       real*8 m,a(200)
---
>       real*8 m,a(100)
644c576
<       real*8 m,mx,a(200)
---
>       real*8 m,mx,a(100)
658c590
<       real*8 m,mc,mhefl,mm,a(200)
---
>       real*8 m,mc,mhefl,mm,a(100)
682c614
<       real*8 m,mhefl,mfgb,mr,m1,m2,r1,a(200)
---
>       real*8 m,mhefl,mfgb,mr,m1,m2,r1,a(100)
709c641
<       real*8 m,mc,mhefl,mm,a4,a5,a(200)
---
>       real*8 m,mc,mhefl,mm,a4,a5,a(100)
730c662
<       real*8 m,mc,mhefl,rx,ry,mm,f,a(200)
---
>       real*8 m,mc,mhefl,rx,ry,mm,f,a(100)
839c771
<       real*8 mx,rx,rzams,rtms,gamma,tau,xx,a(200)
---
>       real*8 mx,rx,rzams,rtms,gamma,tau,xx,a(100)
908,918d839
<       real*8 FUNCTION vrotf(m)
<       implicit none
<       real*8 m
< *
<       vrotf = 330.d0*m**3.3/(15.d0 + m**3.45)
< *
<       return
<       end
< ***
< 
< 
