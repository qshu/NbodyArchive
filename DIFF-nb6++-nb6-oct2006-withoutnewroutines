1,2c1,2
< 4990 2005-03-31 19:38 /work/Umi2/spurzem/5/nbody6compare-oct2006/absorb.f
< nbody6compare-oct2006/absorb.f
---
> 4460 2002-07-12 23:12 /work/Umi2/spurzem/5/nbody6++compare/absorb.f
> nbody6++compare/absorb.f
8c8,9
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMX4=4*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
24a26
>       TIME0 = TIME
27,46c29,30
< *       Avoid zero since TBLOCK = TPREV during the first block-step.
<       IF (DT8.EQ.0.0D0) DT8 = STEP(ICH)/8.0D0
< *
< *       Adopt the nearest truncated step (at most 8 subdivisions).
<       IF (DT2.GT.0.0D0) THEN
<           CALL STEPK(DT2,DTN2)
<           DTN = NINT(DTN2/DT8)*DT8
<       ELSE
< *       Choose negative step if pericentre time < TPREV.
<           DT2 = -DT2
<           CALL STEPK(DT2,DTN2)
<           DTN = -NINT(DTN2/DT8)*DT8
<       END IF
< *
< *       Update time for new polynomial initializations (but check T - T0).
<       TIME = TPREV + DTN
< *
< *       Avoid prediction skip by XVPRED in case TIME - T0 = 0.0.
<       IF (TIME - T0(ICH).EQ.0.0D0) TIME = TIME + DT8/16.0D0
< *
---
>       TIME = TPREV + NINT(DT2/DT8)*DT8
>       TIME = MIN(TBLOCK,TIME)
51,52c35,36
<           WRITE (6,1)  TIME+TOFF, DT2, DT8
<     1     FORMAT (' ABSORB:    TIME DT2 DT8 ',F12.6,1P,2E10.2)
---
>           WRITE (6,1)  TIME0+TOFF, TIME+TOFF, DT2, DT8
>     1     FORMAT (' ABSORB:   TIME0 TIME DT2 DT8 ',2F10.6,1P,2E10.2)
162a147,148
> 
> 
1,2c1,2
< 11246 2006-08-28 11:07 /work/Umi2/spurzem/5/nbody6compare-oct2006/adjust.f
< nbody6compare-oct2006/adjust.f
---
> 9701 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/adjust.f
> nbody6++compare/adjust.f
0a1,4
> # 1 "adjust.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "adjust.F"
4,5c8,9
< *       Parameter adjustment and energy check.
< *       --------------------------------------
---
> * Parameter adjustment and energy check.
> * --------------------------------------
8,10c12,15
<       COMMON/ECHAIN/  ECH
<       SAVE  DTOFF
<       DATA  DTOFF /100.0D0/
---
>       COMMON/ECHAIN/ ECH
>       COMMON/STSTAT/ TINIT,NIR,NIB,NRGL,NKS
>       SAVE DTOFF
>       DATA DTOFF /100.0D0/
13c18
< *       Predict X & XDOT for all particles (except unperturbed pairs).
---
> * Predict X & XDOT for all particles (except unperturbed pairs).
16c21,30
< *       Obtain the total energy at current time (resolve all KS pairs).
---
> * ico = ico + 1
> * do 556 i=1,n
> * write(55,100)ico,name(i),(xdot(k,i),k=1,3)
> *556 continue
> *100 format(1x,2i5,3f7.2)
> *
> * Obtain the total energy at current time (resolve all KS pairs).
> 
> 
> 
17a32
> 
19c34
< *       Initialize c.m. terms.
---
> * Initialize c.m. terms.
25c40
< *       Obtain c.m. & angular momentum integrals and Z-moment of inertia.
---
> * Obtain c.m. & angular momentum integrals and Z-moment of inertia.
29d43
<       ISUN = 1
31d44
<           IF (NAME(I).EQ.1) ISUN = I
36,38c49,53
<    15     CONTINUE
< *         RI2 = (X(1,I) - RDENS(1))**2 + (X(2,I) - RDENS(2))**2 +
< *    &                                   (X(3,I) - RDENS(3))**2
---
>    15 CONTINUE
>           RI2 = (X(1,I) - RDENS(1))**2 + (X(2,I) - RDENS(2))**2 +
>      & (X(3,I) - RDENS(3))**2
> * Skip contribution from escapers.
>           IF (RI2.GT.4.0*RTIDE**2) GO TO 20
43c58
< *       Form c.m. coordinates & velocities (vectors & scalars).
---
> * Form c.m. coordinates & velocities (vectors & scalars).
52c67
< *       Subtract the kinetic energy of c.m. due to possible cloud effects.
---
> * Subtract the kinetic energy of c.m. due to possible cloud effects.
55,56c70,71
< *       Form virial ratio using single particles & c.m. (isolated or tidal). 
<       IF (KZ(14).EQ.0.OR.KZ(14).EQ.3) THEN
---
> * Form virial ratio using single particles & c.m. (isolated or tidal).
>       IF (KZ(14).EQ.0) THEN
58,62d72
<           E(3) = ZKIN - POT
<       ELSE IF (KZ(14).EQ.4) THEN
< *       Employ actual virial energy for central Plummer potential.
<           Q = ZKIN/(POT - VIR)
<           E(3) = ZKIN - POT + ETIDE
64c74
< *       Use Chandrasekhar eq. (5.535) for virial ratio.
---
> * Use Chandrasekhar eq. (5.535) for virial ratio.
66,67c76,77
<           Q = ZKVIR/(POT + 2.0*ETIDE)
< *       Modify angular momentum integral using Chandrasekhar eq. (5.530).
---
>           Q = ZKVIR/(POT - 2.0*ETIDE)
> * Modify angular momentum integral using Chandrasekhar eq. (5.530).
69,74d78
<           E(3) = ZKIN - POT + ETIDE
<       END IF
< *       Include case of Plummer sphere for 3D orbit.
<       IF (KZ(14).EQ.3.AND.MP.GT.0.0D0) THEN
<           Q = ZKIN/(POT - VIR)
<           E(3) = ZKIN - POT + ETIDE
77,80c81,84
< *       Define crossing time using single particle energy (cf. option 14).
<       TCR = ZMASS**2.5/(2.0*ABS(E(3)))**1.5
< *       Note: see below for better definition in Plummer or 3D orbit case.
<       IF (Q.GT.1.0.AND.KZ(14).LT.3) THEN
---
> * Define crossing time and save single particle energy.
>       ETOT = ZKIN - POT + ETIDE
>       TCR = ZMASS**2.5/(2.0*ABS(ETOT))**1.5
>       IF (Q.GT.1.0) THEN
83,84c87
< *       Form provisional total energy.
<       ETOT = ZKIN - POT + ETIDE
---
>       E(3) = ETOT
86c89
< *       Include KS pairs, triple, quad, mergers, collisions & chain.
---
> * Include KS pairs, triple, quad, mergers, collisions & chain.
91,92c94
< *
< *       Update energies and form the relative error (divide by ZKIN or E(3)).
---
> * Update energies and form the relative error (divide by ZKIN or E(3)).
97d98
<           DELTA1 = 0.0D0
102d102
<           DELTA1 = DE
105c105
< *       Save sum of relative energy error for main output and accumulate DE.
---
> * Save sum of relative energy error for main output and accumulate DE.
110c110
< *       Set provisional half-mass radius.
---
> * Set provisional half-mass radius.
113c113
< *       Determine average neighbour number and smallest neighbour sphere.
---
> * Determine average neighbour number and smallest neighbour sphere.
116c116
<       DO 30 I = IFIRST,NTOT
---
>       DO 40 I = IFIRST,NTOT
119,120c119,122
<    30 CONTINUE
<       NNB = NNB/(N - NPAIRS)
---
>    40 CONTINUE
> *
> * Set average neighbour number.
>       NNB = FLOAT(NNB)/FLOAT(N - NPAIRS)
122c124
< *       Use current value if minimum neighbour sphere not implemented.
---
> * Use current value if minimum neighbour sphere not implemented.
125,126c127,128
< *       Find density centre & core radius (Casertano & Hut, Ap.J. 298, 80).
<       IF (N-NPAIRS.GE.20.AND.KZ(29).EQ.0.AND.KZ(5).NE.3) THEN
---
> * Find density centre & core radius (Casertano & Hut, Ap.J. 298, 80).
>       IF (N-NPAIRS.GE.20.AND.KZ(29).EQ.0) THEN
138,167c140
< *       Take the Sun as reference for plotting planetesimal disk members.
<       IF (KZ(5).EQ.3) THEN
<           DO 35 K = 1,3
<               RDENS(K) = X(K,ISUN)
<    35     CONTINUE
< *
< *       Determine the eccentricity dispersion and total energy of disk.
<           DISP2 = 0.0
<           EDISK = 0.0
<           DO 40 I = 1,N
<               IF (NAME(I).EQ.1.OR.NAME(I).EQ.NZERO) GO TO 40
<               RI2 = (X(1,I) - X(1,ISUN))**2 + (X(2,I) - X(2,ISUN))**2
<               VI2 = (XDOT(1,I) - XDOT(1,ISUN))**2 +
<      &              (XDOT(2,I) - XDOT(2,ISUN))**2
<               RRDOT = (X(1,I) - X(1,ISUN))*(XDOT(1,I) - XDOT(1,ISUN)) +
<      &                (X(2,I) - X(2,ISUN))*(XDOT(2,I) - XDOT(2,ISUN))
<               RI = SQRT(RI2)
<               SEMI = 2.0/RI - VI2/(BODY(ISUN) + BODY(I))
<               SEMI = 1.0/SEMI
<               ECC2 = (1.0 - RI/SEMI)**2 +
<      &                RRDOT**2/(SEMI*(BODY(I) + BODY(ISUN)))
<               DISP2 = DISP2 + ECC2
<               EDISK = EDISK - 0.5*BODY(I)/SEMI
<    40     CONTINUE
<           DISP = SQRT(DISP2/FLOAT(N-2))
<           WRITE (35,42)  TTOT, DISP, EDISK
<    42     FORMAT (' ',F8.1,1P,E10.2,E12.4)
<       END IF
< *
< *       Check optional sorting of Lagrangian radii & half-mass radius.
---
> * Check optional sorting of Lagrangian radii & half-mass radius.
172c145
< *       Scale average & maximum core density by the mean value.
---
> * Scale average & maximum core density by the mean value.
176c149
< *       Adopt density contrasts of unity for hot system.
---
> * Adopt density contrasts of unity for hot system.
182c155
< *       Check optional determination of regularization parameters.
---
> * Check optional determination of regularization parameters.
186c159
< *       Form close encounter distance from scale factor & density contrast.
---
> * Form close encounter distance from scale factor & density contrast.
188c161
< *       Use harmonic mean to reduce fluctuations (avoid initial value).
---
> * Use harmonic mean to reduce fluctuations (avoid initial value).
190c163
< *       Impose maximum value for sufficient perturbers.
---
> * Impose maximum value for sufficient perturbers.
192c165
< *       Define scaled DTMIN by RMIN & <M> and include ETAI for consistency.
---
> * Define scaled DTMIN by RMIN & <M> and include ETAI for consistency.
194c167
< *       Specify binding energy per unit mass of hard binary (impose Q = 0.5).
---
> * Specify binding energy per unit mass of hard binary (impose Q = 0.5).
196c169
< *       Adopt central velocity as upper limit (avoids large kick velocities).
---
> * Adopt central velocity as upper limit (avoids large kick velocities).
201d173
<           ECLOSE = MIN(ECLOSE,1.0D0)
204c176
< *       Check optional modification of DTMIN, ECLOSE & TCR for hot system.
---
> * Check optional modification of DTMIN, ECLOSE & TCR for hot system.
214c186
< *       Set useful scalars for the integrator.
---
> * Set useful scalars for the integrator.
219,220c191,193
<       IF (TIME.LE.0.0D0) STEPJ = 0.01*(60000.0/FLOAT(N))**0.3333
< *       Adopt 2*RSMIN for neighbour sphere volume factor in routine REGINT.
---
> * Specify square close encounter force from heaviest body at 5*RMIN.
>       FCRIT2 = (BODY1/(25.0*RMIN2))**2
> * Adopt 2*RSMIN for neighbour sphere volume factor in routine REGINT.
223c196
< *       Update density contrast factor for neighbour sphere modification.
---
> * Update density contrast factor for neighbour sphere modification.
227c200
< *       Include optional stabilization to increase neighbour number.
---
> * Include optional stabilization to increase neighbour number.
233,238c206,237
< *       Define tidal radius for isolated system (2*RTIDE used in ESCAPE).
<       IF (KZ(14).EQ.0) RTIDE = 10.0*RSCALE
< *       Redefine the crossing time for 3D cluster orbit or Plummer model.
<       IF ((KZ(14).EQ.3.OR.KZ(14).EQ.4).AND.ZKIN.GT.0.0) THEN
<           TCR = 2.0*RSCALE/SQRT(2.0*ZKIN/ZMASS)
<       END IF
---
> * Define tidal radius for isolated system (2*RTIDE used in ESCAPE).
>       IF (TIDAL(1).EQ.0.0D0) RTIDE = 10.0*RSCALE
> *
> * write(6,57)rank,ttfrc
> * 57 FORMAT(' IPE=',I4,' ttfrc=',f9.3)
> *
>       call cputim(tt1)
>       ttotal = (tt1-ttota)*60.
> *
>       if(rank.eq.0)then
> *
> * Print energy diagnostics & KS parameters.
>       ICR = INT(TTOT/TCR0)
> C New (Aug.1998) by P.Kroupa: (time also in Myr)
>       WRITE (6,50) rank, TTOT, ttot*tscale, Q, DE, BE(3)-EBIN, EBIN,
>      & EMERGE
>    50 FORMAT (/,' ',I2,' ADJUST:  TIME =',1P,D15.5,0P,'  T[Myr] = ',
>      & F8.2,'  Q =',F5.2,'  DE =',1P,E15.6,'  E =',E15.6,
>      & ' EBIN=',E15.6,' EMERGE=',E15.6)
> *
>       write(6,51) RMIN, DTMIN, RHOM, RSCALE, RSMIN, ECLOSE, ICR
>    51 FORMAT (/, '  RMIN =',1PE8.1,'  DTMIN =',E8.1,' RHOM =',E8.1,
>      &' RSCALE =',E8.1,' RSMIN =',E8.1,'  ECLOSE =',0PF5.2,'  TC =',I5)
> *
>       WRITE(6,55)
>    55 FORMAT('  PE  N       ttot            treg      tirr      ',
>      & 'tpredtot  tint      tinit      tks      ttcomm    tadj     ',
>      & 'tmov      tprednb    tsub     tsub2    xtsub1   xtsub2')
>       WRITE(6,56)isize,n,ttotal,ttreg,ttirr,ttpre,ttint,ttinit,
>      & ttks,ttcomm,ttadj,ttmov,ttnbp,ttsub,ttsub2,
>      & xtsub1,xtsub2
>    56 FORMAT(1X,I3,I6,F13.5,12F10.2,1P,2D13.5)
240,245d238
< *       Print energy diagnostics & KS parameters.
<       ICR = TTOT/TCR
<       WRITE (6,45)  TTOT, Q, DE, BE(3),RMIN, DTMIN, ECLOSE, ICR, DELTA1
<    45 FORMAT (/,' ADJUST:  TIME =',F8.2,'  Q =',F5.2,'  DE =',1P,E10.2,
<      &          '  E =',0P,F10.6,'  RMIN =',1P,E8.1,'  DTMIN =',E8.1,
<      &          '  ECLOSE =',0PF5.2,'  TC =',I5,'  DELTA =',1P,E9.1)
246a240
>       end if
248c242
< *       Perform automatic error control (RETURN on restart with KZ(2) > 1).
---
> * Perform automatic error control (RETURN on restart with KZ(2) > 1).
252c246
< *       Check for escaper removal.
---
> * Check for escaper removal.
257c251
< *       Check correction for c.m. displacements.
---
> * Check correction for c.m. displacements.
262,285c256
< *       Include diagnostics for massive binary (bound or unbound initially).
<       IF (KZ(5).EQ.4) THEN
<           IP = 0
<           DO 50 IPAIR = 1,NPAIRS
<               IF (NAME(2*IPAIR-1).LE.2.OR.NAME(2*IPAIR).LE.2) THEN
<                   IP = IPAIR
<               END IF
<    50     CONTINUE
<           IF (IP.GT.0) THEN
<               I1 = 2*IP - 1
<               I2 = I1 + 1
<               SEMI = -0.5*BODY(N+IP)/H(IP)
<               ECC2 = (1.0 - R(IP)/SEMI)**2 +
<      &                                  TDOT2(IP)**2/(SEMI*BODY(N+IP))
<               EB = BODY(I1)*BODY(I2)*H(IP)/BODY(N+IP)
<               WRITE (35,52)  TTOT, SEMI, EB, E(3), SQRT(ECC2),
<      &                       NAME(I1), NAME(I2)
<    52         FORMAT (' ',F8.1,1P,3E12.4,0P,F7.3,2I5)
< *  52         FORMAT (' T A E EB ECL NAME ',F8.1,1P,3E12.4,0P,F7.3,2I5)
<               CALL FLUSH(35)
<           END IF
<       END IF
< *
< *       See whether standard output is due (allow for setting TIME = TPREV).
---
> * See whether standard output is due (allow for setting TIME = TPREV).
290c261
< *       Update time for next adjustment.
---
> * Update time for next adjustment.
292,293d262
< *       Re-initialize marginal stability counter to avoid including old case.
<       NMARG = 0
295,298c264,266
< *       Obtain elapsed CPU time and update total since last output/restart.
<       CALL CPUTIM(TCOMP)
<       CPUTOT = CPUTOT + TCOMP - CPU0
<       CPU0 = TCOMP
---
> * Obtain elapsed CPU time and update total since last output/restart.
>       call cputim(tt1)
>       CPUTOT = (tt1-ttota)*60.
300c268
< *       Save COMMON after energy check (skip TRIPLE, QUAD, CHAIN).
---
> * Save COMMON after energy check (skip TRIPLE, QUAD, CHAIN).
304,311c272,319
< *       Check termination criteria (TIME > TCRIT & N <= NCRIT).
<       IF (TTOT.GE.TCRIT.OR.N.LE.NCRIT) THEN
< *       Terminate after optional COMMON save.
<           WRITE (6,60)  TTOT, CPUTOT/60.0, ERRTOT, DETOT
<    60     FORMAT (//,9X,'END RUN',3X,'TIME =',F7.1,'  CPUTOT =',F7.1,
<      &                  '  ERRTOT =',F10.6,'  DETOT =',F10.6)
<           IF (KZ(1).GT.0.AND.NSUB.EQ.0) CALL MYDUMP(1,1)
<           STOP
---
> * Check termination criteria (TIME > TCRIT & N <= NCRIT).
> *
> C New (Aug. 1998): P.Kroupa
> *
>       IF (TTOT*TSCALE.GT.TCRITp.OR.TTOT.GT.TCRIT - 20.0*DTMIN
>      & .OR.N.LE.NCRIT) THEN
> * Terminate after optional COMMON save.
>           if(rank.eq.0)
>      & WRITE (6,60) TTOT*TSCALE, TOFF, TIME, TIME+TOFF,
>      & CPUTOT/60.0,ERRTOT, DETOT
>    60 FORMAT (
>      & '  TOFF/TIME/TTOT=',3F16.8,
>      & '  CPUTOT =',F7.1,
>      & '  ERRTOT =',1P,D12.5,'  DETOT =',D12.5)
> *
> * Determine time interval and step numbers per time unit
>       TIMINT = TIME + TOFF - TINIT
> *
> 
> 
> 
>       WRITE (6,195) rank,TIMINT,NSTEPI-NIR,NSTEPB-NIB,NSTEPR-NRGL,
>      & NSTEPU-NKS
>   195 FORMAT (
>      & ' NIRRB=',I11,' NREG=',I11,' NKS=',I11)
>       WRITE (6,196) (NSTEPI-NIR)/TIMINT,(NSTEPB-NIB)/TIMINT,
>      & (NSTEPR-NRGL)/TIMINT,(NSTEPU-NKS)/TIMINT
>   196 FORMAT (
>      & D12.5,' NREG=',D12.5,' NKS=',D12.5)
> 
> 
> 
> *
>           IF (KZ(1).GT.0) CALL MYDUMP(1,1)
>       call cputim(tt1)
> *
> 
> 
> 
>           ttotal=(tt1-ttota)*60.
>       PRINT*,' Total CPU=',ttotal
> 
> 
> 
> 
> 
>       STOP
> *
314c322
< *       Check optional truncation of time.
---
> * Check optional truncation of time.
1,2c1,2
< 6371 2006-08-16 10:18 /work/Umi2/spurzem/5/nbody6compare-oct2006/bindat.f
< nbody6compare-oct2006/bindat.f
---
> 5474 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/bindat.f
> nbody6++compare/bindat.f
0a1,4
> # 1 "bindat.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "bindat.F"
4,5c8,9
< *       Binary data bank.
< *       -----------------
---
> * Binary data bank.
> * -----------------
8,15c12,15
<       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
<       REAL*4  EB(KMAX),ECC(KMAX),RCM(KMAX),ECM(KMAX),PB(KMAX),AS(30)
<       REAL*8  XX(3,3),VV(3,3)
<       LOGICAL  FIRST
<       SAVE  FIRST
<       DATA  FIRST /.TRUE./
---
>       COMMON/BINARY/ CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
>      & HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      & NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       REAL*4 EB(KMAX),ECC(KMAX),RCM(KMAX),ECM(KMAX),PB(KMAX),AS(30)
18c18
< *       Form binding energy and central distance for each KS pair.
---
> * Form binding energy and central distance for each KS pair.
26c26
< *       Determine merger & ghost index for negative c.m. name (skip ghost).
---
> * Determine merger & ghost index for negative c.m. name (skip ghost).
29c29
< *       Employ actual masses and two-body distance for energy & eccentricity.
---
> * Employ actual masses and two-body distance for energy & eccentricity.
34,35c34,35
<      &                                      XREL(3,IMERGE)**2)
< *       Assume that merged binary is near apo or peri (hence ignore TDOT2).
---
>      & XREL(3,IMERGE)**2)
> * Assume that merged binary is near apo or peri (hence ignore TDOT2).
37c37
< *       Include separate diagnostics for the hierarchy (inner comps J1 & J).
---
> * Include separate diagnostics for the hierarchy (inner comps J1 & J).
40c40
<      &                                 TDOT2(JPAIR)**2/(BODY(ICM)*SEMI1)
---
>      & TDOT2(JPAIR)**2/(BODY(ICM)*SEMI1)
42a43,47
>               Q = BODY(J2)/BODYCM
>               XFAC = (1.0 + Q)*(1.0 + E1)/SQRT(ABS(1.0 - E1))
>               FE = 2.8
>               PCR = FE*XFAC**0.4*SEMI
>               PM = SEMI1*(1.0 - E1)/PCR
48,63c53,57
<               DO 2 K = 1,3
<                   XX(K,1) = XREL(K,IMERGE)
<                   XX(K,2) = 0.0
<                   XX(K,3) = X(K,J2)
<                   VV(K,1) = VREL(K,IMERGE)
<                   VV(K,2) = 0.0
<                   VV(K,3) = XDOT(K,J2)
<     2         CONTINUE
<               CALL INCLIN(XX,VV,X(1,ICM),XDOT(1,ICM),ALPH)
<               PCR = stability(CM(1,IMERGE),CM(2,IMERGE),BODY(ICM),E0,E1,
<      &                                                       ALPH)*SEMI
<               PM = SEMI1*(1.0 - E1)/PCR
<               WRITE (84,3) TTOT, NAME(J1), NAME(J), KSTAR(J1), KSTAR(J),
<      &                     KSTARM(IMERGE), E0, E1, PM, RM, P0, P1, SEMI1
<     3         FORMAT (' BINDAT:    T NM K* E0 E1 PM/PC PM0/R* P0 P1 A1',
<      &                             F8.1,2I5,3I4,2F7.3,2F6.1,1P,3E9.1)
---
>               if(rank.eq.0)then
>               WRITE (84,2) TTOT, NAME(J1), NAME(J), KSTAR(J1), KSTAR(J),
>      & KSTARM(IMERGE), E0, E1, PM, RM, P0, P1, SEMI1
>     2 FORMAT (' BINDAT:    T NM K* E0 E1 PM/PC PM0/R* P0 P1 A1',
>      & F8.1,2I5,3I4,2F7.3,2F6.1,1P,3E9.1)
64a59
>               end if
66c61
< *       Form binding energy and eccentricity for standard case.
---
> * Form binding energy and eccentricity for standard case.
68c63
<      &                                             (BODY(J1) + BODY(J2))
---
>      & (BODY(J1) + BODY(J2))
71c66
<      &                                  TDOT2(JPAIR)**2/(BODY(ICM)*SEMI)
---
>      & TDOT2(JPAIR)**2/(BODY(ICM)*SEMI)
74c69
< *       Search merger table to identify corresponding index of c.m. name.
---
> * Search merger table to identify corresponding index of c.m. name.
79c74
<     5         CONTINUE
---
>     5 CONTINUE
92c87
< *       Obtain binding energy (per unit mass) of c.m. motion.
---
> * Obtain binding energy (per unit mass) of c.m. motion.
99c94
<      &                                        (X(3,ICM) - X(3,J))**2 
---
>      & (X(3,ICM) - X(3,J))**2
101c96
<     9     CONTINUE
---
>     9 CONTINUE
103c98
< *       Check for external tidal field (note that HT includes mass).
---
> * Check for external tidal field (note that HT includes mass).
109,110c104,105
<      &                      (X(2,ICM) - RDENS(2))**2 +
<      &                      (X(3,ICM) - RDENS(3))**2)
---
>      & (X(2,ICM) - RDENS(2))**2 +
>      & (X(3,ICM) - RDENS(3))**2)
114,115c109,110
< *       Copy relevant binary diagnostics to single precision.
<       AS(1) = TIME + TOFF
---
> * Copy relevant binary diagnostics to single precision.
>       AS(1) = TTOT
139,143c134
< *       Write formatted data bank on unit 9.
<       IF (FIRST) THEN
<           OPEN (UNIT=9,STATUS='NEW',FORM='FORMATTED',FILE='OUT9')
<           FIRST = .FALSE.
<       END IF
---
> * Write formatted data bank on unit 9.
145c136,139
<       WRITE (9,30)  NPAIRS, MODEL, NRUN, N, NC, NMERGE, (AS(K),K=1,7)
---
> 
> 
> 
>       WRITE (9,30) NPAIRS, MODEL, NRUN, N, NC, NMERGE, (AS(K),K=1,7)
147c141
<       WRITE (9,35)  (AS(K),K=8,17)
---
>       WRITE (9,35) (AS(K),K=8,17)
149c143
<       WRITE (9,40)  (AS(K),K=18,30)
---
>       WRITE (9,40) (AS(K),K=18,30)
159,162c153,156
<           WRITE (9,45)  EB(JPAIR), ECC(JPAIR), ECM(JPAIR), RCM(JPAIR),
<      &                  BODY(J1)*ZMBAR, BODY(J2)*ZMBAR, PB(JPAIR),
<      &                  NAME(J1), NAME(J2), KSTAR(J1), KSTAR(J2), KCM
<    45     FORMAT (F8.5,F7.3,F7.2,F6.2,2F5.1,F8.1,2I6,3I4)
---
>           WRITE (9,45) EB(JPAIR), ECC(JPAIR), ECM(JPAIR), RCM(JPAIR),
>      & BODY(J1)*ZMBAR, BODY(J2)*ZMBAR, PB(JPAIR),
>      & NAME(J1), NAME(J2), KSTAR(J1), KSTAR(J2), KCM
>    45 FORMAT (F8.5,F7.3,F7.2,F6.2,2F5.1,F8.1,2I6,3I4)
164a159,161
> 
> 
> 
1,2c1,2
< 5366 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/binout.f
< nbody6compare-oct2006/binout.f
---
> 5493 2002-02-20 20:20 /work/Umi2/spurzem/5/nbody6++compare/binout.f
> nbody6++compare/binout.f
94c94,95
<               WRITE (6,35)  J, LIST(1,J1), LIST(1,J2), LIST(2,J2),
---
>               if(rank.eq.0)
>      &        WRITE (6,35)  J, LIST(1,J1), LIST(1,J2), LIST(2,J2),
108c109,110
<               WRITE (8,40)  TTOT, NAME(J1), NAME(J2), LIST(2,J2), K,
---
>               if(rank.eq.0)
>      &        WRITE (8,40)  TTOT, NAME(J1), NAME(J2), LIST(2,J2), K,
130c132,133
<       WRITE (6,60)  JOR, JEX, DB, SBCOLL, BBCOLL, CHCOLL, JC,
---
>               if(rank.eq.0)
>      &WRITE (6,60)  JOR, JEX, DB, SBCOLL, BBCOLL, CHCOLL, JC,
132c135
<    60 FORMAT (/,' OR =',I4,'  EX =',I3,'  DB =',F7.3,'  SB =',F8.4,
---
>    60 FORMAT (/,' OR =',I4,'  EX =',I3,'  DB =',F12.3,'  SB =',F8.4,
138c141,142
<       WRITE (6,65)  DISP, EMAX, (NPOP(J),J=1,8), (JEB(K),K=1,KLAST)
---
>               if(rank.eq.0)
>      &WRITE (6,65)  DISP, EMAX, (NPOP(J),J=1,8), (JEB(K),K=1,KLAST)
150c154
<       ETOT = ETOT + ESUB + EMERGE + EMDOT + ECDOT + ECOLL
---
>       ETOT = ETOT + ESUB + EMERGE + EMDOT + ECOLL + ECDOT
157,158c161,162
<       WRITE (6,90)  (E(J),J=1,10), ETOT
<    90 FORMAT (' ENERGIES   ',10F11.5,'  ETOT =',F12.6)
---
>       if(rank.eq.0) WRITE (6,90)  (E(J),J=1,10), ETOT
>    90 FORMAT (' ENERGIES   ',10F12.5,'  ETOT =',F12.6)
1,2c1,2
< 11013 2006-09-08 15:00 /work/Umi2/spurzem/5/nbody6compare-oct2006/binpop.f
< nbody6compare-oct2006/binpop.f
---
> 22118 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/binpop.f
> nbody6++compare/binpop.f
0a1,4
> # 1 "binpop.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "binpop.F"
1a6,17
> C
> C P. Kroupa 1.04.94
> C
> C NOTE: This routine works for <= 100 per cent binaries as the initial
> C set up. It allows choice of an
> C initial period distribution and allows eigenevolution of orbital parameters.
> C It also MERGES the closest binaries to one star.
> C
> C NOTE: A more realistic code for pre-main sequence eigenevolution
> C is contained in binpop_mardling.f. One day it will have to be
> C included in binpop_pk.f as an aditional pre-ms evoltuion sub-routine.
> C
4,5c20,21
< *       Initial binary population.
< *       --------------------------
---
> * Initial binary population.
> * --------------------------
8,10c24,32
<       REAL*8  XORB(2),VORB(2),XREL(3),VREL(3),PX(3),QX(3),BS(NMAX)
<       REAL*4  RAN2
<       DATA  ETA1,ETA2 /2.5,45.0/
---
>       integer pkmerge,pk_sing
>       REAL*8 XORB(2),VORB(2),XREL(3),VREL(3),PX(3),QX(3),BS(NMAX)
>       REAL*4 RAN2
>       real*8 pkmergedist,EBpk
> * Additional vars for MERGED components:
>       real*8 bodypk(nmax),xpk(3,nmax),xdotpk(3,nmax)
>       real*8 bodymergepk(nmax),xmergepk(3,nmax),xdotmergepk(3,nmax)
> * Additional vars for initially single stars:
>       real*8 s_body(nmax),s_x(3,nmax),s_xdot(3,nmax)
11a34
> # 39 "binpop.F"
13,14c36,46
<       READ (5,*)  SEMI0, ECC0, RATIO, RANGE, NSKIP, IDORM, ICIRC
<       NBIN = NBIN0
---
> * recover random number sequence from COMMON variable IDUM1.
>       KDUM = IDUM1
> *
>       pkmerge = 0
> *
> *
>       if(rank.eq.0)
>      & READ (5,*) NBIN, SEMI0, ECC0, RATIO,RANGE, NSKIP, IDORM
> *
> # 58 "binpop.F"
>       NBIN0 = NBIN
16c48,49
<       WRITE (6,1)  NBIN, SEMI0, ECC0, RATIO, RANGE, NSKIP, IDORM, ICIRC
---
>       if(rank.eq.0)
>      &WRITE (6,1) NBIN, SEMI0, ECC0, RATIO, RANGE, NSKIP, IDORM
18,19c51,52
<      &              '  RATIO =',F4.1,'  RANGE =',F6.1,'  NSKIP =',I3,
<      &              '  IDORM =',I2,'  ICIRC =',I2,/)
---
>      & '  RATIO =',F4.1,'  RANGE =',F6.1,'  NSKIP =',I3,
>      & '  IDORM =',I2,/)
21c54
< *       Check type of binary mass distribution (NSKIP, IMF2 or split c.m.).
---
> * Check type of binary mass distribution (NSKIP, IMF2 or split c.m.).
25c58
< *       Select binaries from the most massive bodies (frequency NSKIP).
---
> * Select binaries from the most massive bodies (frequency NSKIP).
31c64
< *       Transfer binary masses to first NBIN locations.
---
> * Transfer binary masses to first NBIN locations.
34c67
< *       Copy binary mass of body #I to new global location.
---
> * Copy binary mass of body #I to new global location.
40c73
< *       Save next NSKIP masses of single bodies.
---
> * Save next NSKIP masses of single bodies.
46c79
< *       Restore the single bodies in subsequent locations.
---
> * Restore the single bodies in subsequent locations.
53c86
< *       Move main variables of all single bodies.
---
> * Move main variables of all single bodies.
60c93
<    12     CONTINUE
---
>    12 CONTINUE
63c96
< *       Create space for each binary component next to primary.
---
> * Create space for each binary component next to primary.
70c103
<    25     CONTINUE
---
>    25 CONTINUE
73c106,109
< *       Introduce binary components from relative motion.
---
> *=========================================================
> *=======================THE LOOP==========================
> *=========================================================
> * Introduce binary components from relative motion.
76,79c112,115
< *       Randomize perihelion, node & inclination (ZI = 0.25 before 3/99).
<           PI = TWOPI*RAN2(IDUM1)
<           OMEGA = TWOPI*RAN2(IDUM1)
<           ZI = 0.5*TWOPI*RAN2(IDUM1)
---
> * Randomize perihelion, node & inclination.
>           PI = TWOPI*RAN2(KDUM)
>           OMEGA = TWOPI*RAN2(KDUM)
>           ZI = 0.5*TWOPI*RAN2(KDUM)
81c117
< *       Set transformation elements (Brouwer & Clemence p. 35).
---
> * Set transformation elements (Brouwer & Clemence p. 35).
87c123
<           QX(3) = COS(PI)*SIN(ZI) 
---
>           QX(3) = COS(PI)*SIN(ZI)
89c125
< *       Specify component masses (copy BODY0 from IMF2 or use RATIO).
---
> * Specify component masses (copy BODY0 from IMF2 or use RATIO).
96c132
<               BODY(I2) = BODY(I1) 
---
>               BODY(I2) = BODY(I1)
102c138,154
< *       Choose random (thermalized; < 0.9 for triples) or fixed eccentricity.
---
> ***************************
> * Choose
> *
> * ECC0<0: thermal distribution f(e)=2e
> * 0<=ECC0<=1 fixed eccentricity
> * ECC0=20 a uniform distr. between 0 and 1
> * ECC0=30 an exponentially decreasing distribution akin to the data in
> * Fig.6a of Duquennoy and Mayor 1991: f(e)=0.1765/(e*e), 0.15<=e<=1
> * ECC0=40:
> * The general distribution is (9.02.94):
> * f(e) = a e^b e0<=e<=1
> * with a = (1+b) / (1-e0^(1+b))
> * Its generating function is
> * e(X) = [((1+b)/a)X + e0^(1+b)]^(1/(1+b))
> * Choose some a and b below.
> * Get thermal distribution if b=1 with e0=0
> *
104c156
<               ECC2 = RAN2(IDUM1)
---
>               ECC2 = RAN2(KDUM)
106,107c158,175
<               IF (KZ(18).GT.1) ECC = MIN(ECC,0.9D0)
<           ELSE
---
>           else if (ecc0.EQ.20) then
>               ecc = RAN2(KDUM)
> *
>           else if (ecc0.EQ.30) then
>               ecc = 1./0.15 - RAN2(KDUM)/0.1765
>               ecc = 1./ecc
> *
>           else if (ecc0.EQ.40) then
>               PK_e0 = 0.D0
>               PK_b = 1.D0
>               PK_a = (1.D0+PK_b) / (1.D0 - PK_e0**(1.D0+PK_b))
> 
>               ecc = RAN2(KDUM)
>               ecc = ((PK_b+1.D0)/PK_a)*ecc + PK_e0**(1.D0+PK_b)
>               ecc = ecc**(1.D0/(1.D0+PK_b))
> *
> *
>           ELSE if (ecc0.GE.0.0.AND.ecc0.LE.1.) then
111,114c179,245
< *       Generate semi-major axis (new option added 4/8/05).
<           IF (KZ(8).GE.4) THEN
< *       Adopt Pavel Kroupa (1995, Eq.11b) distribution for semi-major axis.
<              exp1 = EXP(2.D0*RAN2(IDUM1)/2.5D0) - 1.D0
---
> *****************************
> *
> * Select semi-major axis from uniform distribution in log(A),
> * or a uniform distribution in the range semi0 (=min. ecc.)
> * to semi0+range (=max. ecc.), or SEMI0.
> *
> * Use distribution in semi-major axis if
> * BK(2)=0: RANGE>0: uniform distribution in log(semi) between SEMI0 and
> * SEMI0/RANGE
> * RANGE<0: uniform distribution in semi between SEMI0 and -1*RANGE.
> *
> * Use distribution in logP(days) if
> * BK(2)=1: linearly increasing distribution function f=0.03438*logP
> * BK(2)=2: f=3.5logP/[100+(logP)**2]
> * BK(2)=1,2 are 1st and 2nd iterations!
> * BK(2)=3: f=2.3(logP-1)/[45+(logP-1)**2] This is a "3rd" iteration when
> * pre-ms evolution is taken into account with BK(1).NE.0.
> * BK(2)=4: f=2.5(logP-1)/[45+(logP-1)**2] This is a "34th" iteration when
> * pre-ms evolution is taken into account with BK(1).NE.0, and
> * RBAR<1.5 (in runs /run34n RBAR=1.5 with BK(2)=3 lead to
> * wrong qone distr.
> * BK(2)=5: Duquennoy & Mayor 1991, Gaussian distr.
> * with mean logP=4.8, SDEV in logP=2.3. Use Num.Recipes
> * routine "gasdev.f" to obtain random deviates given "idum1".
> *========= BK(2) = 0 ========
>           if (BK(2).EQ.0) then
>              IF (RANGE.GT.0.0) THEN
>                  EXP1 = RAN2(KDUM)*LOG10(RANGE)
>                  SEMI = SEMI0/10.0**EXP1
>              else if (range.LT.0.0) then
>                  exp1 = RAN2(KDUM)*(-1*range-semi0)
>                  semi = semi0 + exp1
>              ELSE
>                  SEMI = SEMI0
>              END IF
> *========= BK(2) = 1 ========
>           else if (BK(2).EQ.1) then
> * exp = logP(days)
>              exp1 = SQRT(RAN2(KDUM)*2.0/0.03438)
> * Period in yrs:
>              exp1 = 10**exp1 /365.25
> * transform to semi-major axis in model units to continue prgrm from here
> * as before (i.e. when semi-major axis is chosen): Use Kepler law:
> * M1+M2 = a**3/P**2, where mass is in Msun, and a is in AU.
>              semi = (BODY(I1)+BODY(I2))*ZMBAR*exp1*exp1
>              semi = semi**(1./3.)
> * semi in pc and then in modell units:
>              semi = semi/206259.591
>              semi = semi/RBAR
> *========= BK(2) = 2 ========
>           else if (BK(2).EQ.2) then
>              exp1 = EXP(2.0*RAN2(KDUM)/3.50) - 1.
>              exp1 = SQRT(exp1*100.)
> * exp = logP(days)
> * Period in yrs:
>              exp1 = 10**exp1 /365.25
> * transform to semi-major axis in model units to continue prgrm from here
> * as before (i.e. when semi-major axis is chosen): Use Kepler law:
> * M1+M2 = a**3/P**2, where mass is in Msun, and a is in AU.
>              semi = (BODY(I1)+BODY(I2))*ZMBAR*exp1*exp1
>              semi = semi**(1./3.)
> * semi in pc and then in modell units:
>              semi = semi/206259.591
>              semi = semi/RBAR
> *========= BK(2) = 3 ========
>           else if (BK(2).EQ.3) then
>              exp1 = EXP(2.D0*RAN2(KDUM)/2.3D0) - 1.D0
116c247,248
< *       Specify period in yrs.
---
> * exp = logP(days)
> * Period in yrs:
118c250,252
< *       Transform to semi-major axis in model units by Kepler's Law.
---
> * transform to semi-major axis in model units to continue prgrm from here
> * as before (i.e. when semi-major axis is chosen): Use Kepler law:
> * M1+M2 = a**3/P**2, where mass is in Msun, and a is in AU.
121c255
< *       Set semi in pc and then in model units.
---
> * semi in pc and then in modell units:
124,214c258,311
< *       Select semi-major axis from uniform distribution in log(A) or SEMI0.
<           ELSE IF (RANGE.GT.0.0) THEN
<               EXP1 = RAN2(IDUM1)*LOG10(RANGE)
<               SEMI = SEMI0/10.0**EXP1
<           ELSE
<               SEMI = SEMI0
<           END IF
< *
< *       Check for eigen-evolution (Pavel Kroupa & Rosemary Mardling).
<           IF (ICIRC.EQ.1) THEN
<               ICOLL = 0
<               IC0 = 0
<               IC1 = 0
<               IC2 = 0
<               IC3 = 0
<               ZMB = (BODY(I1) + BODY(I2))*ZMBAR
< *       Include minimum period (copy RANGE; at least 1 day).
<               PMIN = MAX(RANGE,1.0D0)
<               IT = 0
<    35         XR = RAN2(IDUM1)
< *       Generate period distribution (Pavel Kroupa: MN 277, 1491, eq.11b).
<               P0 = LOG10(PMIN) + SQRT(ETA2*(EXP(2.0*XR/ETA1) - 1.0))
<               TK = 10.0**P0
< *       Invert eccentricity from thermal distribution (XR = E**2).
<               XR = RAN2(IDUM1)
<               ES0 = SQRT(XR)
< *       Set pericentre distance in AU with period in days & mass in SU.
<               RP0 = (1.0 - ES0)*((TK/365.0)**2*ZMB)**0.3333
< *       Convert to N-body units.
<               RP0 = RP0/RAU
<               A0 = RP0/(1.0 - ES0)
<               E0 = ES0
< *       Limit the maximum semi-major axis to 1000 AU (Oct 2004).
<               IF (A0*RAU.GT.1000.0) GO TO 35
< *       Define K* = 0/1 and enhanced radii for pre-main sequence.
<               KSTAR(I1) = 1
<               KSTAR(I2) = 1
<               IF (BODY(I1)*ZMBAR.LT.0.7) KSTAR(I1) = 0
<               IF (BODY(I2)*ZMBAR.LT.0.7) KSTAR(I2) = 0
<               RADIUS(I1) = 5.0*SQRT(BODY(I1)*ZMBAR)/SU
<               RADIUS(I2) = 5.0*SQRT(BODY(I2)*ZMBAR)/SU
<               IF (RP0.LT.MAX(RADIUS(I1),RADIUS(I2))) THEN
<                   WRITE (6,38)  I1, ZMB, ES0, A0, RP0
<    38             FORMAT (12X,'COLLISION:    I1 MB E A RP ',
<      &                                       I6,F6.1,F7.3,1P,2E10.2)
<                   ICOLL = ICOLL + 1
<                   GO TO 35
<               END IF
< *       Perform eigen-evolution of pericentre & eccentricity for 10^6 yrs.
<               TC = -1.0/TSCALE
<               CALL TCIRC(RP0,ES0,I1,I2,ICIRC,TC)
< *       Copy modified eccentricity and re-evaluate the semi-major axis.
<               ECC = ES0
<               SEMI = RP0/(1.0 - ECC)
<               IT = IT + 1
<               IF (SEMI.GT.SEMI0.AND.IT.LT.25) GO TO 35
<               TK = 365.0*SQRT((SEMI*RAU)**3/ZMB)
<               IF (ECC.LE.0.002) IC0 = IC0 + 1
<               IF (TK.LT.PMIN) IC1 = IC1 + 1
<               IF (TK.LT.2.0*PMIN) IC2 = IC2 + 1
<               IF (TK.LT.5.0*PMIN) IC3 = IC3 + 1
<               WRITE (23,40)  IT, I1, ZMB, E0, ECC, A0, SEMI, TK
<    40         FORMAT (12X,'BINARY:   IT I1 MB E0 E A0 A P ',
<      &                               I2,I5,F5.1,2F7.3,1P,3E10.2)
<               CALL FLUSH(23)
<           ELSE IF (KZ(27).EQ.1.OR.KZ(19).GE.3) THEN
< *       Obtain tidal encounter distance (4*RADIUS) from square root relation.
<               RSUN = 1.0/SU
<               ZM = MAX(BODY(I1),BODY(I2))*ZMBAR
<               RT = 4.0*RSUN*SQRT(ZM)
< *       Modify orbital elements to avoid tidal interaction or collision.
<    42         IF (SEMI*(1.0 - ECC).LT.2.0*RT) THEN
< *       Increase semi-major axis or reduce eccentricity until peri > 2*RT.
<    44             IF (SEMI.LT.2.0*RT) THEN
<                       SEMI = 2.0*SEMI
<                       GO TO 44
<                   ELSE
<                       ECC = 0.9*ECC
<                   END IF
<                   WRITE (17,46)  I1, I2, ECC, SEMI, SEMI*(1.0-ECC), RT
<    46             FORMAT (12X,'REDUCE ECC:    I1 I2 E A PM RT ',
<      &                                        2I5,F7.3,1P,3E10.2)
<                   CALL FLUSH(17)
<                   GO TO 42
<               END IF
<           END IF
< *
< *       Evolve ECC and SEMI via circularization and feeding (Kroupa 1995).
<           IF (ICIRC.EQ.2) THEN
<               CALL PROTO_STAR(ZMBAR,RBAR,BODY(I1),BODY(I2),ECC,SEMI)
<           END IF
---
> *========= BK(2) = 4 ========
>           else if (BK(2).EQ.4) then
>              exp1 = EXP(2.D0*RAN2(KDUM)/2.5D0) - 1.D0
>              exp1 = SQRT(exp1*45.D0) + 1.D0
> * exp = logP(days)
> * Period in yrs:
>              exp1 = 10**exp1 /365.25D0
> * transform to semi-major axis in model units to continue prgrm from here
> * as before (i.e. when semi-major axis is chosen): Use Kepler law:
> * M1+M2 = a**3/P**2, where mass is in Msun, and a is in AU.
>              semi = (BODY(I1)+BODY(I2))*ZMBAR*exp1*exp1
>              semi = semi**(1.D0/3.D0)
> * semi in pc and then in modell units:
>              semi = semi/206259.591D0
>              semi = semi/RBAR
> *========= BK(2) = 5 ========
>           else if (BK(2).EQ.5) then
>              exp1 = -10.
> C Only accept periods logP>1, i.e. longer than 10 days at birth
> C AND periods shorter than 10^(10) days!
>              do while (exp1.LT.-1.6522)
>                 exp1 = GASDEV_pk(KDUM)
>                 if (exp1.GT.2.2696) exp1=-10.
>              end do
> * exp1 is now a Gaussian deviate with mean zero and unit variance
> * Transform to mean=4.8 and variance = 2.3*2.3, i.e to logP, P in days
>             exp1 = 2.3*exp1 + 4.8
> * exp = logP(days)
> * Period in yrs:
>              exp1 = 10**exp1 /365.25D0
> * transform to semi-major axis in model units to continue prgrm from here
> * as before (i.e. when semi-major axis is chosen): Use Kepler law:
> * M1+M2 = a**3/P**2, where mass is in Msun, and a is in AU.
>              semi = (BODY(I1)+BODY(I2))*ZMBAR*exp1*exp1
>              semi = semi**(1.D0/3.D0)
> * semi in pc and then in modell units:
>              semi = semi/206259.591D0
>              semi = semi/RBAR
> *========= BK(2) = ? ========
>           else
>              if(rank.eq.0)write(6,*)' No BK(2) defined!!!!! '
>              STOP
>           end if
> *
> *
> * At this stage we have the mases, eccentricity and period of each binary
> * at "birth", i.e. prior to circularisation and "feeding". Now evolve these
> * to very, very roughly take into account complete circularisation,
> * partial circularisation and "feeding". Do this if option BK(1)=1:
> * (i.e. mass-exchange at proto-stellar time):
>           if (BK(1).EQ.1) then
>              call proto_star_evol(
>      & ZMBAR,RBAR,BODY(I1),BODY(I2),ECC,SEMI)
>           end if
216,218c313
< *       Specify relative motion at apocentre.
<           XORB(1) = SEMI*(1.0 + ECC)
< *       Specify relative motion at apocentre and sum binding energy.
---
> * Specify relative motion at apocentre.
224c319,321
<           EBIN0 = EBIN0 - 0.5*BODY(I1)*BODY(I2)/SEMI
---
>           EBpk = -0.5*BODY(I1)*BODY(I2)/SEMI
> C Moved below to account for accepted binaries only.
> C EBIN0 = EBIN0 - 0.5*BODY(I1)*BODY(I2)/SEMI
226,227c323,324
< *       Transform to relative variables.
<           DO 50 K = 1,3
---
> * Transform to relative variables.
>           DO 40 K = 1,3
230c327
<    50     CONTINUE
---
>    40 CONTINUE
232,233c329,330
< *       Set global variables for each component.
<           DO 55 K = 1,3
---
> * Set global variables for each component.
>           DO 50 K = 1,3
238c335,379
<    55     CONTINUE
---
>    50 CONTINUE
> *
> *
> * Merge binaries that have semi.LE.10 solar radii (all in AU):
> * Solar radius in AU is 4.6523D-3.
>           semi = semi*RBAR*206259.591D0
>           pkmergedist = 10.D0 * 4.6523D-3
> c pkmergedist = 50000.D0 * 4.6523D-3
>           J1 = I1 -2*pkmerge
>           J2 = I2 -2*pkmerge
>           if (semi.LE.pkmergedist) then
>              pkmerge = pkmerge + 1
>              ZMBIN = BODY(I1) + BODY(I2)
> C Added 20.8.96:
>              if(rank.eq.0)then
>              write(6,*)
>              write(6,*)' MERGED stars in binpop_pk.f:'
>              write(6,*)' mass1, mass2, total mass [Msun]'
>              write(6,'(3F8.3)')body(I1)*ZMBAR,body(I2)*ZMBAR,
>      + zmbin*ZMBAR
>              end if
> C End added bit.
>              do K = 1,3
>                  Xmergepk(K,pkmerge) = (BODY(I1)*X(K,I1) +
>      & BODY(I2)*X(K,I2))/ZMBIN
>                  XDOTmergepk(K,pkmerge) = (BODY(I1)*XDOT(K,I1) +
>      & BODY(I2)*XDOT(K,I2))/ZMBIN
>              end do
>              BODYmergepk(pkmerge) = ZMBIN
>           else
> C Sum binding energy for accepted binaries.
>              EBIN0 = EBIN0 + EBpk
>              bodypk(J1) = body(I1)
>              bodypk(J2) = body(I2)
>              do k=1,3
>                 xpk(k,J1) = x(k,I1)
>                 xpk(k,J2) = x(k,I2)
>                 xdotpk(k,J1) = xdot(k,I1)
>                 xdotpk(k,J2) = xdot(k,I2)
>              end do
>           end if
> *
> *=========================================================
> *=================end of THE LOOP=========================
> *=========================================================
241c382,397
< *       Update the total particle number after primary splitting or IMF2.
---
> C Kroupa: 5.11.96
> C Take into account possible initial single stars. Before merging above
> C these occupy positions: 2*NBIN+1....N+NBIN (before merging the stars
> C in binaries occupy positions 1,2,....2*NBIN).
>       pk_sing = 0
>       do i=2*NBIN+1,N+NBIN
>          pk_sing = pk_sing+1
>          s_body(pk_sing)=body(i)
>          do k=1,3
>             s_x(k,pk_sing) = x(k,i)
>             s_xdot(k,pk_sing) = xdot(k,i)
>          end do
>       end do
> *
> * Update the total particle number after primary splitting or IMF2
> * and introduce additional counters for MERGING:
247,251c403,407
<           IF (NSKIP.GT.0) THEN
<               WRITE (6,62)  (BODY(J),J=1,10)
<               WRITE (6,64)  (BODY(J),J=2*NBIN+1,2*NBIN+10)
<    62         FORMAT (/,12X,'BINARY MASSES (1-10):  ',10F9.5)
<    64         FORMAT (/,12X,'SINGLE MASSES (1-10):  ',10F9.5,/) 
---
>           IF (rank.eq.0.and.NSKIP.GT.0) THEN
>               WRITE (6,62) (BODY(J),J=1,10)
>               WRITE (6,64) (BODY(J),J=2*NBIN+1,2*NBIN+10)
>    62 FORMAT (/,12X,'BINARY MASSES (1-10):  ',10F9.5)
>    64 FORMAT (/,12X,'SINGLE MASSES (1-10):  ',10F9.5,/)
255c411,517
< *       Include procedure for introducing dormant binaries.
---
>       Npk = N - pkmerge
>       NZEROpk = Npk
>       NTOTpk = Npk
>       NBINpk = NBIN - pkmerge
> 
> c+++
> CCCCCCCCCCCC for testing:
>         if(rank.eq.0)then
>         write(6,*)
>         write(6,*)' In BINPOP_PK :'
>         write(6,*)'****************************************'
>         write(6,*)'N,NBIN,NBIN0,NBINpk,pkmerge,Npk,pk_sing:'
>         write(6,'(7(I6))')N,NBIN,NBIN0,NBINpk,pkmerge,
>      + Npk,pk_sing
> c write(6,*)
> c write(6,*)
> c write(6,*)' original stars'
> c do i=1,N
> c write(6,'(I4,7(F8.3))') i,body(i)*ZMBAR,
> c + (X(k,i),xdot(k,i),k=1,3)
> c end do
> c write(6,*)
> c write(6,*)
> c write(6,*)' remaining binaries'
> c do i=1,2*NBINpk
> c write(6,'(I4,7(F8.3))') i,bodypk(i)*ZMBAR,
> c + (Xpk(k,i),xdotpk(k,i),k=1,3)
> c end do
> c write(6,*)
> c write(6,*)' merged ones:'
> c do i=1,pkmerge
> c write(6,'(I4,7(F8.3))') i,bodymergepk(i)*ZMBAR,
> c + (Xmergepk(k,i),xdotmergepk(k,i),k=1,3)
> c end do
> c write(6,*)'****************************************'
> c call flush(6)
>          end if
> CCCCCCCCCCCCCC
> *
> * Now overwrite the old vars with the MERGED ones:
>       N = Npk
>       NTOT = ntotpk
>       NZERO = nzeropk
>       NBIN0 = NBIN0 - pkmerge
>       NBIN = NBINpk
> C The stars in remaining binaries:
>       do i=1,2*NBIN
>          body(i) = bodypk(i)
>          do k=1,3
>             x(k,i) = xpk(k,i)
>             xdot(k,i) = xdotpk(k,i)
>          end do
>       end do
> C Add merged (i.e single) stars to end of the above list of stars in binaries:
>       j = 2*NBIN
>       do i=1,pkmerge
>          j = j+1
>          body(j) = bodymergepk(i)
>          do k=1,3
>             x(k,j) = xmergepk(k,i)
>             xdot(k,j) = xdotmergepk(k,i)
>          end do
>       end do
> C Add the initially single stars again at end of the lot:
>       do i=1,pk_sing
>          j=j+1
>          body(j) = s_body(i)
>          do k=1,3
>             x(k,j)=s_x(k,i)
>             xdot(k,j)=s_xdot(k,i)
>          end do
>       end do
> *
> C Added 11.08.98 with Sverre Aarseth: (body0 needed for
> C stellar evolution!)
>       if (j.ne.ntot) then
>          if(rank.eq.0)
>      & write(6,*)j,ntot,' ****** j & ntot must be equal ******'
>          stop
>       end if
> *
>       zmass = 0.D0
>       do i=1,ntot
>          body0(i) = body(i)
>          zmass = zmass + body0(i)
>       end do
>       BODYM = ZMASS/FLOAT(N)
>       if(rank.eq.0)then
>       write(6,*)
>       write(6,*)' BODYM, ZMASS and BODY0(i) updated.'
>       write(6,'(2(a,F10.4))')' BODYM= ',BODYM,' ZMASS= ',ZMASS
>       write(6,*)
> *
> c+++ for testing:
> c write(6,*)
> c write(6,*)
> c write(6,*)' After merging & re-arranging:'
> c write(6,*)' N,NBIN0,NTOT: ',N,NBIN0,NTOT
> c do i=1,N
> c write(6,'(I3,7(F8.3))')i,body(i)*ZMBAR,
> c + (x(k,i),xdot(k,i),k=1,3)
> c end do
> c call flush(6)
>        end if
> *
> *
> * Include procedure for introducing dormant binaries.
264,265c526,527
<      &                         BODY(I2)*XDOT(K,I2))/ZMBIN
<    65         CONTINUE
---
>      & BODY(I2)*XDOT(K,I2))/ZMBIN
>    65 CONTINUE
267c529
<    66     CONTINUE
---
>    66 CONTINUE
269c531
< *       Move the original single particles up to form compact array.
---
> * Move the original single particles up to form compact array.
278,279c540,541
<    67         CONTINUE
<    68     CONTINUE
---
>    67 CONTINUE
>    68 CONTINUE
281c543
< *       Reset particle membership and turn off binary output option (if = 1).
---
> * Reset particle membership and turn off binary output option (if = 1).
290c552
< *       Set coordinates & velocities in c.m. rest frame.
---
> * Set coordinates & velocities in c.m. rest frame.
300c562
<    75     CONTINUE
---
>    75 CONTINUE
307c569
<    85     CONTINUE
---
>    85 CONTINUE
309a572,574
> * Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
> *
312a578,706
> C=======================================================
>       subroutine proto_star_evol(ZMBAR,RBAR,mass1,mass2,ECC,SEMI)
> *
>       implicit none
>       real*8 mass1,mass2,ecc,semi,period
>       real*8 ecc_initial,period_initial
>       real*8 qnew,qold,mtot,Ro,mtot_initial
>       real*8 R_periastron,alpha,beta
>       real*8 ZMBAR,RBAR,au,Rsun
> * astr. unit, solar radius, all in AU (1pc=206259.591AU)
>       parameter(au=206259.591D0,Rsun=4.6523D-3)
> *
> *
> *==============================
> * Choose these to define the model: (alpha==lambda, beta==chi)
> *
> c alpha = 10.D0
> c beta = 1.D0
> * best values:
>       alpha = 28.D0
>       beta = 0.75D0
> *==============================
> *
> *
> *
> * in Msun:
>       mtot = (mass1+mass2)*ZMBAR
>       mtot_initial = mtot
> * in AU:
>       semi = semi*RBAR*au
> * in years:
>       period = semi*semi*semi/mtot
>       period = DSQRT(period)
>       ecc_initial = ecc
>       period_initial = period
> *
> * 1) Circularisation and evolution of orbit as a function of
> * periastron distance (Ro in AU):
> * Note that the algorithm used here leads to circularised orbits for
> * logP<=1 approximately!! (if beta=1.5,alpha=35 approximately)
>       Ro = alpha *Rsun
>       R_periastron = semi*(1.D0-ecc)
>       alpha = -1.D0*(Ro/R_periastron)**beta
>       if (ecc.GT.0.D0) then
>          ecc = DEXP(alpha + DLOG(ecc))
>       else
>          ecc = ecc_initial
>       end if
> *
> * 2) Change mass-ratio towards unity as a function of initial periastron
> * distance:
> *
>       qold = mass1/mass2
>       if (qold.GT.1.D0) qold = 1.D0/qold
>       alpha = -1.D0*alpha
>       if (alpha.GT.1.D0) then
>          qnew = 1.D0
>       else
>          qnew = qold + (1.D0-qold) * alpha
>       end if
> *
> * new masses in model units (remembering q=m1/m2<1) if mass is conserved
> * NOT IMPLEMENTED!
> c mtot = mtot/ZMBAR
> c mass1 = mtot/(qnew+1.D0)
> c mass2 = mtot - mass1
> *
> * Keep the mass of primary fixed and adjust mass of secondary. Note that this
> * algorithm leads to a gain in mass of the binary, and thus of the whole
> * cluster!
> *
> C Added 20.06.96 write statements:
> * if(rank.eq.0)then
> * write(6,*)
> * write(6,*)' FEEDING in binpop_pk.f'
> * write(6,'(a,2F8.3)')' old masses [Msun]:',
> * + mass1*ZMBAR,mass2*ZMBAR
>         mass1 = DMAX1(mass1,mass2)
>         mass2 = qnew*mass1
> * write(6,'(a,2F8.3)')' new masses [Msun]:',
> * + mass1*ZMBAR,mass2*ZMBAR
> * end if
> C End added bit.
> *
> * In Msun:
>         mtot = (mass1+mass2)*ZMBAR
> *
> C This below is wrong as in ecc formula above constant Rperi was assumed!!!
> c* Duquennoy et al. 1992 in "Binaries as tracers of stellar evolution":
> c period = period_initial * DEXP((57.D0/14.D0) *
> c & (ecc*ecc - ecc_initial*ecc_initial))
> C This below is correct:
>        period = period_initial*((1.D0-ecc_initial)/(1.D0-ecc))**1.5D0
>        period = period * DSQRT(mtot_initial/mtot)
> *
> *
> * New semi-major axis and back to model units:
>       semi = mtot * period*period
>       semi = semi**(1.D0/3.D0)
>       semi = semi/(RBAR*au)
> *
>       return
>       end
> C=======================================================
>       FUNCTION gasdev_pk(idum)
>       INTEGER idum
>       REAL gasdev_pk
> CU USES ran1
> C P.Kroupa: 8.11.96: changed to RAN2
>       INTEGER iset
>       REAL fac,gset,rsq,v1,v2,ran2
>       SAVE iset,gset
>       DATA iset/0/
>       if (iset.eq.0) then
> 1 v1=2.*ran2(idum)-1.
>         v2=2.*ran2(idum)-1.
>         rsq=v1**2+v2**2
>         if(rsq.ge.1..or.rsq.eq.0.)goto 1
>         fac=sqrt(-2.*log(rsq)/rsq)
>         gset=v1*fac
>         gasdev_pk=v2*fac
>         iset=1
>       else
>         gasdev_pk=gset
>         iset=0
>       endif
>       return
>       END
> C (C) Copr. 1986-92 Numerical Recipes Software >).
1,2c1,2
< 652 2006-08-16 10:58 /work/Umi2/spurzem/5/nbody6compare-oct2006/block.f
< nbody6compare-oct2006/block.f
---
> 647 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/block.f
> nbody6++compare/block.f
9c9,10
<       COMMON/RAND2/  IY,IFF,IR(97) 
---
>       COMMON/RAND/  IY,IFF,IR(97) 
>       COMMON/ISAVE/  LI0,LI,NS,NSLIST(LMAX)
14d14
<       COMMON/COUNTS/  NCOUNT(70)
18c18
<       DATA  IFF,ICPU  /0,0/
---
>       DATA  IFF,LI0,NS,ICPU  /0,-1,0,0/
23d22
<       DATA  NCOUNT  /70*0/
1,2c1,2
< 4426 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/bodies.f
< nbody6compare-oct2006/bodies.f
---
> 4496 2000-08-21 21:05 /work/Umi2/spurzem/5/nbody6++compare/bodies.f
> nbody6++compare/bodies.f
35c35,36
<           WRITE (6,6)  I, NAME(I), BODY(I), STEP(I), STEPR(I), EI, RI,
---
>           if(rank.eq.0)
>      &    WRITE (6,6)  I, NAME(I), BODY(I), STEP(I), STEPR(I), EI, RI,
83c84,85
<           WRITE (6,35)  NAME(I), NAME(JMIN), BODY(I), BODY(JMIN), EREL,
---
>           if(rank.eq.0)
>      &    WRITE (6,35)  NAME(I), NAME(JMIN), BODY(I), BODY(JMIN), EREL,
85,86c87,88
<    35     FORMAT ('   BINARY ',2I5,2F8.4,F9.1,1P,4E10.2,0P,F7.2,2I5,
<      &                                              1P,E10.1,0P,F7.2,I4)
---
>    35     FORMAT ('   BINARY ',2I5,2F8.4,F9.1,1P4E10.2,0PF7.2,2I5,
>      &                                                1PE10.1,0PF7.2,I4)
107c109,110
<           WRITE (6,35)  NAME(I), NAME(JMIN), BODY(I), BODY(JMIN),
---
>           if(rank.eq.0)
>      &    WRITE (6,35)  NAME(I), NAME(JMIN), BODY(I), BODY(JMIN),
1,2c1,2
< 3002 2006-08-17 16:32 /work/Umi2/spurzem/5/nbody6compare-oct2006/brake.f
< nbody6compare-oct2006/brake.f
---
> 6121 2001-08-04 21:22 /work/Umi2/spurzem/5/nbody6++compare/brake.f
> nbody6++compare/brake.f
1c1
<       SUBROUTINE BRAKE(IPAIR,DSEP)
---
>       SUBROUTINE BRAKE(IPAIR)
4,5c4,5
< *       Orbital changes (GR, mass loss and/or tides).
< *       ---------------------------------------------
---
> *       Magnetic braking & gravitational radiation.
> *       -------------------------------------------
8c8,12
<       REAL*8  M1,M2
---
>       REAL*8 M1,M2
> *     REAL*4 RL,Q
> *     EXTERNAL RL
>       SAVE NDIAG
>       DATA NDIAG /0/
15,17d18
<       DSEP = DSEP/SU 
< *
< *       Set mass and radius of each star in solar units.
20,21c21,47
<       R1 = RADIUS(I1)*SU
<       R2 = RADIUS(I2)*SU
---
> *
> *       Quit if active ROCHE contains WD (TIME > TEV from MDOT).
>       IF ((KSTAR(I).EQ.21.OR.KSTAR(I).EQ.23).AND.
>      &    MAX(KSTAR(I1),KSTAR(I2)).GE.10) THEN
>           GO TO 40
>       END IF
> *
> *       Identify the most magnetically active star (#J2).
>       IF (RADIUS(I1).GE.RADIUS(I2)) THEN
>           IF ((KSTAR(I1).EQ.1.AND.M1.GT.1.3).OR.
>      &        (KSTAR(I1).EQ.0.AND.M1.LT.0.3)) THEN
>               J2 = I2
>           ELSE
>               J2 = I1
>           END IF
>       ELSE
>           IF ((KSTAR(I2).EQ.1.AND.M2.GT.1.3).OR.
>      &        (KSTAR(I2).EQ.0.AND.M2.LT.0.3)) THEN
>               J2 = I1
>           ELSE
>               J2 = I2
>           END IF
>       END IF
> *
> *       Set mass and radius of star #J2 in solar units.
>       M2 = BODY(J2)*ZMBAR
>       R2 = RADIUS(J2)*SU
27,37c53,97
<       SEMI1 = SEMI - DSEP 
< *
< *       Check collision/coalescence (IQCOLL=-2 skips ECOLL updating in COAL).
<       RP = SEMI1*SU*(1.D0 - SQRT(ECC2))
<       IF(KSTAR(I).LE.0.AND.(RP.LE.(R1+R2)))THEN
<          CALL KSPERI(IPAIR)
<          IQCOLL = -2
<          CALL CMBODY(R(IPAIR),2)
<          GOTO 90
<       ENDIF
<       IF(DSEP.EQ.0.D0) GOTO 90
---
>       GM = 1.3D+26
> *       Define binary period, solar radius & GMS in cgs units.
>       TB = 3.147D+07*YRS*SEMI*SQRT(SEMI/BODY(I))
>       RSUN = 6.96D+10
>       GMS = GM*ZMBAR*BODY(I)
> *
> *       Form time derivative of angular momentum (Regos & Tout 1995).
>       ZJDOT = 3.8D-30*1.989D+33*M2*RSUN**4*R2**3*(TWOPI/TB)**3
> *
> *       Determine new semi-major axis from angular momentum relation.
>       ZMU = BODY(I1)*BODY(I2)/BODY(I)
>       ACM = 3.08D+18*RBAR*SEMI
>       ADOT = 2.0*SQRT(ACM/GMS)*ZJDOT/(1.989D+33*ZMBAR*ZMU)
> *
> *       Define old primary and evaluate time scale for spin-down (yrs).
>       TBR = ACM/(3.147D+07*ADOT)
> *
> *       Evaluate alternative expression derived by J/JDOT (factor 2 longer).
> *     J1 = I1
> *     IF (J1.EQ.J2) J1 = I2
> *     TBRAKE = 4.4D+06*(BODY(J1)/BODY(I))/(BODY(I)*ZMBAR)*(ACM/RSUN)**5/
> *    &                                                            R2**3
> *
> *       Include gravitational radiation (64*GM**3/5*c**5; Ap.J. 418, 147).
> *     FAC = 64.0*((6.67D-08*1.989D+33)/3.0D+10)**3/(5.0*9.0D+20)
>       AGDOT = 1.23D+27*BODY(I1)*BODY(I2)*BODY(I)*(ZMBAR/ACM)**3
>       TGR = ACM/(3.147D+07*AGDOT)
> *
> *       Suppress magnetic braking for massive MS/low-mass or evolved star.
>       IF (((M2.GT.1.3.OR.M2.LT.0.3).AND.KSTAR(J2).LE.2).OR.
>      &      KSTAR(J2).GE.10) THEN
>           ADOT = 0.0
>           TBR = 1.0D+10
>       END IF
> *
> *       Combine effects but include possible cutoff of magnetic braking.
>       ADOT = ADOT + AGDOT
> *
> *       Set time-step to 1% change and new look-up time (cf. MDOT re #34).
>       DT = 0.01*SEMI/ABS(ADOT)
>       TEV(I) = TEV(I) + DT
> *
> *       Convert from cgs to scaled units and update semi-major axis.
>       ADOT = ADOT/(1.0D+05*VSTAR)
>       SEMI1 = SEMI - ADOT*DT
40,46c100,107
<       RCHCK = MIN(RADIUS(I1),RADIUS(I2)) 
<       IF(SEMI1.LT.RCHCK) SEMI1 = RCHCK 
< *
< *       Transform to pericentre (R > A & unperturbed).
< *     IF(R(IPAIR).GT.SEMI.AND.LIST(1,I1).EQ.0)THEN
< *        CALL KSAPO(IPAIR)
< *     ENDIF
---
>       IF (ABS(SEMI1).LT.RADIUS(J2).OR.SEMI1.LT.0.0) THEN
>           SEMI1 = RADIUS(J2)
>       END IF
> *
> *       Transform original orbit to pericentre if R > A.
>       IF (R(IPAIR).GT.SEMI) THEN
>           CALL KSAPO(IPAIR)
>       END IF
51,52c112,113
<          V20 = V20 + UDOT(K,IPAIR)**2
<  10   CONTINUE
---
>           V20 = V20 + UDOT(K,IPAIR)**2
>    10 CONTINUE
57d117
<       ZMU = BODY(I1)*BODY(I2)/BODY(I) 
60c120
< *       Specify KS coordinate & velocity scaling factors at arbitrary point.
---
> *       Specify KS coordinate & velocity scaling factors at new pericentre.
62,63c122
< *     V2 = 0.5*(BODY(I) + H(IPAIR)*SEMI1*(1.0 - SQRT(ECC2)))
<       V2 = 0.5*(BODY(I) + H(IPAIR)*R(IPAIR)*(SEMI1/SEMI))
---
>       V2 = 0.5*(BODY(I) + H(IPAIR)*SEMI1*(1.0 - SQRT(ECC2)))
68c127
< *     TDOT2(IPAIR) = 0.0D0
---
>       TDOT2(IPAIR) = 0.0D0
70,75c129,134
<          U(K,IPAIR) = C2*U(K,IPAIR)
<          UDOT(K,IPAIR) = C1*UDOT(K,IPAIR)
<          U0(K,IPAIR) = U(K,IPAIR)
<          R(IPAIR) = R(IPAIR) + U(K,IPAIR)**2
< *        TDOT2(IPAIR) = TDOT2(IPAIR) + 2.0*U(K,IPAIR)*UDOT(K,IPAIR)
<  20   CONTINUE
---
>           U(K,IPAIR) = C2*U(K,IPAIR)
>           UDOT(K,IPAIR) = C1*UDOT(K,IPAIR)
>           U0(K,IPAIR) = U(K,IPAIR)
>           R(IPAIR) = R(IPAIR) + U(K,IPAIR)**2
> *         TDOT2(IPAIR) = TDOT2(IPAIR) + 2.0*U(K,IPAIR)*UDOT(K,IPAIR)
>    20 CONTINUE
78,79c137,170
< *     IF (LIST(1,I1).EQ.0) THEN
< *        CALL KSAPO(IPAIR)
---
>       CALL KSAPO(IPAIR)
> *
> *       Include optional diagnostic output (also 2nd Roche stage).
>       IF (KZ(28).GT.1.OR.KSTAR(I).EQ.23) THEN
>           NDIAG = NDIAG + 1
>           IF (NDIAG.EQ.1.OR.MOD(NDIAG,100).EQ.0) THEN
>               RCOLL = RADIUS(I1) + RADIUS(I2)
>               WRITE (6,25)  TIME, IPAIR, M2, R2, TBR, TGR, R(IPAIR),
>      &                      RCOLL
>    25         FORMAT (' BRAKE    T KS M2 R2 TBR TGR R RCOLL ',
>      &                           F10.4,I4,F6.2,F7.3,1P,2E9.1,2E10.2)
>           END IF
>       END IF
> *
> *       Determine indices for primary & secondary star (donor & accretor).
> *     J1 = I1
> *     J2 = I2
> *     Q = BODY(J1)/BODY(J2)
> *     RL1 = RL(Q)*SEMI1
> *       Evaluate Roche radius for the second star.
> *     Q = 1.0/Q
> *     RL2 = RL(Q)*SEMI1
> *
> *       Compare scaled Roche radii when choosing the primary.
> *     IF (RADIUS(J1)/RL1.LT.RADIUS(J2)/RL2) THEN
> *         J1 = I2
> *         J2 = I1
> *         RL1 = RL2
> *     END IF
> *
> *       Check Roche mass transfer at every stage (AM CVn formation).
> *     IF (RADIUS(J1).GT.RL1) THEN
> *         CALL ROCHE(IPAIR)
> *         IF (IPHASE.LT.0) GO TO 40
82,98c173,186
< *       Include new initialization for perturbed orbit.
<       IF (LIST(1,I1).GT.0) THEN
<          IMOD = KSLOW(IPAIR)
<          CALL KSPOLY(IPAIR,IMOD)
<       ENDIF
< *
< *       Include some diagnostic output.
<       IF(KSTAR(I).EQ.13)THEN
<          NDIAG = NDIAG + 1
<          IF(NDIAG.LT.100.OR.MOD(NDIAG,100).EQ.100)THEN
<             RCOLL = RADIUS(I1) + RADIUS(I2)
<             WRITE (6,25)  TTOT, IPAIR, M1, M2, R1, R2, R(IPAIR),
<      &                    RCOLL
<  25         FORMAT (' BRAKE    T KS M12 R12 R RCOLL ',
<      &                         F10.4,I4,2F6.2,2F7.3,1P,2E10.2)
<          ENDIF
<       ENDIF
---
> *       Perform collision check (compact + evolved star).
>       IF (R(IPAIR).LT.RADIUS(I1) + RADIUS(I2)) THEN
>           RCOLL = RADIUS(I1) + RADIUS(I2)
>           TK = DAYS*SEMI*SQRT(SEMI/BODY(I))
>           WRITE (6,30)  TIME, NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
>      &                  M2, R2, TBR, TGR, R(IPAIR), RCOLL, TK
>    30     FORMAT (' END BRAKE    T NAM K* M2 R2 TBR TGR R RCOLL P ',
>      &                           F10.4,2I6,2I4,F6.2,F7.3,1P,5E9.1)
> *
> *       Predict c.m. and combine the two stars inelastically.
>           CALL XVPRED(I,0)
>           KSPAIR = IPAIR
>           CALL CMBODY(R(IPAIR),2)
>       END IF
100c188
<  90   RETURN
---
>    40 RETURN
102a191
> 
1,2c1,2
< 1398 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/cfuncs.f
< nbody6compare-oct2006/cfuncs.f
---
> 1398 1999-11-03 09:53 /work/Umi2/spurzem/5/nbody6++compare/cfuncs.f
> nbody6++compare/cfuncs.f
1,2c1,2
< 22966 2006-09-07 19:13 /work/Umi2/spurzem/5/nbody6compare-oct2006/chain.f
< nbody6compare-oct2006/chain.f
---
> 21872 2005-03-09 22:47 /work/Umi2/spurzem/5/nbody6++compare/chain.f
> nbody6++compare/chain.f
12a13,15
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
30d32
<       COMMON/SWCALL/ NCALL
107c109
<       DO 2 J = 1,10
---
>       DO 1 J = 1,10
127d128
<       NCALL = 0
135,136c136
< *     EPS = 1.0E-10
<       EPS = 1.0E-12
---
>       EPS = 1.0E-10
151d150
<           RCOLL = 100.0
233,235c232,233
<       GCRIT = 1.0D-05
<       IF (N.EQ.4) GCRIT = 5.0D-06
<       IF (N.GT.4) GCRIT = 1.0D-06
---
>       GCRIT = 5.0D-05
>       IF (N.GT.4) GCRIT = 1.0D-05
238c236,237
<           WRITE (6,15)  N, NPERT, ENERGY, RSUM, RGRAV, TCR, RMAXS(ISUB),
---
>           if(rank.eq.0)
>      &    WRITE (6,15)  N, NPERT, ENERGY, RSUM, RGRAV, TCR, RMAXS(ISUB),
341c340
<       IF (KZ26.GE.2.AND.(.not.stopB.or.KSLOW)) then
---
>       IF (KZ26.EQ.2.AND.(.not.stopB.or.KSLOW)) then
372c371
<           STEP = 10.0*ABS(STEP0)
---
>           STEP = 10.0*STEP0
374c373
<           WRITE (6,*) ' Stepsize = 0!', char(7)
---
>           if(rank.eq.0)WRITE (6,*) ' Stepsize = 0!', char(7)
378c377
<       IF (KZ30.GT.2) THEN
---
>       IF (rank.eq.0.and.KZ30.GT.2) THEN
383c382
< *       Determine two-body distances for stability test and collision search.
---
> *       Update sum of 1/R^2 during forward integration (R^2 before 12/99).
388c387
< *       Find minimum separation for stability test and save chain index.
---
> *       Find minimum separation and chain index.
395d393
< *       Update sum of 1/R^2 during forward integration (R^2 before 12/99).
402c400
< *       Set search distance for closest separation.
---
> *       Specify search distance of two closest particles (2 x 4*r_max).
405,426c403,409
<           SX = MAX(SIZE(I1),SIZE(I2))
< *       Turn off circular orbit indicators for overlapping stars.
<           IF (IMCIRC.GT.0) THEN
<               IF (RM.LT.2.0*SX) THEN
<                   SX = 0.5*RM
<                   NCIRC = 0
<                   ISYNC = 0
<                   IMCIRC = 0
<               ELSE
<                   SX = 0.0
<               END IF
<           END IF
< *       See whether another star is a more likely collider (compare SIZE/R).
<           RY = RM
<           DO 36 K = 1,N-1
<               IF (K.NE.IX) THEN
<                   J1 = INAME(K)
<                   J2 = INAME(K+1)
<                   SY = MAX(SIZE(J1),SIZE(J2))
<                   IF (SY*RINV(K).GT.SX/RY) THEN
<                       SX = SY
<                       RY = 1.0/RINV(K)
---
>           RX = 8.0*MAX(SIZE(I1),SIZE(I2))
> *       Exclude circular binary from pericentre test (N = 3 is OK).
>           IF (IMCIRC.GT.0.AND.N.GT.3) THEN
>               RY = 0.0
>               DO 36 K = 1,N-1
>                   IF (RINV(K).GT.RY.AND.K.NE.IMCIRC) THEN
>                       RY = RINV(K)
428,431c411,415
<               END IF
<    36     CONTINUE
< *       Include factor of 2 in criterion QPMIN < 4*MAX(SIZE(K1),SIZE(K2)).
<           SX = 8.0*SX
---
>    36         CONTINUE
>               RY = 1.0/RY
>           ELSE
>               RY = RM
>           END IF
436c420
<       IF (RY.LT.SX.AND.NSTEP1.GT.NEXT) THEN
---
>       IF (RY.LT.RX.AND.NSTEP1.GT.NEXT) THEN
441d424
<                       GSAVE = GCRIT
445c428
<                       GCRIT = GSAVE
---
>                       GCRIT = 5.0D-05
455d437
<           IMCIRC = 0
504,511c486,487
<           IF (KZ27.LE.2) THEN
<               FAC = 0.5*(M(J1) + M(J2))/M(J1)
<               RCR = 1.7*FAC**0.3333*SIZE(J1)
<           ELSE
<               CLIGHT = 3.0D+05/VSTAR1
<               RCR = 6.0*(M(J1) + M(J2))/CLIGHT**2
<           END IF
< *
---
>           FAC = 0.5*(M(J1) + M(J2))/M(J1)
>           RCR = 1.7*FAC**0.3333*SIZE(J1)
512a489
> *
534c511
< *       Re-initialize with reduced membership NCH.
---
> *       Re-initialize with reduced NCH and terminate for only two particles.
536c513,514
< *       Activate indicator for new chain (terminates at once with N = 2).
---
>               IF (N.EQ.2) GO TO 70
> *       Activate indicator for new chain.
591,592c569,570
< *       Check termination or strong perturbation (T > TMAX or GPERT > 0.01).
<       IF (CHTIME.GT.TMAX.OR.GPERT.GT.0.01) THEN
---
> *       Check termination criteria (T > TMAX or RSUM > RMAXC).
>       IF ((CHTIME.GT.TMAX).OR.(RSUM.GT.RMAXC).OR.GPERT.GT.0.01) THEN
597c575
<           IF (KZ30.GT.2) THEN
---
>           IF (rank.eq.0.and.KZ30.GT.2) THEN
602,603c580
< *       Avoid checking after switch (just in case).
<           IF (ISW.EQ.0) THEN
---
>           IF (ISW.EQ.0.AND.(RSUM.GT.RMAXC.OR.GPERT.GT.0.01)) THEN
669,681d645
< *       Copy Q & P for TRANSK via CHTERM & EREL (KZ26 > 2: rectification).
<       IF (KZ26.GT.2) THEN
<           DO 75 I = 1,N-1
<               KS = 4*(I - 1)
<               DO 72 J = 1,4
<                   QK(KS+J) = Q(KS+J)
<                   PK(KS+J) = P(KS+J)
<    72         CONTINUE
<               RIK = Q(KS+1)**2 + Q(KS+2)**2 + Q(KS+3)**2 + Q(KS+4)**2
<               RINV(I) = 1.0/RIK
<    75     CONTINUE
<       END IF
< *
688c652
<       IF (KZ30.GT.1.AND.QPERI.LT.1.0) THEN
---
>       IF (rank.eq.0.and.KZ30.GT.1.AND.QPERI.LT.1.0) THEN
699a664
> 
1,2c1,2
< 1368 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/chdata.f
< nbody6compare-oct2006/chdata.f
---
> 1369 2001-08-04 17:17 /work/Umi2/spurzem/5/nbody6++compare/chdata.f
> nbody6++compare/chdata.f
43a44
> 
1,2c1,2
< 3938 2006-03-20 05:33 /work/Umi2/spurzem/5/nbody6compare-oct2006/check.f
< nbody6compare-oct2006/check.f
---
> 4180 2001-08-06 16:32 /work/Umi2/spurzem/5/nbody6++compare/check.f
> nbody6++compare/check.f
22a23
>               if(rank.eq.0)then
25a27
>               end if
44a47
>           if(rank.eq.0)then
46a50
>           end if
65a70
>       if(rank.eq.0)then
68a74
>       end if
83a90
>           if(rank.eq.0)then
84a92
>           end if
94a103
>               if(rank.eq.0)then
95a105
>               end if
112c122
< *       Set IPHASE = -1 to ensure new time-step list in INTGRT.
---
> *       Set IPHASE = -1 to ensure new NLIST in routine INTGRT (Hermite).
1,2c1,2
< 10001 2006-09-08 14:46 /work/Umi2/spurzem/5/nbody6compare-oct2006/checkl.f
< nbody6compare-oct2006/checkl.f
---
> 10002 2000-07-26 04:59 /work/Umi2/spurzem/5/nbody6++compare/checkl.f
> nbody6++compare/checkl.f
12,13c12,13
< *       Only consider high-velocity particles if KZ(37) = 1.
<       IF (KZ(37).EQ.1) GO TO 350
---
> *       Only consider high-velocity particles if KZ(18) = 1.
>       IF (KZ(18).EQ.1) GO TO 350
317a318
> 
1,2c1,2
< 680 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/chfind.f
< nbody6compare-oct2006/chfind.f
---
> 680 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/chfind.f
> nbody6++compare/chfind.f
1,2c1,2
< 5653 2004-05-12 17:34 /work/Umi2/spurzem/5/nbody6compare-oct2006/chfirr.f
< nbody6compare-oct2006/chfirr.f
---
> 5734 2005-03-09 18:58 /work/Umi2/spurzem/5/nbody6++compare/chfirr.f
> nbody6++compare/chfirr.f
9c9,10
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
41c42,43
< *         CALL KSRES2(JP,J1,J2,RIJ2)
---
> *         IZZ = KVEC(JP)
> *         CALL KSRES2(JP,J1,J2,RIJ2,IZZ)
1,2c1,2
< 5202 2006-08-30 10:19 /work/Umi2/spurzem/5/nbody6compare-oct2006/chinit.f
< nbody6compare-oct2006/chinit.f
---
> 5292 2002-07-12 20:03 /work/Umi2/spurzem/5/nbody6++compare/chinit.f
> nbody6++compare/chinit.f
8c8,9
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMX4=4*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
143c144
< *       Check next treatment time of perturbers.
---
> *       Check next treatment time of perturbers & output time.
145a147
>       TMAX = MIN(TMAX,TADJ - TIME)
159c161
< *       Set phase indicator < 0 to ensure new time-step list in INTGRT.
---
> *       Set phase indicator < 0 to ensure new NLIST in routine INTGRT.
164a167
> 
1,2c1,2
< 2446 2005-10-13 13:13 /work/Umi2/spurzem/5/nbody6compare-oct2006/chlist.f
< nbody6compare-oct2006/chlist.f
---
> 2448 2000-07-26 04:59 /work/Umi2/spurzem/5/nbody6++compare/chlist.f
> nbody6++compare/chlist.f
9c9,10
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
50,51c51,57
< *       Save perturber membership.
<       LISTC(1) = NNB1 - 1
---
> *       Save perturber membership (copy last neighbour if none).
>       IF (NNB1.EQ.1) THEN
>           LISTC(2) = J
>           LISTC(1) = 1
>       ELSE
>           LISTC(1) = NNB1 - 1
>       END IF
55,64d60
< *
< *       Obtain actual perturbation (note GAMX zero first time).
<       CALL CHPERT(GAMX)
< *
< *     WRITE (6,20)  ICH, NNB2-1, LISTC(1), RSUM, RPERT, GPERT, GAMX
< *  20 FORMAT (' CHLIST:   ICH NB NP RSUM RPERT GPERT GX ',3I4,1P,4E9.1)
< *
<       IF (GAMX.GT.0.0D0) THEN
<           GPERT = GAMX
<       END IF
66c62
< 
---
> *
68c64
<       IF (GPERT.GT.1.0D-06.AND.NPERT.GT.0) THEN
---
>       IF (GPERT.GT.1.0D-05) THEN
73a70,72
> *     WRITE (6,20)  ICH, NNB2-1, LISTC(1), RSUM, RPERT, GPERT
> *  20 FORMAT (' CHLIST:   ICH NB NP RSUM RPERT GPERT  ',3I4,1P,3E9.1)
> 
76a76
> 
1,2c1,2
< 20619 2006-08-14 12:04 /work/Umi2/spurzem/5/nbody6compare-oct2006/chmod.f
< nbody6compare-oct2006/chmod.f
---
> 17089 2003-06-25 20:39 /work/Umi2/spurzem/5/nbody6++compare/chmod.f
> nbody6++compare/chmod.f
30c30
< *       Identify the dominant perturber (skip if none or NN >= 6).
---
> *       Identify the dominant perturber (skip if none or NN >= 4).
34c34
<       IF (NNB.EQ.0.OR.NN.GE.6) GO TO 10
---
>       IF (NNB.EQ.0.OR.NN.GE.5) GO TO 10
36c36
<       DO 2 L = 2,NNB+1
---
>       DO 5 L = 2,NNB+1
46c46
<     2 CONTINUE
---
>     5 CONTINUE
53c53
< *       Check for rejection (RIJ > 3*MIN(RSUM,RMIN); RDOT > 0 & G < 0.05).
---
> *       Check for rejection (RIJ > 2*MIN(RSUM,RMIN); RDOT > 0 & G < 0.05).
55,89c55
< *
< *       Include test on fast escaper approaching a perturber having RDOT > 0.
<       IF (GPERT.GT.0.05.AND.RDOT.GT.0) THEN
< *       Bypass test and repeated diagnostics for large perturbation.
<           IF (GPERT.GT.0.5) GO TO 5
<           RDX = 0.0
<           L = 0
< *       Evaluate actual distance and relative radial velocity of end member.
<     3     RJX2 = (XCH(L+1) - X(1,JCLOSE))**2 +
<      &           (XCH(L+2) - X(2,JCLOSE))**2 +
<      &           (XCH(L+3) - X(3,JCLOSE))**2
<           RDI = (XCH(L+1) - X(1,JCLOSE))*(VCH(L+1) - XDOT(1,JCLOSE)) +
<      &          (XCH(L+2) - X(2,JCLOSE))*(VCH(L+2) - XDOT(2,JCLOSE)) +  
<      &          (XCH(L+3) - X(3,JCLOSE))*(VCH(L+3) - XDOT(3,JCLOSE))
< *       See whether any chain member is approaching the intruder.
<           IF (RDI.LT.0.0) THEN
<               RJX = SQRT(RJX2)
<               RDX = RDI/RJX
<           END IF
< *       Consider the last chain member similarly.
<           IF (L.EQ.0) THEN
<               L = 3*(NN - 1)
<               GO TO 3
<           END IF
< *       Bypass RDOT < 0 test for approaching ejection candidate.
<           IF (RDX.LT.0.0.AND.RJX.LT.2.0*RSUM/FLOAT(NN-1)) THEN
<               WRITE (6,4)  NAME(JCLOSE), GPERT, RIJ, RJX, RDX
<     4         FORMAT (' TRY ABSORB    NAM PERT RIJ RJX RDX ',
<      &                                I6,F6.2,1P,4E9.1)
<               GO TO 5
<           END IF
<       END IF
< *
< *       Include conditions for skipping (large RIJ & size or small GPERT).
<       IF (RIJ.GT.3.0*MIN(RSUM,RMIN)) GO TO 10
---
>       IF (RIJ.GT.3.0*MIN(RSUM,RMIN).OR.NAME(JCLOSE).LT.0) GO TO 10
92,94c58
< *       Allow triple hierarchy subject to maximum membership of 6.
<     5 IF (NN.GT.3.AND.NAME(JCLOSE).LT.0) GO TO 10
<       IF (NN.GT.4.AND.JCLOSE.GT.N) GO TO 10
---
>       IF (RSUM+RIJ.GT.2.0*RMIN) GO TO 10
105,106c69,70
< *       Widen the impact parameter test to be on safe side.
<       IF (PMIN.GT.1.5*RSUM.AND.GPERT.LT.0.05) GO TO 10
---
>       IF (PMIN.GT.RSUM.AND.GPERT.LT.0.4) GO TO 10
>       IF (NN.GE.4.AND.JCLOSE.GT.N) GO TO 10
108,111c72,75
< *       Delay accepting very small binary (suppressed; eccentricity effect).
< *     IF (JCLOSE.GT.N.AND.GPERT.LT.0.25) THEN
< *         IF (100.0*R(JCLOSE-N).LT.RIJ) GO TO 10
< *     END IF
---
> *       Delay accepting very small binary.
>       IF (JCLOSE.GT.N.AND.GPERT.LT.0.4) THEN
>           IF (100.0*R(JCLOSE-N).LT.RIJ) GO TO 10
>       END IF
132,141c96,99
<           IF (KZ(30).GT.1) THEN
<               IF (JCLOSE.GT.N) THEN
<                   SEMI = -0.5*BODY(JCLOSE)/H(JCLOSE-N)
<               ELSE
<                   SEMI = 0.0
<               END IF
<               WRITE (6,6)  NSTEP1, JCLOSE, NAME(JCLOSE), GPERT, RIJ,
<      &                     RSUM, PMIN, SEMI
<     6         FORMAT (' ABSORB:    # JCLOSE NMJ GPERT RIJ RSUM PMIN A ',
<      &                             3I6,F6.2,1P,4E9.1)
---
>           IF (rank.eq.0.and.KZ(30).GT.1) THEN
>               WRITE (6,6)  JCLOSE, NAME(JCLOSE), GPERT, RIJ, RSUM, PMIN
>     6         FORMAT (' ABSORB:    JCLOSE NMJ GPERT RIJ RSUM PMIN ',
>      &                             2I6,F6.2,1P,3E9.1)
151d108
<               GSAVE = GCRIT
154c111
<               GCRIT = GSAVE
---
>               GCRIT = 5.0E-05
167c124
<               IF (RM.LT.SMALL.AND.SEMI.LT.SMALL) THEN
---
>               IF (rank.eq.0.and.RM.LT.SMALL.AND.SEMI.LT.SMALL) THEN
224,252d180
< *       Try escape check if middle distance is largest.
<       IF (KCASE.EQ.0.AND.NN.GE.5.AND.
<      &    1.0/RINV(ISORT(1)).GT.2.0*RMIN) THEN
<           R1 = 1.0/RINV(1)
<           R2 = 1.0/RINV(NN-1)
< *       Set relevant indices for beginning or end of chain.
<           IF (R1.GT.R2) THEN
<               IESC = INAME(1)
<               JX = INAME(2)
<               IB = 1
<               ISORT(1) = 1
<               R3 = 1.0/RINV(2)
<           ELSE
<               IESC = INAME(NN)
<               JX = INAME(NN-1)
<               IB = NN - 1
<               ISORT(1) = NN - 1
<               R3 = 1.0/RINV(NN-2)
<           END IF
< *       Define binary indices for large second separation.
<           IF (R3.GT.MAX(R1,R2)) THEN
<               JESC = JX
<               IBIN = IB
<               KCASE = 2
<           ELSE
<               KCASE = 1
<           END IF
<       END IF
< *
256c184
<       IF (KZ(30).GT.2) THEN
---
>       IF (rank.eq.0.and.KZ(30).GT.2) THEN
259c187
<    12     FORMAT (' CHMOD:    IESC JESC # ISORT1 R ',2I3,I6,I3,1P,5E9.1)
---
>    12     FORMAT (' CHMOD:    IESC JESC # ISORT1 R ',2I3,I5,I3,1P,5E9.1)
278,288c206,207
< *       Consider removal of outermost particle instead if binary is wide.
<           IF (RB.GT.0.25*RJB) THEN
< *       Change pointer to end of chain and redefine IESC.
<               IF (ISORT(1).EQ.2) THEN
<                   ISORT(1) = 1
<               ELSE
<                   ISORT(1) = NN - 1
<               END IF
<               IESC = JESC
<               GO TO 30
<           END IF
---
> *       Consider single particle for separation ratio > 1/4.
>           IF (RB.GT.0.25*RJB) GO TO 30
289a209
>           RB = 0.0
312c232
< *       Adopt arithmetic mean of RSUM and RMAXS for delaying escape.
---
> *       Adopt harmonic mean of RSUM and RMAXS for delaying escape.
315c235
<       IM = ISORT(1)
---
>       IM = ISORT(1)  
338,340c258,261
<               ELSE IF (GB.LT.0.01.AND.NCH.GT.4.AND.
<      &                 (RDOT**2.GT.BODY(ICH)/RI.OR.RI.GT.RMIN)) THEN
<                   WRITE (6,28)  IESC, JESC, NAMEC(IESC), NAMEC(JESC),
---
>               ELSE IF (GB.LT.0.001.AND.NCH.GT.4.AND.
>      &                 RDOT**2.GT.BODY(ICH)/RI) THEN
>                   if(rank.eq.0)
>      &            WRITE (6,28)  IESC, JESC, NAMEC(IESC), NAMEC(JESC),
360,372c281,285
<               HI = 0.5*RDOT**2 - BODY(ICH)/RI
<               IF (HI.GT.0.0) THEN
<                   VINF = SQRT(2.0*HI)*VSTAR
<               ELSE
<                   VINF = 0.0
<               END IF
<               IF (KZ(30).GT.1.OR.VINF.GT.1.0) THEN
<                   WRITE (6,28)  IESC, JESC, NAMEC(IESC), NAMEC(JESC),
<      &                          RI, RDOT**2, 2.0*BODY(ICH)/RI, RB, VINF
<    28             FORMAT (' CHAIN ESCAPE:    IESC JESC NM RI RDOT2 ',
<      &                                      '2*M/R RB VINF ',
<      &                                       2I3,2I6,1P,4E9.1,0P,F6.1)
<               END IF
---
>               if(rank.eq.0)
>      &         WRITE (6,28)  IESC, JESC, NAMEC(IESC), NAMEC(JESC),
>      &                      RI, RDOT**2, 2.0*BODY(ICH)/RI, RB
>    28         FORMAT (' CHAIN ESCAPE:    IESC JESC NM RI RDOT2 2*M/R ',
>      &                                   'RB',I4,I3,2I6,1P,4E9.1)
396d308
<       RB = 0.0
403c315
< *       Note that arithmetic mean tends to delay escape.
---
> *       Note that harmonic mean tends to delay escape.
413,421c325,326
<                   IB = ISORT(NN-1)
< *       Prevent NN = 4 termination near small pericentre (subject to safety).
<                   IF (1.0/RINV(IB).GT.0.1*RGRAV.OR.RSUM.GT.RMIN) THEN
<                       KCASE = -1
<                       GO TO 50
<                   ELSE
<                       KCASE = 0
<                       GO TO 60
<                   END IF
---
>                   KCASE = -1
>                   GO TO 50
425,426c330
<               IF ((ER.LT.0.0.AND.RX.LT.MIN(2.0*RSUM,2.0*RMIN)).OR.
<      &            (NN.EQ.3.AND.GI.GT.0.1)) THEN
---
>               IF (ER.LT.0.0.AND.RX.LT.2.0*RSUM) THEN
443,445c347,350
<                       IF (RY.LT.0.9*SEMI.AND.RI.LT.2.0*RMIN) THEN
<                           WRITE (6,31)  NSTEP1, RY/SEMI, RI, RDOT**2,
<      &                                  2.0*BODY(ICH)/RI, SEMI
---
>                       IF (RY.LT.0.9*SEMI) THEN
> *                         if(rank.eq.0)
> *    &                     WRITE (6,31)  NSTEP1, RY/SEMI, RI, RDOT**2,
> *    &                                  2.0*BODY(ICH)/RI, SEMI
495,499c400,405
<               IF (RY.LT.0.9*SEMI.AND.RI.LT.2.0*RMIN) THEN
<                   WRITE (6,31)  NSTEP1, RY/SEMI, RI, RDOT**2,
<      &                          2.0*BODY(ICH)/RI, SEMI
<    31             FORMAT (' CHAIN DELAY    # R/A RI RD2 VP2 A ',
<      &                                     I5,F6.2,1P,4E9.1)
---
>               IF (RY.LT.0.9*SEMI) THEN
> *                 if(rank.eq.0)
> *    &            WRITE (6,31)  NSTEP1, RY/SEMI, RI, RDOT**2,
> *    &                          2.0*BODY(ICH)/RI, SEMI
> *  31             FORMAT (' CHAIN DELAY    # R/A RI RD2 VP2 A ',
> *    &                                     I5,F6.2,1P,4E9.1)
519c425
<           IF (KZ(30).GT.1.OR.VINF.GT.2.0) THEN
---
>           IF (rank.eq.0.and.KZ(30).GT.1.OR.VINF.GT.10.0) THEN
542c448
< *       Set phase indicator < 0 to ensure new time-step list in INTGRT.
---
> *       Set phase indicator < 0 to ensure new NLIST in routine INTGRT.
547a454
> 
1,2c1,2
< 1476 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/chpot.f
< nbody6compare-oct2006/chpot.f
---
> 1476 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/chpot.f
> nbody6++compare/chpot.f
1,2c1,2
< 5963 2006-08-27 00:08 /work/Umi2/spurzem/5/nbody6compare-oct2006/chstab.f
< nbody6compare-oct2006/chstab.f
---
> 6388 2005-03-09 22:48 /work/Umi2/spurzem/5/nbody6++compare/chstab.f
> nbody6++compare/chstab.f
12a13,15
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
66a70,79
> *       Replace the EK criterion by the MA analytical stability formula.
>       Q0 = M(I3)/MB
>       IF (ECC1.LT.1.0) THEN
>           XFAC = (1.0 + Q0)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
>       ELSE
>           XFAC = 1.0 + Q0
>       END IF
>       FE = 1.0
>       PCRIT = 2.8*FE*XFAC**0.4*SEMI
> *
70,71c83,84
< *       Replace the EK criterion by the general stability expression.
<       PCRIT = stability(M(I1),M(I2),M(I3),ECC,ECC1,ALPHA)*SEMI
---
> *       Include fudge factor for inclination effect.
>       YFAC = 1.0 - 0.3*ALPHA/180.0
73c86
<       PCRIT = 1.01*PCRIT
---
>       PCRIT = 1.01*YFAC*PCRIT
102c115
< *       Construct the Runge-Lenz vector (Heggie & Rasio 1995, Eq.(5)).
---
> *       Construct the Runge-Lenz vector (Heggie & Rasio 1996, Eq.(5)).
134d146
<       ALPHA = 180.0*ALPHA/3.1415
136a149
> *       Perform termination for positive radial velocity at safe distance.
139c152,156
<           WRITE (6,20)  NAMEC(I1), NAMEC(I2), NAMEC(I3), ECC, EMAX,
---
> *         K1 = INAME(I1)
> *         K2 = INAME(I2)
> *         K3 = INAME(I3)
>           if(rank.eq.0)
>      &    WRITE (6,20)  NAMEC(I1), NAMEC(I2), NAMEC(I3), ECC, EMAX,
144c161
<      &                         '  PC =',E9.2,'  IN =',0P,F7.1)
---
>      &                         '  PC =',E9.2,'  IN =',0P,F6.1)
146,147c163,164
<           Q0 = M(I3)/MB
<           WRITE (81,30)  TIMEC, RI, NAMEC(I3), Q0, ECC, EMAX, ECC1,
---
>           if(rank.eq.0)
>      &    WRITE (81,30)  TIMEC, RI, NAMEC(I3), Q0, ECC, EMAX, ECC1,
149c166
<    30     FORMAT (F8.1,F5.1,I6,F6.2,3F6.3,1P,2E10.2,0P,F5.2,F8.1)
---
>    30     FORMAT (F8.1,F5.1,I6,F6.2,3F6.3,1P,2E10.2,0P,F5.2,F6.1)
155c172
< *       Wait for favourable configuration (R > SEMI, R3 > 3*SEMI & RDOT3 > 0.
---
> *       Wait for favourable configuration (R > SEMI, R3 > SEMI1 & RDOT3 > 0).
158c175,176
<               WRITE (6,40)  ECC, ECC1, ALPHA, RB, R3, PCRIT, PMIN, APO
---
>               if(rank.eq.0)
>      &        WRITE (6,40)  ECC, ECC1, ALPHA, RB, R3, PCRIT, PMIN, APO
164,168c182,183
< *       Enforce termination of long-lived configuration using two limits.
<       ELSE IF (NSTEP1.GT.50000.AND.PMIN.GT.0.9*PCRIT.AND.
<      &    R3.GT.SEMI1) THEN
<           ITERM = -1
<       ELSE IF (NSTEP1.GT.500000.AND.R3.GT.SEMI1) THEN
---
> *       Enforce termination of long-lived configuration which fails the test.
>       ELSE IF (NSTEP1.GT.50000) THEN
174a190,191
> 
> 
1,2c1,2
< 16846 2006-09-02 14:37 /work/Umi2/spurzem/5/nbody6compare-oct2006/chterm.f
< nbody6compare-oct2006/chterm.f
---
> 14439 2003-06-25 21:03 /work/Umi2/spurzem/5/nbody6++compare/chterm.f
> nbody6++compare/chterm.f
10c10
<       REAL*8  M,MASS,MC,MIJ,MKK,R2(NMX,NMX),ANG(3)
---
>       REAL*8  M,MASS,MC,MIJ,MKK,R2(NMX,NMX)
25d24
<       COMMON/KSAVE/  K1,K2
34c33
< *       Prepare KS regularization(s) and direct integration of other bodies.
---
> *       Prepare KS regularization and direct integration of any other bodies.
40d38
<       I6 = 0
47c45
<       ELSE IF (NCH.EQ.4) THEN
---
>       ELSE
49,73c47,48
<       ELSE IF (NCH.GT.4) THEN
< *       Determine indices for second closest pair.
<           RX1 = 1.0
<           RX0 = R2(I1,I2)
<           DO 2 J1 = 1,NCH
< *       Avoid choosing close pair I1-I2.
<               IF (J1.EQ.I1.OR.J1.EQ.I2) GO TO 2
<               DO 1 J2 = J1+1,NCH
<                   IF (J2.EQ.I1.OR.J2.EQ.I2) GO TO 1
<                   IF (R2(J1,J2).LT.RX1.AND.R2(J1,J2).GT.RX0) THEN
<                       RX1 = R2(J1,J2)
<                       I3 = J1
<                       I4 = J2
<                   END IF
<     1         CONTINUE
<     2     CONTINUE
< *       Identify remaining single particle(s) by exclusion.
<           DO 3 I = 1,NCH
<               IF (I.EQ.I1.OR.I.EQ.I2.OR.I.EQ.I3.OR.I.EQ.I4) GO TO 3
<               IF (I5.EQ.0) THEN
<                   I5 = I
<               ELSE 
<                   I6 = I
<               END IF
<     3     CONTINUE
---
>           I5 = I4
>           IF (NCH.EQ.5) I5 = IJ(5)
75,76d49
<       IF (I5.EQ.0) I5 = I4
<       IF (I6.EQ.0) I6 = I4
78,79c51,52
<       IF (KZ(30).GT.1) THEN
<           WRITE (6,4)  SQRT(R2(I1,I2)), SQRT(R2(I1,I3)),SQRT(R2(I2,I3)),
---
>       IF (rank.eq.0.and.KZ(30).GT.2) THEN
>           WRITE (6,1)  SQRT(R2(I1,I2)), SQRT(R2(I1,I3)),SQRT(R2(I2,I3)),
81c54
<     4     FORMAT (' CHTERM:   RIJ (1-2 1-3 2-3 2-4 3-4)  ',1P,5E9.1)
---
>     1     FORMAT (' CHTERM:   RIJ (1-2 1-3 2-3 2-4 3-4)  ',1P,5E9.1)
89d61
<       IF (NCH.EQ.6) JLIST(11) = NAMEC(I6)
129a102,110
> *       Predict current X & XDOT for c.m. and neighbours to order F3DOT.
>       CALL XVPRED(ICM,-1)
>       NNB1 = LIST(1,ICH) + 1
>       DO 25 L = 2,NNB1
> *       Note possibility T0(J) = TIME in routine REDUCE would skip on -2.
>           J = LIST(L,ICH)
>           CALL XVPRED(J,-1)
>    25 CONTINUE
> *
132a114,115
> *       Note TBLOCK = TPREV set in REDUCE which can precede termination.
>       IF (DT8.EQ.0.0D0) DT8 = STEP(ICM)/8.0D0
152c135
< *       Restrict TIME to current block-step and save for use by KSPERI.
---
> *       Include safety check just in case and save TIME for possible reset.
155,163c138
< *
< *       Predict current X & XDOT for c.m. and neighbours to order F3DOT.
<       CALL XVPRED(ICM,-1)
<       NNB1 = LIST(1,ICH) + 1
<       DO 25 L = 2,NNB1
< *       Note possibility T0(J) = TIME in routine REDUCE would skip on -2.
<           J = LIST(L,ICH)
<           CALL XVPRED(J,-1)
<    25 CONTINUE
---
>       IF (NSTEP1.GE.50000) TBLOCK = TPREV
172,177c147,151
<       JLIST(7) = I1
<       JLIST(8) = I2
<       JLIST(9) = I3
<       JLIST(10) = I4
<       JLIST(11) = I5
<       JLIST(12) = I6
---
>       JLIST(6) = I1
>       JLIST(7) = I2
>       JLIST(8) = I3
>       JLIST(9) = I4
>       JLIST(10) = I5
190c164
<           LL = JLIST(L+6)
---
>           LL = JLIST(L+5)
240,241c214,215
< *       Set JLIST(7) < 0 to denote that body #I3 & I4 will be new KS pair.
<                   JLIST(7) = -1
---
> *       Set JLIST(6) < 0 to denote that body #I3 & I4 will be new KS pair.
>                   JLIST(6) = -1
265c239
< *       Assign new neighbours for dominant KS and any other members.
---
> *       Assign new neighbours for dominant KS, I3 & I4.
266a241,242
>       J3 = JLIST(3)
>       J4 = JLIST(4)
268,271c244,245
<       DO 65 L = 3,NCH
<           J = JLIST(L)
<           CALL NBLIST(J,RS0)
<    65 CONTINUE
---
>       IF (NCH.GT.2) CALL NBLIST(J3,RS0)
>       IF (NCH.GT.3) CALL NBLIST(J4,RS0)
281c255
<           IF (NCH.EQ.3) JLIST(2) = MAX(IFIRST + 4,JLIST(1) + 1)
---
>           IF (NCH.EQ.3) JLIST(2) = JCLOSE
287c261
<           JLIST(1) = MAX(IFIRST + 4,JCOMP + 1)
---
>           JLIST(1) = JCLOSE
292,295c266,267
<       IF (NCH.GE.3) THEN
<           CALL FCLOSE(ICOMP,NNB)
<           CALL FCLOSE(JCOMP,NNB)
<       END IF
---
>       CALL FCLOSE(ICOMP,NNB)
>       CALL FCLOSE(JCOMP,NNB)
311,312c283
<       IF (NCH.GE.5) I5 = JLIST(5)
<       IF (NCH.EQ.6) I6 = JLIST(6)
---
>       IF (NCH.EQ.5) I5 = JLIST(5)
338c309
<               IF (NCH.GE.5.AND.I5.GT.0) THEN
---
>               IF (NCH.EQ.5.AND.I5.GT.0) THEN
341,344d311
<                   IF (NCH.EQ.6) THEN
<                       CALL FPOLY1(I6,I6,0)
<                       CALL FPOLY2(I6,I6,0)
<                   END IF
356,357c323,324
< *       Include initialization of #I5/I6 before KS calls change address.
<       ELSE IF (NCH.GE.5.AND.I5.GT.0) THEN
---
> *       Include initialization of 5th body before KS calls change address.
>       ELSE IF (NCH.EQ.5.AND.I5.GT.0) THEN
360,363d326
<           IF (NCH.EQ.6) THEN
<               CALL FPOLY1(I6,I6,0)
<               CALL FPOLY2(I6,I6,0)
<            END IF
371,403d333
< *       Include optional rectification by standard KS procedure.
<           IF (KZ(26).GT.2) THEN
<               RX = 0.0
< *       Determine chain index of closest pair.
<               DO 70 K = 1,NCH-1
<                   IF (RINV(K).GT.RX) THEN
<                       RX = RINV(K)
<                       IM = K
<                   END IF
<    70         CONTINUE
< *       Set dominant pair mass references as IM & IM+1.
<               K1 = INAME(IM)
<               K2 = INAME(IM+1)
< *       Obtain regular values of binding energy and semi-major axis.
<               CALL EREL(IM,EB,SEMI)
<               HI = -0.5*BODY(NTOT)/SEMI
< *       Evaluate total energy explicitly.
<               CALL CONST(XCH,VCH,M,NCH,ENER2,ANG,GAM)
<               ERR = (ECH - ENER2)/ECH
<               EB1 = EB/ECH
<               GI = GAMMA(NPAIRS)
< *       Rectify KS elements of dominant and weakly perturbed binary.
<               IF (EB1.GT.0.9.AND.GI.LT.GMAX) THEN
<                   IF (ABS(ERR).GT.1.0D-08) THEN
<                       WRITE (6,72)  NCH, NSTEP1, EB1, SEMI, GI, ERR
<    72                 FORMAT (' CHAIN RECTIFY    NCH # EB/E A G ERR ',
<      &                                           I4,I6,F6.2,1P,3E10.2)
<                   END IF
< *       Copy new value of H and employ standard rectification.
<                   H(NPAIRS) = HI
<                   CALL KSRECT(NPAIRS)
<               END IF
<           END IF
431c361
<       IF (KZ(30).GT.1) THEN
---
>       IF (rank.eq.0.and.KZ(30).GT.1) THEN
454c384
<           IF (KZ(30).GT.1) THEN
---
>           IF (rank.eq.0.and.KZ(30).GT.1) THEN
510a441,443
> *       Reduce subsystem counter on collision (increased again by CHINIT).
>   100 IF (ITERM.LT.0) NSUB = NSUB - 1
> *
512c445
<   100 IF (ITERM.GE.0) TPREV = TIME - 16.0*DT8
---
>       IF (ITERM.GE.0) TPREV = TIME - 16.0*DT8
516a450,451
> 
> 
1,2c1,2
< 1654 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/clint.f
< nbody6compare-oct2006/clint.f
---
> 1654 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/clint.f
> nbody6++compare/clint.f
1,2c1,2
< 2243 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/cloud0.f
< nbody6compare-oct2006/cloud0.f
---
> 2331 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/cloud0.f
> nbody6++compare/cloud0.f
0a1,4
> # 1 "cloud0.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "cloud0.F"
4,5c8,9
< *       Cloud initialization.
< *       ---------------------
---
> * Cloud initialization.
> * ---------------------
8,10c12,14
<       COMMON/CLOUDS/  XCL(3,MCL),XDOTCL(3,MCL),BODYCL(MCL),RCL2(MCL),
<      &                CLM(MCL),CLMDOT(MCL),CLDOT,VCL,SIGMA,RB2,PCL2,
<      &                TCL,STEPCL,NCL,NEWCL
---
>       COMMON/CLOUDS/ XCL(3,MCL),XDOTCL(3,MCL),BODYCL(MCL),RCL2(MCL),
>      & CLM(MCL),CLMDOT(MCL),CLDOT,VCL,SIGMA,RB2,PCL2,
>      & TCL,STEPCL,NCL,NEWCL
11a16
> # 21 "cloud0.F"
13c18
< *       Initialize cloud variables.
---
> * Initialize cloud variables.
19,23c24,40
< *
< *       Read the cloud parameters.
<       READ (5,*)  NCL, RB2, VCL, SIGMA, (CLM(J),J=1,NCL),
<      &            (RCL2(J),J=1,NCL)
<       WRITE (6,100)  NCL, RB2, VCL, SIGMA
---
>       RB2 = 0.0
>       BODYCL(1) = 0.0
>       CLMDOT(1) = 0.0
>       RCL2(1) = 0.0
>       DO 10 K = 1,3
>           XCL(K,1) = 0.0
>           XDOTCL(K,1) = 0.0
>    10 CONTINUE
> *
>       IF (KZ(13).EQ.0) GO TO 120
> *
> * Read the cloud parameters.
>       if(rank.eq.0)
>      &READ (5,*) NCL, RB2, VCL, SIGMA, (CLM(J),J=1,NCL),
>      & (RCL2(J),J=1,NCL)
> # 51 "cloud0.F"
>       WRITE (6,100) NCL, RB2, VCL, SIGMA
25c42
<      &    '  MEAN CLOUD VELOCITY (KM/SEC) =',F5.1,'  DISPERSION =',F5.1)
---
>      & '  MEAN CLOUD VELOCITY (KM/SEC) =',F5.1,'  DISPERSION =',F5.1)
28c45
< *       Set cloud parameters in scaled units.
---
> * Set cloud parameters in scaled units.
31c48
< *       Rms velocity of cluster members in km/sec.
---
> * Rms velocity of cluster members in km/sec.
33c50
< *       Velocity unit.
---
> * Velocity unit.
35c52
< *       Cloud velocity in scaled units.
---
> * Cloud velocity in scaled units.
37c54
< *       Specify conservative cloud integration step using crossing time.
---
> * Specify conservative cloud integration step using crossing time.
40,44c57
< *       Adopt a quantized value.
<       CALL STEPK(STEPCL,DTN)
<       STEPCL = DTN
< *
< *       Scale radii & masses to model units.
---
> * Scale radii & masses to model units.
50,51c63,64
<       WRITE (6,102)  RB2, VCL, SIGMA, STEPCL, (CLM(J),J=1,NCL),
<      &               (RCL2(J),J=1,NCL)
---
>       WRITE (6,102) RB2, VCL, SIGMA, STEPCL, (CLM(J),J=1,NCL),
>      & (RCL2(J),J=1,NCL)
54c67
< *       Time scale for 'sun-rise' is 0.05 of the cloud crossing time.
---
> * Time scale for 'sun-rise' is 0.05 of the cloud crossing time.
57c70
< *       Define the square of cloud half-mass radii & growth times.
---
> * Define the square of cloud half-mass radii & growth times.
63c76
< *       Set square boundary radius & impact parameter.
---
> * Set square boundary radius & impact parameter.
66c79
< *       Define density centre for routine CLOUD.
---
> * Define density centre for routine CLOUD.
71c84
< *       Initialize new clouds on the boundary.
---
> * Initialize new clouds on the boundary.
76c89
<       RETURN
---
>   120 RETURN
1,2c1,2
< 2357 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/cloud.f
< nbody6compare-oct2006/cloud.f
---
> 2471 2002-08-24 22:40 /work/Umi2/spurzem/5/nbody6++compare/cloud.f
> nbody6++compare/cloud.f
13a14,15
> * recover random number sequence from COMMON variable IDUM1.
>       KDUM = IDUM1
20,21c22
< *       Note that IDUM1 is saved in COMMON6 for restarts.
<           A(K+1) = 2.0*RAN2(IDUM1) - 1.0
---
>           A(K+1) = 2.0*RAN2(KDUM) - 1.0
28,29c29,30
<       RANPHI = TWOPI*RAN2(IDUM1)
<       RANDI = SQRT(RAN2(IDUM1))
---
>       RANPHI = TWOPI*RAN2(KDUM)
>       RANDI = SQRT(RAN2(KDUM))
36c37
<       IF (KZ(13).GE.2) THEN
---
>       IF (KZ(13).NE.1.AND.KZ(13).NE.2) THEN
38,39c39,40
<               A(5) = RAN2(IDUM1)
<               A(6) = TWOPI*RAN2(IDUM1)
---
>               A(5) = RAN2(KDUM)
>               A(6) = TWOPI*RAN2(KDUM)
69a71,72
> *       Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
1,2c1,2
< 20705 2006-09-15 15:27 /work/Umi2/spurzem/5/nbody6compare-oct2006/cmbody.f
< nbody6compare-oct2006/cmbody.f
---
> 15446 2003-07-04 19:03 /work/Umi2/spurzem/5/nbody6++compare/cmbody.f
> nbody6++compare/cmbody.f
9,10c9,10
<       COMMON/RCLOSE/  RIJ(4,4),RCOLL4,QPERI4,SIZE4(4),ECOLL4,IP(4)
<       COMMON/CCOLL2/  QK(NMX4),PK(NMX4),RIK(NMX,NMX),SIZE(NMX),VSTAR1,
---
>       COMMON/CLOSE/  RIJ4(4,4),RCOLL4,QPERI4,SIZE4(4),ECOLL4,IP(4)
>       COMMON/CCOLL2/  QK(NMX4),PK(NMX4),RIK(NMX,NMX),SIZE(NMX),ASYNC,
13c13,31
<       REAL*8  CM(6),A0(3),A2(3)
---
>       REAL*8  CM(6),LUMS(10),TSCLS(20),GB(10)
>       REAL*8  M01,M02,M03,M1,M2,M3,LUM,MC1,MC2,MC3
>       SAVE KTYPE
>       INTEGER  KTYPE(0:14,0:14)
>       DATA KTYPE /1,1,1,23,24,25,25,24,24,24,313,315,315,5,5,
>      &            1,1,1,23,24,25,25,24,24,24,313,315,315,5,5,
>      &            1,1,1,23,24,25,25,24,24,24,313,315,315,5,5,
>      &            23,23,23,23,24,25,25,23,23,23,313,315,315,5,5,
>      &            24,24,24,24,24,25,25,24,24,24,313,315,315,5,5,
>      &            25,25,25,25,25,25,25,25,25,25,313,315,315,5,5,
>      &            25,25,25,25,25,25,25,25,25,25,313,315,315,5,5,
>      &            24,24,24,23,24,25,25,4,4,4,4,4,4,5,5,
>      &            24,24,24,23,24,25,25,4,4,4,4,4,4,5,5,
>      &            24,24,24,23,24,25,25,4,4,4,4,4,4,5,5,
>      &            323,323,323,323,323,323,323,4,4,4,5,5,5,5,5,
>      &            325,325,325,325,325,325,325,4,4,4,5,5,5,5,5,
>      &            325,325,325,325,325,325,325,4,4,4,5,5,5,5,5,
>      &            5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,
>      &            5,5,5,5,5,5,5,5,5,5,5,5,5,5,5/
15,17d32
<       LOGICAL FIRST
<       SAVE FIRST
<       DATA FIRST /.TRUE./
33,42c48,51
<           I = N + KSPAIR
<           DT = 0.1*STEP(I)
<           IF (DT.GT.2.4E-11) THEN
<               TIME2 = TIME - TPREV
<               CALL STEPK(DT,DTN)
<               TIME = TPREV + INT((TIME2 + DT)/DTN)*DTN
<               TIME = MIN(TBLOCK,TIME)
<           ELSE
<               TIME = MIN(T0(I) + STEP(I),TBLOCK)
<           END IF
---
>           DT2 = TIME - TPREV
>           DT8 = (TBLOCK - TPREV)/8.0D0
>           TIME = TPREV + NINT(DT2/DT8)*DT8
>           TIME = MIN(TBLOCK,TIME)
44a54,58
> *       Save binding energy and terminate KS pair.
>           EB = BODY(2*KSPAIR-1)*BODY(2*KSPAIR)*H(KSPAIR)/BODY(N+KSPAIR)
>           I = N + KSPAIR
>           JCLOSE = 0
> *
46,49c60
<           I1 = 2*KSPAIR - 1
<           I2 = I1 + 1
<           JCL = 0
<           NP1 = LIST(1,I1) + 1
---
>           NP1 = LIST(1,2*KSPAIR-1) + 1
51c62
<               J = LIST(L,I1)
---
>               J = LIST(L,2*KSPAIR-1)
55,57d65
<               A12 = 0.0
<               A22 = 0.0
<               A1A2 = 0.0
61,72c69
<                   RDOT = RDOT + (X(K,I) - X(K,J))*(XDOT(K,I) -XDOT(K,J))
<                   K1 = K + 1
<                   IF (K1.GT.3) K1 = 1
<                   K2 = K1 + 1
<                   IF (K2.GT.3) K2 = 1
<                   A0(K) = (X(K1,I1)-X(K1,I2))*(XDOT(K2,I1)-XDOT(K2,I2))
<      &                  - (X(K2,I1)-X(K2,I2))*(XDOT(K1,I1)-XDOT(K1,I2))
<                   A2(K) = (X(K1,J) - X(K1,I))*(XDOT(K2,J) - XDOT(K2,I))
<      &                  - (X(K2,J) - X(K2,I))*(XDOT(K1,J) - XDOT(K1,I))
<                   A12 = A12 + A0(K)**2
<                   A22 = A22 + A2(K)**2
<                   A1A2 = A1A2 + A0(K)*A2(K)
---
>                   RDOT = (X(K,I) - X(K,J))*(XDOT(K,I) - XDOT(K,J))
80,93c77,86
<                   ECC1 = SQRT(ECC2)
<                   RP1 = A1*(1.0 - ECC1)
<                   SEMI = -0.5*BODY(I)/H(KSPAIR)
<                   ECC = 1.0 - R(KSPAIR)/SEMI
<                   RA = SEMI*(1.0 + ECC)
<                   SR = RP1/RA
<                   GA = 2.0*BODY(J)*(RA/RP1)**3/BODY(I)
< *       Determine inclination (8 bins of 22.5 degrees).
<                   FAC = A1A2/SQRT(A12*A22)
<                   ANGLE = 360.0*ACOS(FAC)/TWOPI
<                   WRITE (6,4)  KSPAIR, NAME(J), H(KSPAIR), ECC, SEMI,
<      &                         A1, RP1, GA, ECC1, SR, ANGLE
<     4             FORMAT (' HIERARCHY:   KS NMJ H E A0 A1 RP GA E1 SR ',
<      &                    'IN',2I6,F7.0,F9.5,1P,4E9.1,0P,F6.2,F6.1,F7.1)
---
>                   RP = A1*(1.0 - SQRT(ECC2))
>                   A0 = -0.5*BODY(I)/H(KSPAIR)
>                   ECC = 1.0 - R(KSPAIR)/A0
>                   RA = A0*(1.0 + ECC)
>                   SR = RP/RA
>                   if(rank.eq.0)
>      &            WRITE (6,4)  KSPAIR, NAME(J), H(KSPAIR), ECC, A0, A1,
>      &                         RP, ECC, SR
>     4             FORMAT (' HIERARCHY:   KS NMJ H E A0 A1 RP E1 SR',
>      &                              2I6,F7.0,F8.4,1P,3E9.1,0PF6.2,F6.1)
95d87
< *
98c90
<                   IF (JCL.GT.0) THEN
---
>                   IF (JCLOSE.GT.0) THEN
100c92
<                       JCL = J
---
>                       JCLOSE = J
103c95
<                       JCL = J
---
>                       JCLOSE = J
115c107,108
<                   WRITE (6,6)  NAM1, NAM2, LISTD(K), K
---
>                   if(rank.eq.0)
>      &            WRITE (6,6)  NAM1, NAM2, LISTD(K), K
120,121c113,121
< *       Predict body #JCL to current time in case of no collision.
<           IF (JCL.GT.0) CALL XVPRED(JCL,-1)
---
> *       Update body #JCLOSE to current time for new KS with combined c.m.
>           IF (JCLOSE.GT.0) THEN
>               CALL XVPRED(JCLOSE,-1)
>               T0(JCLOSE) = TIME
>               DO 8 K = 1,3
>                   X0DOT(K,JCLOSE) = XDOT(K,JCLOSE)
>                   X0(K,JCLOSE) = X(K,JCLOSE)
>     8         CONTINUE
>           END IF
130c130,134
<               T0(I1) = TIME
---
>               T0(2*KSPAIR-1) = TIME
>           ELSE IF (KSTAR(N+KSPAIR).GT.0) THEN
>               CALL KSPERI(KSPAIR)
>               TIME = TIME0
>               T0(2*KSPAIR-1) = TIME
133c137
< *       Save collision distance and VINF before any common envelope stage.
---
> *       Save collision distance and VINF (km/sec).
139,196d142
< *       Include diagnostics for every collision/coalescence event.
<           IF (KZ(19).GE.3) THEN
<               ZM1 = BODY(I1)*ZMBAR
<               ZM2 = BODY(I2)*ZMBAR
<               R1 = RADIUS(I1)*SU
<               R2 = RADIUS(I2)*SU
<               WRITE (86,9)  TPHYS, NAME(I1), NAME(I2), KSTAR(I1),
<      &                      KSTAR(I2), ZM1, ZM2, R1, R2, RCOLL*SU, ECC
<     9         FORMAT (' COLL:    TPH NAM K* M R* QP E ',
<      &                           F8.1,2I6,2I4,2F6.2,3F7.1,F8.4)
<               CALL FLUSH(86)
<           END IF
< *
< *       Include special procedure for common envelope stage with mass loss.
<           IF (KZ(19).GE.3) THEN
<               K1 = KSTAR(I1)
<               K2 = KSTAR(I2)
<               ICASE = KTYPE(K1,K2)
<               IF(ICASE.GT.100)THEN
<                   IQCOLL = 4
<                   CALL EXPEL(I1,I2,ICASE)
<                   IF (ICASE.LT.0) GO TO 100
< *       Treat collision as before in case of CE without coalescence.
<                   ICOMP = I1
<               END IF
<           END IF
< *
< *       Update body #JCL to current time for new KS with combined c.m.
<           IF (JCL.GT.0) THEN
< *             CALL XVPRED(JCL,-1)
<               T0(JCL) = TIME
<               CALL DTCHCK(TIME,STEP(JCL),DTK(40))
<               DO 8 K = 1,3
<                   X0DOT(K,JCL) = XDOT(K,JCL)
<                   X0(K,JCL) = X(K,JCL)
<     8         CONTINUE
<           END IF
< *
< *       Check diagnostics of degenerate binary (skip case of velocity kick).
<           IF(KZ(8).GT.3.AND.MAX(KSTAR(I1),KSTAR(I2)).GE.10)THEN
<               IF(KSTAR(I1).LE.12)THEN
<                   CALL DEGEN(KSPAIR,KSPAIR,5)
<               END IF
<           END IF
< *
< *       Check optional diagnostics for final stage of binary evolution.
<           IF (KZ(8).GT.3) THEN
<               CALL BINEV(KSPAIR)
<           END IF
< *
< *       Save binding energy (BODY(I2) = 0 is OK).
<           EB = BODY(I1)*BODY(I2)*H(KSPAIR)/BODY(I)
<           WHICH1 = ' BINARY '
<           IF (H(KSPAIR).GT.0.0) THEN
<               WHICH1 = ' HYPERB '
<               NHYP = NHYP + 1
<           END IF
< *
198,202d143
<           KSTARI = KSTAR(I)
<           T0(I1) = TIME
<           SEMI = -0.5*BODY(I)/H(KSPAIR)
<           TK = DAYS*SEMI*SQRT(SEMI/BODY(I))
<           CALL DTCHCK(TIME,STEP(I1),DTK(40))
208a150
>           WHICH1 = ' BINARY '
210d151
< *       Note JLIST(1->NCH) contains global indices (JLIST(4)=0 for NCH=3).
215,217c156,157
<           IF (NSYS.GT.4) I5 = JLIST(5)
<           IQCOLL = 5
<           KSTARI = 0
---
>           I5 = JLIST(5)
> *       Ignore case of three-body system here (JLIST(4) = 0).
220,221c160,161
<           ECC = MAX(ECC,0.001D0)
<           IF (EBS.GT.0) THEN
---
>           ECC = MAX(ECC,0.0D0)
>           IF (EBS.GT.0.0) THEN
225,280d164
< *
< *       Set new quantized time (note: restore if problems in CHTERM).
< *         TIME = TBLOCK
< *
< *       Include special treatment for common envelope stage inside chain.
<           IF (ICH.GT.0.AND.KZ(19).GE.3) THEN
<               ZM1 = BODY(I1)*ZMBAR
<               ZM2 = BODY(I2)*ZMBAR
<               R1 = RADIUS(I1)*SU
<               R2 = RADIUS(I2)*SU
<               ECC = 1.0 + 2.0*EBS*DMINC/(BODY(I1)*BODY(I2))
<               ECC = MAX(ECC,0.0D0)
<               WRITE (86,9)  TPHYS, NAME(I1), NAME(I2), KSTAR(I1),
<      &                      KSTAR(I2), ZM1, ZM2, R1, R2, DMINC*SU, ECC
< *
<               K1 = KSTAR(I1)
<               K2 = KSTAR(I2)
<               ICASE = KTYPE(K1,K2)
<               IF(ICASE.GT.100)THEN
<                   IQCOLL = 6
<                   CALL EXPEL2(I1,I2,ICASE)
< *       Decide between chain restart, coalescence or collision.
<                   IF (ICASE.GT.0) THEN
< *       Adopt negative membership and reverse NSYS to denote chain restart.
<                       NCH = -NSYS
<                       NSYS = -NSYS
<                       GO TO 100
<                   END IF
< *       Check for coalescence (one or two bodies of zero mass).
<                   IF (BODY(I1).EQ.0.0D0.OR.BODY(I2).EQ.0.0D0) THEN
< *       Include rare case of two massless stars (defined by KSTAR = 15).
<                       IF (BODY(I1) + BODY(I2).EQ.0.0D0) THEN
<                           RI = SQRT(X(1,I1)**2 + X(2,I1)**2 +X(3,I1)**2)
<                           VI = SQRT(XDOT(1,I1)**2 + XDOT(2,I1)**2 +
<      &                                              XDOT(3,I1)**2)
<                           DTMAX = DTK(1)
<                           CALL DTCHCK(TIME,DTMAX,DTK(40))
<                           WRITE (6,10)  KSTAR(I1), KSTAR(I2), DTMAX
<    10                     FORMAT (' MASSLESS CM   K* DTX ',2I4,1P,E10.2)
<                           GO TO 32
<                       END IF
< *       Reduce the membership (< 0 for SETSYS) and remove ghost from chain.
<                       NCH = -(NSYS - 1)
<                       JLIST(1) = I1
<                       IF (BODY(I1).EQ.0.0D0) JLIST(1) = I2
<                       DO 11 L = 2,NSYS-1
<                           JLIST(L) = JLIST(L+1)
<    11                 CONTINUE
<                       GO TO 100
<                   END IF
< *       Treat collision as before in case of CE without coalescence.
<                   ICOMP = I1
<                   JLIST(1) = I1
<                   JLIST(2) = I2
<               END IF
<           END IF
283,289c167,168
< *       Obtain mass loss and evolution epoch of composite star.
<       DM = 0.0D0
<       IF (KZ(19).GE.3) THEN
<           CALL MIX(I1,I2,DM)
<           ICOMP = I1
< *       Note possible switching of I1 and I2 (cf. JLIST).
<       END IF
---
> *       Set new quantized time (note: restore if problems in CHTERM).
> *     TIME = TBLOCK
291c170
< *       Define global c.m. coordinates & velocities from body #I1 & I2.
---
> *       Form global c.m. coordinates & velocities from body #I1 & I2.
293c172
<       DO 12 K = 1,3
---
>       DO 10 K = 1,3
296c175
<    12 CONTINUE
---
>    10 CONTINUE
298,314c177,257
< *	Set T0 = TIME for correct potential energy correction in FCORR.
<       IF (ICH.GT.0) THEN
<           DO 14 L = 1,NCH
<               J = JLIST(L)
<               T0(J) = TIME
<               CALL DTCHCK(TIME,STEP(J),DTK(40))
<    14     CONTINUE
<       END IF
< *
< *       Ensure the heaviest body is new progenitor (only ICOMP is needed).
<       IF (BODY(I2).GT.BODY(I1)) THEN
<           I1S = I1
<           I1 = I2
<           I2 = I1S
<           ICOMP = I1
<           JCOMP = I2
<       END IF
---
> *       Change stellar evolution parameters if mass loss option is active.
>       IF (KZ(19).GE.3) THEN
>           M1 = BODY(I1)*ZMBAR
>           M2 = BODY(I2)*ZMBAR
>           RS1 = RADIUS(I1)*SU
>           RS2 = RADIUS(I2)*SU
>           TPHYS = (TIME + TOFF)*TSTAR
> *
> *       Determine evolution time scales for first star.
>           KW1 = KSTAR(I1)
>           M01 = BODY0(I1)*ZMBAR
>           AGE1 = TEV(I1)*TSTAR - EPOCH(I1)
>           CALL STAR(KW1,M01,M1,TMS1,TN,TSCLS,LUMS,GB,ZPARS)
>           CALL HRDIAG(M01,AGE1,M1,TMS1,TN,TSCLS,LUMS,GB,ZPARS,
>      &                RM,LUM,KW1,MC1,RCC)
> *       Obtain time scales for second star.
>           KW2 = KSTAR(I2)
>           M02 = BODY0(I2)*ZMBAR
>           AGE2 = TEV(I2)*TSTAR - EPOCH(I2)
>           CALL STAR(KW2,M02,M2,TMS2,TN,TSCLS,LUMS,GB,ZPARS)
>           CALL HRDIAG(M02,AGE2,M2,TMS2,TN,TSCLS,LUMS,GB,ZPARS,
>      &                RM,LUM,KW2,MC2,RCC)
> *
> *       Treat different types using collision matrix (Chris Tout 4/4/02).
>           M3 = M1 + M2
>           IF (KTYPE(KW1,KW2).EQ.1) THEN
> *       Specify new age based on complete mixing (KSTAR <= 2).
>               M03 = M01 + M02
>               KW = 1
>               CALL STAR(KW,M03,M3,TMS3,TN,TSCLS,LUMS,GB,ZPARS)
>               AGE3 = 0.1*TMS3*(AGE1*M1/TMS1 + AGE2*M2/TMS2)/M3
> *       Determine proper final type for giants.
>           ELSE IF (KTYPE(KW1,KW2)/10.EQ.2) THEN
>               KW = KTYPE(KW1,KW2) - 20
>               MC3 = MAX(MC1,MC2)
> *       Distinguish between first or second component being a white dwarf.
>           ELSE IF (KTYPE(KW1,KW2)/10.EQ.31) THEN
>               MC3 = M1
>               KW = KTYPE(KW1,KW2) - 310
>           ELSE IF (KTYPE(KW1,KW2)/10.EQ.32) THEN
>               MC3 = M2
>               KW = KTYPE(KW1,KW2) - 320
>           ELSE
> *       Define neutron star or black hole in other cases (depends on M3).
>               M03 = M3
>               KW = 13
>               AGE3 = 0.0
>           END IF
> *
> *       Obtain initial mass and age from the general evolution package.
>           IF (KTYPE(KW1,KW2).GT.20) THEN
>               AGE3 = 0.0
>               CALL GNTAGE(MC3,M3,KW,ZPARS,M03,AGE3)
> *       Note absence of mass loss (routine COMENV not included yet).
>           END IF
> *
> *       Update type, initial mass, evolution times and epoch.
>           KSTAR(I1) = KW
>           BODY0(I1) = M03/ZMBAR
>           TEV0(I1) = TIME
>           TEV(I1) = TIME + 0.001/TSTAR
>           EPOCH(I1) = TEV0(I1)*TSTAR - AGE3
> *
> *       Check for blue straggler.
>           IF (TMS3.LT.TPHYS.AND.KW.LE.1) THEN
>               NBS = NBS + 1
>           END IF
> *
>           if(rank.eq.0)
>      &    WRITE (6,15)  NAME(I1), KSTAR(I1), TEV(I1)*TSTAR, M1, M2,
>      &                  RS1, RS2, TPHYS, AGE3
>    15     FORMAT (' NEW STAR:    NAME KW TEV M1 M2 R1 R2 TP AGE ',
>      &                           I6,I4,F7.1,2F6.1,F7.1,F6.1,2F8.1)
>           TEV(I2) = 1.0E+10
>       END IF
> *
> *       Copy all members of neighbour or perturber list.
>       NNB = LIST(1,I1)
>       DO 20 L = 1,NNB
>           JPERT(L) = LIST(L+1,I1)
>    20 CONTINUE
318,322d260
< *       Copy perturber list to JPERT.
<           NNB = LIST(1,I1)
<           DO 15 L = 1,NNB
<               JPERT(L) = LIST(L+1,I1)
<    15     CONTINUE
330,335c268,276
< *       Obtain differential effect on #I1 & #I2 due to other members.
<           DO 16 L = 3,NSYS
<               JPERT(L-2) = JLIST(L)
<    16     CONTINUE
<           NP = NSYS - 2
<           CALL NBPOT(2,NP,POT1)
---
> *       Obtain differential effect on #I1 & #I2 due to closest member #I3.
>           JPERT(1) = I3
>           CALL NBPOT(2,1,POT1)
> *       Include possible fourth member.
>           IF (NSYS.GT.3) THEN
>               JPERT(1) = I4
>               CALL NBPOT(2,1,POT3)
>               POT1 = POT1 + POT3
>           END IF
339,340d279
<       ZM1 = BODY(I1)*ZMBAR
<       ZM2 = BODY(I2)*ZMBAR
342,343c281,282
<       BODY(I2) = 0.0D0
<       SPIN(I1) = (SPIN(I1) + SPIN(I2))*(1.0 - DM/ZM)
---
>       BODY(I2) = 0.0
>       LIST(1,I2) = 0
345,348c284,285
< *     STEP(I2) = 1.0D+06
<       DTMAX = DTK(1)
<       CALL DTCHCK(TIME,DTMAX,DTK(40))
<       STEP(I2) = DTMAX
---
>       STEP(I2) = 1.0D+06
>       STEPR(I2) = 1.0D+06
354c291
<       DO 20 K = 1,3
---
>       DO 30 K = 1,3
356d292
<           X0(K,I1) = CM(K)
365a302,303
>           D0(K,I2) = 0.0
>           D1(K,I2) = 0.0
368c306,310
<    20 CONTINUE
---
>           D0R(K,I2) = 0.0
>           D1R(K,I2) = 0.0
>           D2R(K,I2) = 0.0D0
>           D3R(K,I2) = 0.0D0
>    30 CONTINUE
370,371d311
< *       Refresh index of dominant body in case of switch in routine MIX.
<       JLIST(1) = I1
376c316,322
<           CALL NBPOT(1,NP,POT2)
---
>           JPERT(1) = I3
>           CALL NBPOT(1,1,POT2)
>           IF (NSYS.GT.3) THEN
>               JPERT(1) = I4
>               CALL NBPOT(1,1,POT4)
>               POT2 = POT2 + POT4
>           END IF
381,398c327,330
< *       Remove the ghost particle from perturber lists containing #I1.
<       IF (NSYS.EQ.2) THEN
<           JPERT(1) = I2
<           JLIST(1) = I2
<           CALL NBREM(I1,1,NNB)
< *       Remove ghost from list of I1 (use NTOT as dummy here).
<           JPERT(1) = I1
<           CALL NBREM(NTOT,1,1)
<       END IF
< *
< *       Include correction procedure in case of mass loss (cf routine MIX).
<       IF (KZ(19).GE.3.AND.DM.GT.0.0D0) THEN
< *
< *       Determine neighbour list for chain member.
<           IF (NSYS.GT.2) THEN
<               RSI = RSCALE*(10.0/FLOAT(N - NPAIRS))**0.3333
<               CALL NBLIST(I1,RSI)
<           END IF
---
> *       Remove the ghost particle from neighbour lists containing #I1.
>       JPERT(1) = I2
>       JLIST(1) = I2
>       CALL NBREM(I1,1,NNB)
400,434c332,334
<           NNB = LIST(1,I1)
<           ILIST(1) = NNB
<           DO 24 L = 2,NNB+1
<               ILIST(L) = LIST(L,I1)
<    24     CONTINUE
< *
< *       Reduce mass of composite body and update total mass (check SN mass).
<           BODY(I1) = ZM - DM
<           BODY(I1) = MAX(BODY(I1),0.0D0)
<           ZMASS = ZMASS - DM
< *
< *       Perform total force & energy corrections (new polynomial set later).
<           KW = KSTAR(I1)
<           CALL FCORR(I1,DM,KW)
< *
< *       Initialize new polynomials of neighbours & #I for DM > 0.1 DMSUN.
<           IF (DM*ZMBAR.GT.0.1) THEN
< *
< *       Include body #I at the end (counting from location #2; not KS case).
<               NNB2 = NNB + 2
<               ILIST(NNB2) = I1
<               IF (NSYS.EQ.2) NNB2 = NNB2 - 1
< *
< *       Obtain new F & FDOT and time-steps.
<               DO 30 L = 2,NNB2
<                   J = ILIST(L)
<                   DO 25 K = 1,3
<                       X0DOT(K,J) = XDOT(K,J)
<    25             CONTINUE
<                   CALL FPOLY1(J,J,0)
<                   CALL FPOLY2(J,J,0)
<    30         CONTINUE
<           END IF
<           TPREV = TIME - STEPX
<       END IF
---
> *       Remove ghost from list of I1 (use NTOT as dummy here).
>       JPERT(1) = I1
>       CALL NBREM(NTOT,1,1)
436,470c336,338
< *       Check creation of ghost(s) after collision of two white dwarfs.
<    32 IF (KSTAR(I1).EQ.15) THEN
<           T0(I1) = TADJ + DTADJ 
<           STEP(I1) = DTMAX
<           DO 35 K = 1,3
<               X0(K,I1) = 1000.0*RSCALE*X(K,I1)/RI
<               X(K,I1) = X0(K,I1)
<               X0DOT(K,I1) = SQRT(0.004*ZMASS/RSCALE)*XDOT(K,I2)/VI
<               XDOT(K,I1) = X0DOT(K,I1)
<               F(K,I1) = 0.0D0
<               FDOT(K,I1) = 0.0D0
<               D2(K,I1) = 0.0D0
<               D3(K,I1) = 0.0D0
<    35     CONTINUE
< *       Include case of two ghost stars.
<           IF (BODY(I2).EQ.0.0D0.AND.I1.NE.I2) THEN
<               I1 = I2
<               GO TO 32
<           END IF
< *       Perform initialization of single particle in three-body chain.
<           IF (NSYS.EQ.3) THEN
<               ICOMP = I3
< *       Make quick exit from routine CHAIN on zero membership.
<               NSYS = 0
<               NSUB = NSUB - 1
<               NCH = 0
<               ECH = 0.0
<               GO TO 40
<           END IF
< *       Include treatment for larger chain here when needed (rare case).
<           IF (NSYS.GT.3) THEN
<               WRITE (6,38)  NAME(I1)
<    38         FORMAT (' DANGER!    ZERO MASS IN CHAIN    NAME',I7)
<               STOP
<           END IF
---
> *       Replace body #I3 by spurious member (> 0) if it is an only neighbour.
>       IF (LIST(1,I1).EQ.1.AND.LIST(2,I1).EQ.I3) THEN
>           LIST(2,I1) = MIN(I1+I2+I3,N)
478c346
<       IF (JLIST(7).LT.0) THEN
---
>       IF (JLIST(6).LT.0) THEN
483a352,353
> *
> *       Obtain dominant F & FDOT on body #I1 & I3 for #I4 in FPOLY2.
484a355,356
>       CALL FCLOSE(I1,3)
>       CALL FCLOSE(I3,3)
486c358
< *       Check KS case for new regularization with close hierarchical body.
---
> *       Predict neighbour coordinates & velocities in case of KS collision.
488c360,363
<           IF (JCL.GT.0) THEN
---
>           NNB = LIST(1,ICOMP)
>           CALL XVPRED(ICOMP,NNB)
> *       Perform immediate KS regularization with close hierarchical body.
>           IF (JCLOSE.GT.0) THEN
490c365
<               JCOMP = JCL
---
>               JCOMP = JCLOSE
496c371
< *       Initialize force polynomial for new single, third or fourth body.
---
> *       Initialize force polynomial for new single or third body (ICOMP).
499,503c374,377
<       IF (NSYS.EQ.5) THEN
<           CALL FPOLY1(I5,I5,0)
<           CALL FPOLY2(I5,I5,0)
<           WRITE (6,42)  NAME(I5), STEP(I5)
<    42     FORMAT (' 5-CHAIN!    NM DT ',I7,1P,E10.2)
---
> *
> *       See whether body #ICOMP should be added to NLIST.
>       IF (T0(ICOMP) + STEP(ICOMP).LT.TLIST) THEN
>           CALL NLMOD(ICOMP,1)
505,506c379
<       IF (NSYS.EQ.0) GO TO 95
<       IF (NSYS.LE.2) GO TO 80
---
>       IF (NSYS.EQ.2) GO TO 80
508c381
< *       Add kinetic energy from last body and check DMIN in TRIPLE or QUAD.
---
> *       Check chain parameters or DMIN in TRIPLE or QUAD.
510a384
>           RCOLL = DMINC
522d395
<           I = I3
526d398
<           EB = EBS
528d399
<           I = I4
532d402
<           EB = EBS
534a405,426
> *       Obtain binding energy of the subsystem (ignore ghost).
>       ZKE = 0.0D0
>       POTS = 0.0D0
>       DO 60 L = 1,NSYS
>           I = JLIST(L)
>           ZKE = ZKE + BODY(I)*(XDOT(1,I)**2 + XDOT(2,I)**2 +
>      &                                        XDOT(3,I)**2)
>    60 CONTINUE
> *
>       DO 70 L = 1,NSYS-1
>           DO 65 LL = L+1,NSYS
>               I = JLIST(L)
>               J = JLIST(LL)
>               RIJ2 = (X(1,I) - X(1,J))**2 + (X(2,I) - X(2,J))**2 +
>      &                                      (X(3,I) - X(3,J))**2
>               POTS = POTS + BODY(I)*BODY(J)/SQRT(RIJ2)
>    65     CONTINUE
>    70 CONTINUE
> *
> *       Form net energy correction for triple or quad case.
>       EB = ENERGY - (0.5D0*ZKE - POTS)
> *
544,579c436
<       E(10) = E(10) + EB + DP
< *
< *       Open the second coalescence unit #26 first time.
<       IF (FIRST.AND.(IQCOLL.EQ.3.OR.KSTARI.GE.10)) THEN
<           OPEN (UNIT=26,STATUS='NEW',FORM='FORMATTED',FILE='COAL2')
<           FIRST = .FALSE.
< *
< *       Print cluster scaling parameters at start of the run.
<           WRITE (26,82)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
<      &                   NBIN0, NZERO
<    82     FORMAT (/,6X,'MODEL:    RBAR =',F5.1,'  <M> =',F6.2,
<      &                 '  M1 =',F6.1,'  TSCALE =',F6.2,
<      &                 '  NB =',I4,'  N0 =',I6,//)
< *
<           WRITE (26,84)
<    84     FORMAT ('   TIME  NAME  NAME  K1  K2  IQ  M1   M2',
<      &            '   DM    R1     R2    r/Rc   R     P',/)
<       END IF
< *
< *       Distinguish case of contact binary (i.e. coalescence).
<       IF (IQCOLL.EQ.3.OR.KSTARI.GE.10) THEN
<           NPOP(8) = NPOP(8) + 1
<           NCOAL = NCOAL + 1
<           WRITE (6,85)  IQCOLL, NAME1, NAME2, ZM*SMU, RCOLL, EB, DP, ECC
<    85     FORMAT (/,' BINARY COAL    IQCOLL =',I3,'  NAME =',2I6,
<      &             '  M =',F6.2,'  RCOLL =',1P,E8.1,' EB =',E9.1,
<      &             '  DP =',E9.1,'  E =',0P,F8.4)
< *
<           WRITE (26,86)  TTOT, NAME1, NAME2, KSTAR(I1), KSTAR(I2),
<      &                   IQCOLL, ZM1, ZM2, DM*ZMBAR, R1, R2, RI/RC,
<      &                   RCOLL*SU, TK
<    86     FORMAT (1X,F6.1,2I6,3I4,3F5.1,2F7.2,F6.2,F7.2,1P,E9.1)
<           CALL FLUSH(26)
<           GO TO 95
<       END IF
< *
---
>       E(10) = E(10) + EB
583,584c440,445
<       WRITE (6,90)  WHICH1, NSYS, NAME1, NAME2, ZM*SMU, RCOLL, EB,
<      &              VINF, ECC, DP
---
> *       Set IPHASE < 0 to ensure updating of time-step sequence.
>       IPHASE = -1
> *
>       if(rank.eq.0)
>      &WRITE (6,90)  WHICH1, NSYS, NAME1, NAME2, ZM, RCOLL, EB, VINF,
>      &              ECC, DP
586c447
<      &             '  M =',F6.2,'  RCOLL =',1P,E8.1,'  EB =',E9.1,
---
>      &             '  M =',F7.4,'  RCOLL =',1P,E8.1,'  EB =',E9.1,
589,598d449
< *       Specify IPHASE < 0 for new sorting.
<    95 IPHASE = -1
< *
< *       Reduce NSUB for chain (temporary increase by CHINIT before CHTERM).
<   100 IF (ICH.GT.0) THEN
<           NSUB = NSUB - 1
<       END IF
< *       Skip NSUB reduction for continuation of CHAIN (bug fix 26/8/06).
<   110 TTOT = TIME + TOFF
< *
601a453,454
> 
> 
1,2c1,2
< 3313 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/cmcorr.f
< nbody6compare-oct2006/cmcorr.f
---
> 3140 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/cmcorr.f
> nbody6++compare/cmcorr.f
53c53
<       IF (KZ(14).GT.0.AND.KZ(14).LE.2) THEN
---
>       IF (KZ(14).GT.0) THEN
55,56d54
< *       Skip ghosts to avoid spurious prediction inside 1.0E+10.
<               IF (BODY(I).EQ.0.0D0) GO TO 60
63d60
<                   FRDOT(K,I) = FRDOT(K,I) - DD
1,2c1,2
< 4603 2005-05-11 23:58 /work/Umi2/spurzem/5/nbody6compare-oct2006/cmfirr.f
< nbody6compare-oct2006/cmfirr.f
---
> 3827 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/cmfirr.f
> nbody6++compare/cmfirr.f
10,11c10
< *
< *       Initialize the perturbing force & first derivative.
---
> *       Initialize the perturbing force & derivative.
17d15
< *       Set individual KS components and indicators for unresolved pair.
20a19
> *       Define indicator for summing over each KS component rather than c.m.
21a21
>       RPERT2 = CMSEP2*R(IPAIR)**2
23,28c23
< *       Specify perturber indices for decision-making.
<       NP = LIST(1,I1)
<       LP = 2
<       JP = LIST(2,I1)
< *
< *       Perform irregular force loop for perturbed c.m.
---
> *       Force loop treats case I > N and any other c.m. neighbours.
32,48c27,36
< *       Advance lower perturber index (includes possible old neighbour).
<     2     IF (K.GT.JP.AND.LP.LE.NP) THEN
<               LP = LP + 1
<               JP = LIST(LP,I1)
< *       Include rare case of two consecutive previous neighbours.
<               GO TO 2
<           END IF
< *
< *       Distinguish between nearby perturber and more distant neighbour.
<           IF (K.NE.JP) THEN
<               IF (K.LE.N) GO TO 10
< *       Check c.m. approximation (point-mass assumption OK for #I).
<               A1 = X(1,K) - XI(1)
<               A2 = X(2,K) - XI(2)
<               A3 = X(3,K) - XI(3)
<               RIJ2 = A1*A1 + A2*A2 + A3*A3
<               IF (RIJ2.GT.CMSEP2*R(K-N)**2) GO TO 10
---
>           A1 = X(1,K) - XI(1)
>           A2 = X(2,K) - XI(2)
>           A3 = X(3,K) - XI(3)
>           RIJ2 = A1*A1 + A2*A2 + A3*A3
> *
> *       Decide appropriate summation (c.m. approximation or components).
>           IF (K.LE.N) THEN
>               IF (RIJ2.GT.RPERT2) GO TO 10
>               GO TO 3
>           ELSE IF (RIJ2.LT.CMSEP2*R(K-N)**2) THEN
50,65c38,41
<               IF (LIST(1,KDUM).EQ.0) GO TO 10
<               K = KDUM
<               GO TO 10
< *       Consider more carefully the case of identified perturber.
<           ELSE
< *       Determine next perturber index (if any).
<               IF (LP.LE.NP) THEN
<                   LP = LP + 1
<                   JP = LIST(LP,I1)
<               END IF
< *       Specify first KS component if #JP is perturbed c.m.
<               IF (K.GT.N) THEN
<                   KDUM = 2*(K - N) - 1
<                   IF (LIST(1,KDUM).GT.0) THEN
<                       K = KDUM
<                   END IF
---
>               IF (LIST(1,KDUM).EQ.0) THEN
>                   KDUM = 0
>               ELSE
>                   K = KDUM
68a45,47
> *       Check c.m. approximation for current pair.
>           IF (RIJ2.GT.RPERT2) GO TO 10
> *
70c49
<           IFP = 1
---
>     3     IFP = 1
134d112
<    
1,2c1,2
< 9380 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/cmfreg.f
< nbody6compare-oct2006/cmfreg.f
---
> 7829 2001-08-27 15:09 /work/Umi2/spurzem/5/nbody6++compare/cmfreg.f
> nbody6++compare/cmfreg.f
11,12c11
< *       Set non-zero indicator for perturbed c.m.
<       NP = 0
---
> *       Adopt accurate force for perturbed c.m. particle.
15c14,18
<           IF (LIST(1,2*IPAIR-1).GT.0) NP = 1
---
>           I2 = 2*IPAIR
>           I1 = I2 - 1
>           RPERT2 = CMSEP2*R(IPAIR)**2
>           BODYIN = 1.0/BODY(I)
>           IF (GAMMA(IPAIR).GE.GMIN) GO TO 10
18,19d20
< *       Prepare case of single particle or unperturbed c.m. (second call).
<       IF (I.LE.N.OR.NP.EQ.0) THEN
21,44c22,32
<           NNB1 = NPAIRS
<           RMAX1 = 0.0
<           DO 10 LJ = 1,NNB1
<               JLIST(LJ) = N + LJ
<               RMAX1 = MAX(RMAX1,R(LJ))
<    10     CONTINUE
< *
< *       Adopt adequate square distance for c.m. approximation.
<           RCM2 = MAX(RCRIT2,CMSEP2*RMAX1**2)
< *       Define dummy indices for skipping perturber test.
<           JP = 0
<           LP = 1
<           GO TO 25
<       END IF
< *
< *       Specify variables for treatment of perturbed c.m. particle.
<       I2 = 2*IPAIR
<       I1 = I2 - 1
<       RPERT2 = CMSEP2*R(IPAIR)**2
<       BODYIN = 1.0/BODY(I)
< *       Initialize perturber list for decision-making.
<       NP = LIST(1,I1)
<       LP = 2
<       JP = LIST(2,I1)
---
>       NNB1 = NPAIRS
>       RMAX1 = 0.0
>       DO 1 LJ = 1,NNB1
>           JLIST(LJ) = N + LJ
>           RMAX1 = MAX(RMAX1,R(LJ))
>     1 CONTINUE
> *
> *       Set minimum square distance for c.m. approximation.
>       RCM2 = MAX(RCRIT2,CMSEP2*RMAX1**2)
> *       Use accurate force algorithm for J > N.
>       GO TO 30
47c35
<       RCM2 = MAX(RCRIT2,RPERT2)
---
>    10 RCM2 = MAX(RCRIT2,RPERT2)
58c46
< *       Form a list of particles for more careful consideration.
---
> *       Form a list of c.m. particles to be resolved.
77,78c65,66
< *       Begin dual purpose force loop (all RIJ2 < RCM2, J > N or I <= N).
<    25 DO 60 LJ = 1,NNB1
---
> *       Begin dual purpose force loop (all RIJ2 < RCM2 or J > N).
>    30 DO 60 LJ = 1,NNB1
87c75
< *       First see if the distance exceeds c.m. approximation limit.
---
> *       First see whether the distance exceeds c.m. approximation limit.
91c79
< *       Check whether particle #J satisfies neighbour criteria.
---
> *       Test whether particle #J satisfies neighbour criteria.
94c82
< *       Consider small step particle (may give large correction terms).
---
>           IF (JDUM.EQ.I) GO TO 60
95a84
> *       Omission of small step particle may give large correction terms.
100d88
<           IF (JDUM.EQ.I) GO TO 60
105,112c93,98
<           KCM = 1
< *
< *       Advance lower perturber index (includes possible old neighbour).
<    26     IF (LP.LE.NP.AND.J.GT.JP) THEN
<               LP = LP + 1
<               JP = LIST(LP,I1)
< *       Include rare case of two consecutive previous neighbours.
<               GO TO 26
---
>           ICM = 1
> *       Irregular force indicator in case I > N or J > N are resolved.
>           IF (J.GT.N) THEN
> *       See whether c.m. approximation applies (skip perturbed case).
>               J1 = 2*(J - N) - 1
>               IF (RIJ2.LT.CMSEP2*R(J-N)**2.AND.LIST(1,J1).GT.0) GO TO 50
115,139c101,103
< *       Decide appropriate expressions from perturber comparison.
<           IF (J.NE.JP) THEN
<               IF (J.LE.N) GO TO 30
<               IF (RIJ2.GT.CMSEP2*R(J-N)**2) GO TO 30
<               KDUM = 2*(J - N) - 1
<               IF (LIST(1,KDUM).GT.0) THEN
<                   K = KDUM
<                   J2 = K + 1
<                   GO TO 50
<               END IF
<           ELSE
< *       Treat perturbers more carefully.
<               IF (LP.LE.NP) THEN
<                   LP = LP + 1
<                   JP = LIST(LP,I1)
<               END IF
<               J2 = 0
<               IF (J.GT.N) THEN
<                   KDUM = 2*(J - N) - 1
<                   IF (LIST(1,KDUM).GT.0) THEN
<                       J = KDUM
<                       J2 = J + 1
<                   END IF
<               END IF
<               GO TO 40
---
>           IF (I.GT.N) THEN
> *       See whether c.m. force needs summation over each component.
>               IF (RIJ2.LT.RPERT2.AND.GAMMA(IPAIR).GE.GMIN) GO TO 40
142c106
<    30     DR2I = 1.0/RIJ2
---
>           DR2I = 1.0/RIJ2
154c118
< *       Obtain relevant force on c.m (KCM = 0 denotes regular force).
---
> *       Obtain relevant force on c.m (ICM = 0 denotes resolved pair).
170c134
<           IF (KCM.NE.0) THEN
---
>           IF (ICM.NE.0) THEN
189c153,154
<           IF (K.EQ.J2) GO TO 42
---
>           IF (K.EQ.J + J) GO TO 42
> *
192,193c157,166
< *       Treat c.m. approximation for #I and #K as single or composite.
<    50     A1 = X(1,K) - XI(1)
---
>    50     J = J - N
>           J2 = J + J
> *       Sum over the components (unperturbed case is OK).
>           K = J2 - 1
> *       Treat all interactions between components of two perturbed pairs.
>           IF (I.GT.N) THEN
>               IF (RIJ2.LT.RPERT2.AND.GAMMA(I-N).GT.GMIN) GO TO 42
>           END IF
> *
>    52     A1 = X(1,K) - XI(1)
205c178
<           IF (KCM.NE.0) THEN
---
>           IF (ICM.NE.0) THEN
222c195
<           IF (K.EQ.J2) GO TO 50
---
>           IF (K.EQ.J2) GO TO 52
225,249c198,203
< *       Define regular force indicator.
<    54 KCM = 0
< *       Distinguish between second and first call (I > N & I <= N, J > N)
<       IF (JP.EQ.0) THEN
< *       Note that first case is for J > N and #I single or unperturbed c.m.
<           IF (RIJ2.LT.CMSEP2*R(J-N)**2) THEN
<               J2 = 2*(J - N)
<               K = J2 - 1
<               GO TO 50
<           END IF
<       ELSE IF (J.LE.N) THEN
< *       Consider case of single #J and perturbed c.m.
<           IF (RIJ2.LT.RPERT2) THEN
<               J2 = 0
<               GO TO 40
<           END IF
<       ELSE
< *       Split final case I > N & J > N into two parts according to RPERT2.
<           IF (RIJ2.GT.RPERT2) THEN
<               IF (RIJ2.GT.CMSEP2*R(J-N)**2) THEN
<                   K = J
<                   J2 = 0
<               ELSE
<                   J2 = 2*(J - N)
<                   K = J2 - 1
---
> *       Resolve components if I > N or J > N and no c.m. approximation.
>    54     IF (J.GT.N) THEN
>               IF (RIJ2.LT.CMSEP2*R(J-N)**2) THEN
> *       Set zero indicator to denote current pair resolved for regular force.
>                   ICM = 0
>                   GO TO 50
251,256c205,209
< *       Adopt c.m. approximation for #I.
<               GO TO 50
<           ELSE
< *       See whether both c.m. bodies should be resolved.
<               IF (RIJ2.GT.CMSEP2*R(J-N)**2) THEN
<                   J2 = 0
---
>           END IF
> *
>           IF (I.GT.N) THEN
>               IF (RIJ2.LT.RPERT2) THEN
>                   ICM = 0
258,261d210
<               ELSE
<                   J2 = 2*(J - N)
<                   K = J2 - 1
<                   GO TO 42
264d212
<       END IF
279c227
< *       Check force correction due to regularized chain (same as CMFIRR).
---
> *       Check force correction due to regularized chain (G < GMIN in REGINT).
281c229
<           IF (JP.GT.0) THEN
---
>           IF (GAMMA(I-N).GT.GMIN) THEN
1,2c1,2
< 108 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/common2.h
< nbody6compare-oct2006/common2.h
---
> 108 1995-08-17 11:49 /work/Umi2/spurzem/5/nbody6++compare/common2.h
> nbody6++compare/common2.h
1,2c1,2
< 3827 2006-09-02 12:24 /work/Umi2/spurzem/5/nbody6compare-oct2006/common6.h
< nbody6compare-oct2006/common6.h
---
> 3947 2006-06-17 08:31 /work/Umi2/spurzem/5/nbody6++compare/common6.h
> nbody6++compare/common6.h
1c1
< *       common6.
---
> *       COMMON6.
6c6
<       REAL*8  MP,MP0,MPDOT
---
>       INTEGER BK
8,11c8,17
<       COMMON/NBODY/  X(3,NMAX),X0(3,NMAX),X0DOT(3,NMAX),F(3,NMAX),
<      &               FDOT(3,NMAX),BODY(NMAX),RS(NMAX),XDOT(3,NMAX),
<      &               FI(3,NMAX),D1(3,NMAX),D2(3,NMAX),D3(3,NMAX),
<      &               FR(3,NMAX),D1R(3,NMAX),D2R(3,NMAX),D3R(3,NMAX),
---
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       SAVE
>       COMMON/MPIDAT/group,rank,ierr,isize,status
> *
>       COMMON/NBODY/  X(ID,NMAX),X0(ID,NMAX),X0DOT(ID,NMAX),F(ID,NMAX),
>      &               XN(ID,NMAX),XNDOT(ID,NMAX),
>      &               FDOT(ID,NMAX),BODY(NMAX),RS(NMAX),XDOT(ID,NMAX),
>      &               FI(ID,NMAX),D1(ID,NMAX),D2(ID,NMAX),D3(ID,NMAX),
>      &               FR(ID,NMAX),D1R(ID,NMAX),D2R(ID,NMAX),D3R(ID,NMAX),
19c25
<      &               FP0(4,KMAX),FD0(4,KMAX),TBLIST,DTB,KBLIST(KMAX),
---
>      &               FP0(4,KMAX),FD0(4,KMAX),TBLIST,DTB,KBLIST(10*KMAX),
22c28
<       COMMON/NAMES/  N,NTOT,NPAIRS,NNBMAX,NCRIT,NFIX,NMERGE,NSUB,NCH,
---
>       COMMON/NAMES/  N,NTOT,NPAIRS,NNBOPT,NCRIT,NFIX,NMERGE,NSUB,NCH,
24a31
>      &               BK(10),LSHORT(NMAX),NNBMAX,
26c33
<      &               KSLOW(KMAX),NAME(NMAX),LIST(LMAX,NMAX),NCHAOS
---
>      &               KSLOW(KMAX),NLIST(NMAX),NAME(NMAX),LIST(LMAX,NMAX)
31c38
<      &               NKSTRY,NKSREG,NKSHYP,NKSPER,NPRECT,NMARG,NKSMOD,
---
>      &               NKSTRY,NKSREG,NKSHYP,NKSPER,NPRECT,NKSREF,NKSMOD,
34,35c41,42
<      &               NDUMP,NBPREV,NPOP(10),JCMAX,NEWHI,NSTEPB,NBFLUX,
<      &               NDUMMY(10)
---
>      &               NDUMP,NBPREV,NPOP(10),JCMAX,NEWHI,NBLCKR,IPE,NPES,
>      &               NSTEPB,NBFLUX,NDUMMY(8)
37c44,45
<       COMMON/PARAMS/ CPU,ETAI,ETAR,DTADJ,DELTAT,TCRIT,QE,RBAR,ZMBAR,
---
>       COMMON/PARAMS/ CPU,ETAI,ETAR,DTADJ,DELTAT,TCRIT,TCRITp,
>      &               QE,RBAR,ZMBAR,
40c48
<      &               SMIN,RMIN2,RMIN22,STEPJ,ALPHA,ZNBMIN,ZNBMAX,EBH,
---
>      &               SMIN,RMIN2,RMIN22,FCRIT2,ALPHA,ZNBMIN,ZNBMAX,EBH,
45c53
<      &               RTIDE,TSCALE,TIDAL(4),ETIDE,RSFAC,RSPH2,BETA2,
---
>      &               RTIDE,TSCALE,TIDAL(4),ETIDE,RSFAC,RSPH2,BETA,
49,50c57
<      &               TDUMP,SCOEFF(12),TOFF,TTOT,EBESC,EMESC,ESESC,
<      &               CLIGHT,RZ,DUMMY
---
>      &               TDUMP,SCOEFF(12),TOFF,TTOT,DUMMY
55c62
<      &               XHYD,YHEL,ZMET,ZPARS(20),SPNFAC,
---
>      &               XHYD,YHEL,ZMET,ZPARS(20),
57,64c64,65
<      &               EPOCH(NMAX),SPIN(NMAX),XSTAR(NMAX),ZLMSTY(NMAX),
<      &               IQCOLL,NAS,NBH,NBKICK,NBR,NBRK,NBS,NCHA,NCIRC,
<      &               NCOAL,NCONT,NDD,NEMOD,NGB,NGLOB,NGLOB0,NHE,NHG,NHI,
<      &               NHYP,NKICK,NMDOT,NMS,NNH,NRG,NRO,NROCHE,NRS,NRSAVE, 
<      &               NSHOCK,NSLP,NSN,NSP,NSPIR,NSTAB,NTZ,NWD,
<      &               ITYPE(5),KSAVE(4),KSTAR(NMAX),
<      &               KTYPE(0:14,0:14),NEINT,IBLUE,NGDUM(8),
<      &               ITAIL0,NTAIL,NTTOT,NSTAIL,N1
---
>      &               EPOCH(NMAX),NMDOT,NRG,NHE,NRS,NWD,NNH,NSN,NBS,NTZ,
>      &               NBH,NKICK,NBKICK,KSAVE(2),ITYPE(10),KSTAR(NMAX)
66c67,68
<       COMMON/PLPOT/  MP,AP2,VIR,MP0,MPDOT,TDELAY,RTIDE0,QVIR,PLDUM(4)
---
>       COMMON/HERMIT/ FIDOT(ID,NMAX),D0(ID,NMAX),FRDOT(ID,NMAX),
>      &               D0R(ID,NMAX),TIMENW(NMAX)
68,70c70
<       COMMON/HERMIT/ FIDOT(3,NMAX),D0(3,NMAX),FRDOT(3,NMAX),D0R(3,NMAX)
< *
<       COMMON/BLOCKS/ TPREV,TBLOCK,DTK(40),TIMENW(NMAX)
---
>       COMMON/BLOCKS/ TPREV,TBLOCK,DTK(64)
72a73,80
> *        Common block to keep neighbour density and potential high prec (R.Sp.)
>       COMMON/WORK2/RHO(NMAX),XNDBL(NMAX),PHIDBL(NMAX)
> *
>       COMMON/TIMING/ttota,ttreg,ttirr,ttpre,ttinit,ttint,ttks,
>      *  ttcomm,ttadj,ttmov,ttnbp,ttsub,ttsub2,ttfrc,xtsub1,xtsub2,
>      *  isernb,iserreg
> 
> 
1,2c1,2
< 414 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/commonc.h
< nbody6compare-oct2006/commonc.h
---
> 414 1995-08-17 11:49 /work/Umi2/spurzem/5/nbody6++compare/commonc.h
> nbody6++compare/commonc.h
1,2c1,2
< 982 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/const.f
< nbody6compare-oct2006/const.f
---
> 982 2005-03-09 22:59 /work/Umi2/spurzem/5/nbody6++compare/const.f
> nbody6++compare/const.f
1,2c1,2
< 4786 2006-02-05 18:15 /work/Umi2/spurzem/5/nbody6compare-oct2006/core.f
< nbody6compare-oct2006/core.f
---
> 4837 2002-02-26 15:37 /work/Umi2/spurzem/5/nbody6++compare/core.f
> nbody6++compare/core.f
9c9
<       COMMON/WORK1/  RHO(NMAX)
---
>       DATA RHOM/1.0D0/
16a17
> *       Initialize neighbour densities of all singles and c.m.
18a20
>           RHO(I) = 0.D0
26a29
> 
37c40
< *       Skip and set density to zero if there are no neighbours.
---
> *       Skip and set density to zero of there are no neighbours
39,41c42,43
<               RHO(I) = 0.0
<               GO TO 50
<           END IF 
---
>           RHO(I) = 0.0D0
>           ELSE
87,89c89,96
<           RHO(I) = XMASS/(RLIST(I6)*SQRT(RLIST(I6)))
< *       Define particle number density (not used).
< *         RHON = RHO(I)/ZMASS
---
>           IF (RLIST(I6).GT.0.0D0) THEN
>               RINV32 = 1.0D0/(RLIST(I6)*SQRT(RLIST(I6)))
>           ELSE
>               RINV32 = 0.0D0
>           END IF
>           RHO(I) = XMASS*RINV32
> *       For multi-mass store also five neighbour particle density
>           XNDBL(I) = RINV32
92a100
>           END IF
113,116d120
< *       Ignore density centre for Plummer binary models except at end.
<           IF (KZ(5).EQ.2.AND.TTOT.LT.TCRIT) THEN
<               RDENS(K) = 0.0
<           END IF
1,2c1,2
< 639 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/cputim.f
< nbody6compare-oct2006/cputim.f
---
> 535 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/cputim.f
> nbody6++compare/cputim.f
0a1,4
> # 1 "cputim.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "cputim.F"
4,5c8,9
< *       CPU time.
< *       ---------
---
> * CPU time.
> * ---------
7c11,12
<       REAL*8  TCOMP
---
>       INCLUDE 'common6.h'
>       REAL*8 TCOMP
9c14
<       REAL*4  TARRAY(2)
---
>       REAL*4 tt,TARRAY(2),etime
11,21c16,19
< *
< *       Initialize timer (first call) or obtain elapsed time.
<       IF (ICPU.EQ.0) THEN
< *         CALL LIB$INIT_TIMER
<           TCOMP = 0.0
< *         TCOMP = ETIME(TARRAY)
< *         TCOMP = MCLOCK()/6000.
<           ICPU = 1
<       ELSE
< *         CALL LIB$STAT_TIMER(2,ITIME)
< *         TCOMP = FLOAT(ITIME)/6000.0
---
> * Initialize timer (first call) or obtain elapsed time.
> * TCOMP = FLOAT(ITIME)/6000.0
> * TCOMP = REAL(IRTC())*6.67D-9/60.
> # 29 "cputim.F"
23,25c21,24
< *         TCOMP = MCLOCK()/6000.
< *       Elapsed CPU time in minutes on VAX, SUN or MIPS & IBM RS/6000.
<       END IF
---
> 
> * TCOMP = MCLOCK()/6000.
> * Elapsed CPU time in minutes on VAX, SUN or MIPS & IBM RS/6000.
> * and T3D
1,2c1,2
< 3929 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/cstab2.f
< nbody6compare-oct2006/cstab2.f
---
> 4452 2005-03-09 23:00 /work/Umi2/spurzem/5/nbody6++compare/cstab2.f
> nbody6++compare/cstab2.f
12a13,15
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
77c80,81
<       PCRIT0 = stability(M(I1),M(I2),M(I3),ECC0,ECC,0.0D0)*SEMI0
---
>       XFAC0 = (1.0 + M(I3)/MB)*(1.0 + ECC)/SQRT(1.0 - ECC)
>       PCRIT0 = 2.8*XFAC0**0.4*SEMI0
91c95,105
< *       Obtain the inclination (in radians).
---
> *       Replace the EK criterion by the MA analytical stability formula.
>       Q0 = M(I4)/MB1
>       IF (ECC1.LT.1.0) THEN
>           XFAC = (1.0 + Q0)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
>       ELSE
>           XFAC = 1.0 + Q0
>       END IF
>       FE = 1.0
>       PCRIT = 2.8*FE*XFAC**0.4*SEMI
> *
> *       Obtain the inclination.
94,95c108,110
< *       Replace the EK criterion by the general stability formula.
<       PCRIT = stability(MB,M(I3),M(I4),ECC,ECC1,ALPHA)*SEMI
---
> *       Include fudge factor for inclination effect.
>       YFAC = 1.0 - 0.3*ALPHA/180.0
>       PCRIT = YFAC*PCRIT
101c116,117
<           WRITE (6,20)  ECC, ECC1, SEMI, SEMI1, PMIN, PCRIT, EK
---
>           if(rank.eq.0)then
>           WRITE (6,20)  ECC, ECC1, SEMI, SEMI1, PMIN, PCRIT, EK, YFAC
104c120
<      &                     '  EK =',E9.2)
---
>      &                     '  EK =',E9.2,'  YF =',0P,F5.2)
106a123
>           end if
109,110c126,129
<           WRITE (81,30)  TIMEC, RI, NAMEC(I3), QL, Q1, ECC, ECC1,
<      &                   SEMI, SEMI1, PCRIT/PMIN, 180.*ALPHA/3.14, EMAX
---
>           K = INAME(I3)
>           if(rank.eq.0)
>      &    WRITE (81,30)  TIMEC, RI, NAMEC(K), QL, Q1, ECC, ECC1,
>      &                   SEMI, SEMI1, PCRIT/PMIN, ALPHA, EMAX
1,2c1,2
< 4526 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/cstab3.f
< nbody6compare-oct2006/cstab3.f
---
> 4723 2005-03-09 23:02 /work/Umi2/spurzem/5/nbody6++compare/cstab3.f
> nbody6++compare/cstab3.f
11a12,14
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
87c90
<           XFAC = 40.0*(1.0 + Q0)
---
>           XFAC = 1.0 + Q0
96c99
<       YFAC = 1.0 - 0.3*ALPHA/3.14
---
>       YFAC = 1.0 - 0.3*ALPHA/180.0
113c116,117
<                   WRITE (6,19)  NSTEP1, ECC4, SEMI, PCRIT, PMIN4, G4
---
>                   if(rank.eq.0)
>      &            WRITE (6,19)  NSTEP1, ECC4, SEMI, PCRIT, PMIN4, G4
125c129,130
<           WRITE (6,20)  ECC, ECC1, SEMI, SEMI1, PMIN, PCRIT, EK, PZ
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  ECC, ECC1, SEMI, SEMI1, PMIN, PCRIT, EK, PZ
131,132c136,138
<           WRITE (81,30)  TIMEC, RI, NAMEC(I3), QL, Q1, ECC, ECC1,
<      &                   SEMI, SEMI1, PCRIT/PMIN, 180.*ALPHA/3.14, EMAX
---
>           if(rank.eq.0)
>      &    WRITE (81,30)  TIMEC, RI, NAMEC(I3), QL, Q1, ECC, ECC1,
>      &                   SEMI, SEMI1, PCRIT/PMIN, ALPHA, EMAX
139a146
> 
1,2c1,2
< 4023 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/cstab4.f
< nbody6compare-oct2006/cstab4.f
---
> 4685 2005-03-09 23:02 /work/Umi2/spurzem/5/nbody6++compare/cstab4.f
> nbody6++compare/cstab4.f
12a13,15
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
79c82,85
<       IF (SEMI.LT.0.0.OR.ECC.GT.1.0) THEN
---
>       RB0 = SQRT(RB0)
>       SEMI0 = 2.0/RB0 - VREL2/MB
>       SEMI0 = 1.0/SEMI0
>       IF (SEMI0.LT.0.0.OR.ECC.GT.1.0) THEN
83c89,91
<       PCRIT0 = stability(M(I1),M(I2),M(I3),ECC,ECC1,0.0D0)*SEMI
---
>       ECC0 = SQRT((1.0 - RB0/SEMI0)**2 + RDOT**2/(SEMI0*MB))
>       XFAC0 = (1.0 + M(I3)/MB)*(1.0 + ECC)/SQRT(1.0 - ECC)
>       PCRIT0 = 2.8*XFAC0**0.4*SEMI0
90,91c98,103
< *       Obtain the inclination.
<       CALL INCLIN(XX,VV,XCM,VCM,ALPHA)
---
> *       Form hierarchical stability ratio (Eggleton & Kiseleva 1995).
>       QL = MB/MB2
>       Q1 = MAX(M(I2)/M(I1),M(I1)/M(I2))
>       Q3 = QL**0.33333
>       Q13 = Q1**0.33333
>       AR = 1.0 + 3.7/Q3 - 2.2/(1.0 + Q3) + 1.4/Q13*(Q3 - 1.0)/(Q3 + 1.0)
93,99c105,111
< *       Use the general stability formula for the widest binary.
<       IF (SEMI.GT.SEMI2) THEN
<           PCRIT = stability(M(I1),M(I2),MB2,ECC,ECC1,ALPHA)
<           AIN = SEMI
<       ELSE IF (SEMI2.GT.0.0) THEN
<           PCRIT = stability(M(I3),M(I4),MB,0.0D0,ECC1,ALPHA)
<           AIN = SEMI2
---
>       EK = AR*SEMI*(1.0D0 + ECC)
>       PMIN = SEMI1*(1.0D0 - ECC1)
> *
> *       Replace the EK criterion by the MA analytical stability formula.
>       Q0 = MB2/MB
>       IF (ECC1.LT.1.0) THEN
>           XFAC = (1.0 + Q0)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
101,102c113
<           AIN = 0.0
<           PCRIT = 0.0
---
>           XFAC = 1.0 + Q0
104c115,124
<       PCRIT = PCRIT*(1.0 + 0.1*ABS(SEMI/SEMI2))*AIN
---
>       FE = 1.0
>       PCRIT = 2.8*FE*XFAC**0.4*SEMI
>       PCRIT = PCRIT*(1.0 + 0.1*ABS(SEMI2/SEMI))
> *
> *       Obtain the inclination.
>       CALL INCLIN(XX,VV,XCM,VCM,ALPHA)
> *
> *       Include fudge factor for inclination effect.
>       YFAC = 1.0 - 0.3*ALPHA/180.0
>       PCRIT = YFAC*PCRIT
108,110c128
<       PMIN = SEMI1*(1.0D0 - ECC1)
<       IF (PMIN.GT.PCRIT.AND.AIN.GT.0.0.AND.SEMI1.GT.0.0.AND.
<      &    RB.GT.SEMI) THEN
---
>       IF (PMIN.GT.PCRIT.AND.SEMI.GT.0.0.AND.SEMI1.GT.0.0) THEN
112,113c130,131
<           ALPHA = 180.0*ALPHA/3.14
<           WRITE (6,20)  ECC, ECC1, SEMI, SEMI1, PMIN, PCRIT, ALPHA
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  ECC, ECC1, SEMI, SEMI1, PMIN, PCRIT, EK, ALPHA
116c134
<      &                     '  PC =',E9.2,'  IN =',0P,F6.1)
---
>      &                     '  PC =',E9.2,'  EK =',E9.2,'  IN =',0P,F6.1)
119,121c137,141
<           WRITE (81,30)  TIMEC, RI, NAMEC(I3), ECC, ECC1, SEMI, SEMI1,
<      &                   PCRIT/PMIN, ALPHA, EMAX
<    30     FORMAT (F9.5,F5.1,I6,2F6.3,1P,2E10.2,0P,F5.2,F6.1,F6.3)
---
>           K = INAME(I3)
>           if(rank.eq.0)
>      &    WRITE (81,30)  TIMEC, RI, NAMEC(K), QL, Q1, ECC, ECC1,
>      &                   SEMI, SEMI1, PCRIT/PMIN, ALPHA, EMAX
>    30     FORMAT (F9.5,F5.1,I6,2F6.2,2F6.3,1P,2E10.2,0P,F5.2,F6.1,F6.3)
1,2c1,2
< 7191 2005-04-01 15:37 /work/Umi2/spurzem/5/nbody6compare-oct2006/cstab5.f
< nbody6compare-oct2006/cstab5.f
---
> 6323 2005-03-09 23:02 /work/Umi2/spurzem/5/nbody6++compare/cstab5.f
> nbody6++compare/cstab5.f
8a9
>       COMMON/CHREG/  TIMEC,TMAX,RMAXC,CM(10),NAMEC(6),NSTEP1,KZ27,KZ30
10,11c11,15
<      &        XCM2(3),VCM2(3),XB(3),VB(3),M1,M2,M3
<       INTEGER  IJ(NMX),ISORT(NMX)
---
>      &        XCM2(3),VCM2(3),XB(3),VB(3)
>       INTEGER  IJ(NMX)
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
15,16c19
<       IR = 0
<       DO 1 I = 1,N-2
---
>       DO 5 I = 1,N-2
17a21
>           IR = 0
21c25
<     1 CONTINUE
---
>     5 CONTINUE
23,26c27,31
< *       Exit on at least one unfavourable distance ratio.
<       IF (IR.GT.0) THEN
< *         WRITE (6,2)  I, (1.0/RINV(K),K=1,N-1)
< *   2     FORMAT (' CSTAB5 TEST    I R ',I4,1P,5E9.1)
---
> *       Exit if more than one small distance ratio.
>       IF (IR.GT.1) THEN
> *         if(rank.eq.0)
> *    &    WRITE (6,2)  NSTEP1, I, (1.0/RINV(K),K=1,N-1)
> *   2     FORMAT (' CSTAB5 TEST    # I R ',I6,I4,1P,5E9.1)
38,43d42
<       CALL HPSORT(N-1,RINV,ISORT)
<       IB2 = ISORT(2)
<       IB3 = ISORT(3)
<       RATIO = RINV(IB3)/RINV(IB2)
<       IF (RATIO.GT.0.25.AND.RATIO.LT.4.0) GO TO 40
< *
52,84c51
<       I5 = 0
<       IF (N.EQ.2) THEN
<           I3 = I2
<           I4 = I1
<       ELSE IF (N.EQ.3) THEN
<           I4 = I1
< *       Note N = 4 is already defined correctly (but redundant here).
<       ELSE IF (N.GT.4) THEN
< *       Determine indices of second closest pair (avoid pair I1-I2).
<           RX1 = 1.0
<           RX0 = R2(I1,I2)
<           DO 5 J1 = 1,N
<               IF (J1.EQ.I1.OR.J1.EQ.I2) GO TO 5
<               DO 4 J2 = J1+1,N
<                   IF (J2.EQ.I1.OR.J2.EQ.I2) GO TO 4
<                   IF (R2(J1,J2).LT.RX1.AND.R2(J1,J2).GT.RX0) THEN
<                       RX1 = R2(J1,J2)
<                       I3 = J1
<                       I4 = J2
<                   END IF
<     4         CONTINUE
<     5     CONTINUE
< *       Identify remaining single particle(s) by exclusion.
<           DO 8 I = 1,N
<               IF (I.EQ.I1.OR.I.EQ.I2.OR.I.EQ.I3.OR.I.EQ.I4) GO TO 8
<               IF (I5.EQ.0) THEN
<                   I5 = I
<               ELSE 
<                   I6 = I
<               END IF
<     8     CONTINUE
<       END IF
< *
---
>       I5 = IJ(5)
127,130c94
< *         Q0 = M5/(MB + MB2)
<           M1 = MB
<           M2 = MB2
<           M3 = M5
---
>           Q0 = M5/(MB + MB2)
147,150c111
< *         Q0 = MB2/(MB + M5)
<           M1 = MB
<           M2 = M5
<           M3 = MB2
---
>           Q0 = MB2/(MB + M5)
167,170c128
< *         Q0 = MB/(MB2 + M5)
<           M1 = MB2
<           M2 = M5
<           M3 = MB
---
>           Q0 = MB/(MB2 + M5)
202a161,171
>       PMIN = SEMI1*(1.0D0 - ECC1)
> *
> *       Evaluate the MA analytical stability formula.
>       IF (ECC1.LT.1.0) THEN
>           XFAC = (1.0 + Q0)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
>       ELSE
>           XFAC = 1.0 + Q0
>       END IF
>       FE = 1.0
>       PCRIT = 2.8*FE*XFAC**0.4*SEMI
> *
206,207c175,176
< *       Employ the general stability criterion.
<       PCRIT = stability(M1,M2,M3,ECC0,ECC1,ALPHA)*SEMI
---
> *       Include fudge factor for inclination effect.
>       YFAC = 1.0 - 0.3*ALPHA/180.0
210c179,180
<       IF (SEMI2.GT.0.0) PCRIT = (1.0 + 0.1*SEMI2/SEMI)*PCRIT
---
>       IF (SEMI2.GT.0.0) YFAC = (1.0 + 0.1*SEMI2/SEMI)*YFAC
>       PCRIT = YFAC*PCRIT
213d182
<       PMIN = SEMI1*(1.0D0 - ECC1)
216c185
<      &    RB0.GT.SEMI0.AND.SEMI2.GT.0.0) THEN
---
>      &    RB0.GT.SEMI0) THEN
218,219c187,189
<           WRITE (6,20)  ECC0, ECC1, SEMI, SEMI1, PMIN, PCRIT, SEMI2,
<      &                  180.0*ALPHA/3.14
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  ECC0, ECC1, SEMI, SEMI1, PMIN, PCRIT, SEMI2,
>      &                  ALPHA
227a198
> 
1,2c1,2
< 2772 2006-09-15 16:03 /work/Umi2/spurzem/5/nbody6compare-oct2006/data.f
< nbody6compare-oct2006/data.f
---
> 4144 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/data.f
> nbody6++compare/data.f
0a1,4
> # 1 "data.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "data.F"
4,5c8,9
< *       Initial conditions.
< *       -------------------
---
> * Initial conditions.
> * -------------------
8c12,14
<       REAL*4  RAN2
---
>       REAL*8 A(8)
>       CHARACTER*1 CHAR(80)
>       LOGICAL LREADN,LREADP,LREADF
9a16
> # 21 "data.F"
11,34c18,24
< *       Initialize the portable random number generator (range: 0 to 1).
<       KDUM = -1
<       RN1 = RAN2(KDUM)
< *       Skip the first random numbers (IDUM1 specified at input).
<       DO 1 K = 1,IDUM1
<           RN1 = RAN2(KDUM)
<     1 CONTINUE
< *
< *       Save random number sequence in COMMON for future use.
<       IDUM1 = KDUM
< *
< *       Read IMF parameters, # primordials, Z-abundance, epoch & HR interval.
<       READ (5,*)  ALPHA, BODY1, BODYN, NBIN0, NHI0, ZMET, EPOCH0, DTPLOT
<       IF (ZMET.LE.0.0D0) ZMET = 1.0D-04
<       IF (ZMET.GT.0.03) ZMET = 0.03
<       IF (KZ(12).GT.0) DTPLOT = MAX(DTPLOT,DELTAT)
< *
<       CALL zcnsts(ZMET,ZPARS)
<       WRITE (6,4)  ZPARS(11), ZPARS(12), ZMET
<     4 FORMAT (//,12X,'ABUNDANCES:  X =',F6.3,'  Y =',F6.3,'  Z =',F6.3)
< *
< *       Check option for reading initial conditions from input file.
<       IF (KZ(22).GE.2) THEN
<           ZMASS = 0.0
---
> * Set provisional total mass (rescaled in routine SCALE).
>       ZMASS = FLOAT(N)
> *
> * Check option for reading initial conditions from input file.
>       if(rank.eq.0)then
> *
>       IF (KZ(22).EQ.2.OR.KZ(22).EQ.6) THEN
36,40c26,31
<               READ (10,*)  BODY(I), (X(K,I),K=1,3), (XDOT(K,I),K=1,3)
<               ZMASS = ZMASS + BODY(I)
<     5     CONTINUE
< *       Include possibility of retaining the mass distribution.
<           IF (KZ(22).GT.2) GO TO 40
---
>               READ (10,*) BODY(I), (X(K,I),K=1,3), (XDOT(K,I),K=1,3)
>     5 CONTINUE
> * Read tidal radius if cutoff required
>       IF (KZ(23).GE.3) READ (10,*) RTIDE
>           PRINT*,' rank ',rank,N,' body data read from unit 10 ',
>      * ' RTIDE =',RTIDE
41a33,88
> * End reading NBODY input data format.
> *
> * Read TREE input format
>       IF (KZ(22).EQ.3.OR.KZ(22).EQ.7) THEN
>           READ(10,*) N
>           READ(10,*) DUMDY
>           READ(10,*) DUMDY
>           PRINT*,' N=',N
>           DO 51 I = 1,N
>           READ(10,*)BODY(I)
>    51 CONTINUE
>           PRINT*,' masses read ',BODY(1),BODY(N)
>           DO 52 I = 1,N
>    52 READ(10,*)(X(K,I),K=1,3)
>           DO 53 I = 1,N
>    53 READ(10,*)(XDOT(K,I),K=1,3)
>           NTOT = N
>           PRINT*,' rank ',rank,N,' body data read from unit 10 '
>           CALL FLUSH(6)
>       END IF
> * End read TREE input format
> * Read STARLAB input format
>       IF (KZ(22).EQ.4.OR.KZ(22).EQ.8) THEN
>           I = 0
>           IS = 0
>           LREADF = .FALSE.
>           LREADP = .FALSE.
>   61 CONTINUE
>           READ(10,'(2A1)')(CHAR(K),K=1,2)
> *
>           LREADN=(.NOT.LREADF).AND.CHAR(1).EQ.'('.AND.CHAR(2).EQ.'P'
>           IF(LREADN)THEN
>           LREADF=.TRUE.
>           READ(10,111)N
>           PRINT*,' Read N=',N
>           NTOT = N
>           END IF
> *
>           LREADP=CHAR(1).EQ.'('.AND.CHAR(2).EQ.'D'
>           IF(LREADP.AND.IS.EQ.0)THEN
>           IS = 1
>           ELSE
>           IF(LREADP)THEN
>           I = I + 1
>           READ(10,*)CHAR(1),CHAR(2),BODY(I)
>           READ(10,*)CHAR(1),CHAR(2),(X(K,I),K=1,3)
>           READ(10,*)CHAR(1),CHAR(2),(XDOT(K,I),K=1,3)
>           END IF
>           END IF
>           IF(I.LT.N)GO TO 61
>           PRINT*,N,' Particles read from Starlab File'
>  111 FORMAT(5X,I5)
>       END IF
> *
>       end if
> # 101 "data.F"
43c90,99
< *       Include the case of equal masses (ALPHA = 1 or BODY1 = BODYN).
---
> * Read mass function parameters, # primordials, Z-abundance & epoch.
> * And plot interval for HR diagram.
>        if(rank.eq.0)then
>        READ (5,*) ALPHA, BODY1, BODYN, NBIN0, ZMET, EPOCH0,DTPLOT
>        end if
> # 116 "data.F"
> *
>       IF(KZ(22).GE.2)GO TO 50
> *
> * Include the case of equal masses (ALPHA = 1 or BODY1 = BODYN).
47,50c103,104
<    10     CONTINUE
< *       Set provisional total mass (rescaled in routine SCALE).
<           ZMASS = FLOAT(N)
<           GO TO 40
---
>    10 CONTINUE
>           IF (KZ(20).NE.6) GO TO 40
53c107
< *       Choose between two realistic IMF's and standard Salpeter function.
---
> * Choose between two realistic IMFs and standard Salpeter function.
60a115,116
> * Metallicity should be set to minimum value.
>       IF(ZMET.EQ.0.D0) ZMET = 1.D-4
62,66c118
<       WRITE (6,15)  ALPHA, BODY1, BODYN
<    15 FORMAT (/,12X,'STANDARD IMF    ALPHA =',F5.2,
<      &              '  BODY1 =',F5.1,'  BODYN =',F5.2)
< *
< *       Generate a power-law mass function with exponent ALPHA.
---
> * Generate a power-law mass function with exponent ALPHA.
73c125
< *       Assign individual masses sequentially.
---
> * Assign individual masses sequentially.
80c132,139
< *       Scale the masses to <M> = 1 for now and set consistent total mass.
---
>       if(rank.eq.0)then
>       WRITE (6,15) ALPHA, BODY1, BODYN, ZMASS, NBIN0, ZMET, EPOCH0
>    15 FORMAT (/,12X,'STANDARD IMF    ALPHA =',F5.2,
>      & '  BODY1 =',F5.1,'  BODYN =',F5.2,' ZMASS =',1P,E12.5,0P,
>      & ' NBIN0=',I5,' ZMET =',F5.2,' EPOCH0 =',F5.2)
>       end if
> *
> * Scale the masses to <M> = 1 for now and set consistent total mass.
87c146
< *       Set up initial coordinates & velocities (uniform or Plummer model).
---
> * Set up initial coordinates & velocities (uniform or Plummer model).
91a151,152
>    50 CONTINUE
> *
1,2c1,2
< 14687 2006-09-09 17:04 /work/Umi2/spurzem/5/nbody6compare-oct2006/define.f
< nbody6compare-oct2006/define.f
---
> 14336 2005-03-09 14:56 /work/Umi2/spurzem/5/nbody6++compare/define.f
> nbody6++compare/define.f
4c4
< *       Definition of input parameters, options & counters.
---
> *       Definition of input parameters, options & counters. (NB6++)
6a7,8
> * ********** NOTE: Contents of [] to be removed with time.*************
> * ********** Not read by nb6++                            *************
12,14d13
< ***
< * NBODY6:
< *
17,20c16,24
< ***
< * INPUT:
< *
< *       N       Total particle number (singles + binary c.m.; < NMAX - 2).
---
> *       TCRITp  Termination time in Myrs.
> *       isernb  Max size of sequential irr blocks on parallel machine 
> *               for single CPU dummy
> *       iserreg as isernb for reg blocks
> *               for single CPU dummy
> *--------
> *       N       Total number of centre of masses (<NMAX - 2).
> *               e.g: N=100 binaries = NBIN0=NBIN below for f=1
> *                    N=100, and NBIN0=NBIN=50 for f=0.5
23,24c27,29
< *       NRAND   Random number sequence skip.
< *       NNBMAX  Maximum number of neighbours (< LMAX - 2).
---
> *       NRAND   Random number seed; any positive integer
> *               [ NNBMAX  Maximum neighb.numb. (= MIN(N/2,LMAX-3) set in input.F].
> *       NNBOPT  Desired optimal neighbour number (R.Sp.)
26c31
< *
---
> *--------
30,32c35,39
< *       DTADJ   Time interval for parameter adjustment (N-body units).
< *       DELTAT  Output time interval (N-body units).
< *       TCRIT   Termination time (N-body units).
---
> *       DTADJ   Time interval for parameter adjustment.
> *       DELTAT  Output time interval.
> *->             NFIX=1 and DTADJ=DELTAT => OUT3 written every adjust time
> *       TCRIT   Termination time.
> *->             The _earlier_ termination criterion becomes active
34c41
< *       RBAR    Virial cluster radius in pc (set = 1 for isolated cluster).
---
> *       RBAR    Virial cluster radius in pc (set = 0 for isolated cluster).
36,38c43,46
< *
< *       KZ(J)   Non-zero options for alternative paths (see table).
< *
---
> *--------
> *       KZ(J)   Non-zero options for alternative paths (see table below).
> *       BK(J)   Non-zero options for binpop_4new routine (see table below).
> *--------
45,48c53,54
< ***
< * INPUT: if (kz(4).gt.0)
< *
< *       DELTAS  Output interval for binary search (in TCR; suppressed).
---
> *--------
> *       DELTAS  Output interval for binary search (option 4).
51,54c57,58
< ***
< * DATA:
< *
< *       ALPHAS  Power-law index for initial mass function (used if #20 < 2).
---
> *--------
> *       ALPHAS  Power-law index for initial mass function (routine DATA).
56,58c60,61
< *       BODYN   Minimum particle mass before scaling.
< *       NBIN0   Number of primordial binaries (for IMF2 with KZ(20) > 1).
< *       NHI0    Primordial hierarchies (may be needed in IMF if > 0).
---
> *       BODYN   Minimum particle mass before scaling (KZ(20): solar mass).
> *       NBIN0   Number of primordial binaries (for IMF2 with KZ(20) > 2).
61,86c64,65
< *       DTPLOT  Plotting interval for HRDIAG (N-body units; >= DELTAT).
< ***
< * SETUP: if(kz(5).eq.2)
< *
< *       APO     Separation of two Plummer models (SEMI = APO/(1 + ECC).
< *       ECC     Eccentricity of two-body orbit (ECC < 0.999).
< *       N2      Membership of second Plummer model (N2 <= N).
< *       SCALE   Second scale factor (>= 0.2 for limiting minimum size).
< *
< *        if(kz(5).eq.3)
< *
< *       APO     Separation between the perturber and Sun.
< *       ECC     Eccentricity of orbit (=1 for parabolic encounter).
< *       DMIN    Minimum distance of approach (pericentre).
< *       SCALE   Perturber mass scale factor (=1 for Msun).
< *
< *        if(kz(5).eq.4)
< *
< *       SEMI    Semi-major axis (slightly modified; ignore if ECC > 1).
< *       ECC     Eccentricity (ECC > 1: NAME = 1 & 2 free-floating).
< *       M1      Mass of first member (in units of mean mass).
< *       M2      Mass of second member (rescaled total mass = 1).
< ***
< * SCALE:
< *
< *       Q       Virial ratio (Q = 0.5 for equilibrium).
---
> *--------
> *       Q       Virial ratio (routine SCALE; Q = 0.5 for equilibrium).
89,122c68,92
< *       RTIDE   Unscaled tidal radius (#14 >= 2; otherwise copied to RSPH2).
< ***
< * XTRNL0: if (kz(14).eq.2)
< *
< *       GMG     Point-mass galaxy (solar masses, linearized circular orbit).
< *       RG0     Central distance (in kpc).
< *
< *         if (kz(14).eq.3)
< *       GMG     Point-mass galaxy (solar masses).
< *       DISK    Mass of Miyamoto disk (solar masses).
< *       A       Softening length in Miyamoto potential (in kpc).
< *       B       Vertical softening length (kpc).
< *       VCIRC   Galactic circular velocity (km/sec) at RCIRC (=0: no halo).
< *       RCIRC   Central distance for VCIRC with logarithmic potential (kpc).
< *       RG      Initial position; GMG+DISK=0, VG(3)=0: A(1+E)=RG(1), E=RG(2).
< *       VG      Initial cluster velocity vector (km/sec).
< *
< *         if (kz(14).eq.3.or.kz(14).eq.4)
< *       MP      Total mass of Plummer sphere (in scaled units).
< *       AP      Plummer scale factor (square saved in AP2).
< *       MPDOT   Decay time for gas expulsion (MP = MP0/(1 + MPDOT*(T-TD)).
< *       TDELAY  Delay time for starting gas expulsion (T > TDELAY).
< ***
< * HOTSYS: if (kz(29).gt.0)
< *
< *       SIGMA0  Hot initial velocities in km/sec (CALL REFLCT suppressed).
< ***
< * BINPOP: if (kz(8).eq.1.or.kz(8).gt.2)
< *
< *       SEMI    Max semi-major axis in model units (all equal if RANGE = 0).
< *       ECC     Initial eccentricity (< 0 for thermal distribution).
< *       RATIO   Mass ratio M1/(M1 + M2); (= 1.0: M1 = M2 = <M>; not #20 > 1).
< *       RANGE   Range in SEMI for uniform logarithmic distribution (> 0).
< *       NSKIP   Binary frequency of mass spectrum (#20 < 2; body #1 first).
---
> *       RSPH2   Radius of reflecting sphere (option 29; units of RSCALE).
> *--------
> *       NCL     Number of interstellar clouds (routine CLOUD0; option 13).
> *       RB2     Radius of cloud boundary in pc (square is saved).
> *       VCL     Mean cloud velocity in km/sec.
> *       SIGMA   Gaussian velocity dispersion of clouds in km/sec.
> *       CLM     Individual cloud masses in solar masses (maximum is MCL).
> *       RCL2    Half-mass radii of clouds in pc (square is saved).
> *--------
> *       SIGMA0  Hot initial velocities in km/sec (routine HOTSYS; option 29).
> *--------
> *       NBIN    Number of initial binaries (routine BINPOP; option 8).
> *       SEMI    Initial semi-major axis (= 0 for range of energies).
> *       ECC     Initial eccentricity (for BINPOP_4NEW)
> *               <=1 AND >=0 for one particular fixed ecc. for all systems
> *               < 0 for thermal distribution,
> *               =20 for uniform distribution,
> *               =30 for f(e)=0.1765/(e*e)
> *               =40 for general f(e)=a*e^b, e0<=e<=1 with a=(1+b)/(1-e0^(1+b))
> *                   e0 and b must be defined in binpop routine
> *       RATIO   Mass ratio M1/(M1 + M2); (= 1.0: M1 = M2 = <M>).
> *       NBGR    Number of binaries in fixed energy groups.
> *       REDUCE  Reduction factor in semi-major axis for each group.
> *       RANGE   Energy range for uniform logarithmic distribution.
> *       NSKIP   Binary frequency of mass spectrum (starting from body #1).
124,128c94,97
< *       ICIRC   Eigenevolution (=1: Kroupa & Mardling; =2: Kroupa 1995).
< ***
< * HIPOP: if (kz(8).gt.0.and.kz(18).gt.1)
< *
< *       SEMI    Max semi-major axis in model units (all equal if RANGE = 0).
---
> *       ICIRC   Eigenevolution & period distribution (RANGE: minimum period).
> *--------
> *       NHI     Number of primordial hierarchies (routine HIPOP; #11 > 1).
> *       SEMI    Semi-major axis in model units (all equal if RANGE = 0).
133,137c102,104
< ***
< * INTIDE: if (kz(27).gt.0)
< *
< *       RSTAR   Size of typical star in A.U.
< *       IMS     # idealized main-sequence stars.
---
> *--------
> *       RSTAR   Size of typical star in A.U. (routine INTIDE; option 27).
> *       IMS     # idealized main-sequence stars (routine INTIDE; option 27).
141,149d107
< ***
< * CLOUD0: if (kz(13).gt.0)
< *
< *       NCL     Number of interstellar clouds.
< *       RB2     Radius of cloud boundary in pc (square is saved).
< *       VCL     Mean cloud velocity in km/sec.
< *       SIGMA   Velocity dispersion (#13 > 1: Gaussian).
< *       CLM     Individual cloud masses in solar masses (maximum MCL).
< *       RCL2    Half-mass radii of clouds in pc (square is saved).
159,160c117
< *       3  Basic data on unit 3 at output time (unformatted, frequency NFIX).
< *             =1/2: standard and/or tail; =3: tail only; >3: cluster + tail.
---
> *       3  Basic data on unit 3 at output time (frequency NFIX).
162,165c119
< *       5  Initial conditions (#22 =0; =0: uniform & isotropic sphere;
< *                =1: Plummer; =2: two Plummer models in orbit, extra input;
< *                =3: massive perturber and planetesimal disk, extra input).
< *                =4: massive initial binary, extra input; output on unit 35).
---
> *       5  Initial conditions (#22 =0; =0: uniform & isotropic; =1: Plummer).
167,171c121,122
< *       7  Lagrangian radii (>0: RSCALE; =2, 3, 4: output units 6, 7, 12;
< *                 =5: density & rms velocity at given radii on unit 26 & 27;
< *                 =6: Lagrangian radii for two mass groups on unit 31 & 32.
< *       8  Primordial binaries (=1 & >=3; >0: BINOUT; >2: BINDAT; >3: HIDAT;
< *                               =4: Kroupa period distribution).
---
> *       7  Lagrangian radii (>0: RSCALE; =2, 3, 4: output on unit 6 & 7).
> *       8  Primordial binaries (=1 & 3; >0: BINOUT; >2: BINDAT; >3: HIDAT).
173a125
> *      11  Hierarchical systems (=1: diagnostics; =2: primordial; =3: both).
175d126
< *      11  (unused at present).
177,178c128
< *      14  External force (=1: standard tidal field; =2: point-mass galaxy;
< *             =3: point-mass + disk + halo + Plummer; =4: Plummer sphere).
---
> *      14  External force (=1: standard tidal field; =2: not implemented).
182,184c132,136
< *      18  Hierarchical systems (=1: diagnostics; =2: primordial; =3: both).
< *      19  Mass loss (=1: old supernova scheme; =3: Eggleton, Tout & Hurley).
< *      20  Initial mass function (=1: Scalo; =2,4,6: Kroupa; =3,5: Eggleton).
---
> *      18  Neighbour additions in CHECKL (>0: high-velocity; >1: all types).
> *      19  Mass loss (=1: supernova scheme; =3: Eggleton, Tout & Hurley).
> *      20  Initial mass function (=1: Tout; =2,4: Kroupa; =3,5: Eggleton).
> *          >3 => mass ratio distr. as defined in imf2.f
> *          =2 for KTG93 IMF with random pairing (imf2.f)
187,189c139,142
< *      23  Escaper removal (>1: diagnostics in file ESC; =2: angles unit #6;
< *                           >=3: initialization & integration of tidal tail).
< *      24  Initial conditions for subsystem (routine SCALE; KZ(24) = #).
---
> *                               (=4: starlab input format)
> *      23  Removal of escapers (=1: isolated cluster; =2: diag; 
> *                               =3: tidal cut       ; =4: diag).
> *      24  Initial conditions for subsystems (routine SCALE and input from dat.10).
191,192c144,146
< *      26  Slow-down of two-body motion (>=1: KS; >=2: chain; =3: rectify).
< *      27  Tidal effects (=1: sequential; =2: chaos; =3: GR).
---
> *      26  Slow-down of two-body motion (>=1: KS binary; =2: chain binary).
> *      27  Two-body tidal interaction (n = 1.5: type 3 & 5; n = 3: others).
> *      27  Tidal circularization & collisions (R_coll = 0.75*(R_1 + R_2)).
195c149
< *      30  Chain regularization (=1: basic; >1: extra output; >2: each step).
---
> *      30  Chain regularization (>=2: main output; >2: diagnostic output).
199,206c153,180
< *      34  Roche-lobe overflow (=-1 or =0: no Roche; =1, 2, 3: Roche;
< *               =-1: no synch; =0, 1: synch; =2: BSE synch; =3: BSE tides).
< *      35  Time offset (global time from TTOT = TIME + TOFF; offset = 100).
< *      36  Step reduction for hierarchical systems (not recommended!).
< *      37  Neighbour additions in CHECKL (>0: high-velocity; >1: all types).
< *      38  Force polynomial corrections (=0: I > N; not recommended).
< *      39  No unique density centre (skips velocity modification of RS(I)).
< *      40  Increase of neighbour numbers if <NNB> < NNBMAX/2.
---
> *      34  Roche lobe overflow (not implemented yet).
> *      35  Time offset (global time from TTOT = TIME + DTOFF).
> *      36  Step reduction for hierarchical systems.
> *      37  Fast time-step criterion (>0: STEP; >1: STEPR).
> *      38  No force polynomial corrections (I <= N; block-step version).
> *      39  shape analysis by routine ellan (=2) with Ch. Theis
> *      40  adjust neighbour number to optimal neighbour number.
> *       ---------------------------------------------------------------------
> *
> *
> *       Options BK(J)   (for binpop_4new.f)
> *       *************
> *
> *       ---------------------------------------------------------------------
> *       1  =0: no proto-star evolution                                       
> *          =1:"proto-star" evol. of ecc,period in binpop_4new.f           
> *       2  = -1: use NBGR and REDUCE in binpop_pk.f
> *          =0:flat distr. in semi-major axis                                 
> *          =1:f=0.034388logP                                                 
> *          =2:f=3.5logP/[100+(logP)**2]                                      
> *             KZ(40)=1,2 are 1st and 2nd iterations                          
> *          =3:f=2.3(logP-1)/[45+(logP-1)**2]                                 
> *          =4:f=2.5(logP-1)/[45+(logP-1)**2] -- derived in K2
> *               NOTE: in routine adjust.f KZ(40)>0 is used to adjust         
> *                     neighbour number                                       
> *          =5:f = Duquennoy&Mayor (1991), i.e. Gaussian in logP 
> *       4  =1: file peri_hyperbol.dat opened and written to (see ksint.f)
> *          =0: not opened
230,232c204,208
< *       NFAST   Fast particles included in LISTV (option 18).
< *       NBFAST  Fast particles included in neighbour list (option 18).
< *       NBLOCK  Number of blocks (block-step version).
---
> *       NFAST   Fast particle included in LISTV (option 18).
> *       NBFAST  Fast particle included in neighbour list (option 18).
> *       NBREF   Boundary reflections (option 29; suppressed).
> *       NBLOCK  Number of irregular blocks (block-step version).
> *       NBLCKR  Number of regular blocks (block-step version) (R.Sp.)
242d217
< *       NMARG   Marginal merger stability (accepted after 10,000 tries).
248d222
< *       NEWHI   New hierarchical systems (counted by routine HIARCH).
252c226
< *       NDISS   Tidal dissipations at pericentre (option 27).
---
> *       NDISS   Tidal dissipation at pericentre (option 27).
254c228
< *       NSYNC   Number of synchronous binaries (option 27).
---
> *       NSYNC   Number of synchronous binaries (a < RSYNC; option 27).
259,266d232
< *       NRG     Red giants.
< *       NHE     Helium stars.
< *       NRS     Red supergiants.
< *       NNH     Naked Helium stars.
< *       NWD     White dwarfs.
< *       NSN     Neutron stars.
< *       NBH     Black holes.
< *       NBS     Blue stragglers.
290,293c256
< *      19       Circularizing binary (c.m. value).
< *      20       Circularized binary.
< *      21       First Roche stage (inactive).
< *      22       Second Roche stage.
---
> *      20       Circularized binary (c.m. value).
1,2c1,2
< 2054 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/delay.f
< nbody6compare-oct2006/delay.f
---
> 1937 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/delay.f
> nbody6++compare/delay.f
27,31c27,28
< *      Preserve contents of KSAVE during chain regularization.
<           IF (NCH.EQ.0) THEN
<               KSAVE(1) = 0
<               KSAVE(2) = 0
<           END IF
---
>           KSAVE(1) = 0
>           KSAVE(2) = 0
1,2c1,2
< 7314 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/derqp3.f
< nbody6compare-oct2006/derqp3.f
---
> 7314 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/derqp3.f
> nbody6++compare/derqp3.f
1,2c1,2
< 9994 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/derqp4.f
< nbody6compare-oct2006/derqp4.f
---
> 9994 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/derqp4.f
> nbody6++compare/derqp4.f
1,2c1,2
< 12007 2006-09-07 19:38 /work/Umi2/spurzem/5/nbody6compare-oct2006/derqp.f
< nbody6compare-oct2006/derqp.f
---
> 11676 2001-08-04 17:17 /work/Umi2/spurzem/5/nbody6++compare/derqp.f
> nbody6++compare/derqp.f
318,319c318,319
<               WRITE (6,26)  ITER, IM, G0, QPMIN, ECC
<    26         FORMAT (' WARNING!    NO CONVERGENCE    # IM GI QP ECC ',
---
>               WRITE (6,26)  ITER, IM, G0, QPMIN, DSC
>    26         FORMAT (' WARNING!    NO CONVERGENCE    # IM GI QP DSC ',
349,350c349
< *       Skip exclusion in GR case (denoted by large VSTAR1).
<           IF (ECC.LT.0.002.AND.IMCIRC.EQ.0.AND.VSTAR1.LT.100.0) THEN
---
>           IF (ECC.LT.0.003.AND.IMCIRC.EQ.0) THEN
412,418d410
< *       Avoid apocentre region of secondary binary (algorithmic confusion).
<           ELSE IF (RB.GT.SEMI.AND.IMCIRC.GT.0) THEN
<               JC = 0
<               ITER = 0
<               IMCIRC = 0
<               ICOLL = 0
<               KCOLL = .false.
434a427
> 
1,2c1,2
< 3193 2005-03-26 16:05 /work/Umi2/spurzem/5/nbody6compare-oct2006/difsy1.f
< nbody6compare-oct2006/difsy1.f
---
> 3497 1999-03-23 10:20 /work/Umi2/spurzem/5/nbody6++compare/difsy1.f
> nbody6++compare/difsy1.f
1,4c1
<       subroutine difsy1(n,eps,h,x,y)
< c          Bulirsch-Stoer integrator.
< c          --------------------------
< c      For \Gamma=(H-E)/L and Y(ntime)=time
---
>       SUBROUTINE DIFSY1(N,EPS,H,X,Y)
6c3,16
<       PARAMETER  (NMX=80,NMX7=7*NMX)
---
> *
> *       Bulirsch-Stoer integrator.
> *       --------------------------
> *
> *       Works if Gamma = (H - E)/L. For other time transformations EPS
> *       must be scaled appropriately such that the test is esentially
> *       of the form (H - E)/L < EPS.
> *       Convergence test: ABS(Q'*DP) < EPS*TFAC & ABS(P'*DQ) < EPS*TFAC.
> *       Reference: Mikkola (1987). In 'The Few Body Problem' p. 311.
> *       This works only if eqs. are canonical and we have P's & Q's.
> *       One additional eq. is allowed (e.g. for t'=...??) but not checked.
> *
> *
>       PARAMETER  (NMX=80)
13,14c23,25
<       LOGICAL  KONV,BO,KL,GR,FYBAD
<       DATA DT /NMX7*0.0D0/
---
>       LOGICAL  KONV,BO,KL,GR,FYBAD,stopB
>       COMMON/SLOW2/  stepl,stopB
> *     REAL*8  EP(4)
18,24c29,34
< *     nhalf2=(n/2)*2
<       jti=0
<       fy=1.
<       reduc=0.5
<        do i=1,n
<        ya(i)=y(i)
<        end do
---
> *
>       JTI=0
>       FY=1.
>       DO I=1,N
>       YA(I)=Y(I)
>       END DO
27,67c37,70
<       IF (JC.GT.0)H=DSC
<    10 xn=x+h
<       bo=.false.
<       m=1
<       jr=2
<       js=3
<       do  j=1,10 ! Jmax (10 -> efficient,  4 -> short steps)
<        if(bo)then
<        d(2)=16d0/9.d0
<        d(4)=64.d0/9.d0
<        d(6)=256.d0/9.d0
<        else
<        d(2)=2.25d0
<        d(4)=9.d0
<        d(6)=3.6d1
<        end if
<        if(j.gt.7)then
<        l=7
<        d(7)=6.4d1
<        else
<        l=j
<        d(l)=m*m
<        end if
<       konv=l.gt.3
<       m=m+m
<       g=h/(m)
<       b=g+g
<       m=m-1
<        do i=1,n
<        yl(i)=ya(i)
<        ym(i)=ya(i)+g*dz(i)
<        end do
<       do k=1,m
<       CALL DERQP(YM(1),YM(LX),YM(LE),YM(LP),YM(LV),YM(LT),
<      &           DY(1),DY(LX),DY(LE),DY(LP),DY(LV),DY(LT))
<        do i=1,n
<        u=yl(i)+b*dy(i)
<        yl(i)=ym(i)
<        ym(i)=u
<        end do
<       end do
---
>       IF(JC.GT.0)H=DSC
>    10 XN=X+H
>       BO=.FALSE.
>       M=1
>       JR=2
>       JS=3
> *     DO J=1,10
>       DO J=1,J10
>       IF(BO)THEN
>       D(2)=16.D0/9.D0
>       D(4)=64.D0/9.D0
>       D(6)=256.D0/9.D0
>       ELSE
>       D(2)=2.25D0
>       D(4)=9.D0
>       D(6)=3.6D1
>       END IF
>       IF(J.GT.7)THEN
>       L=7
>       D(7)=6.4D1
>       ELSE
>       L=J
>       D(L)=M*M
>       END IF
>       KONV=L.GT.3
>       M=M+M
>       G=H/(M)
>       B=G+G
>       M=M-1
>       DO I=1,N
>       YL(I)=YA(I)
>       YM(I)=YA(I)+G*DZ(I)
>       END DO
>       DO K=1,M
70,133c73,76
<       kl=l.lt.2
<       gr=l.gt.5
<       fs=0.
<       do i=1,n
<       v=dt(i,1)
<       c=(ym(i)+yl(i)+g*dy(i))*0.5d0
<       dt(i,1)=c
<       ta=c
<       if(.not.kl)then
<       do k=2,l
<       b1=d(k)*v
<       b=b1-c
<       w=c-v
<       u=v
<        if(b.ne.0.d0)then
<        b=w/b
<        u=c*b
<        c=b1*b
<        end if
<       v=dt(i,k)
<       dt(i,k)=u
<       ta=u+ta
<       end do
<       is=i+n/2
<       if(is.gt.nhalf2)is=i-(n/2)
<       dyis=dabs(dy(is))
<       if(i.eq.n)dyis=1/(abs(ya(i))+abs(ta)) ! for time
<         if(konv)then
<         test=dabs( (y(i)-ta)*dyis )
<         if(test.gt.eps) konv=.false.
<         end if
<       if(.not.gr)then
<       fv=dabs(w)*dyis
<       if(fs.lt.fv) fs=fv
<       end if
<       end if
<       y(i)=ta
<       end do
<        if(fs.ne.0.d0)then
<        fa=fy
<        k=l-1
<        fy=(ep(k)/fs)**(1./(l+k))
<        fa7=0.7*fa
<        if(l.eq.2)fa7=0.0
<        fybad=.not.((fa7.gt.fy).or.(fy.gt.0.7))
<         if(fy bad)then
<         h=h*fy
<         jti=jti+1
<          if(jti.gt.5)then
<          h=0.0
<           do i=1,n
<           y(i)=ya(i)
<           end do
<          return
<          end if
<         goto 10
<         end if
<        end if
<       if(konv)then
<       h=xn-x
<       x=xn
< *     if(fy.gt.10.0)fy=10. ! factor 10 may be too large
<       if(fy.gt.4.0)fy=4. ! factor 10 may be too large
<       h=h*fy
---
> *
> *       Include procedure for terminating slow-down treatment.
>       if (l.gt.3.and.stopB) then
>       stepl=(k-1)*B+G
136,146c79,161
<       d(3)=4.d0
<       d(5)=1.6d1
<       bo=.not.bo
<       m=jr
<       jr=js
<       js=m+m
<       end do
<       h=reduc*h
<       reduc=0.01+reduc*reduc
<       goto 10
<       end
---
> *
>       DO I=1,N
>       U=YL(I)+B*DY(I)
>       YL(I)=YM(I)
>       YM(I)=U
>       END DO
>       END DO
>       CALL DERQP(YM(1),YM(LX),YM(LE),YM(LP),YM(LV),YM(LT),
>      &           DY(1),DY(LX),DY(LE),DY(LP),DY(LV),DY(LT))
>       KL=L.LT.2
>       GR=L.GT.5
>       FS=0.
>       DO I=1,N
>       V=DT(I,1)
>       C=(YM(I)+YL(I)+G*DY(I))*0.5D0
>       DT(I,1)=C
>       TA=C
>       IF(.NOT.KL)THEN
>       DO K=2,L
>       B1=D(K)*V
>       B=B1-C
>       W=C-V
>       U=V
>       IF(B.NE.0.D0)THEN
>       B=W/B
>       U=C*B
>       C=B1*B
>       END IF
>       V=DT(I,K)
>       DT(I,K)=U
>       TA=U+TA
>       END DO
>       IS=I+N/2
>       IF(IS.GT.NHALF2)IS=I-(N/2)
>       DYIS=DABS(DY(IS))
> *     DYIS=DABS(DY(IS))*TFACIN
>       IF(I.GT.NHALF2)DYIS=0.0D0
>       IF(KONV)THEN
>       TEST=DABS((Y(I)-TA)*DYIS)
>       IF(TEST.GT.EPS) KONV=.FALSE.
>       END IF
>       IF(.NOT.GR)THEN
>       FV=DABS(W)*DYIS
>       IF(FS.LT.FV) FS=FV
>       END IF
>       END IF
>       Y(I)=TA
>       END DO
>       IF(FS.NE.0.D0)THEN
>       FA=FY
>       K=L-1
>       FY=0.5*(EP(K)/FS)**(1./(L+K))
>       FA7=0.7*FA
>       IF(L.EQ.2)FA7=0.0D0
>       FYBAD=.NOT.((FA7.GT.FY).OR.(FY.GT.0.7))
>       IF(FYBAD)THEN
>       H=H*FY
>       JTI=JTI+1
>       IF(JTI.GT.5)THEN
>       H=0.0D0
>       DO I=1,N
>       Y(I)=YA(I)
>       END DO
>       RETURN
>       END IF
>       GOTO 10
>       END IF
>       END IF
>       IF(KONV)THEN
>       X=XN
>       H=H*FY
>       RETURN
>       END IF
>       D(3)=4.D0
>       D(5)=1.6D1
>       BO=.NOT.BO
>       M=JR
>       JR=JS
>       JS=M+M
>       END DO
>       H=0.5*H
>       GOTO 10
>       END
1,2c1,2
< 3215 2004-05-11 12:58 /work/Umi2/spurzem/5/nbody6compare-oct2006/difsy3.f
< nbody6compare-oct2006/difsy3.f
---
> 3180 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/difsy3.f
> nbody6++compare/difsy3.f
16c16
<       PARAMETER  (NMX=17,NMX7=7*NMX)
---
>       PARAMETER  (NMX=17)
23d22
<       DATA DT /NMX7*0.0D0/
61c60
<       G=H/M
---
>       G=H/(M)
125c124
<       IF(FYBAD)THEN
---
>       IF(FY BAD)THEN
1,2c1,2
< 3200 2004-05-11 12:59 /work/Umi2/spurzem/5/nbody6compare-oct2006/difsy4.f
< nbody6compare-oct2006/difsy4.f
---
> 3165 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/difsy4.f
> nbody6++compare/difsy4.f
16c16
<       PARAMETER  (NMX=25,NMX7=7*NMX)
---
>       PARAMETER  (NMX=25)
23d22
<       DATA DT /NMX7*0.0D0/
61c60
<       G=H/M
---
>       G=H/(M)
125c124
<       IF(FYBAD)THEN
---
>       IF(FY BAD)THEN
1,2c1,2
< 1503 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/efac2.f
< nbody6compare-oct2006/efac2.f
---
> 1504 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/efac2.f
> nbody6++compare/efac2.f
51a52
> 
1,2c1,2
< 1510 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/efac3.f
< nbody6compare-oct2006/efac3.f
---
> 1511 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/efac3.f
> nbody6++compare/efac3.f
51a52
> 
1,2c1,2
< 2484 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/endreg.f
< nbody6compare-oct2006/endreg.f
---
> 2484 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/endreg.f
> nbody6++compare/endreg.f
1,2c1,2
< 2513 2006-08-30 11:31 /work/Umi2/spurzem/5/nbody6compare-oct2006/energy.f
< nbody6compare-oct2006/energy.f
---
> 2327 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/energy.f
> nbody6++compare/energy.f
9d8
< *
25,26c24,26
<       I = 1
<    20 JMIN = I + 1
---
> *
>       DO 20 I = 1,NTOT
>       JMIN = I + 1
31a32,38
> *
>       IPAIR = 0
>       IF (I.GT.N)  THEN
> *       Binding energy at center of mass position without binary members
>           IPAIR = I - N
>       END IF
> *
32a40,41
>       POTI = 0.D00
> *       POTI contains potential at particles position to be stored later (R.Sp.)
34,35c43,45
<       DO 30 J = JMIN,N
<           IF (BODY(J).EQ.0.0D0) GO TO 30
---
>       DO 30 J = 1,N
>       IF (J.EQ.I .OR. J.EQ.2*IPAIR-1 .OR. J.EQ.2*IPAIR .OR.
>      *    BODY(J).EQ.0.0D0 .OR. BODY(I).EQ.0.0D0)  GO TO 30
39c49,52
<           POTJ = POTJ + BODY(J)/SQRT(A1*A1 + A2*A2 + A3*A3)
---
>       A4 = BODY(J)/DSQRT (A1*A1 + A2*A2 + A3*A3)
>       POTI = POTI - A4
> *  also J.LT.N?
>       IF(J.GE.JMIN)POTJ = POTJ + A4
41c54,55
< *
---
> *       Store potential in shared vector first (R.Sp.)
>       PHIDBL(I) = POTI
43,44c57
<       I = I + 1
<       IF (I.LT.N) GO TO 20
---
>    20 CONTINUE
50a64
> *
53,57c67,69
< *       Obtain the tidal potential energy for linearized external field. 
<       IF (KZ(14).EQ.0) THEN
< *       Note: ETIDE holds accumulated tidal energy if KZ(14) = 3.
<           ETIDE = 0.0D0
<       ELSE IF (KZ(14).LE.2) THEN
---
> *       Obtain the tidal potential if external field is present.
>       ETIDE = 0.0D0
>       IF (KZ(14).GT.0) THEN
59,73d70
<       ELSE IF (KZ(14).EQ.4.OR.(KZ(14).EQ.3.AND.MP.GT.0.0D0)) THEN
< *       Include optional tidal energy and virial for Plummer potential.
<           ETIDE = 0.0
<           VIR = 0.0
<           DO 50 I = 1,N
<               RI2 = AP2
<               DO 45 K = 1,3
<                   RI2 = RI2 + X(K,I)**2
<    45         CONTINUE
<               FM = BODY(I)*MP/(RI2*SQRT(RI2))
<               DO 48 K = 1,3
<                   VIR = VIR - FM*X(K,I)**2
<    48         CONTINUE
<               ETIDE = ETIDE - BODY(I)*MP/SQRT(RI2)
<    50     CONTINUE
1,2c1,2
< 1715 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/erel3.f
< nbody6compare-oct2006/erel3.f
---
> 1715 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/erel3.f
> nbody6++compare/erel3.f
1,2c1,2
< 1451 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/erel4.f
< nbody6compare-oct2006/erel4.f
---
> 1451 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/erel4.f
> nbody6++compare/erel4.f
1,2c1,2
< 1523 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/erel.f
< nbody6compare-oct2006/erel.f
---
> 1523 1997-03-01 11:44 /work/Umi2/spurzem/5/nbody6++compare/erel.f
> nbody6++compare/erel.f
1,2c1,2
< 19302 2006-09-08 15:01 /work/Umi2/spurzem/5/nbody6compare-oct2006/escape.f
< nbody6compare-oct2006/escape.f
---
> 18913 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/escape.f
> nbody6++compare/escape.f
0a1,4
> # 1 "escape.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "escape.F"
4,5c8,9
< *       Escaper removal.
< *       ----------------
---
> * Escaper removal.
> * ----------------
8,14c12,15
<       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
<       CHARACTER*11  WHICH1
<       LOGICAL  FIRST
<       SAVE  FIRST
<       DATA  FIRST /.TRUE./
---
>       COMMON/BINARY/ CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
>      & HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      & NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       CHARACTER*11 WHICH1
17c18
< *       Adopt twice the tidal radius as escape condition.
---
> * Adopt twice the tidal radius as escape condition.
19c20,26
<       IF (KZ(27).EQ.3) RESC2 = 1000.0
---
> * For tidal cutoff check only energy
>       IF(KZ(23).GE.3)THEN
>           RESC2 = 0.D0
>           ETID = ZMASS/RTIDE
>           ZMOLD = ZMASS
>       END IF
> *
22a30
>       NCRIT2 = 0
29c37
< *       Set the distance (squared) with respect to the density centre.
---
> * Set the distance (squared) with respect to the density centre.
31,32c39,40
<     5 RI2 = (X(1,I) - RDENS(1))**2 + (X(2,I) - RDENS(2))**2 + 
<      &                               (X(3,I) - RDENS(3))**2
---
>     5 RI2 = (X(1,I) - RDENS(1))**2 + (X(2,I) - RDENS(2))**2 +
>      & (X(3,I) - RDENS(3))**2
34d41
<       VI2 = XDOT(1,I)**2 + XDOT(2,I)**2 + XDOT(3,I)**2
36c43,44
< *       See whether escape is indicated (retain merger ghost particles).
---
>       IF(KZ(23).LE.2) THEN
> * See whether escape is indicated (retain ghost particles).
39c47
< *       Find distance to the nearest neighbour and calculate potential.
---
> * Find distance to the nearest neighbour and calculate potential.
44c52
<      &                                      (X(3,I) - X(3,J))**2
---
>      & (X(3,I) - X(3,J))**2
50,51c58,60
<     8     CONTINUE
< *       Check escape criterion for external fields or isolated system.
---
>     8 CONTINUE
>           VI2 = XDOT(1,I)**2 + XDOT(2,I)**2 + XDOT(3,I)**2
> * Check escape criterion for tidal case or isolated system.
53,54c62,88
<           IF (KZ(14).EQ.4.OR.KZ(14).EQ.3) THEN
<               EI = EI - MP/SQRT(RI2 + AP2)
---
>           IF (KZ(14).GT.0.OR.EI.GT.0.0) GO TO 30
>           IF (NAME(I).LT.0) GO TO 30
>       END IF
> *
>       ELSE
> * Check tidal cutoff criterion - use last computed phi-value
> * Find distance to the nearest neighbour
>           POTI = 0.0D0
>           NNB = LIST(1,I)
>           RJMIN2 = 1.0D+10
>           DO 9 L = 1,NNB
>               J = LIST(L+1,I)
>               RIJ2 = (X(1,I) - X(1,J))**2 + (X(2,I) - X(2,J))**2 +
>      & (X(3,I) - X(3,J))**2
>               IF (RIJ2.LT.RJMIN2) THEN
>                   RJMIN2 = RIJ2
>                   JMIN = J
>               END IF
>     9 CONTINUE
>           VI2 = XDOT(1,I)**2 + XDOT(2,I)**2 + XDOT(3,I)**2
>           POTI = -PHIDBL(I)
> * Check escape criterion for tidal case or isolated system.
>           EI = 0.5*VI2 - POTI + ETID
> *
>           IF (EI.GT.0.0.AND.RI2.GT.RTIDE2) THEN
>           NCRIT2 = NCRIT2 + 1
>           GO TO 30
56d89
<           IF ((KZ(14).GT.0.AND.KZ(14).NE.4).OR.EI.GT.0.0) GO TO 30
65c98
< *       Form centre of mass terms.
---
> * Form centre of mass terms.
70c103
<    14     CONTINUE
---
>    14 CONTINUE
74,77c107,110
<       STEPI = MIN(STEPI,1.0D0)
<       JLAST = MIN(NCORR,NMAX)
<       WRITE (6,18)  N, NSESC, NBESC, ZMASS, BE(3), CMR(4), RESC, STEPI,
<      &              RSI, ZMASS/FLOAT(N), NCRIT1, (JLIST(J),J=1,JLAST)
---
>       JLAST = MIN(2*NCORR,NMAX)
>       if(rank.eq.0)
>      &WRITE (6,18) N, NSESC, NBESC, ZMASS, BE(3), CMR(4), RESC, STEPI,
>      & RSI, ZMASS/FLOAT(N), NCRIT1, (JLIST(J),J=1,JLAST)
79c112
<      &                                        I6,2X,6I6,/,5(10X,20I6,/))
---
>      & I6,2X,6I6,/,5(10X,20I6,/))
81,85c114,118
< *     IF (KZ(23).EQ.2.AND.KZ(14).EQ.1) THEN
< *         JLAST = MIN(2*NCORR,LMAX)
< *         WRITE (6,20)  (ILIST(J),J=1,JLAST)
< *  20     FORMAT (/,' ESCAPE ANGLES ',11(2I4,2X),9(/,15X,11(2I4,2X)))
< *     END IF
---
>       IF (KZ(23).EQ.2.OR.KZ(23).EQ.4)THEN
>           JLAST = MIN(2*NCORR,NMAX)
>           if(rank.eq.0) WRITE (6,20) (ILIST(J),J=1,JLAST)
>    20 FORMAT (/,' ESCAPE ANGLES ',11(2I4,2X),9(/,15X,11(2I4,2X)))
>       END IF
87c120
< *       Check updating of global index for chain c.m.
---
> * Check updating of global index for chain c.m.
92c125
< *       Set phase indicator < 0 for new time-step list in INTGRT.
---
> * Set phase indicator < 0 for new NLIST in routine INTGRT (Hermite).
98,99c131,132
<      &                                 (X(3,JMIN) - RDENS(3))**2
< *       See whether nearest body satisfies escape condition or RIJ > 10*RMIN.
---
>      & (X(3,JMIN) - RDENS(3))**2
> * See whether nearest body satisfies escape condition or RIJ > 10*RMIN.
101a135,141
> *
>       IF(KZ(23).GE.3)THEN
>           VI2 = XDOT(1,JMIN)**2 + XDOT(2,JMIN)**2 + XDOT(3,JMIN)**2
>           EI = 0.5*VI2 + PHIDBL(JMIN) + ETID
>           IF(EI.GT.0.D0) GO TO 40
>       END IF
> *
104,105c144,145
<      &     (XDOT(2,I) - XDOT(2,JMIN))**2 +
<      &     (XDOT(3,I) - XDOT(3,JMIN))**2
---
>      & (XDOT(2,I) - XDOT(2,JMIN))**2 +
>      & (XDOT(3,I) - XDOT(3,JMIN))**2
107c147
< *       Check velocity of binary component in case of bound pair.
---
> * Check velocity of binary component in case of bound pair.
110c150
< *       Retain escaper if dynamical effect on neighbour is significant.
---
> * Retain escaper if dynamical effect on neighbour is significant.
113c153
< *       Form optional output diagnostics.
---
> * Form optional output diagnostics.
121c161
< *       Escape angles with respect to the X-axis and XY-plane.
---
> * Escape angles with respect to the X-axis and XY-plane.
126c166
< *       Accumulate escaper names and save current name in case I > N.
---
> * Accumulate escaper names and save current name in case I > N.
134,139c174
< *       Check initialization of tidal tail integration for 3D model.
<       IF (KZ(23).GE.3.AND.KZ(14).EQ.3) THEN
<           CALL TAIL0(I)
<       END IF
< *
< *       Obtain binding energy of body #I and update optional tidal radius.
---
> * Obtain binding energy of body #I and update optional tidal radius.
141c176
<       IF (KZ(14).GT.0.AND.KZ(14).LT.3) THEN
---
>       IF (KZ(14).GT.0) THEN
145,148d179
<       ELSE IF (KZ(14).EQ.4.OR.KZ(14).EQ.3) THEN
< *       Include optional Plummer sphere and update tidal radius.
<           POTI = POTI + MP/SQRT(RI2 + AP2)
<           RTIDE = RTIDE0*ZMASS**0.3333
152c183,189
< *       Correct total energy (also ZKIN & POT for consistency).
---
> * Update tidal radius in case of tidal cutoff (R.Sp.)
>       IF(KZ(23).GE.3)THEN
>           RTOLD = RTIDE
>           RTIDE = RTIDE*(ZMASS/ZMOLD)**0.3333
>       END IF
> *
> * Correct total energy.
154,155d190
<       ZKIN = ZKIN - ZK
<       POT = POT - BODY(I)*POTI
157c192
< *       Update total mass and save energy & number of single escapers.
---
> * Update total mass and save energy & number of single escapers.
164d198
<       ESESC = ESESC + EI
166,171c200,201
< *       Include optional escape output on unit 11.
<       IF (KZ(23).GT.1) THEN
<           IF (FIRST) THEN
<               OPEN (UNIT=11,STATUS='NEW',FORM='FORMATTED',FILE='ESC')
<               FIRST = .FALSE.
<           END IF
---
> * Include optional escape output on unit 11.
>       IF (KZ(23).EQ.2.OR.KZ(23).EQ.4) THEN
175,176c205,206
< *       Distinguish between tidal field and isolated system (ECRIT at RTIDE).
<           IF (KZ(14).GT.0.AND.KZ(14).LE.2) THEN
---
> * Distinguish between tidal field and isolated system (ECRIT at RTIDE).
>           IF (KZ(14).GT.0) THEN
186,188c216,223
<           WRITE (11,45)  TESC, BESC, EESC, VKM, KSTARI, NAME(I)
<    45     FORMAT (F8.1,3F6.1,I4,I6)
<           CALL FLUSH(11)
---
> 
> 
> 
>           WRITE (11,45) TESC, BESC, EESC, VKM, KSTARI
>    45 FORMAT (F8.1,3F6.1,I4)
> 
> 
> 
191c226
< *       Reduce particle number & total membership and check NNBMAX.
---
> * Reduce particle number & total membership and check NNBMAX.
194,197c229,232
<       NNBMAX = MIN((N - NPAIRS)/2,NNBMAX)
<       ZNBMAX = 0.9*NNBMAX
<       ZNBMIN = MAX(0.2*NNBMAX,1.0)
< *       Set indicator for removal of c.m. or KS components.
---
>       NNBMAX = MIN(N/2,NNBMAX)
>       ZNBMAX = 0.9*FLOAT(NNBMAX)
>       ZNBMIN = MAX(0.01*FLOAT(NNBMAX),1.0)
> * Set indicator for removal of c.m. or KS components.
200c235
< *       Update COMMON arrays to remove the escaper and correct F & FDOT.
---
> * Update COMMON arrays to remove the escaper and correct F & FDOT.
203c238
< *       Delete escaper from neighbour lists and reduce higher locations.
---
> * Delete escaper from neighbour lists and reduce higher locations.
208c243
<    70     IF (LIST(L,J).NE.I) GO TO 130
---
>    70 IF (LIST(L,J).NE.I) GO TO 130
210c245
< *       Move up the remaining list members and reduce membership by one.
---
> * Move up the remaining list members and reduce membership by one.
213c248
<    80     CONTINUE
---
>    80 CONTINUE
215,217c250,256
< *       Reduce the steps to minimize error effect (do not allow DT < 0).
< *         STEP(J) = MAX(0.5D0*STEP(J),TIME - T0(J))
< *         STEPR(J) = MAX(0.5D0*STEPR(J),TIME - T0R(J))
---
> * Reduce the steps to minimize error effect (do not allow DT < 0).
> * STEP(J) = MAX(0.5D0*STEP(J),TIME - T0(J))
> * STEPR(J) = MAX(0.5D0*STEPR(J),TIME - T0R(J))
> * Add body #J to time-step list unless already a member.
> * IF (T0(J) + STEP(J).LT.TLIST) THEN
> * CALL NLMOD(J,1)
> * END IF
220c259
< *       Add a distant body as neighbour if list only contains escaper.
---
> * Add a distant body as neighbour if list only contains escaper.
222c261
<   100     K = K + 1
---
>   100 K = K + 1
224c263
<      &                                  (X(3,J) - X(3,K))**2
---
>      & (X(3,J) - X(3,K))**2
230,231c269,270
< *       Reduce higher particle locations by one.
<   130     IF (LIST(L,J).GT.I) LIST(L,J) = LIST(L,J) - 1
---
> * Reduce higher particle locations by one.
>   130 IF (LIST(L,J).GT.I) LIST(L,J) = LIST(L,J) - 1
236c275,278
< *       Update list of old KS components (remove #I and rename > I).
---
> * Modify time-step list due to escaper removal (-2 for extra test).
>       CALL NLMOD(I,-2)
> *
> * Update list of old KS components (remove #I and rename > I).
240c282
< *       Remove both components of pair and reduce membership by two.
---
> * Remove both components of pair and reduce membership by two.
244c286
<   165         CONTINUE
---
>   165 CONTINUE
249c291
< *       Reduce higher particle locations by one (separate loop for pairs).
---
> * Reduce higher particle locations by one (separate loop for pairs).
254,256c296,298
< *       Update list of high velocity particles (remove #I and rename > I).
<       NNV = LISTV(1)
<       DO 190 L = 2,NNV+1
---
> * Update list of high velocity particles (remove #I and rename > I).
>       NNB = LISTV(1)
>       DO 190 L = 2,NNB+1
258,259c300,301
< *       Remove escaper and reduce the membership.
<               DO 185 K = L,NNV
---
> * Remove escaper and reduce the membership.
>               DO 185 K = L,NNB
261c303
<   185         CONTINUE
---
>   185 CONTINUE
264c306
< *       Reduce higher particle locations by one (or three for c.m.).
---
> * Reduce higher particle locations by one (or three for c.m.).
271c313
< *       Check special case of second KS component removal.
---
> * Check special case of second KS component removal.
274c316
< *       See whether the escaper is a single particle or c.m.
---
> * See whether the escaper is a single particle or c.m.
277c319
< *       Prepare removal of regularized pair.
---
> * Prepare removal of regularized pair.
280c322
< *       Skip correction if ghost is also merged binary (NAMEI = 0 below).
---
> * Skip correction if ghost is also merged binary (NAMEI = 0 below).
288c330
<           PMIN  = SEMI*(1.0 - ECC)
---
>           PMIN = SEMI*(1.0 - ECC)
294c336
< *       Obtain two-body elements of ghost binary and update energies.
---
> * Obtain two-body elements of ghost binary and update energies.
309c351
< *       Update total energy (ECOLL with EB < -1 & #27 > 0 affects BINOUT).
---
> * Update total energy (ECOLL with EB < -1 & #27 > 0 affects BINOUT).
311d352
<       EBIN = EBIN - EB
313,314c354,355
< *       Check optional diagnostics for hierarchical systems.
<       IF (NAMEI.LE.0.AND.(KZ(18).EQ.1.OR.KZ(18).EQ.3)) THEN
---
> * Check optional diagnostics for hierarchical systems.
>       IF (NAMEI.LE.0.AND.(KZ(11).EQ.1.OR.KZ(11).EQ.3)) THEN
319c360,364
< *       Distinguish between actual and ghost binary (mergers come later).
---
> * Specify binary type (0: standard; -1: merged binary).
>       M = 0
>       IF (NAMEI.LE.0) M = -1
> *
> * Distinguish between actual and ghost binary (mergers come later).
323c368
< *       Include rare case of higher-order system (4, 5 or 6 members).
---
> * Include rare case of higher-order system (4, 5 or 6 members).
328c373
<   195         CONTINUE
---
>   195 CONTINUE
332,333c377,378
<   196         CONTINUE
< *       Identify quartet, quintuplet or sextuplet.
---
>   196 CONTINUE
> * Identify quartet, quintuplet or sextuplet.
336c381
< *       Include both types of quintuplet: [[B,S],B] and [[B,B],S].
---
> * Include both types of quintuplet: [[B,S],B] and [[B,B],S].
344d388
<               ZM3 = (CM(3,JM) + CM(4,JM))*ZMBAR
348,353c392,396
<               WRITE (6,199)  WHICH1, NAME(2*IPAIR-1), NAME(2*IPAIR),
<      &                       NAME(I3HJ), ZM1, ZM2, ZM3, EB3, SEMI3, PB3
<   199         FORMAT (/,A11,' ESCAPE    NM =',3I6,'  M =',3F6.2,
<      &                    '  EB3 =',F8.4,'  A3 =',1P,E8.1,'  P3 =',E8.1)
< *       Copy actual name of outer component for KS binary output.
<               NAME2 = NAME(I3HJ)
---
>               if(rank.eq.0)
>      & WRITE (6,199) WHICH1, NAME(2*IPAIR-1), NAME(2*IPAIR),
>      & NAME(I3HJ), ZM1, ZM2, EB3, SEMI3, PB3
>   199 FORMAT (/,A11,' ESCAPE    NM =',3I6,'  M =',2F5.1,
>      & '  EB3 =',F8.4,'  A3 =',1P,E8.1,'  P3 =',E8.1)
356,364c399,409
<           VI = SQRT(0.5*VI2*ZMASS/ABS(ZKIN))
<           WRITE (6,200)  IPAIR, NAME(2*IPAIR-1), NAME2,
<      &                   KSTAR(2*IPAIR-1), KSTAR(2*IPAIR), KSTARI,
<      &                   LIST(2,2*IPAIR), BODY(2*IPAIR-1)*ZMBAR,
<      &                   BODY(2*IPAIR)*ZMBAR, EB, RATIO, VI, ECC, EI, PB
<   200     FORMAT (/,' BINARY ESCAPE    KS =',I5,'  NM =',2I6,
<      &                '  K* =',4I3,'  M =',2F5.1,'  EB =',F8.4,
<      &                '  R*/PM =',F5.2,'  V/<V> =',F5.2,'  E =',F5.2,
<      &                '  EI =',F8.5,'  P =',1P,E8.1)
---
>           if(rank.eq.0)then
>           VI = SQRT(0.5*VI2*ZMASS/ZKIN)
>           WRITE (6,200) IPAIR, NAME(2*IPAIR-1), NAME2,
>      & KSTAR(2*IPAIR-1), KSTAR(2*IPAIR), KSTARI,
>      & LIST(2,2*IPAIR), BODY(2*IPAIR-1)*ZMBAR,
>      & BODY(2*IPAIR)*ZMBAR, EB, RATIO, VI, ECC, EI, PB
>   200 FORMAT (/,' BINARY ESCAPE    KS =',I5,'  NM =',2I6,
>      & '  K* =',4I3,'  M =',2F5.1,'  EB =',F8.4,
>      & '  R*/PM =',F5.2,'  V/<V> =',F5.2,'  E =',F5.2,
>      & '  EI =',F8.5,'  P =',1P,E8.1)
>           end if
366,371c411,417
<           WRITE (6,202)  IPAIR, NAME(2*IPAIR-1), NAME(2*IPAIR),
<      &                   KSTAR(2*IPAIR-1), KSTAR(2*IPAIR), KSTAR(I),
<      &                   CM(3,IM)*SMU, CM(4,IM)*SMU, EB1, ECC, SEMI, PB
<   202     FORMAT (/,' QUAD ESCAPE    KS =',I5,'  NM =',2I6,
<      &                '  K* =',3I3,'  M =',2F5.1,'  EB =',F8.4,
<      &                '  E =',F7.3,'  A =',1P,E8.1,'  P =',E8.1)
---
>           if(rank.eq.0)
>      & WRITE (6,202) IPAIR, NAME(2*IPAIR-1), NAME(2*IPAIR),
>      & LIST(2,2*IPAIR), KSTAR(JM), CM(3,IM)*ZMBAR,
>      & CM(4,IM)*ZMBAR, EB1, ECC, SEMI, PB
>   202 FORMAT (/,' QUAD ESCAPE    KS =',I5,'  NM =',2I6,
>      & '  K* =',2I3,'  M =',2F5.1,'  EB =',F8.4,
>      & '  E =',F7.3,'  A =',1P,E8.1,'  P =',E8.1)
376c422
< *       Accumulate escaping binary energies and increase the counter.
---
> * Accumulate escaping binary energies and increase the counter.
386d431
<       EBESC = EBESC + EB
388c433
<       IF (NAMEI.GT.0) THEN
---
>       IF (M.EQ.0) THEN
394c439
< *       Reduce particle number, pair index & single particle index. 
---
> * Reduce particle number, pair index & single particle index.
399c444
< *       Move up all tables of regularized pairs below IPAIR.
---
> * Move up all tables of regularized pairs below IPAIR.
404c449
< *       Increase index for removing KS components.
---
> * Increase index for removing KS components.
407c452
< *       Remove COMMON arrays of the second component before the first.
---
> * Remove COMMON arrays of the second component before the first.
410c455
< *       Reduce NTOT by 3 and N by 2 when KS pair escapes.
---
> * Reduce NTOT by 3 and N by 2 when KS pair escapes.
415c460
< *       Check selection of possible ghost in higher-order system.
---
> * Check selection of possible ghost in higher-order system.
422c467
<   208     CONTINUE
---
>   208 CONTINUE
429c474
< *       Include the case of escaping merger.
---
> * Include the case of escaping merger.
432c477
< *       Locate current position in the merger table (standard case).
---
> * Locate current position in the merger table (standard case).
437c482
< *       Skip on failed detection just in case.
---
> * Skip on failed detection just in case.
440c485
< *       Include case of higher-order system (outer single or binary).
---
> * Include case of higher-order system (outer single or binary).
443c488
< *       Determine the ghost index.
---
> * Determine the ghost index.
447,448c492,493
<   215     CONTINUE
< *       Specify nominal escape distance for ghost removal.
---
>   215 CONTINUE
> * Specify nominal escape distance for ghost removal.
450c495
< *       Define possible KS pair index for quadruple system correction.
---
> * Define possible KS pair index for quadruple system correction.
454c499
< *       Consider current ghost unless deeper hierarchy is present.
---
> * Consider current ghost unless deeper hierarchy is present.
457c502
< *       Search for c.m. name one level below current (NAMEI < 0).
---
> * Search for c.m. name one level below current (NAMEI < 0).
461,462c506,507
<   220         CONTINUE
< *       Use previous merger index to look for binary ghost at earlier level.
---
>   220 CONTINUE
> * Use previous merger index to look for binary ghost at earlier level.
466c511
<   225         CONTINUE
---
>   225 CONTINUE
470c515
< *       Adopt original solution on failure to identify binary.
---
> * Adopt original solution on failure to identify binary.
473c518
< *       Set nominal escape distance of any new ghost (I3HI <= N possible).
---
> * Set nominal escape distance of any new ghost (I3HI <= N possible).
478c523
< *       Copy merger energy to respective energy bins (primordial or new).
---
> * Copy merger energy to respective energy bins (primordial or new).
485d529
<       EMESC = EMESC + ZMU*HM(JM)
487c531
< *       Reduce membership if IM is last (otherwise done in RESET).
---
> * Reduce membership if IM is last (otherwise done in RESET).
492c536
< *       Identify merged ghost particle (single body or binary c.m.).
---
> * Identify merged ghost particle (single body or binary c.m.).
497c541
< *       Include search over lower level on failed identification.
---
> * Include search over lower level on failed identification.
501c545
<   232     CONTINUE
---
>   232 CONTINUE
504c548
< *       Skip if correct ghost not identified (note I3HI # JCOMP if JM # IM).
---
> * Skip if correct ghost not identified (note I3HI # JCOMP if JM # IM).
507c551
< *       Form two-body elements and period of inner binary.
---
> * Form two-body elements and period of inner binary.
517c561
< *       Include extra corrections for mergers between binary pairs.
---
> * Include extra correction for mergers between binary pairs.
523c567,568
<               IF (JM.EQ.NMERGE) NMERGE = NMERGE - 1
---
> * Copy smaller index for QUAD binary output.
>               IM = JM
530c575
<   235     CONTINUE
---
>   235 CONTINUE
533,542c578,588
<           PCRIT = stability(CM(1,JM),CM(2,JM),BODY(JCOMP),ECC0,ECC,
<      &                                                       0.0D0)
<           PCRIT = PCRIT*SEMI0
< *
<           WRITE (6,240)  NAME1, NAMEG(JM), KSTAR1, KSTAR(JCOMP),
<      &                   KSTARM(JM), CM(1,JM)*ZMBAR, CM(2,JM)*ZMBAR,
<      &                   EB, ECC0, PMIN/PCRIT, SEMI0, PB
<   240     FORMAT (/,' HIARCH ESCAPE    NM =',2I6,'  K* =',3I3,
<      &              '  M =',2F5.1,'  EB =',F8.4,'  E =',F7.3,
<      &              '  PM/PC =',1P,E8.1,'  A =',E8.1,'  P =',E8.1)
---
>           Q = ZM2/BODYCM
>           XFAC = (1.0 + Q)*(1.0 + ECC)/SQRT(1.0 - ECC)
>           PCRIT = 2.8*XFAC**0.4*SEMI0
> *
>           if(rank.eq.0)
>      & WRITE (6,240) NAME1, NAMEG(JM), KSTAR1, KSTAR(JCOMP),
>      & KSTARM(JM), CM(1,JM)*ZMBAR, CM(2,JM)*ZMBAR,
>      & EB, ECC0, PMIN/PCRIT, SEMI0, PB
>   240 FORMAT (/,' HIARCH ESCAPE    NM =',2I6,'  K* =',3I3,
>      & '  M =',2F5.1,'  EB =',F8.4,'  E =',F7.3,
>      & '  PM/PC =',1P,E8.1,'  A =',E8.1,'  P =',E8.1)
544c590
< *       Remove the ghost particle (NAME = 0 & EB = 0 for second binary).
---
> * Remove the ghost particle (NAME = 0 & EB = 0 for second binary).
1,2c1,2
< 2155 2006-09-09 12:29 /work/Umi2/spurzem/5/nbody6compare-oct2006/events.f
< nbody6compare-oct2006/events.f
---
> 2106 2005-03-11 12:58 /work/Umi2/spurzem/5/nbody6++compare/events.f
> nbody6++compare/events.f
28c28
<           WRITE (6,15)
---
>           if(rank.eq.0)WRITE (6,15)
32c32,33
<           WRITE (6,20)  NMDOT, NRG, NHE, NRS, NNH, NWD, NSN, NBH, NBS,
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  NMDOT, NRG, NHE, NRS, NNH, NWD, NSN, NBH, NBS,
35c36
<    20     FORMAT (' #4',I8,I4,I5,I6,5I5,6F6.1,F7.1,I7,I6,14I4)
---
>    20     FORMAT (' #4',I7,2I5,I6,5I5,6F6.1,F7.1,I7,I6,14I4)
55,63c56,64
<       IF (NDISS + NCOLL + NCOAL.GT.0) THEN
<           WRITE (6,30)
<    30     FORMAT (/,5X,'NDISS  NTIDE  NSYNC  NCOLL  NCOAL  NCIRC',
<      &                 '  NROCHE  NRO   EBIN   ECOLL  EMDOT  ECDOT',
<      &                 '  EKICK  ESESC  EBESC  EMESC')
<           WRITE (6,35)  NDISS, NTIDE, NSYNC, NCOLL, NCOAL, NCIRC,
<      &                  NROCHE, NRO, EBIN, ECOLL, EMDOT, ECDOT, EKICK,
<      &                  ESESC, EBESC, EMESC
<    35     FORMAT (' #5',6I7,I8,I5,F7.2,F8.2,6F7.2)
---
>       IF (NDISS + NCOLL.GT.0) THEN
>           EESC = E(5) + E(7)
>           if(rank.eq.0)WRITE (6,30)
>    30     FORMAT (/,5X,'NDISS  NTIDE  NSYNC  NCOLL    EBIN   ECOLL',
>      &               '   EMDOT  ECDOT  EKICK   EESC')
>           if(rank.eq.0)
>      &    WRITE (6,35)  NDISS, NTIDE, NSYNC, NCOLL, EBIN, ECOLL,
>      &                  EMDOT, ECDOT, EKICK, EESC
>    35     FORMAT (' #5',4I7,3F8.2,3F7.2)
68a70,71
> 
> 
1,2c1,2
< 8664 2004-05-11 10:18 /work/Umi2/spurzem/5/nbody6compare-oct2006/evolve.f
< nbody6compare-oct2006/evolve.f
---
> 8856 2005-03-11 16:10 /work/Umi2/spurzem/5/nbody6++compare/evolve.f
> nbody6++compare/evolve.f
7a8
> *
16c17
< *     NBSTAT = NBSTAT + 1
---
>       NBSTAT = NBSTAT + 1
54a56
>       if(rank.eq.0)then
62a65
>       end if
103c106,107
<               WRITE (4,100)  NAME(J), EB, SEMIJ, ECCJ, RIJ, GEFF, P,RDOT
---
>               if(rank.eq.0)
>      &        WRITE (4,100)  NAME(J), EB, SEMIJ, ECCJ, RIJ, GEFF, P,RDOT
125c129
<           WRITE (4,100)  NAME(JMIN), (WORK(K),K=1,7)
---
>           if(rank.eq.0)WRITE (4,100)  NAME(JMIN), (WORK(K),K=1,7)
224c228,229
<               WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
---
>               if(rank.eq.0)
>      &        WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
230c235,236
<               WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
---
>               if(rank.eq.0)
>      &        WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
236c242,243
<               WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
---
>               if(rank.eq.0)
>      &        WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
244c251,252
<               WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
---
>               if(rank.eq.0)
>      &        WRITE (4,50)  LEVEL, TIME, NAME(I), NAME(J2), EB, SEMI,
1,2c1,2
< 1858 2006-09-20 13:48 /work/Umi2/spurzem/5/nbody6compare-oct2006/expand.f
< nbody6compare-oct2006/expand.f
---
> 1859 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/expand.f
> nbody6++compare/expand.f
60a61
> 
1,2c1,2
< 2378 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/extend.f
< nbody6compare-oct2006/extend.f
---
> 2378 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/extend.f
> nbody6++compare/extend.f
1,2c1,2
< 2345 2005-11-01 19:11 /work/Umi2/spurzem/5/nbody6compare-oct2006/fchain.f
< nbody6compare-oct2006/fchain.f
---
> 1636 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/fchain.f
> nbody6++compare/fchain.f
10c10
<       REAL*8  XI(3),XIDOT(3),DX(3),DV(3),FIRR(3),FD(3),XIS(3),VIS(3)
---
>       REAL*8  XI(3),XIDOT(3),DX(3),DV(3),FIRR(3),FD(3)
13,28c13
< *       Use c.m. values for correction of perturbed KS (call from KCPERT).
<       I2 = 0
<       IF (I.LT.IFIRST) THEN
<           IPAIR = KVEC(I)
<           IF (I.EQ.2*IPAIR) I2 = 1
<           ICM = N + IPAIR
< *       Save local variables for individual chain contributions.
<           DO 1 K = 1,3
<               XIS(K) = XI(K)
<               VIS(K) = XIDOT(K)
<               XI(K) = X(K,ICM)
<               XIDOT(K) = XDOT(K,ICM)
<     1     CONTINUE
<       END IF
< *
< *       Evaluate terms for the original chain c.m. interaction.
---
> *       Subtract chain c.m. force from the current value (I =< N).
41c26
< *       Subtract force and first derivative from current values.
---
> *       Subtract force & first derivative.
47,54d31
< *       Restore XI & XIDOT for KS components (perturbed case).
<       IF (I.LT.IFIRST) THEN
<           DO 12 K = 1,3
<               XI(K) = XIS(K)
<               XIDOT(K) = VIS(K)
<    12     CONTINUE
<       END IF
< *
56c33
<       IF (IR.EQ.0.AND.I2.EQ.0) THEN
---
>       IF (IR.EQ.0) THEN
1,2c1,2
< 1132 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/fclose.f
< nbody6compare-oct2006/fclose.f
---
> 1132 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/fclose.f
> nbody6++compare/fclose.f
1,2c1,2
< 1939 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/fcloud.f
< nbody6compare-oct2006/fcloud.f
---
> 1929 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/fcloud.f
> nbody6++compare/fcloud.f
28c28
<               A9 = 3.0*(A(1)*A(4) + A(2)*A(5) + A(3)*A(6))/RIJ2
---
>               A9 = 3.0*(A(1)*A(4) + A(2)*A(5) + A(3)*A(6))
47c47
<               A9 = 3.0*(A(1)*A(4) + A(2)*A(5) + A(3)*A(6))/RIJ2
---
>               A9 = 3.0*(A(1)*A(4) + A(2)*A(5) + A(3)*A(6))
1,2c1,2
< 4247 2006-09-21 13:23 /work/Umi2/spurzem/5/nbody6compare-oct2006/fcorr.f
< nbody6compare-oct2006/fcorr.f
---
> 4229 2000-04-13 20:22 /work/Umi2/spurzem/5/nbody6++compare/fcorr.f
> nbody6++compare/fcorr.f
4,5c4,5
< *       Total force corrections due to masss loss.
< *       ------------------------------------------
---
> *       Total force corrections due to mass loss.
> *       -----------------------------------------
33,34c33,34
< *       Define consistent c.m. variables for KS mass loss (exclude Roche).
<       IF (I.GT.N.AND.KSTAR(I).LE.10) THEN
---
> *       Define consistent c.m. coordinates & velocities for KS mass loss.
>       IF (I.GT.N) THEN
86c86
< *       Use neighbour list of #J to distinguish irregular & regular terms.
---
> *       Use neighbour list to distinguish irregular & regular terms.
88c88
<           DO 25 L = 2,NNB1
---
>           DO 30 L = 2,NNB1
96a97,110
> *       Reduce the step and see whether body #J should be added to NLIST.
> *                 STEP(J) = MAX(0.5D0*STEP(J),TIME - T0(J))
>                   IF (T0(J) + STEP(J).LT.TLIST) THEN
>                       CALL NLMOD(J,1)
>                   END IF
>                   GO TO 40
>               ELSE IF (LIST(L,J).GT.I) THEN
>                   DO 25 K = 1,3
>                       F(K,J) = F(K,J) - 0.5*A(K)*A5
>                       FR(K,J) = FR(K,J) - A(K)*A5
>                       FDOT(K,J) = FDOT(K,J) - ONE6*A(K+3)
>                       D1R(K,J) = D1R(K,J) - A(K+3)
>                       FRDOT(K,J) = FRDOT(K,J) - A(K+3)
>    25             CONTINUE
99,105d112
<    25     CONTINUE      
<           DO 30 K = 1,3
<               F(K,J) = F(K,J) - 0.5*A(K)*A5
<               FR(K,J) = FR(K,J) - A(K)*A5
<               FDOT(K,J) = FDOT(K,J) - ONE6*A(K+3)
<               D1R(K,J) = D1R(K,J) - A(K+3)
<               FRDOT(K,J) = FRDOT(K,J) - A(K+3)
110c117
<       EMDOT = EMDOT - DM*POTJ + 0.5*DM*VI2
---
>       ECDOT = ECDOT - DM*POTJ + 0.5*DM*VI2
112,113c119,120
< *       Modify energy loss further for c.m. body (exclude Roche cases).
<       IF (I.GT.N.AND.KSTAR(I).LE.10) THEN
---
> *       Check energy correction due to velocity kick.
>       IF (I.GT.N.AND.IKICK) THEN
117,119c124,126
< *       See whether linearized tidal terms should be included.
<       IF (KZ(14).GT.0.AND.KZ(14).LT.3) THEN
<           EMDOT = EMDOT - 0.5*DM*(TIDAL(1)*X(1,I)**2 +
---
> *       See whether tidal terms should be included.
>       IF (KZ(14).GT.0) THEN
>           ECDOT = ECDOT - 0.5*DM*(TIDAL(1)*X(1,I)**2 +
123,132d129
< *       Check optional Plummer potential.
<       IF (KZ(14).EQ.4.OR.KZ(14).EQ.3) THEN
<           RI2 = AP2
<           DO 50 K = 1,3
<               RI2 = RI2 + X(K,I)**2
<   50      CONTINUE
<           EMDOT = EMDOT - DM*MP/SQRT(RI2)
<       END IF
< *
< *       Accumulate energy loss for conservation check (not used).
1,2c1,2
< 2177 2004-12-14 09:44 /work/Umi2/spurzem/5/nbody6compare-oct2006/ficorr.f
< nbody6compare-oct2006/ficorr.f
---
> 1862 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/ficorr.f
> nbody6++compare/ficorr.f
42d41
<               FIDOT(K,J) = FIDOT(K,J) - A(K+3)
64,66c63,65
< *       See whether linearized tidal terms should be included.
<       IF (KZ(14).GT.0.AND.KZ(14).LT.3) THEN
<           ECDOT = ECDOT - 0.5*DM*(TIDAL(1)*X(1,I)**2 +
---
> *       See whether tidal terms should be included.
>       IF (KZ(14).GT.0) THEN
>           EMDOT = EMDOT - 0.5*DM*(TIDAL(1)*X(1,I)**2 +
70,78d68
< *       Check optional Plummer potential.
<       IF (KZ(14).EQ.4.OR.KZ(14).EQ.3) THEN
<           RI2 = AP2
<           DO 50 K = 1,3
<               RI2 = RI2 + X(K,I)**2
<   50      CONTINUE
<           ECDOT = ECDOT - DM*MP/SQRT(RI2)
<       END IF
< *
1,2c1,2
< 1607 2006-08-16 10:20 /work/Umi2/spurzem/5/nbody6compare-oct2006/findj.f
< nbody6compare-oct2006/findj.f
---
> 1583 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/findj.f
> nbody6++compare/findj.f
9,10c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
1,2c1,2
< 3932 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/flyby.f
< nbody6compare-oct2006/flyby.f
---
> 3422 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/flyby.f
> nbody6++compare/flyby.f
13c13
<       RJMIN2 = 1000.0
---
>       RJMIN2 = 1.0
76,77d75
<       RJJ = 0.0
<       VJJ = 0.0
80,81d77
<           RJJ = RJJ + (X(K,JCOMP) - X(K,J))**2
<           VJJ = VJJ + (XDOT(K,JCOMP) - XDOT(K,J))**2
98,106d93
< *
< *       Increase the cross section for quadruples.
<       IF (JCOMP.GT.N) THEN
<           SEMI2 = -0.5*BODY(JCOMP)/H(JCOMP-N)
<           APO = APO + ABS(SEMI2)
<       END IF
< *
<       SEMIJ = 2.0/SQRT(RJJ) - VJJ/(BODY(JCOMP) + BODY(J))
<       SEMIJ = 1.0/SEMIJ
109,112d95
<           IF (SEMI.LT.0.0.AND.GAMMA(IPAIR).LT.0.5) THEN
<               ITERM = 0
<               GO TO 20
<           END IF
120a104
> 
1,2c1,2
< 4071 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/fpcorr.f
< nbody6compare-oct2006/fpcorr.f
---
> 4610 2001-08-15 16:39 /work/Umi2/spurzem/5/nbody6++compare/fpcorr.f
> nbody6++compare/fpcorr.f
1c1
<       SUBROUTINE FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT)
---
>       SUBROUTINE FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT,FIRR,FREG,FD,FDR,KLIST)
9c9,10
<      &        A(12),F2DOT(3),F3DOT(4)
---
>      &        A(12),F1DOT(3),F2DOT(3),F3DOT(4)
>       REAL*8 FIRR(3),FREG(3),FD(3),FDR(3),FMPI(3),FDMPI(3)
10a12
>       INTEGER KLIST(LMAX)
12a15,16
>       NNB0 = KLIST(1)
> *
20a25,26
>           FMPI(K) = 0.5D0*(FREG(K) + FIRR(K))
>           FDMPI(K) = ONE6*(FDR(K) + FD(K))
24d29
<       NNB0 = LIST(1,I)
34,35d38
< *
< *       Use c.m. values of XDOT, F & FDOT for single KS components.
36a40
> *       Use c.m. values of XDOT, F & FDOT for single KS components.
38c42
< *         STEPJ = STEP(JCM)
---
>           STEPJ = STEP(JCM)
40c44,45
< *
---
>           S3 = 3.0*S
> *       Predict because we are in parallel section (R.Sp.)
42,45c47,52
<               A(K) = X(K,J) - XI(K)
<               A(K+3) = XDOT(K,J) - XIDOT(K)
<               A(K+6) = 2.0*(F(K,JCM) - F(K,I))
<               A(K+9) = 6.0*(FDOT(K,JCM) - FDOT(K,I))
---
>               A(K) = ((FDOT(K,JCM)*S + F(K,JCM))*S + X0DOT(K,JCM))*S +
>      &                                                 X0(K,JCM) - XI(K)
>               A(K+3) = (FDOT(K,JCM)*S3 + 2.0*F(K,JCM))*S + X0DOT(K,JCM)-
>      &                                                         XIDOT(K)
>               A(K+6) = 2.0*(F(K,JCM) - FMPI(K))
>               A(K+9) = 6.0*(FDOT(K,JCM) - FDMPI(K))
50c57
< *         STEPJ = STEP(J)
---
>           STEPJ = STEP(J)
53,54c60
< *
< *       Predict F & FDOT of body #J to order FDOT.
---
> *       Predict because we are in parallel section (R.Sp.)
56c62,63
<               A(K) = X(K,J) - XI(K)
---
>               A(K) = ((FDOT(K,J)*S + F(K,J))*S + X0DOT(K,J))*S +
>      &                                                 X0(K,J) - XI(K)
59,60c66,67
<               A(K+6) = 2.0*(FDOT(K,J)*S3 + F(K,J) - F(K,I))
<               A(K+9) = 6.0*(FDOT(K,J) - FDOT(K,I))
---
>               A(K+6) = 2.0*(FDOT(K,J)*S3 + F(K,J) - FMPI(K))
>               A(K+9) = 6.0*(FDOT(K,J) - FDMPI(K))
82,83c89
< *       Suppress F1DOT terms (already done in REGINT).
< *         F1DOT(K) = F1DOTK*A14
---
>           F1DOT(K) = F1DOTK*A14
102c108
< *             F1DOT(K) = -F1DOT(K)
---
>               F1DOT(K) = -F1DOT(K)
110c116
< *         SAVE1(K) = SAVE1(K) + F1DOT(K)
---
>           SAVE1(K) = SAVE1(K) + F1DOT(K)
122,123c128
< *       Note that corrected value of D1 & D1R already set in routine REGINT.
< *         D1(K,I) = D1(K,I) + SAVE1(K)
---
>           D1(K,I) = D1(K,I) + SAVE1(K)
125a131
> *       No correction of D1R because it is actually correct from regint.
1,2c1,2
< 896 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/fpert.f
< nbody6compare-oct2006/fpert.f
---
> 896 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/fpert.f
> nbody6++compare/fpert.f
1,2c1,2
< 4267 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/fpoly1.f
< nbody6compare-oct2006/fpoly1.f
---
> 4271 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/fpoly1.f
> nbody6++compare/fpoly1.f
10d9
< *
49a49
> *
94a95
> *
108a110
> *
1,2c1,2
< 4475 2005-02-15 13:21 /work/Umi2/spurzem/5/nbody6compare-oct2006/fpoly2.f
< nbody6compare-oct2006/fpoly2.f
---
> 4474 2002-02-20 13:30 /work/Umi2/spurzem/5/nbody6++compare/fpoly2.f
> nbody6++compare/fpoly2.f
10d9
< *
15a15,17
> *       Include an initial skip for primordial binaries (large derivatives).
> *     IF (NBIN0.GT.0.AND.TIME.EQ.0.0D0) GO TO 80
> *
27,29d28
< *       Include an initial skip for primordial binaries (large derivatives).
<       IF (NBIN0.GT.0.AND.TIME.EQ.0.0D0) GO TO 80
< *
119c118
< *       Advance the neighbour list until last member is identified. 
---
> *       Advance the neighbour list until last member is identified.
125a125
> *
1,2c1,2
< 3429 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/freeze.f
< nbody6compare-oct2006/freeze.f
---
> 3430 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/freeze.f
> nbody6++compare/freeze.f
30c30
< *       Specify regularized time (based on Baumgarte & Stielel, 1974).
---
> *       Specify regularized time (based on Stiefel & Scheifele, p. 85).
1,2c1,2
< 1182 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ghost.f
< nbody6compare-oct2006/ghost.f
---
> 1182 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/ghost.f
> nbody6++compare/ghost.f
1,2c1,2
< 6787 2004-03-08 11:51 /work/Umi2/spurzem/5/nbody6compare-oct2006/gntage.f
< nbody6compare-oct2006/gntage.f
---
> 6789 2003-06-26 01:43 /work/Umi2/spurzem/5/nbody6++compare/gntage.f
> nbody6++compare/gntage.f
228a229,230
> 
> 
1,2c1,2
< 2437 2006-08-16 10:20 /work/Umi2/spurzem/5/nbody6compare-oct2006/hcorr.f
< nbody6compare-oct2006/hcorr.f
---
> 1718 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/hcorr.f
> nbody6++compare/hcorr.f
8,10d7
<       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
21c18
< *       Define c.m. index and old semi-major axis.
---
> *       Define c.m. index and save old elements & reduced mass.
24,45c21,23
< *
< *       Distinguish different cases (KS, triple or outer ghost of quadruple).
<       IF (BODY(I).GT.0.0D0) THEN
<           ZMU0 = BODY(I1)*BODY(I2)/BODY(J)
<       ELSE
<           IM = 0
<           JJ = I
<           IF (I.LT.IFIRST) JJ = N + KVEC(I)
< *       Determine merger index for inner and outer binary masses.
<           DO 1 K = 1,NMERGE
<               IF (NAMEG(K).EQ.NAME(JJ)) IM = K
<     1     CONTINUE
<           IF (IM.EQ.0) THEN
<               WRITE (6,5) NAME(I), NAME(JJ), (NAMEG(K),K=1,NMERGE)
<     5         FORMAT (' DANGER HCORR!    NMI NMJJ NMG ',12I6)
<               STOP
<           END IF
< *       Form old reduced mass from inner and outer binary.
<           ZM1 = CM(1,IM) + CM(2,IM)
<           ZM2 = CM(3,IM) + CM(4,IM)
<           ZMU0 = ZM1*ZM2/BODY(J)
<       END IF
---
> *     ECC2 = (1.0 - R(IPAIR)/SEMI0)**2 + TDOT2(IPAIR)**2/(BODY(J)*SEMI0)
> *     ECC = SQRT(ECC2)
>       ZMU0 = BODY(I1)*BODY(I2)/BODY(J)
52,56c30
<       IF (BODY(I).GT.0.0D0) THEN
<           ZMU1 = (BODY(I1) - DM)*BODY(I2)/BODY(J)
<       ELSE
<           ZMU1 = ZM1*(ZM2 - DM)/BODY(J)
<       END IF
---
>       ZMU1 = (BODY(I1) - DM)*BODY(I2)/BODY(J)
69a44,46
> *       Set new mass temporarily to be consistent with routine EXPAND.
>       BODY(I) = BODY(I) - DM
> *
72a50,52
> *       Restore the component mass here to allow updating in routine MDOT.
>       BODY(I) = BODY(I) + DM
> *
75a56
> 
1,2c1,2
< 9811 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/hiarch.f
< nbody6compare-oct2006/hiarch.f
---
> 9678 2002-06-14 23:09 /work/Umi2/spurzem/5/nbody6++compare/hiarch.f
> nbody6++compare/hiarch.f
17,21d16
< *       Open unit #10 the first time.
<       IF (FIRST) THEN
<           OPEN (UNIT=10,STATUS='NEW',FORM='FORMATTED',FILE='HIARCH')
<           FIRST = .FALSE.
< *
22a18
>       IF (FIRST) THEN
24c20
<               WRITE (10,1)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
---
>               WRITE (12,1)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
37c33
<           WRITE (10,2)
---
>           WRITE (12,2)
41c37
<           WRITE (10,3)
---
>           WRITE (12,3)
200c196
<           WRITE (10,10)  TTOT, SEMI, SEMI1, ECC1, PMIN, TK1, Q,
---
>           WRITE (12,10)  TTOT, SEMI, SEMI1, ECC1, PMIN, TK1, Q,
251c247
<           WRITE (10,20)  TTOT, SQRT(RI)/RC, SEMI, ECC, PMIN, TK1,
---
>           WRITE (12,20)  TTOT, SQRT(RI)/RC, SEMI, ECC, PMIN, TK1,
255c251
<           CALL FLUSH(10)
---
>           CALL FLUSH(12)
280a277,278
> 
> 
1,2c1,2
< 8895 2006-08-16 10:20 /work/Umi2/spurzem/5/nbody6compare-oct2006/hidat.f
< nbody6compare-oct2006/hidat.f
---
> 8391 2002-07-31 07:17 /work/Umi2/spurzem/5/nbody6++compare/hidat.f
> nbody6++compare/hidat.f
9,10c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
12c12
< *     REAL*4  EB(KMAX),ECM(KMAX)
---
>       REAL*4  EB(KMAX),ECM(KMAX)
14c14
<       SAVE  FIRST
---
>       SAVE  FIRST 
17,18c17
< *
< *       Write formatted data bank on unit 87.
---
> *       Write formatted data bank on unit 13.
20d18
<           OPEN (UNIT=87,STATUS='NEW',FORM='FORMATTED',FILE='HIDAT')
22c20
<           WRITE (87,1)
---
>           if(rank.eq.0)WRITE (13,1)
33c31,32
<           WRITE (87,3)  NPAIRS, NRUN, N, NC, NMERGE, MULT, NEWHI, TTOT
---
>           if(rank.eq.0)
>      &    WRITE (13,3)  NPAIRS, NRUN, N, NC, NMERGE, MULT, NEWHI, TIME
39c38
< *     ISTAB = 0
---
>       ISTAB = 0
47d45
<           KCM = KSTARM(IM)
70c68
< *             EB(IPAIR) = CM(1,IM)*CM(2,IM)*HM(IM)/BODYCM
---
>               EB(IPAIR) = CM(1,IM)*CM(2,IM)*HM(IM)/BODYCM
90c88
< *             EB(IPAIR) = CM(1,IM)*CM(2,IM)*HM(IM)/BODYCM
---
>               EB(IPAIR) = CM(1,IM)*CM(2,IM)*HM(IM)/BODYCM
106a105,108
>               Q = BODY(J2)/BODYCM
>               XFAC = (1.0 + Q)*(1.0 + E1)/SQRT(ABS(1.0 - E1))
>               FE = 2.8
>               PCR = FE*XFAC**0.4*SEMI
121d122
<               PCR = stability(M1,M2,M3,E0,E1,ANGLE)*SEMI
123,129c124,132
< *       Perform stability check.
<               IF (PMIN*(1.0 - GAMMA(JPAIR)).LT.PCR.AND.E1.LT.0.96.AND.
<      &            LIST(1,J1).GT.0) THEN
< *                 ISTAB = JPAIR
<                   WRITE (6,20)  NAME(J1), NAME(J), 180.0*ANGLE/3.14, E1,
<      &                          PMIN, PCR, GAMMA(JPAIR), R0(JPAIR)
<    20             FORMAT (' MERGE UNSTAB    NAM INC E1 PM PCR G R0 ',
---
> *       Perform stability check for new inclination (skip quadruples).
>               YF = 1.0 - 0.3*ANGLE/180.0
>               IF (PMIN*(1.0 - GAMMA(JPAIR)).LT.YF*PCR.AND.
>      &            E1.LT.0.96) THEN
>                   ISTAB = JPAIR
>                   if(rank.eq.0)
>      &            WRITE (6,20)  NAME(J1), NAME(J), ANGLE, E1, PMIN,
>      &                          YF*PCR, GAMMA(JPAIR), R0(JPAIR)
>    20             FORMAT (' MERGE UNSTAB    NAM INC E1 PM YF*PCR G R0 ',
130a134
> *                 R0(JPAIR) = 1.1*YF*PCR
140d143
<               KCM = KSTAR(ICM)
142,143c145,146
< *       Locate the first KS component (former c.m. hence subtract NZERO).
<               DO 23 K = 1,IFIRST
---
> *       Locate the massive KS component (former c.m. hence subtract NZERO).
>               DO 24 K = 1,IFIRST
145c148
<    23         CONTINUE
---
>    24         CONTINUE
147,162d149
< *       Include the case of [[B,S],[B,S]] which requires more work.
<               IF (BODY(J).EQ.0.0D0) THEN
<                   JM = 0
<                   DO 24 K = 1,NMERGE
<                       IF (NAMEM(IM).EQ.NAMEG(K)) JM = K
<    24             CONTINUE
<                   IF (JM.EQ.0) GO TO 30
<                   J = 0
< *       Employ new ghost identification to find the corresponding c.m index.
<                   DO 25 K = N+1,NTOT
<                       IF (NAME(K).EQ.NAMEM(JM)) J = K
<    25             CONTINUE
<                   IF (J.EQ.0) GO TO 30
<                   J = 2*(J - N)
< *       Note that both the triple masses (M1,M2) are saved in CM(1->4,JM).
<               END IF
182c169
< *             EB(IPAIR) = BODYJ1*BODYJ2*H(JPAIR)/BODYCM
---
>               EB(IPAIR) = BODYJ1*BODYJ2*H(JPAIR)/BODYCM
190c177
< *       Evaluate the potential energy of c.m.
---
> *       Evaluate the potential energy of c.m..
192,193c179,180
<           DO 26 K = IFIRST,NTOT
<               IF (K.EQ.ICM) GO TO 26
---
>           DO 25 K = IFIRST,NTOT
>               IF (K.EQ.ICM) GO TO 25
197c184
<    26     CONTINUE
---
>    25     CONTINUE
208c195
< *         ECM(IPAIR) = 0.5*VJ2 - PHI
---
>           ECM(IPAIR) = 0.5*VJ2 - PHI
211,212c198,201
<           WRITE (87,28)  NAME(J1), NAM2, NAME(J2), KSTAR(J1), KSTAR(J),
<      &                   KCM, M1, M2, M3, RI, EMAX, E0, E1, P0, P1
---
>           if(rank.eq.0)
>      &    WRITE (13,28)  NAME(J1), NAM2, NAME(J2), KSTAR(J1), KSTAR(J),
>      &                   KSTARM(IM), M1, M2, M3, RI, EMAX, E0, E1,
>      &                   P0, P1
215c204
<       CALL FLUSH(87)
---
>       CALL FLUSH(13)
226a216
> 
1,2c1,2
< 3955 2004-05-11 11:47 /work/Umi2/spurzem/5/nbody6compare-oct2006/himax2.f
< nbody6compare-oct2006/himax2.f
---
> 4174 2001-05-20 16:20 /work/Umi2/spurzem/5/nbody6++compare/himax2.f
> nbody6++compare/himax2.f
4c4
< *       Maximum eccentricity of inner hierarchical binary.
---
> *       Maximum eccentricity of outer hierarchical binary.
8c8,12
<       REAL*8  A1(3),A2(3),XREL(3),VREL(3),EI(3),HI(3),HO(3),BHAT(3)
---
>       COMMON/BINARY/  CM(4,MMAX),YREL(3,MMAX),ZREL(3,MMAX),
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       REAL*8  A1(3),A2(3),XREL(3),VREL(3),EI(3),HI(3),HO(3),BHAT(3),
>      &        EVEC(3)
26c30
<       A12 = 0.0
---
>     4 A12 = 0.0
54c58
< *       Construct the Runge-Lenz vector (Heggie & Rasio 1995, IAU174, Eq.5).
---
> *       Construct the Runge-Lenz vector (Heggie & Rasio 1995, Eq.(5)).
59a64
>           EVEC(K) = EI(K)
1,2c1,2
< 4435 2006-08-16 10:21 /work/Umi2/spurzem/5/nbody6compare-oct2006/himax.f
< nbody6compare-oct2006/himax.f
---
> 4303 1999-12-23 13:14 /work/Umi2/spurzem/5/nbody6++compare/himax.f
> nbody6++compare/himax.f
10c10
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
---
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAGM(MMAX)
12c12
<      &        UI(4),V(4)
---
>      &        UI(4),V(4),EVEC(3)
31,35d30
< *       Ensure that unperturbed binary is resolved.
<       IF (LIST(1,2*IPAIR-1).EQ.0.OR.X(1,JCOMP).EQ.X(1,I)) THEN
<           CALL RESOLV(IPAIR,1)
<       END IF
< *
37c32
<       A12 = 0.0
---
>     4 A12 = 0.0
68c63
< *       Construct the Runge-Lenz vector (Heggie & Rasio 1995, IAU174, Eq.5).
---
> *       Construct the Runge-Lenz vector (Heggie & Rasio 1995, Eq.(5)).
73a69
>           EVEC(K) = EI(K)
1,2c1,2
< 5187 2005-08-17 16:44 /work/Umi2/spurzem/5/nbody6compare-oct2006/hipop.f
< nbody6compare-oct2006/hipop.f
---
> 5039 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/hipop.f
> nbody6++compare/hipop.f
0a1,4
> # 1 "hipop.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "hipop.F"
4,5c8,9
< *       Initial hierarchical population.
< *       --------------------------------
---
> * Initial hierarchical population.
> * --------------------------------
8,16c12,24
<       REAL*8  XORB(2),VORB(2),XREL(3),VREL(3),PX(3),QX(3),
<      &        BS(MMAX),XS(3,MMAX),VS(3,MMAX)
<       REAL*4  RAN2
< *
< *
< *       Read input parameters (same usage as routine BINPOP).
<       READ (5,*)  SEMI0, ECC0, RATIO, RANGE, ICIRC
<       NHI = NHI0
<       WRITE (6,1)  NHI, SEMI0, ECC0, RATIO, RANGE, ICIRC
---
>       REAL*8 XORB(2),VORB(2),XREL(3),VREL(3),PX(3),QX(3),
>      & BS(MMAX),XS(3,MMAX),VS(3,MMAX)
>       REAL*4 RAN2
> *
> # 21 "hipop.F"
> * recover random number sequence from COMMON variable IDUM1.
>       KDUM = IDUM1
> *
> * Read input parameters (same usage as routine BINPOP).
>       if(rank.eq.0)READ (5,*) NHI, SEMI0, ECC0, RATIO, RANGE, ICIRC
> # 34 "hipop.F"
>       NHI0 = NHI
>       WRITE (6,1) NHI, SEMI0, ECC0, RATIO, RANGE, ICIRC
18,19c26,27
<      &              '  E =',F6.2,'  RATIO =',F4.1,'  RANGE =',F6.1,
<      &              '  ICIRC =',I2,/)
---
>      & '  E =',F6.2,'  RATIO =',F4.1,'  RANGE =',F6.1,
>      & '  ICIRC =',I2,/)
22,23c30,31
<           WRITE (6,2)  NBIN0, NHI
<     2     FORMAT (5X,'FATAL ERROR!   NBIN0 =',I4,'  NHI =',I4)
---
>           WRITE (6,2) NBIN0, NHI
>     2 FORMAT (5X,'FATAL ERROR!   NBIN0 =',I4,'  NHI =',I4)
27c35
< *       Introduce binary components by splitting the primary.
---
> * Introduce binary components by splitting the primary.
30,33c38,41
< *       Randomize perihelion, node & inclination.
<           PI = TWOPI*RAN2(IDUM1)
<           OMEGA = TWOPI*RAN2(IDUM1)
<           ZI = 0.5*TWOPI*RAN2(IDUM1)
---
> * Randomize perihelion, node & inclination.
>           PI = TWOPI*RAN2(KDUM)
>           OMEGA = TWOPI*RAN2(KDUM)
>           ZI = 0.25*TWOPI*RAN2(KDUM)
35c43
< *       Set transformation elements (Brouwer & Clemence p. 35).
---
> * Set transformation elements (Brouwer & Clemence p. 35).
41c49
<           QX(3) = COS(PI)*SIN(ZI) 
---
>           QX(3) = COS(PI)*SIN(ZI)
43c51
< *       Determine two-body elements for original binary.
---
> * Determine two-body elements for original binary.
55c63
<     5     CONTINUE
---
>     5 CONTINUE
64,65c72,73
< *       Specify component masses (primary fraction range 0.5 - 0.9).
<           Q0 = 0.5 + 0.4*RAN2(IDUM1)
---
> * Specify component masses (primary fraction range 0.5 - 0.9).
>           Q0 = 0.5 + 0.4*RAN2(KDUM)
72c80
< *       Choose random (thermalized) or fixed eccentricity.
---
> * Choose random (thermalized) or fixed eccentricity.
74c82
<               ECC2 = RAN2(IDUM1)
---
>               ECC2 = RAN2(KDUM)
80c88
< *       Select semi-major axis from uniform distribution in log(A) or SEMI0.
---
> * Select semi-major axis from uniform distribution in log(A) or SEMI0.
82,89c90,92
<    10     IF (RANGE.GT.0.0) THEN
<               IF (ITER.LE.5) THEN
<                   EXP = RAN2(IDUM1)*LOG10(RANGE)
<                   SEMI = SEMI1/10.0**EXP
<               ELSE
< *       Shrink by factor 2 if no success after 5 iterations.
<                   SEMI = 0.5*SEMI
<               END IF
---
>    10 IF (RANGE.GT.0.0) THEN
>               EXP = RAN2(KDUM)*LOG10(RANGE)
>               SEMI = SEMI0/10.0**EXP
94,96c97,101
< *       Check stability criterion (maximum 12 tries with inclination effect).
<           PCRIT = stability(BODY(I1),BODY(I2),BS(I),ECC,ECC1,ZI)
<           PCRIT = PCRIT*SEMI
---
> * Check standard stability criterion (maximum of 10 tries).
>           Q0 = BS(I)/ZMB
>           XFAC = (1.0 + Q0)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
>           FE = 1.0
>           PCRIT = 2.8*FE*XFAC**0.4*SEMI
98c103
<           IF (PMIN.LT.PCRIT.AND.ITER.LE.12.AND.SEMI.LT.SEMI0) GO TO 10
---
>           IF (PMIN.LT.PCRIT.AND.ITER.LT.10) GO TO 10
102,104c107,109
<           WRITE (6,20)  ITER, ECC, ECC1, PMIN, PCRIT, P0, P1
<    20     FORMAT (' HIERARCHY:    IT E E1 PMIN PCRIT P0 P1 ',
<      &                            I4,2F7.3,1P,4E9.1)
---
>           WRITE (6,20) ITER, ECC, ECC1, PMIN, PCRIT, P0, P1
>    20 FORMAT (' HIERARCHY:    IT E E1 PMIN PCRIT P0 P1 ',
>      & I4,2F7.3,1P,4E9.1)
106c111
< *       Specify relative motion at apocentre and sum binding energy.
---
> * Specify relative motion at apocentre and sum binding energy.
113c118
< *       Transform to relative variables.
---
> * Transform to relative variables.
117c122
<    25     CONTINUE
---
>    25 CONTINUE
119c124
< *       Save old secondary and set global variables for each component.
---
> * Save old secondary and set global variables for each component.
127c132
<    30     CONTINUE
---
>    30 CONTINUE
130c135
< *       Move single particles down by NHI to make room for outer components.
---
> * Move single particles down by NHI to make room for outer components.
138c143
<    45     CONTINUE
---
>    45 CONTINUE
142c147
< *       Place hierarchical components immediately after the binaries.
---
> * Place hierarchical components immediately after the binaries.
149c154
<    55     CONTINUE
---
>    55 CONTINUE
152c157
< *       Update the particle number and reset NHI (might be used elsewhere).
---
> * Update the particle number.
156c161,163
<       NHI = 0
---
> *
> * Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
1,2c1,2
< 3490 2005-03-08 19:23 /work/Umi2/spurzem/5/nbody6compare-oct2006/histab.f
< nbody6compare-oct2006/histab.f
---
> 2790 2003-06-23 19:31 /work/Umi2/spurzem/5/nbody6++compare/histab.f
> nbody6++compare/histab.f
16c16
< *       Evaluate semi-major axis & eccentricity of inner binary.
---
> *       Set semi-major axis & eccentricity of inner binary.
18,19c18,19
<       ECC2 = (1.0D0 - R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
<       ECC = SQRT(ECC2)
---
> *     ECC2 = (1.0D0 - R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
> *     ECC = SQRT(ECC2)
26c26
< *       Note sign error in third term of Eq. (2).
---
> *       Note sign error in third term of their Eq. (2).
44c44
< *       Exit on hyperbolic orbit.
---
> *       Terminate on hyperbolic orbit.
50a51
> *       Obtain outer pericentre (needed in routine UNPERT).
56c57
< *       Evaluate the basic stability condition without fudge factor.
---
> *       Evaluate the stability formula without fudge factor.
58a60
> *       ZFAC = (1.0 + ECC1)/(1.0 - ECC1)**0.182*(1.0 + Q)/(1.0 + ECC)**3
61c63
<           XFAC = 40.0*(1.0 + Q)
---
>           XFAC = 1.0 + Q
63c65,67
<       PCRIT = 2.8*XFAC**0.4*SEMI
---
> *     PCRIT = 2.6*ZFAC**0.355*SEMI*(1.0 + ECC)
>       FE  = 1.0
>       PCRIT = 2.8*FE*XFAC**0.4*SEMI
65,68c69,71
< *       Exit if stability value falls outside practical limits.
<       IF ((PCRIT.GT.1.5*PMIN.OR.PCRIT.LT.0.5*PMIN).AND.J.LE.N) THEN
<           RSTAB = PCRIT
<           GO TO 20
---
> *       Resolve weakly perturbed binary (NB! also X(K,I1) = X(K,I2)).
>       IF (GAMMA(IPAIR).LT.GMIN.OR.X(1,I1).EQ.X(1,I2)) THEN
>           CALL RESOLV(IPAIR,1)
71,87c74,84
< *       Choose the most active triple in case of two binaries.
<       IF (J.GT.N) THEN
<           SEMI2 = -0.5D0*BODY(J)/H(J-N)
< *       Adopt 10% fudge factor with linear dependence on smallest ratio.
<           YFAC = 1.0 + 0.1*MIN(SEMI2/SEMI,SEMI/SEMI2)
<           IF (SEMI2.GT.SEMI) THEN
<               ECC2 = (1.0 - R(J-N)/SEMI2)**2 +
<      &                             TDOT2(J-N)**2/(BODY(J)*SEMI2)
<               ECC = SQRT(ECC2)
<               SEMIZ = SEMI2
<               SEMI2 = SEMI
<               SEMI = SEMIZ
<               IPAIR = J - N
<               I1 = 2*IPAIR - 1
<               I2 = I1 + 1
<               J = I
<           END IF
---
> *       Determine inclination for triple configuration.
>       IF (J.LE.N) THEN
>           DO 10 K = 1,3
>               XX(K,1) = X(K,I1)
>               XX(K,2) = X(K,I2)
>               XX(K,3) = X(K,J)
>               VV(K,1) = XDOT(K,I1)
>               VV(K,2) = XDOT(K,I2)
>               VV(K,3) = XDOT(K,J)
>    10     CONTINUE
>           CALL INCLIN(XX,VV,X(1,I),XDOT(1,I),ANGLE)
89,94c86
<           YFAC = 1.0
<       END IF
< *
< *       Resolve weakly perturbed binary (prevent X(K,I1) = X(K,I2)).
<       IF (GAMMA(IPAIR).LT.GMIN.OR.X(1,I1).EQ.X(1,I2)) THEN
<           CALL RESOLV(IPAIR,1)
---
>           ANGLE = 0.0
97,112c89,92
< *       Determine inclination for triple configuration (NB! radians).
<       DO 10 K = 1,3
<           XX(K,1) = X(K,I1)
<           XX(K,2) = X(K,I2)
<           XX(K,3) = X(K,J)
<           VV(K,1) = XDOT(K,I1)
<           VV(K,2) = XDOT(K,I2)
<           VV(K,3) = XDOT(K,J)
<   10  CONTINUE
<       CALL INCLIN(XX,VV,X(1,I),XDOT(1,I),ANGLE)
< *
< *       Employ the improved stability criterion for doubtful cases.
<       RSTAB = stability(BODY(I1),BODY(I2),BODY(J),ECC,ECC1,ANGLE)*SEMI
< *       Note: the present stability routine includes inclination!
< *     RSTAB = YFAC*RSTAB
<       PCRIT = RSTAB
---
> *       Include fudge factor in the stability condition.
>       YFAC = 1.0 - 0.3*ANGLE/180.0
>       PCRIT = YFAC*PCRIT
>       RSTAB = PCRIT
116a97,98
> 
> 
1,2c1,2
< 5691 2004-09-16 13:29 /work/Umi2/spurzem/5/nbody6compare-oct2006/hivel.f
< nbody6compare-oct2006/hivel.f
---
> 3618 2001-08-06 16:36 /work/Umi2/spurzem/5/nbody6++compare/hivel.f
> nbody6++compare/hivel.f
10c10
< *       Copy membership and add 1 for analogy with HARP/GRAPE.
---
> *       Copy membership and add 1 for analogy with HARP.
34c34,35
<               WRITE (29,3)  LI, NAME(LI), SQRT(RL2), SQRT(VL2)
---
>               if(rank.eq.0)
>      &        WRITE (29,3)  LI, NAME(LI), SQRT(RL2), SQRT(VL2)
36d36
<               CALL FLUSH(29)
71,72c71
< *       Add any new high-velocity particles (save F**2 > N & STEP < DTMIN).
<       NHV = 0
---
> *       Add any new high-velocity particles (skip F**2 > N & STEP < DTMIN).
74a74,76
> *       Adopt geometric mean of close encounter and core mass force.
>           IF (FI2.GT.FLOAT(N).OR.STEP(I).LT.DTMIN.OR.
>      &        STEPR(I).LT.20.0*DTMIN) GO TO 10
78,87c80
< *       Form a list of recently ejected candidates.
<           IF (FI2.GT.FLOAT(N).OR.STEP(I).LT.DTMIN.OR.
<      &        STEPR(I).LT.20.0*DTMIN) THEN
<               IF (VI2.GT.VMAX2) THEN
<                   NHV = NHV + 1
<                   JLIST(NHV) = I
<               END IF
<               GO TO 10
<           END IF
<           IF (VI2.GT.VMAX2.AND.RI2.LT.4.0*RSCALE**2) THEN
---
>           IF (VI2.GT.VMAX2.AND.RI2.LT.9.0*RSCALE**2) THEN
97c90,91
<               WRITE (29,9)  TIME+TOFF, NHI-1, I, NAME(I), KSTAR(I),
---
>               if(rank.eq.0)
>      &        WRITE (29,9)  TIME+TOFF, NHI, I, NAME(I), KSTAR(I),
101d94
<               CALL FLUSH(29)
105,153d97
< *       Consider single fast particle or hyperbolic two-body motion.
<       IF ((NHV.EQ.1.OR.NHV.EQ.2).AND.NHI.LE.MLV-NHV) THEN
< *       Compare any candidates with existing members.
<           DO 20 K = 1,NHV
<               DO 15 L = 2,NHI
<                   IF (JLIST(K).EQ.LISTV(L)) GO TO 30
<    15         CONTINUE
<    20     CONTINUE
<           I1 = JLIST(1)
< *       Include single particles without further tests.
<           IF (NHV.EQ.1) THEN
<               NHI = NHI + 1
<               LISTV(1) = LISTV(1) + 1
<               NFAST = NFAST + 1
<               LISTV(NHI) = I1
<               VI2 = X0DOT(1,I1)**2 + X0DOT(2,I1)**2 + X0DOT(3,I1)**2
<               WRITE (29,22)  TTOT, NHI-1, NAME(I1), IPHASE, SQRT(VI2),
<      &                       STEP(I1)
<    22         FORMAT (' HIVEL ADD    T NHI NM IPH VI DT ',
<      &                               F10.4,I4,I6,I4,F6.1,1P,E10.2)
<               GO TO 30
<           END IF
< *       Evaluate two-body energy.
<           I2 = JLIST(2)
<           RIJ2 = 0.0
<           VIJ2 = 0.0
<           RDOT = 0.0
<           DO 25 K = 1,3
<               RIJ2 = RIJ2 + (X(K,I1) - X(K,I2))**2
<               VIJ2 = VIJ2 + (XDOT(K,I1) - XDOT(K,I2))**2
<               RDOT = RDOT + (X(K,I1) - X(K,I2))*(XDOT(K,I1)-XDOT(K,I2))
<    25     CONTINUE
<           RIJ = SQRT(RIJ2)
<           SEMI = 2.0/RIJ - VIJ2/(BODY(I1) + BODY(I2))
< *       Accept outwards hyperbolic motion arising from recent interaction.
<           IF (SEMI.LT.0.0.AND.RIJ.LT.10.0*RMIN.AND.RDOT.GT.0.0) THEN
<               NHI = NHI + 1
<               LISTV(NHI) = I1
<               NHI = NHI + 1
<               LISTV(NHI) = I2
<               LISTV(1) = LISTV(1) + 2
<               NFAST = NFAST + 2
<               WRITE (29,28) TTOT, NHI-1, NAME(I1), NAME(I2), IPHASE, RIJ
<    28         FORMAT (' HIVEL ADD    T NHI NM IPH RIJ ',
<      &                               F12.4,I4,2I6,I4,1P,E10.2)
<           END IF
<       END IF
< *
<    30 CONTINUE
161a106
> 
1,2c1,2
< 5615 2006-09-01 12:01 /work/Umi2/spurzem/5/nbody6compare-oct2006/hmdot2.f
< nbody6compare-oct2006/hmdot2.f
---
> 5081 2002-06-12 23:18 /work/Umi2/spurzem/5/nbody6++compare/hmdot2.f
> nbody6++compare/hmdot2.f
1c1
<       SUBROUTINE HMDOT2(J,IGHOST,IMERGE,M1,KW,MC,DMS,RNEW,ITERM)
---
>       SUBROUTINE HMDOT2(IGHOST,IMERGE,M1,KW,MC,DMS,RNEW,ITERM)
9,11c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAGM(MMAX)
<       REAL*8  BODYI(2),W(2)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
23a23,26
> *       Decide which component needs updating by comparing evolution times.
>       J = I1
>       IF (TEV(I2).LT.TEV(J)) J = I2
> *
26,29c29,30
< *     IF (RADIUS(J)*SU.GT.500.0) IQUIT = .TRUE.
< *     IF (BODY0(J)*ZMBAR.GT.15.0.AND.KSTAR(J).GE.4) IQUIT = .TRUE.
< *     IF (ABS(M1 - MC).LT.0.1*M1.OR.MC.GT.1.4) IQUIT = .TRUE.
< *     IF (BODY0(J)*ZMBAR - M1.GT.0.5*M1) IQUIT = .TRUE.
---
>       IF (RADIUS(J)*SU.GT.500.0) IQUIT = .TRUE.
>       IF (BODY0(J)*ZMBAR.GT.15.0.AND.KSTAR(J).GE.4) IQUIT = .TRUE.
31,32c32
< *     IF (KSTAR(IGHOST).LT.0.OR.BODY(ICM).EQ.0.0D0) IQUIT = .TRUE.
<       IF (BODY(ICM).EQ.0.0D0) IQUIT = .TRUE.
---
>       IF (KSTAR(IGHOST).LT.0.OR.BODY(ICM).EQ.0.0D0) IQUIT = .TRUE.
34c34
< *       Quit for mis-identification or advanced evolution.
---
> *       Quit for mis-identification, tidal evolution or double hierarchy.
53,54c53,54
< *       Skip further modifications on zero mass loss of same type.
<       IF (ABS(DMS/M1).EQ.0.0D0.AND.KW.EQ.KSTAR(J)) GO TO 50
---
> *       Skip further modifications on small mass loss of same type.
>       IF (ABS(DMS/M1).LT.0.01.AND.KW.EQ.KSTAR(J)) GO TO 50
65a66
>       Q = BODY(2*IPAIR-1)/ZMB
69,83c70,72
< *       Evaluate old separation, square regularized velocity, t'' & ECC.
<       RI = 0.0D0
<       V20 = 0.0
<       TD2 = 0.0
<       DO 10 K = 1,4
<           RI = RI + U(K,JPAIR)**2
<           V20 = V20 + UDOT(K,JPAIR)**2
<           TD2 = TD2 + 2.0*U(K,JPAIR)*UDOT(K,JPAIR)
<    10 CONTINUE
<       ECC2 = (1.0 - RI/SEMI0)**2 + TD2**2/(SEMI0*ZMB0)
<       ECC = SQRT(ECC2)
< *
< *       Obtain stability parameters for the new configuration.
<       PCRIT = stability(CM(3,IMERGE),CM(4,IMERGE),BODY(2*IPAIR-1),ECC,
<      &                                              ECC1,0.0D0)*SEMI2
---
> *       Obtain stability parameters of the new configuration.
>       XFAC = (1.0 + Q)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
>       PCRIT = 2.8*XFAC**0.4*SEMI2
94,112c83,100
< *       Check for possible circularization (tidal or sequential).
<       RP = SEMI0*(1.0 - ECC)
<       IF (KZ(27).GT.0.AND.RP.LT.4.0*RADIUS(J).AND.ECC.GT.0.002) THEN
<           TC = 1.0D+10
<           IF (KZ(27).EQ.2) THEN
<               J1 = 2*JPAIR - 1
<               J2 = J1 + 1
<               DO 14 K = 1,2
<                   BODYI(K) = CM(K+2,IMERGE)
<    14         CONTINUE
<               TG = 1.0
< *       Evaluate the circularization time.
<               CALL HICIRC(RP,ECC,J1,J2,BODYI,TG,TC,EC,ED,W)
<               IF (TC.GT.2000) GO TO 18
<           END IF
<           WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), ECC, DMS,
<      &                  RP, RADIUS(J), TC
<    15     FORMAT (' HMDOT2 TERM    NM K* E DM RP R* TC ',
<      &                             I6,2I4,F8.4,F7.3,1P,3E10.2)
---
> *       Evaluate old separation, square regularized velocity & t''.
>       RI = 0.0D0
>       V20 = 0.0
>       TD2 = 0.0
>       DO 10 K = 1,4
>           RI = RI + U(K,JPAIR)**2
>           V20 = V20 + UDOT(K,JPAIR)**2
>           TD2 = TD2 + 2.0*U(K,JPAIR)*UDOT(K,JPAIR)
>    10 CONTINUE
> *
> *       Check condition for sequential circularization.
>       ECC2 = (1.0 - RI/SEMI0)**2 + TD2**2/(SEMI0*ZMB0)
>       RP = SEMI0*(1.0 - SQRT(ECC2))
>       IF (KZ(27).GT.0.AND.RP.LT.4.0*RADIUS(J)) THEN
>           if(rank.eq.0)
>      *    WRITE (6,15)  NAME(J), KSTAR(J), KSTAR(IGHOST), SQRT(ECC2),
>      &                  RP, RADIUS(J)
>    15     FORMAT (' HMDOT2 TERM   NAM K* E RP R*',I6,2I4,F8.4,1P,2E10.2)
118c106
<    18 DH = DM/SEMI0*(1.0 - 0.5*DM/ZMB0)
---
>       DH = DM/SEMI0*(1.0 - 0.5*DM/ZMB0)
151,153c139,142
< *       Print some diagnostics on non-zero mass loss.
<       IF (DMS.GT.1.0D-03) THEN
<           WRITE (6,30)  NAME(J), KSTAR(J), IMERGE, KM, M1, DMS, PMIN,
---
> *       Print some diagnostics on significant mass loss.
>       IF (DMS.GT.0.005*M1) THEN
>           if(rank.eq.0)
>      *    WRITE (6,30)  NAME(J), KSTAR(J), IMERGE, KM, M1, DMS, PMIN,
156c145
<      &                        I6,3I4,F6.2,1P,7E10.2,0P,F10.6)
---
>      &                        I6,3I4,2F6.2,1P,6E10.2,0P,F10.6)
161a151,152
> 
> 
1,2c1,2
< 6110 2006-09-01 12:02 /work/Umi2/spurzem/5/nbody6compare-oct2006/hmdot.f
< nbody6compare-oct2006/hmdot.f
---
> 4634 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/hmdot.f
> nbody6++compare/hmdot.f
1c1
<       SUBROUTINE HMDOT(J,IMERGE,M1,KW,MC,DMS,RNEW,ITERM)
---
>       SUBROUTINE HMDOT(IGHOST,IMERGE,M1,KW,MC,DMS,RNEW,ITERM)
9,11c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAGM(MMAX)
<       REAL*8  BODYI(2),W(2)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
21a21,24
> *       Decide which component needs updating by comparing evolution times.
>       J = IGHOST
>       IF (TEV(I1).LT.TEV(J)) J = I1
> *
24,27d26
< *     IF (RADIUS(J)*SU.GT.500.0) IQUIT = .TRUE.
< *     IF (BODY0(J)*ZMBAR.GT.15.0.AND.KSTAR(J).GE.4) IQUIT = .TRUE.
< *     IF (ABS(M1 - MC).LT.0.1*M1.OR.MC.GT.1.4) IQUIT = .TRUE.
< *     IF (BODY0(J)*ZMBAR - M1.GT.0.5*M1) IQUIT = .TRUE.
29,30c28
< *     IF (KSTARM(IMERGE).LT.0.OR.BODY(ICM).EQ.0.0D0) IQUIT = .TRUE.
<       IF (BODY(ICM).EQ.0.0D0) IQUIT = .TRUE.
---
>       IF (KSTARM(IMERGE).LT.0) IQUIT = .TRUE.
32c30
< *       Quit for mis-identification, advanced evolution or double merger.
---
> *       Quit for mis-identification or advanced evolution.
46,47c44,45
< *       Skip further modifications on zero mass loss of same type.
<       IF (ABS(DMS/M1).EQ.0.0D0.AND.KW.EQ.KSTAR(J)) GO TO 50
---
> *       Skip further modifications on small mass loss of same type.
>       IF (ABS(DMS/M1).LT.0.01.AND.KW.EQ.KSTAR(J)) GO TO 50
58a57
>       Q = BODY(2*IPAIR)/ZMB
62,76d60
< *       Evaluate old separation, square regularized velocity, t'' & ECC.
<       RI = 0.0D0
<       V20 = 0.0
<       TD2 = 0.0
<       DO 10 K = 1,4
<           RI = RI + UM(K,IMERGE)**2
<           V20 = V20 + UMDOT(K,IMERGE)**2
<           TD2 = TD2 + 2.0*UM(K,IMERGE)*UMDOT(K,IMERGE)
<    10 CONTINUE
<       ECC2 = (1.0 - RI/SEMI0)**2 + TD2**2/(SEMI0*ZMB0)
<       ECC = SQRT(ECC2)
< *
< *       Determine inclination (use #I1 as first KS component).
<       CALL HIMAX(I1,IMERGE,ECC,SEMI0,EMAX,EMIN,ZI,TG,EDAV)
< *
78,79c62,63
<       PCRIT = stability(CM(1,IMERGE),CM(2,IMERGE),BODY(2*IPAIR),ECC,
<      &                                            ECC1,ZI)*SEMI2
---
>       XFAC = (1.0 + Q)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
>       PCRIT = 2.8*XFAC**0.4*SEMI2
90,117c74,91
< *       Check for possible circularization (tidal or sequential).
<       RP = SEMI0*(1.0 - ECC)
<       IF (KZ(27).GT.0.AND.RP.LT.4.0*RADIUS(J).AND.ECC.GT.0.002.AND.
<      &    KSTARM(IMERGE).GE.0) THEN
<           TC = 1.0D+10
<           IF (KZ(27).EQ.2) THEN
<               I2 = 0
< *       Identify the ghost by searching single bodies.
<               DO 12 K = IFIRST,N
<                   IF (BODY(K).EQ.0.0D0.AND.
<      &                NAME(K).EQ.NAMEG(IMERGE)) THEN
<                       I2 = K
<                   END IF
<    12         CONTINUE
<               IF (I2.GT.0) THEN
<                   DO 14 K = 1,2
<                       BODYI(K) = CM(K,IMERGE)
<    14             CONTINUE
<                   TG = 1.0
< *       Evaluate the circularization time.
<                   CALL HICIRC(RP,ECC,I1,I2,BODYI,TG,TC,EC,ED,W)
<                   IF (TC.GT.2000) GO TO 18
<               END IF
<           END IF
<           WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), ECC, DMS,
<      &                  RP, RADIUS(J), TC
<    15     FORMAT (' HMDOT TERM    NAM K* E DM RP R* TC ',
<      &                            I6,2I4,F8.4,F7.3,1P,3E10.2)
---
> *       Evaluate old separation, square regularized velocity & t''.
>       RI = 0.0D0
>       V20 = 0.0
>       TD2 = 0.0
>       DO 10 K = 1,4
>           RI = RI + UM(K,IMERGE)**2
>           V20 = V20 + UMDOT(K,IMERGE)**2
>           TD2 = TD2 + 2.0*UM(K,IMERGE)*UMDOT(K,IMERGE)
>    10 CONTINUE
> *
> *       Check condition for likely tidal dissipation (TCIRC not possible).
>       ECC2 = (1.0 - RI/SEMI0)**2 + TD2**2/(SEMI0*ZMB0)
>       RP = SEMI0*(1.0 - SQRT(ECC2))
>       IF (KZ(27).GT.1.AND.RP.LT.3.0*RADIUS(J).AND.
>      &    KSTARM(IMERGE).EQ.0) THEN
>           WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), SQRT(ECC2),
>      &                  RP, RADIUS(J)
>    15     FORMAT (' HMDOT TERM    NAM K* E RP R*',I6,2I4,F8.4,1P,2E10.2)
120,126d93
<       ELSE IF (ECC.GT.0.002) THEN
<           IF (RP.LT.2.0*RADIUS(J)) THEN
<               WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), ECC, DMS,
<      &                      RP, RADIUS(J)
<               ITERM = 1
<               GO TO 50
<           END IF
130c97
<    18 DH = DM/SEMI0*(1.0 - 0.5*DM/ZMB0)
---
>       DH = DM/SEMI0*(1.0 - 0.5*DM/ZMB0)
162,168c129,133
< *       Print some diagnostics on non-zero mass loss.
<       IF (DMS.GT.1.0D-03) THEN
<           WRITE (6,30)  NAME(J), KSTAR(J), IMERGE, KM, M1, DMS, PMIN,
<      &                  PCRIT, SEMI2, SEMI1, DECORR
<    30     FORMAT (' HMDOT    NAM K* IM KM M1 DM PM PC A A1 DE ',
<      &                       I6,3I4,F6.2,1P,5E10.2,0P,F10.6)
<       END IF
---
> *       Print some diagnostics.
>       WRITE (6,30)  NAME(J), KSTAR(J), IMERGE, KM, M1, DMS, PMIN, PCRIT,
>      &              SEMI2, SEMI1, DECORR
>    30 FORMAT (' HMDOT    NAM K* IM KM M1 DM PM PC A A1 DE ',
>      &                   I6,3I4,2F6.2,1P,4E10.2,0P,F10.6)
172a138
> 
1,2c1,2
< 1593 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/hotsys.f
< nbody6compare-oct2006/hotsys.f
---
> 1584 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/hotsys.f
> nbody6++compare/hotsys.f
0a1,4
> # 1 "hotsys.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "hotsys.F"
4,5c8,9
< *       Hot initial system.
< *       -------------------
---
> * Hot initial system.
> * -------------------
8a13
> # 18 "hotsys.F"
10c15
< *       Determine the rms velocity from current kinetic energy.
---
> * Determine the rms velocity from current kinetic energy.
15c20
<     5     CONTINUE
---
>     5 CONTINUE
19c24
< *       Define GM & PC in cgs units and form velocity scale in km/sec.
---
> * Define GM & PC in cgs units and form velocity scale in km/sec.
24c29
< *       Ensure ZMBAR & RBAR > 0 (=0: assume <M>/Sun = 1, RBAR = 1 pc).
---
> * Ensure ZMBAR & RBAR > 0 (=0: assume <M>/Sun = 1, RBAR = 1 pc).
28c33
< *       Scale to working units of RBAR in pc & ZMBAR in solar masses.
---
> * Scale to working units of RBAR in pc & ZMBAR in solar masses.
31,32c36,40
< *       Read central velocity dispersion and form scaling factor.
<       READ (5,*)  SIGMA0
---
> * Read central velocity dispersion and form scaling factor.
>       if(rank.eq.0)READ (5,*) SIGMA0
> 
> 
> 
35c43
< *       Scale the velocities to central velocity dispersion of SIGMA0 km/sec.
---
> * Scale the velocities to central velocity dispersion of SIGMA0 km/sec.
40c48
<    15     CONTINUE
---
>    15 CONTINUE
43c51
< *       Rescale crossing time, output times & termination time.
---
> * Rescale crossing time, output times & termination time.
52c60
<       WRITE (6,30)  SIGMA0, VRMS, VSCALE
---
>       WRITE (6,30) SIGMA0, VRMS, VSCALE
54c62
<      &                                              '  VSCALE =',F6.3,/)
---
>      & '  VSCALE =',F6.3,/)
1,2c1,2
< 972 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/hpsort.f
< nbody6compare-oct2006/hpsort.f
---
> 972 2005-03-11 11:18 /work/Umi2/spurzem/5/nbody6++compare/hpsort.f
> nbody6++compare/hpsort.f
1,2c1,2
< 23146 2006-08-16 10:17 /work/Umi2/spurzem/5/nbody6compare-oct2006/hrdiag.f
< nbody6compare-oct2006/hrdiag.f
---
> 19188 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/hrdiag.f
> nbody6++compare/hrdiag.f
3c3
<      &                  r,lum,kw,mc,rc,menv,renv,k2)
---
>      &                  r,lum,kw,mc,rc)
6,7c6,7
< *       H-R diagram for population I stars.
< *       -----------------------------------
---
> *       H-R diagram for stars of different metallicity.
> *       -----------------------------------------------
20c20,21
< *       MS hook and more elaborate CHeB
---
> *       MS hook and more elaborate CHeB.
> *       Final version by JRH 8/98 for Z in range [0.0001,0.03].
25,26d25
<       integer wdflag,nsflag
<       parameter(wdflag=1,nsflag=1)
29,34c28,31
<       real*8 r,lum,mc,rc,menv,renv,k2
<       real*8 mch,mlp,tiny
<       parameter(mch=1.44d0,mlp=12.d0,tiny=1.0d-14)
<       real*8 mxns,mxns0,mxns1
<       parameter(mxns0=1.8d0,mxns1=3.d0)
<       real*8 mass0,mt0,mtc
---
>       real*8 r,lum,mc,rc
>       real*8 mch,mxns,mlp
>       parameter(mch=1.44d0,mxns=1.8d0,mlp=12.d0)
>       real*8 mtc
38c35
<       real*8 rx,ry,delr,rzams,rtms,gamma,rmin,taumin,rg
---
>       real*8 rx,ry,delr,rzams,rtms,gamma,rmin,taumin
41,42c38,39
<       real*8 am,xx,fac,rdgen,mew,lum0,kap,zeta,ahe,aco
<       parameter(lum0=7.0d+04,kap=-0.5d0,ahe=4.d0,aco=16.d0)
---
>       real*8 am,xx,rdgen,mew,lum0,kap,zeta,ahe,aco
>       parameter(lum0=7.0d+04,kap=-0.5d0,ahe=6.964d0,aco=44.313d0)
47,48c44,45
<       real*8 rgbf,rminf,ragbf,rzahbf,rzhef,rhehgf,rhegbf,rpertf
<       real*8 mctmsf,mcgbtf,mcgbf,mcheif,mcagbf,lzahbf
---
>       real*8 rgbf,rminf,ragbf,rzahbf,rzhef,rhelmf,rpertf
>       real*8 mcgbtf,mcgbf,mcheif,mcagbf
52,53c49,50
<       external rgbf,rminf,ragbf,rzahbf,rzhef,rhehgf,rhegbf,rpertf
<       external mctmsf,mcgbtf,mcgbf,mcheif,mcagbf,lzahbf
---
>       external rgbf,rminf,ragbf,rzahbf,rzhef,rhelmf,rpertf
>       external mcgbtf,mcgbf,mcheif,mcagbf
68c65
< *       KW      Classification type (0 - 15).
---
> *       KW      Classification type (1 - 15).
72,83d68
< * Set maximum NS mass depending on which NS mass prescription is used. 
<       mxns = mxns0
<       if(nsflag.eq.1) mxns = mxns1
< *
<       mass0 = mass
<       if(mass0.gt.100.d0) mass = 100.d0
<       mt0 = mt
<       if(mt0.gt.100.d0) mt = 100.d0
< *
< * Make evolutionary changes to stars that have not reached KW > 5.
< *
<       if(kw.gt.6) goto 90
84a70
>       mc = 0.d0
88,89c74,76
<       rzams = rzamsf(mass)
<       rtms = rtmsf(mass)
---
> * Make evolutionary changes to stars that have not reached KW > 5.
> *
>       if(kw.gt.6) goto 90
95c82,83
<          rg = rgbf(mt,lums(3))
---
>          rzams = rzamsf(mass)
>          rtms = rtmsf(mass)
101d88
<             mc = 0.d0
139c126
<             if(mass.lt.(zpars(1)-0.3d0))then
---
>             if(mass.lt.(zpars(1)-0.3))then
156d142
<             mcx = mc
164,167d149
<             neta = mctmsf(mass)
<             tau = (aj - tm)/thg
<             mc = ((1.d0 - tau)*neta + tau)*mc
<             mc = MAX(mc,mcx)
177c159
<                   mc = 0.d0
---
>                   mc = mt
186d167
<                   mass = mt
189a171
>                tau = (aj - tm)/thg
192c174
<                   rx = rg
---
>                   rx = rgbf(mt,lums(3))
200c182
<                      rx = rg
---
>                      rx = rgbf(mt,lums(4))
204c186
<                   if(tau2.lt.tiny) rx = ry
---
>                   if(tau2.eq.0.0) rx = ry
224c206
< * Star has a non-degenerate He core which may grow, but
---
> * Star has a non-degenarate He core which may grow, but
232d213
<          rg = r
239c220
<                mc = 0.d0
---
>                mc = mt
248d228
<                mass = mt
261a242
>          kw = 4
269d249
< *
274,275c254
<             rg = rgbf(mt,lx)
<             rmin = rg*zpars(13)**(mass/zpars(2))
---
>             rmin = rgbf(mt,lx)*zpars(13)**(mass/zpars(2))
285c264
<             tau2 = taul*(tau - 1.d0) + tauh*tau
---
>             tau2 = taul*(tau - 1.0d0) + tauh*tau
287d265
<             rg = rg + tau*(ry - rg)
297d274
<             rg = rgbf(mt,lums(4))
302c279
<                rx = rg
---
>                rx = rgbf(mt,lums(4))
313,317c290,291
<                if(ABS(rmin-rx).gt.tiny)then
<                   taul = (log(rx/rmin))**(1.d0/3.d0)
<                endif
<                tauh = 0.d0
<                if(ry.gt.rmin) tauh = (log(ry/rmin))**(1.d0/3.d0)
---
>                if(rmin.ne.rx) taul = (log(rx/rmin))**(1.d0/3.d0)
>                tauh = (log(ry/rmin))**(1.d0/3.d0)
319c293
<                tau2 = taul*(tau - 1.d0) + tauh*tau
---
>                tau2 = taul*(tau - 1.0d0) + tauh*tau
321d294
<                rg = rg + tau*(ry - rg)
324d296
<                rg = r
337d308
<                rg = r
355d325
<                rg = rx + tau*(ry - rx)
371,372d340
<          else
<             kw = 4
374d341
< *
378a346,348
> * Set the core mass and then test whether it exceeds either
> * the total mass or the maximum allowed core mass.
> *
385d354
< *
429d397
<          rg = r
431,432c399
< * Mc,x represents the C core mass and we now test whether it
< * exceeds either the total mass or the maximum allowed core mass.
---
> * Mc,x represents the C core mass
434c401
<          if(mcmax-mcx.lt.tiny)then
---
>          if(mcx.ge.mcmax)then
438,439c405
<                mt = mc
<                if(mcbagb.lt.1.6d0)then
---
>                if(mcbagb.lt.1.6)then
442a409
>                   mt = mc
447a415
>                   mt = mc
450d417
<                mass = mt
452c419
<                if(mcbagb.lt.1.6d0)then
---
>                if(mcbagb.lt.1.6)then
457,458d423
<                   kw = 15
<                   aj = 0.d0
460,461c425,426
<                   lum = 1.0d-10
<                   r = 1.0d-10
---
>                   r = 0.d0
>                   kw = 15
463,479c428
<                   if(nsflag.eq.0)then
<                      mt = 1.17d0 + 0.09d0*mc
<                   elseif(nsflag.ge.1)then
< *
< * Use NS/BH mass given by Belczynski et al. 2002, ApJ, 572, 407.
< *
<                      if(mc.lt.2.5d0)then
<                         mcx = 0.161767d0*mc + 1.067055d0
<                      else
<                         mcx = 0.314154d0*mc + 0.686088d0
<                      endif
<                      if(mc.le.5.d0)then
<                         mt = mcx
<                      elseif(mc.lt.7.6d0)then
<                         mt = mcx + (mc - 5.d0)*(mt - mcx)/2.6d0
<                      endif
<                   endif
---
>                   mt = 1.17d0 + mc/11.12d0
504,505c453
<          rzams = rzhef(mt)
<          rx = rzams
---
>          rx = rzhef(mt)
516d463
<             rg = rx
526c473
<             kw = 8
---
>             kw = 9
528,533c475
<             r = rhehgf(mt,lum,rx,lums(2))
<             rg = rhegbf(lum)
<             if(r.ge.rg)then
<                kw = 9
<                r = rg
<             endif
---
>             r = rhelmf(kw,mt,lum,rx,lums(2))
537c479
<             if(mcmax-mc.lt.tiny)then
---
>             if(mc.ge.mcmax)then
541c483
<                   if(mass.lt.1.6d0)then
---
>                   if(mass.lt.1.6)then
554d495
<                   mass = mt
556c497
<                   if(mass.lt.1.6d0)then
---
>                   if(mass.lt.1.6)then
561,562d501
<                      kw = 15
<                      aj = 0.d0
564,565c503,504
<                      lum = 1.0d-10
<                      r = 1.0d-10
---
>                      r = 0.d0
>                      kw = 15
567,580c506
<                      if(nsflag.eq.0)then
<                         mt = 1.17d0 + 0.09d0*mc
<                      elseif(nsflag.ge.1)then
<                         if(mc.lt.2.5d0)then
<                            mcx = 0.161767d0*mc + 1.067055d0
<                         else
<                            mcx = 0.314154d0*mc + 0.686088d0
<                         endif
<                         if(mc.le.5.d0)then
<                            mt = mcx
<                         elseif(mc.lt.7.6d0)then
<                            mt = mcx + (mc - 5.d0)*(mt - mcx)/2.6d0
<                         endif
<                      endif
---
>                      mt = 1.17d0 + mc/11.12d0
607d532
< * unless WD is ONe.
609,619c534,537
<             if(kw.eq.12)then
<                kw = 13
<                mt = 1.3d0
< *              mt = 1.17d0 + 0.09d0*mc
<             else
<                kw = 15
<                aj = 0.d0
<                mt = 0.d0
<                lum = 1.0d-10
<                r = 1.0d-10
<             endif
---
>             kw = 15
>             aj = 0.d0
>             mt = 0.d0
>             r = 0.d0
621d538
< *
623c540
<                xx = ahe
---
>                xx = zpars(14)/ahe
625,644c542
<                xx = aco
<             endif
< *
<             if(wdflag.eq.0)then
< *
< * Mestel cooling
< *
<                lum = 635.d0*mt*zpars(14)/(xx*(aj+0.1d0))**1.4d0
< *
<             elseif(wdflag.ge.1)then
< *
< * modified-Mestel cooling
< *
<                if(aj.lt.9000.0)then
<                   lum = 300.d0*mt*zpars(14)/(xx*(aj+0.1d0))**1.18d0
<                else
<                   fac = (9000.1d0*xx)**5.3d0
<                   lum = 300.d0*fac*mt*zpars(14)/(xx*(aj+0.1d0))**6.48d0
<                endif
< *
---
>                xx = zpars(14)/aco
646,652c544,545
< *
<             if(mt.lt.0.000005d0)then
<                r = 0.009d0
<             elseif(mt.lt.0.0005d0)then
<                r = 0.09d0
<             else
<                r = 0.0115d0*SQRT(MAX(1.48204d-06,(mch/mt)**(2.d0/3.d0)
---
>             lum = 635.d0*mt*xx/(aj+0.1d0)**1.4
>             r = 0.0115d0*SQRT(MAX(7.5614367d-07,(mch/mt)**(2.d0/3.d0)
654,656d546
<                r = MIN(0.1d0,r)
<             endif
< *
672,673c562,563
<             lum = 0.02d0*(mt**0.67d0)/(MAX(aj,0.1d0))**2
<             r = 1.4d-05
---
>             lum = 40.d0/(MAX(aj,1.d0))**3.d0
>             r = 1.0d-05
682c572
<          lum = 1.0d-10
---
>          lum = 1.0d-06/mt
698,703c588,589
<             if(wdflag.eq.0)then
<                lx = 635.d0*mc*zpars(14)/((ahe*0.1d0)**1.4d0)
<             elseif(wdflag.ge.1)then
<                lx = 300.d0*mc*zpars(14)/((ahe*0.1d0)**1.18d0)
<             endif
<             rx = 0.0115d0*SQRT(MAX(1.48204d-06,
---
>             lx = 635.d0*mc*zpars(14)/(ahe*0.1d0**1.4)
>             rx = 0.0115d0*SQRT(MAX(7.5614367d-07,
720c606
<          if(tn.gt.tbagb) tau = 3.d0*(aj-tbagb)/(tn-tbagb)
---
>          tau = 3.d0*(aj-tbagb)/(tn-tbagb)
723c609
<          if(tau.lt.1.d0) lx = lums(2)*(lx/lums(2))**tau
---
>          if(tau.lt.1.0) lx = lums(2)*(lx/lums(2))**tau
725c611
<          rx = MIN(rhehgf(mc,lx,rx,lums(2)),rhegbf(lx))
---
>          rx = rhelmf(kwp,mc,lx,rx,lums(2))
729,734c615,616
<          if(wdflag.eq.0)then
<             lx = 635.d0*mc*zpars(14)/((aco*0.1d0)**1.4d0)
<          elseif(wdflag.ge.1)then
<             lx = 300.d0*mc*zpars(14)/((aco*0.1d0)**1.18d0)
<          endif
<          rx = 0.0115d0*SQRT(MAX(1.48204d-06,
---
>          lx = 635.d0*mc*zpars(14)/(aco*0.1d0**1.4)
>          rx = 0.0115d0*SQRT(MAX(7.5614367d-07,
739,741d620
<          menv = 1.0d-10
<          renv = 1.0d-10
<          k2 = 0.21d0
749c628
<          if(mew.lt.1.d0)then
---
>          if(mew.lt.1.0)then
762,776d640
< * Calculate mass and radius of convective envelope, and envelope
< * gyration radius.
< *
<       if(kw.lt.10)then
<          CALL mrenv(kw,mass,mt,mc,lum,r,rc,aj,tm,lums(2),lums(3),
<      &              lums(4),rzams,rtms,rg,menv,renv,k2)
<       endif
< *
<       if(mass.gt.99.99d0)then
<          mass = mass0
<       endif
<       if(mt.gt.99.99d0)then
<          mt = mt0
<       endif
< *
1,2c1,2
< 5743 2006-08-16 17:03 /work/Umi2/spurzem/5/nbody6compare-oct2006/hrplot.f
< nbody6compare-oct2006/hrplot.f
---
> 6866 2006-06-20 02:26 /work/Umi2/spurzem/5/nbody6++compare/hrplot.f
> nbody6++compare/hrplot.f
9,10c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
12c12
<       REAL*8  M0,M1,M2,LUM,LUM2,MC,ME
---
>       REAL*8  M0,M1,M2,LUM,LUM2,MC
15c15
<       WRITE (82,1)  NPAIRS, TPHYS
---
>       if(rank.eq.0) WRITE (82,1)  NPAIRS, TPHYS
19c19
<       WRITE (83,1)  NS, TPHYS
---
>       if(rank.eq.0) WRITE (83,1)  NS, TPHYS
35c35
<                   WRITE (6,3)  I, NCH
---
>                   if(rank.eq.0) WRITE (6,3)  I, NCH
45a46,57
> * 1. Patch by Jarrod against fpe's (A. Ernst)
>          IF((KW.LE.1.OR.KW.EQ.7).AND.AGE.GT.TM)THEN
>             AGE = 0.999D0*TM
>          ELSEIF(KW.LE.9.AND.AGE.GT.TN)THEN
>             IF(KW.LE.6)THEN
>                AGE = MIN(AGE,0.9999D0*TSCLS(11))
>             ELSE
>                AGE = MIN(AGE,0.9999D0*TSCLS(5))
>                AGE = MIN(AGE,0.99D0*TN)
>             ENDIF
>          ENDIF
> * End patch
47c59
<      &                RM,LUM,KW,MC,RCC,ME,RE,K2)
---
>      &                RM,LUM,KW,MC,RCC)
71c83
<                   AGE = MAX(TPLOT,TEV0(J1))*TSTAR - EPOCH(J1)
---
>                   AGE = MAX(TPLOT,TEV0(J))*TSTAR - EPOCH(J1)
72a85,89
> * 2. Patch by Jarrod against fpe's (A. Ernst)  
>                   IF(AGE.GT.TN)THEN
>                     AGE = MIN(0.98D0*TN,TEV0(J)*TSTAR - EPOCH(J))
>                   ENDIF
> * End patch
74c91
<      &                        RM,LUM,KW,MC,RCC,ME,RE,K2)
---
>      &                        RM,LUM,KW,MC,RCC)
81c98
< *       Skip second binary of quadruple.
---
> *       Skip second binary in quadruple.
90,91c107,108
<                   AGE = MAX(TPLOT,TEV0(J1))*TSTAR - EPOCH(J1)
<                   KW = KSTAR(J1)
---
>                   AGE = MAX(TPLOT,TEV0(J2))*TSTAR - EPOCH(J2)
>                   KW = KSTAR(J2)
92a110,114
> * 3. Patch by Jarrod against fpe's (A. Ernst)
>                   IF(AGE.GT.TN)THEN
>                     AGE = MIN(0.98D0*TN,TEV0(J)*TSTAR - EPOCH(J))
>                   ENDIF
> * End patch
94c116
<      &                        RM,LUM,KW,MC,RCC,ME,RE,K2)
---
>      &                        RM,LUM,KW,MC,RCC)
99c121,133
<               CALL STAR(KW2,M0,M2,TM,TN,TSCLS,LUMS,GB,ZPARS)
---
>               CALL STAR(KW2,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
> * 4. Patch by Jarrod against fpe's (A. Ernst)
>               IF((KW2.LE.1.OR.KW2.EQ.7).AND.AGE.GT.TM)THEN
>                  AGE = 0.999D0*TM
>               ELSEIF(KW2.LE.9.AND.AGE.GT.TN)THEN
>                  IF(KW2.LE.6)THEN
>                     AGE = MIN(AGE,0.9999D0*TSCLS(11))
>                  ELSE
>                     AGE = MIN(AGE,0.9999D0*TSCLS(5))
>                     AGE = MIN(AGE,0.99D0*TN)
>                  ENDIF
>               ENDIF
> * End patch              
101c135
<      &                    RM,LUM,KW,MC,RCC,ME,RE,K2)
---
>      &                    RM2,LUM2,KW,MC,RCC)
120,124c154,157
<               TE1 = 0.25*(ZL1 - 2.0*R1) + 3.7
<               TE2 = 0.25*(ZL2 - 2.0*R2) + 3.7
<               WRITE (82,5)  NAME(J1), NAME(J2), KW, KW2, KSTAR(ICM),
<      &            RI, ECC, PB, SEMI, M1, M2, ZL1, ZL2, R1, R2, TE1, TE2
<     5         FORMAT (2I6,2I3,I4,F6.1,F6.3,10F7.3)
---
>               if(rank.eq.0)
>      &        WRITE (82,5)TTOT, NAME(J1), NAME(J2), KW, KW2, KSTAR(ICM),
>      &                    RI, ECC, PB, SEMI, M1, M2, ZL1, ZL2, R1, R2
>     5         FORMAT (1X,1P,D15.7,2I8,3I5,10D15.5)
136,137c169,171
<               WRITE (83,10)  NAME(I), KW, RI, M1, ZL1, R1, TE
<    10         FORMAT (I6,I3,F6.1,4F7.3)
---
>               if(rank.eq.0) 
>      &    WRITE (83,10)  TTOT, NAME(I), KW, RI, M1, ZL1, R1
>    10         FORMAT (1X,1P,D15.7,I8,I5,4D15.5)
141,142d174
< *       Update next plotting time.
<       TPLOT = TPLOT + DTPLOT
148a181,182
> 
> 
1,2c1,2
< 390 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/iblock.f
< nbody6compare-oct2006/iblock.f
---
> 390 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/iblock.f
> nbody6++compare/iblock.f
12c12
<       DO 1 K = 2,40
---
>       DO 1 K = 2,64
1,2c1,2
< 1903 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ichain.f
< nbody6compare-oct2006/ichain.f
---
> 1903 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/ichain.f
> nbody6++compare/ichain.f
1,2c1,2
< 3643 2005-07-02 19:28 /work/Umi2/spurzem/5/nbody6compare-oct2006/imf2.f
< nbody6compare-oct2006/imf2.f
---
> 3730 2005-03-09 14:24 /work/Umi2/spurzem/5/nbody6++compare/imf2.f
> nbody6++compare/imf2.f
6d5
< *       BODY10,BODYN are in M_sun.
9,11c8,10
<       REAL*4  RAN2
<       REAL*8  IMFBD
<       REAL*8  LM,UM,BCM
---
>       REAL*4 RAN2
>       REAL*8  BTMP(NMAX)
>       REAL*8  LM,UM,ZM,IMFBD
13d11
<       COMMON/WORK1/  BCM(NMAX)
15c13
< *=========================  if KZ(20)=2:
---
> *=========================
22c20
< *       Generate initial mass function (N-NBIN0 singles & 2*NBIN0 binaries).
---
> * recover random number sequence from COMMON variable IDUM1.
23a22,23
> *
> *       Generate initial mass function (KZ(20) = 2 or > 2).
40c40
<           IF (ZM.GE.BODYN.AND.ZM.LE.BODY10) THEN
---
>           IF (ZM.GT.BODYN.AND.ZM.LT.BODY10) THEN
53c53
<           BCM(I) = BODY(2*I-1) + BODY(2*I)
---
>           BTMP(I) = BODY(2*I-1) + BODY(2*I)
59c59
<           CALL SORT1(NBIN0,BCM,JLIST)
---
>           CALL SORT1(NBIN0,BTMP,JLIST)
79,80c79,80
<           BODY(NBIN0-I+1) = BCM(I)
<           ZMB = ZMB + BCM(I)
---
>           BODY(NBIN0-I+1) = BTMP(I)
>           ZMB = ZMB + BTMP(I)
83,85c83,87
<       WRITE (6,45)  NBIN0, BODY(1), BODY(NBIN0), ZMB/FLOAT(NBIN0)
<    45 FORMAT (//,12X,'BINARY STAR IMF:    NB =',I5,
<      &               '  RANGE =',1P,2E10.2,'  <MB> =',E9.2)
---
>       if(rank.eq.0)then
>       WRITE (6,45)  NBIN0, BODY(1), BODY(NBIN0), ZMB, ZMB/FLOAT(NBIN0)
>    45 FORMAT (/,12X,'BINARY STAR IMF:   NB =',I5,'  RANGE =',1P,2E10.2,
>      &     ' ZMB =',E9.2,'  <MB> =',E9.2)
>       end if
93c95
<           BCM(NS) = BODY(NBIN0+L)
---
>           BTMP(NS) = BODY(NBIN0+L)
98c100
<       CALL SORT1(NS,BCM,JLIST)
---
>       CALL SORT1(NS,BTMP,JLIST)
103,104c105,106
<           BODY(N-I+1) = BCM(I)
<           ZMS = ZMS + BCM(I)
---
>           BODY(N-I+1) = BTMP(I)
>           ZMS = ZMS + BTMP(I)
107,109c109,112
<       WRITE (6,80)  N-NBIN0, BODY(NBIN0+1), BODY(N), ZMS/FLOAT(N-NBIN0)
<    80 FORMAT (/,12X,'SINGLE STAR IMF:    NS =',I5,'  RANGE =',1P,2E10.2,
<      &                                            '  <MS> =',E9.2)
---
>       if(rank.eq.0)
>      &WRITE (6,80)N-NBIN0,BODY(NBIN0+1),BODY(N),ZMS,ZMS/FLOAT(N-NBIN0)
>    80 FORMAT (/,12X,'SINGLE STAR IMF:   NS =',I5,'  RANGE =',1P,2E10.2,
>      &     ' ZMS =',E9.2,'  <MS> =',E9.2)
112c115,117
<    90 ZMBAR = ZMASS/FLOAT(N)
---
>    90 CONTINUE
> *       Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
1,2c1,2
< 19966 2004-11-16 00:37 /work/Umi2/spurzem/5/nbody6compare-oct2006/imfbd.f
< nbody6compare-oct2006/imfbd.f
---
> 19400 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/imfbd.f
> nbody6++compare/imfbd.f
1,8c1
< C
< C Note: this routine contains the correction from Carsten Weidner
< C       (Nov.2004), that for LOM above a certain value the integral
< C       was not computed correctly.
< C
< C
< C===========================================================
<       REAL*8 FUNCTION IMFBD(XX,LOM,UPM)
---
>       real*8 FUNCTION IMFBD(XX,LOM,UPM)
17,18c10
< * (For equal masses, LOM=UPM and IMFBD = UPM.)
< * LOM and UPM must be kept unchanged.
---
> * For equal masses, LOM=UPM and IMFBD = UPM.
22,27c14,19
<       REAL*8    ML,MH,M0,M1,M2,MU
<       REAL*8    ALPHA0,ALPHA1,ALPHA2,ALPHA3,ALPHA4
<       REAL*8    K,XH,X0,X1,X2,XU,MUP
<       REAL*8    MTOT,MASSH,MASS0,MASS1,MASS2,MASSU
<       REAL*8    XX,LOM,UPM,LM,UM,ZM
<       REAL*8    BETA,INTGR,MINTGR,MGEN,XIN
---
>       REAL*8   ML,MH,M0,M1,M2,MU
>       REAL*8   ALPHA0,ALPHA1,ALPHA2,ALPHA3,ALPHA4
>       REAL*8   K,XH,X0,X1,X2,XU,MUP
>       REAL*8   MTOT,MASSH,MASS0,MASS1,MASS2,MASSU
>       REAL*8   XX,LOM,UPM,LM,UM,ZM
>       REAL*8   BETA,INTGR,MINTGR,MGEN,XIN
39,46d30
< c      DATA    ML,     MH,    M0,      M1,      M2,    MU/
< c     &      0.01D0, 0.08D0, 0.5D0,  1.0D0,   8.0D0, 100.0D0/
< c      DATA      ALPHA0, ALPHA1, ALPHA2, ALPHA3, ALPHA4/
< c     &          0.3D0,  1.3D0,  2.2D0,   2.7D0,  2.7D0/
< *
< *
< C       Standard of average IMF:
< *
48c32
<      &      0.01D0, 0.08D0, 0.5D0,  1.0D0,   8.0D0, 100.0D0/
---
>      &      0.01D0, 0.08D0, 0.5D0,  1.0D0,   5.0D0, 100.0D0/
50,51c34
<      &          0.3D0,  1.3D0,  2.3D0,   2.3D0,  2.3D0/
< *
---
>      &          1.3D0,  1.3D0,  2.2D0,   2.7D0,  2.7D0/
54,57d36
< C      DATA    ML,     MH,    M0,      M1,      M2,    MU/
< C     &      0.01D0, 0.08D0, 0.5D0,  1.0D0,   8.0D0, 150.0D0/
< C      DATA      ALPHA0, ALPHA1, ALPHA2, ALPHA3, ALPHA4/
< C     &          0.3D0,  1.3D0,  2.3D0,   2.35D0,  2.35D0/
58a38,41
> c      DATA    ML,     MH,    M0,      M1,      M2,    MU/
> c     &      2.D0, 2.D0, 2.D0,  2.0D0,   5.0D0, 500.0D0/
> c      DATA      ALPHA0, ALPHA1, ALPHA2, ALPHA3, ALPHA4/
> c     &          1.3D0,  -0.3D0,  2.2D0,   -.7D0,  7.D0/
63,66c46,49
< C      DATA   ML,       MH,    M0,      M1,      M2,    MU/
< C     &     0.01D0,   0.08D0, 0.08D0,   1.0D0,  8.0D0, 100.0D0/
< C      DATA    ALPHA0,  ALPHA1,   ALPHA2,  ALPHA3, ALPHA4/
< C     &        0.3D0,   0.3D0,    1.2D0,   2.3D0,  2.3D0/
---
> c      DATA   ML,       MH,    M0,      M1,      M2,    MU/
> c     &     0.01D0,   0.08D0, 0.5D0,   1.0D0,  5.0D0, 100.0D0/
> c      DATA    ALPHA0,  ALPHA1,   ALPHA2,  ALPHA3, ALPHA4/
> c     &        2.3D0,   2.3D0,    2.3D0,   2.3D0,  2.3D0/
660a644
> 
1,2c1,2
< 1773 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/imf.f
< nbody6compare-oct2006/imf.f
---
> 1692 2005-03-09 14:16 /work/Umi2/spurzem/5/nbody6++compare/imf.f
> nbody6++compare/imf.f
10,11d9
< *       Generate Scalo IMF (Eggleton, Fitchett & Tout, Ap.J. 347, 998).
<       ITER = 1
14a13,14
> *       Generate Scalo IMF (Eggleton, Fitchett & Tout, Ap.J. 347, 998).
>       ITER = 1
49c49
<       WRITE (6,20)  BODY(1), BODY(N), ZMASS/FLOAT(N)
---
>       if(rank.eq.0)WRITE (6,20) BODY(1), BODY(N), ZMASS, ZMASS/FLOAT(N)
51,54c51
<      &                                '  BODY(N) =',E9.2,'  <M> =',E9.2)
< *
< *       Replace input value by actual mean mass in solar units.
<       ZMBAR = ZMASS/FLOAT(N)
---
>      &           '  BODY(N) =',E9.2,' ZMASS =',E9.2,'  <M> =',E9.2)
1,2c1,2
< 33893 2006-09-18 19:00 /work/Umi2/spurzem/5/nbody6compare-oct2006/impact.f
< nbody6compare-oct2006/impact.f
---
> 24880 2003-06-26 01:12 /work/Umi2/spurzem/5/nbody6++compare/impact.f
> nbody6++compare/impact.f
9,10c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAGM(MMAX)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
13d12
<       CHARACTER*8  WHICH1
15,17c14,16
<       INTEGER LISTQ(100)
<       SAVE LISTQ,QCHECK
<       DATA IZARE,LISTQ(1),QCHECK /0,0,0.0D0/
---
>       CHARACTER*8  WHICH1
>       SAVE  NMARG,NWARN
>       DATA  NMARG,NWARN /0,0/
27c26
<       JCOMP = IFIRST
---
>       JCOMP = I
31,33d29
<       TTOT = TIME + TOFF
<       RI2 = (X(1,I) - RDENS(1))**2 + (X(2,I) - RDENS(2))**2 +
<      &                               (X(3,I) - RDENS(3))**2
97,145c93
< *       Quit on hyperbolic orbit with large impact parameter.
<       IF (ECC1.GT.1.0.AND.PMIN.GT.50.0*SEMI) GO TO 100
< *
< *       Include rectification for non-circular binaries with KSTAR = 10 & 12.
<       IF (KZ(27).EQ.2.AND.KSTAR(I).GE.10.AND.KSTAR(I).LE.18) THEN
<           IF (ECC.GT.0.1.AND.MOD(KSTAR(I),2).EQ.0) THEN
<               RM = MAX(RADIUS(I1),RADIUS(I2))
<               ICIRC = -1
<               CALL INDUCE(IPAIR,EMAX,EMIN,ICIRC,TC,ANGLE,TG,EDAV)
<               WRITE (6,15)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
<      &                      KSTAR(I), LIST(1,I1), ECC, SEMI, RM, PMIN,
<      &                      GAMMA(IPAIR), TC, 360.0*ANGLE/TWOPI, EMAX
<    15         FORMAT (' NON-CIRCULAR    NM K* NP E A R* PM G TC IN EX ',
<      &                                  2I7,4I4,F7.3,1P,5E9.1,0P,2F7.2)
< *       Circularize the orbit instantaneously for short TC.
<               IF (TC.LT.-100.0) THEN
< *       Set temporary unperturbed orbit (avoids new KSPOLY in DEFORM).
<                   NP = LIST(1,I1)
<                   LIST(1,I1) = 0
<                   DT1 = STEP(I1)
<                   TIME0 = TIME
<                   CALL KSRECT(IPAIR)
<                   QP = SEMI*(1.0 - ECC)
<                   ERR = ABS(QP - R(IPAIR))/QP
< *       Deform orbit to circular eccentricity after determining apocentre.
<                   IF (R(IPAIR).GT.SEMI.OR.ERR.GT.1.0D-04) THEN
< *       Reduce eccentric anomaly by pi for inward motion.
<                       IF (TDOT2(IPAIR).LT.0.0D0) THEN
<                           CALL KSAPO(IPAIR)
<                       END IF
<                   END IF
< *       Predict to pericentre and transform by pi to exact apocentre.
<                   CALL KSPERI(IPAIR)
<                   CALL KSAPO(IPAIR)
<                   ECCM = 0.002
<                   CALL DEFORM(IPAIR,ECC,ECCM)
<                   LIST(1,I1) = NP
< *        Resolv X & XDOT and initialize KS polynomial at apocentre time.
<                   IF (NP.EQ.0) DT1 = 0.0
<                   TIME = TIME0 - DT1
<                   CALL RESOLV(IPAIR,1)
<                   CALL KSPOLY(IPAIR,1)
<               ELSE
<                   KSTAR(I) = 0
<               END IF
<           END IF
<       END IF
< *
< *       Form binding energy of inner & outer binary (NB! redefine I1).
---
> *       Form binding energy of inner & outer binary.
148d95
<       IF(ABS(EB).LT.1.0D-10) EB = -1.0D-10
167,168d113
<           SEMIX = MAX(SEMI,SEMI2)
<           APO = APO + MAX(ABS(SEMI2),R(JPAIR))
169a115
>           APO = APO + MAX(ABS(SEMI2),R(JPAIR))
171,172c117,118
<           IF (1.0/SEMI.LT.0.5/RMIN) GO TO 100
< *       Consider merger for PMIN > SEMI and large semi-major axis ratio.
---
>           IF (1.0/SEMI.LT.1.0/RMIN) GO TO 100
> *       Retain KS treatment for PMIN > SEMI and large semi-major axis ratio.
191d136
< *       Employ initial size as upper limit in case of weakly bound system.
196c141,143
<           IF (RIJ.GT.MAX(3.0*RGRAV,RMIN).OR.RSUM.GT.2.0*RMIN) GO TO 30
---
>           IF (RIJ.GT.MAX(3.0*RGRAV,RMIN).OR.RGRAV.GT.RMIN) GO TO 30
> *       Allow perturber distance 40*RGRAV because of the short duration.
>           IF (40.0*RGRAV.GT.RS(I)) GO TO 30
200a148
> *         IF (GI.LT.0.001) GO TO 30
202c150,152
<               IF (SEMI0.LT.SEMI2) J1 = I1
---
>               IF (SEMI0.LT.SEMI2) THEN
>                   J1 = 2*(I - N) - 1
>               END IF
206,208d155
<               IF (MIN(SEMI0,SEMI2).LT.0.05*RIJ) THEN
<               IF (MAX(SEMI0,SEMI2).LT.0.1*RIJ) GO TO 30
<               END IF
212c159
< *       Include special case of strong interraction and large ECC1.
---
> *       Include special case of strong interaction and large ECC1.
214c161
<           IF (APO.LT.0.01*RMIN.AND.PMIN.LT.2.5*APO) GO TO 16
---
>           IF (APO.LT.0.01*RMIN.AND.PMIN.LT.2.5*APO) GO TO 17
218d164
< *     IF ((APO.GT.0.01*RMIN.OR.JCOMP.GT.N).AND.PMIN.GT.APO) GO TO 30
220d165
< *     IF (APO.LE.0.01*RMIN.AND.PMIN.GT.2.0*APO) GO TO 30
223c168
<    16 IF (JCOMP.GT.N.AND.PMIN.GT.0.1*RMIN) THEN
---
>    17 IF (JCOMP.GT.N.AND.PMIN.GT.0.1*RMIN) THEN
226,227c171
<       IF (JCOMP.GT.N.AND.PMIN.GT.4.0*SEMIX.AND.
<      &   (ECC1.GT.0.9.AND.ECC1.LT.1.0)) GO TO 30
---
>       IF (R(IPAIR).GT.RMIN) GO TO 30
240,241c184
< *         ELSE IF (PMIN.GT.0.9*RSTAB) THEN
<           ELSE IF (PMIN.GT.0.7*RSTAB) THEN
---
>           ELSE IF (PMIN.GT.RSTAB) THEN
246,250d188
<           IF (PMIN.GT.0.6*RSTAB.AND.PMIN.LT.0.9*RSTAB) GO TO 100
< *       Delay for large distance ratio outside 0.5*RMIN.
<           IF (RIJ.GT.MAX(10.0*APO,0.5*RMIN)) GO TO 100
<           IF (RIJ.GT.10.0*APO) GO TO 100
<           IF (PMIN.GT.2.5*APO) GO TO 40
252d189
<       IF (PMIN.GT.3.0*SEMI.AND.JCOMP.LE.N) GO TO 40
254,255c191,195
<       IF (JCOMP.GT.N) THEN
<           IF (RIJ.GT.10.0*APO) GO TO 100
---
> *       Specify maximum size of unperturbed motion.
>       IF (PERT2.GT.0.0) THEN
>          RPERT = (100.0*GSTAR*(BODY(I) + BODY(JCOMP))/(2.0*PERT2))**0.33
>       ELSE
>          RPERT = 10.0*SEMI
256a197
> *
262,263d202
<           PERIM = R(IPAIR) + RIJ
<           IF (JCOMP.GT.N) PERIM = PERIM + R(JPAIR)
265,266c204,210
<           CALL PERMIT(PERIM,IGO)
<           IF (IGO.GT.0) GO TO 100
---
>           CALL PERMIT(RPERT,IGO)
>           IF (IGO.GT.0) THEN
>               NWARN = NWARN + 1
>               IF (NWARN.LT.50.and.rank.eq.0) WRITE (6,19)  RPERT
>    19         FORMAT (' IMPACT    TERMINATION REQUEST    RPERT',1P,E9.1)
>               GO TO 100
>           END IF
271,272c215
<       IF (KCHAIN.GT.0) WHICH1 = ' CHAIN  '
< *
---
>       IF (KCHAIN.GT.0) WHICH1 = ' CHAIN '
274c217,218
<           WRITE (6,18)  I, JCOMP, ECC, ECC1, SEMI1, RIJ, GAMMA(IPAIR)
---
>           if(rank.eq.0)
>      &    WRITE (6,18)  I, JCOMP, ECC, ECC1, SEMI1, RIJ, GAMMA(IPAIR)
280c224,225
<           WRITE (6,20)  WHICH1, IPAIR, TTOT, H(IPAIR), R(IPAIR),
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  WHICH1, IPAIR, TIME+TOFF, H(IPAIR), R(IPAIR),
283c228
<    20     FORMAT (/,' NEW',A8,I4,'  T =',F8.2,'  H =',F6.0,
---
>    20     FORMAT (/,' NEW',A8,I5,'  T =',F8.2,'  H =',F7.0,
287c232
<           CALL FLUSH(3)
---
>           CALL FLUSH(6)
290,300c235,242
< *       Include any close single or c.m. perturber (cf. routine SETSYS).
<       IF (JMAX.NE.JCOMP.AND.SQRT(RMAX2).LT.MIN(2.0D0*RSUM,RMIN).AND.
<      &    NAME(JMAX).GT.0) THEN
<           IF (JCOMP.GT.N.AND.JMAX.GT.N) THEN
<               JCMAX = 0
<           ELSE
<               WRITE (6,21)  NAME(JCOMP), NAME(JMAX), RSUM, SQRT(RMAX2)
<    21         FORMAT (' B+2 CHAIN    NAM RSUM RMX ',2I7,1P,2E10.2)
<               CALL XVPRED(JMAX,-1)
<               JCMAX = JMAX
<           END IF
---
> *       Include any close single perturber (cf. routine SETSYS).
>       IF (JMAX.NE.JCOMP.AND.SQRT(RMAX2).LT.2.0*RIJ.AND.
>      &    JMAX.LE.N.AND.NAME(JMAX).GT.0) THEN
>           if(rank.eq.0)
>      &    WRITE (6,22)  NAME(JCOMP), NAME(JMAX), RSUM, SQRT(RMAX2)
>    22     FORMAT (' B+2 CHAIN    NAM RSUM RMX ',2I6,1P,2E10.2)
>           CALL XVPRED(JMAX,-1)
>           JCMAX = JMAX
304a247,250
> *       Predict coordinates and velocities of #JCOMP & c.m. to F3DOT.
>       CALL XVPRED(JCOMP,-1)
>       CALL XVPRED(I,0)
> *
308c254
< *       Check B-B interaction for switch of IPAIR & JPAIR or inert binary.
---
> *       Replace unperturbed near-synchronous binary by inert body in CHAIN.
311c257,258
<           WRITE (6,22)  NAME(I1), NAME(I2), NAME(K1), NAME(K1+1),
---
>           if(rank.eq.0)
>      &    WRITE (6,24)  NAME(I1), NAME(I2), NAME(K1), NAME(K1+1),
314,319c261,263
<    22     FORMAT (' CHAIN B-B    NAME K* E0 E1 A0 A2 RIJ A1 PM ',
<      &                           4I7,2I4,2F7.3,1P,5E10.2)
<           RT = 4.0*MAX(RADIUS(I1),RADIUS(I2))
<           IF (SEMI0.LT.4.0*RT.AND.LIST(1,J1).EQ.0.OR.
<      &        MIN(SEMI0,SEMI2).LT.0.01*RIJ) THEN
< *       Ensure that widest binary comes first (more similar to triple).
---
>    24     FORMAT (' CHAIN B-B    NAME K* E0 E1 A0 A2 RIJ A1 PM ',
>      &                           4I6,2I4,2F7.3,1P,5E10.2)
>           IF (SEMI0.LT.4.0*RT.AND.LIST(1,J1).EQ.0) THEN
331,332c275,277
<                   WRITE (6,25)  SEMI0, RIJ, R(JPAIR), GAMMA(JPAIR)
<    25             FORMAT (' INERT BINARY    A RIJ R G ',1P,4E10.2)
---
>                   if(rank.eq.0)
>      &            WRITE (6,25)  SEMI0, RIJ, R(JPAIR), GAMMA(JPAIR)
>    25             FORMAT (' INERT BINARY    A0 RIJ R G ',1P,4E10.2)
346,347c291,292
< *       Switch pair indices and rename JCOMP if JPAIR has smaller size.
<           IF (STEP(J1).LT.STEP(I1).AND.LIST(1,I1).GT.0) THEN
---
> *       Switch pair indices and rename JCOMP if JPAIR has smaller step.
>           IF (STEP(J1).LT.STEP(I1)) THEN
354,357c299
<           IF (KZ(27).LE.0.AND.JPAIR.GT.IPAIR) THEN
<               IF (JCLOSE.GT.0) JCLOSE = JCLOSE - 1
<           END IF
< *       Terminate smallest pair first and reduce second index if higher.
---
> *       Terminate first KS pair (replaced by delay procedure).
358a301
> *       Reduce second index if higher than first.
362c305
< *       See whether chain regularization indicator should be switched on.
---
> *       See whether chain regularization indicator should be activated.
369a313,316
> *       Terminate binary in triple or widest B-B binary (replaced by delay).
> *     CALL KSTERM
> *
>       IF (N.GT.10) GO TO 999
374c321,322
<           WRITE (6,28)  NAME(I), NAME(JCOMP), NAME(JG),ECC1, PMIN, RIJ
---
>           if(rank.eq.0)
>      &    WRITE (6,28)  NAME(I), NAME(JCOMP), NAME(JG), ECC1, PMIN, RIJ
399a348
>   999 CONTINUE
404,405c353
<    30 NMTRY = NMTRY + 1
<       RA = SEMI1*(1.0 + ECC1)
---
>    30 RA = SEMI1*(1.0 + ECC1)
408,442c356,359
< *       Identify formation of wide quadruple before merger is accepted.
<       IF (JCOMP.GT.N.AND.ECC1.LT.1.0.AND.SEMI1.LT.0.1*RSCALE) THEN
<           NNB = LISTQ(1) - 1
<           K = 0
< *       See whether current list contains first inner/outer component.
<           NAM1 = NAME(2*JPAIR-1)
<           DO 32 L = 2,NNB+2
<               IF (NAM1.EQ.LISTQ(L)) K = K + 1
<    32     CONTINUE
< *       Generate diagnostics of first five outer orbits every half period.
<           IF (K.LE.5.AND.TIME.GT.QCHECK.AND.KZ(37).GT.0) THEN
<               ZMB = BODY(I) + BODY(JCOMP)
<               RI = SQRT(RI2)
<               TK = SEMI1*SQRT(SEMI1/ZMB)
<               QCHECK = TIME + MIN(0.5*TWOPI*TK,0.1*TCR)
<               TK = DAYS*TK
< *       Check the stability criterion.
<               PCR = stability(BODY(I1),BODY(I2),BODY(JCOMP),ECC,ECC1,
<      &                                                  0.0D0)*SEMIX
<               WRITE (89,33)  TTOT, NAME(2*IPAIR-1), NAM1, K, RI,
<      &                       ECC1, EB, EB2, EB1, TK, PMIN, PCR
<    33         FORMAT (' QUAD    T NAM LQ RI E1 EB EB2 EB1 P1 PM PC ',
<      &                          F8.1,2I6,I4,F6.2,F8.4,1P,3E12.3,3E9.1)
<               CALL FLUSH(89)
< *       Remove two oldest members if list is too big.
<               IF (NNB.GT.96) THEN
<                   DO 34 K = 2,NNB
<                       LISTQ(K) = LISTQ(K+2)
<    34             CONTINUE
<                   NNB = NNB - 2
<               END IF
< *       Add current names (inner & outer) at end and update membership.
<               LISTQ(NNB+3) = NAME(2*IPAIR-1)
<               LISTQ(NNB+4) = NAME(2*JPAIR-1)
<               LISTQ(1) = NNB + 3
---
> *       Do not allow merger in the inner region of perturbed eccentric orbit.
>       IF (RIJ.LT.SEMI1.AND.LIST(1,I1).GT.0) THEN
>           IF (ECC1.GT.0.95.AND.RIJ.LT.2.0*PMIN) THEN
>               GO TO 100
452a370,371
>       RI2 = (X(1,I) - RDENS(1))**2 + (X(2,I) - RDENS(2))**2 +
>      &                               (X(3,I) - RDENS(3))**2
458,459d376
< *       Extend maximum apocentre for massive systems (less perturbers).
<           IF (BODY(I) + BODY(JCOMP).GT.10.0*BODYM) RFAC = 2.0*RFAC
463,468c380,381
< *     ZF = 1.0
< *     IF (BODY(I)*SMU.LT.0.4) ZF = 1.5
<       IF (MIN(BODY(I1),BODY(I2)).LT.0.05*BODYM) THEN
< *       Use orbital velocity condition instead of binding energy for planets.
<           IF (SEMI1.GT.2.0*RMIN) GO TO 100
<       ELSE IF (EB.GT.EBH.OR.EB1.GT.EBS.OR.RA.GT.RFAC) THEN
---
> *     IF (EB.GT.EBH.OR.EB1.GT.EBS.OR.RA.GT.RFAC) THEN
>       IF (EB.GT.EBH.OR.EB1.GT.EBS) THEN
469a383,386
>       ELSE
> *       Set close encounter indices for hard hierarchy (redundant ?).
>           ICLOSE = I
>           JCLOSE = JCOMP
470a388
>       IF (SEMI1.LT.0.0.AND.RA.GT.RFAC) GO TO 100
473,477c391
<       IF (ECC1.LT.0.95) THEN
<           PERT = PERT*(RA/RIJ)**3
<       ELSE
<           PERT = PERT*(ABS(SEMI1)/RIJ)**3
<       END IF
---
>       PERT = PERT*(RA/RIJ)**3
480c394
< *       Check tidal capture option (synchronous or evolving binary orbit).
---
> *       Check for circularization or collision.
482,530c396,413
< *       Skip merger if outer component would suffer tidal dissipation.
< ***       IF (SEMI1*(1.0 - ECC1).LT.4.0*RADIUS(JCOMP)) GO TO 100
< *       Do not allow merger if Roche overflow or mass loss during next orbit.
<           TK = TWOPI*SEMI1*SQRT(SEMI1/(BODY(I) + BODY(JCOMP)))
<           TM = MIN(TEV(I1),TEV(I2),TEV(JCOMP),TEV(I))
<           IF (KZ(34).LT.0.AND.TM - TIME.LT.STEPX) THEN
<               RT = 5.0*MAX(RADIUS(I1),RADIUS(I2))
<               IF (A0.LT.RT.OR.KSTAR(I).GT.0) THEN
<                   CALL TRFLOW(IPAIR,DTR)
<                   IF ((MOD(KSTAR(I),2).EQ.1.AND.DTR.LT.STEPX).OR.
<      &                 DTR.LT.TK) GO TO 100
<               END IF
<               IF (JCOMP.GT.N.AND.KSTAR(JCOMP).GT.0) THEN
<                   CALL TRFLOW(JPAIR,DTR)
<                   IF(MOD(KSTAR(JCOMP),2).EQ.1.OR.DTR.LT.STEPX) GOTO 100
<               END IF
<           END IF
< *
< *       Ensure SLEEP for circularizing binary with TCIRC > 1.0E+06.
<           QPERI = A0*(1.0 - ECC)
<           RM = MAX(RADIUS(I1),RADIUS(I2))
<           IF (KSTAR(I).EQ.-2.AND.QPERI.GT.10.0*RM) THEN
<               ICIRC = -1
<               CALL INDUCE(IPAIR,EMAX,EMIN,ICIRC,TC,ANGLE,TG,EDAV)
<               IF (TC.GT.1.0D+06) THEN
<                   WRITE (6,35)  NAME(I1), KSTAR(I1), KSTAR(I2), ECC,
<      &                          EMAX, QPERI/RM, EDAV, a0, PMIN, TC
<    35             FORMAT (' IMPACT SLEEP    NM K* E EX QP/R ED A PM TC',
<      &                                      I7,2I4,2F8.4,F6.1,1P,4E10.2)
<                   KSTAR(I) = 0
<                   NSLP = NSLP + 1
<                   II = -I
<                   CALL SPIRAL(II)
<               END IF
<           END IF
< *
< *       Delay merger for recently updated standard binary and short TCIRC.
<           DT = MIN(TEV(I1),TEV(I2)) - TIME
<           IF (KSTAR(I).EQ.0.AND.NAME(I).GT.0.AND.DT.LT.TK) THEN
<               ICIRC = -1
<               CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
< *             WRITE (6,36) NAME(I1), ECC, TTOT, RADIUS(I1)*SU, QPERI, TC
< *  36         FORMAT (' TCIRC    NAM E T R* QP TC ',
< *    &                           I6,F7.3,F8.3,F7.1,1P,2E10.2)
< *       Beware possible termination by routine HMDOT using QPERI < 3*RADIUS.
<               IF (TC.LT.2000.0) GO TO 100
<           END IF
<           IF (KZ(19).GE.3) THEN
<               IF (MIN(TEV(I1),TEV(I2)).LT.TIME + TK) GO TO 100
---
> *       Skip merger for active phase of tidal dissipation.
>           RT = 4.0*MAX(RADIUS(I1),RADIUS(I2))
>           PERI = SEMI*(1.0 - ECC)
> *       Include circularization test (binary may be unperturbed).
>           IF (ECC.LT.0.0021.AND.KSTAR(I).EQ.0) KSTAR(I) = 20
>           IF (PERI.LT.RADIUS(I1) + RADIUS(I2)) THEN
>               KSPAIR = IPAIR
>               CALL CMBODY(PERI,2)
>               IF (IPHASE.LT.0) GO TO 100
>           END IF
>           IF (ECC.GT.0.1.AND.KSTAR(I).EQ.20) THEN
>               if(rank.eq.0)
>      &        WRITE (6,35)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
>      &                      KSTAR(I), LIST(1,I1), ECC, SEMI, RT, PERI,
>      &                      GAMMA(IPAIR)
>    35         FORMAT (' NON-CIRCULAR    NM K* NP E A RT PERI G ',
>      &                                  2I5,4I4,F7.3,1P,4E9.1)
>               KSTAR(I) = 0
532,533c415
< *       Skip chaotic binary (KSTAR = -2 is treated below).
<           IF (KSTAR(I).EQ.-1.OR.KSTAR(JCOMP).EQ.-1) GO TO 100
---
>           IF (PERI.LT.0.99*RT.AND.KSTAR(I).EQ.0) GO TO 100
538,564c420,430
<       IF (NP.LE.3) THEN
<           RS2 = CMSEP2*RMIN2
<           CALL NBLIST(I,RS2)
<           NP = LIST(1,I)
< *       Copy neighbour list (routine FPERT skips body #JCOMP).
<           DO 38 L = 1,NP
<               JLIST(L) = ILIST(L+1)
<    38     CONTINUE
<       END IF
< *
< *       Allow highly eccentric outer orbit (estimated PERT may be excessive).
<       IF (ECC1.GT.0.98.AND.RIJ.LT.0.1*SEMI1) THEN
<           PERT = PERT4
<           GO TO 40
<       END IF
< *
< *       Evaluate the actual perturbation.
<       CALL FPERT(I,JCOMP,NP,PERT2)
<       PERT2 = PERT2*RJMIN2/(BODY(I) + BODY(JCOMP))
<       GI = PERT2*(RA/RIJ)**3
< *       Switch to direct integration for planetary systems if GI > 1D-04.
<       IF (MIN(BODY(I1),BODY(I2)).LT.0.05*BODYM) THEN
<           IF (GI.GT.1.0D-04) GO TO 100
<       END IF
< *     IF (PERT4.GT.GMAX.OR.PERT.GT.0.1) GO TO 100
<       IF (PERT4.GT.GMAX.OR.GI.GT.0.05) GO TO 100
<  
---
> *       Allow highly eccentric outer orbit by reducing estimated PERT.
> *     IF (ECC1.GT.0.98.AND.RIJ.LT.0.1*SEMI1) PERT = PERTM
>       IF (PERT4.GT.GMAX.OR.PERT.GT.0.05) GO TO 100
> *
> *       Check for sufficient perturbers at apocentre (RP < 2*RS).
>       RP = SQRT(CMSEP2)*RA
>       NNB = LIST(1,I)
> *       Allow for increased neighbour radius (updated in routine MERGE).
>       RSI = RS(I)*MAX((FLOAT(NNBMAX)/FLOAT(NNB))**0.3333,1.0)
>       IF (RP.GT.2.0*RSI) GO TO 100
> *
572,581d437
< *     IF (NMERGE.GE.MMAX - 1.OR.RIJ.GT.RMIN) GO TO 100
<       IF (NMERGE.GE.MMAX - 1) GO TO 100
< *
< *       Do not allow merger in the inner region of perturbed eccentric orbit.
<       IF (RIJ.LT.SEMI1.AND.LIST(1,I1).GT.0) THEN
< *       Note: moved down from label 30 with 0.1*SEMI1 replacing 2*PMIN.
<           IF (ECC1.GT.0.95.AND.RIJ.LT.0.1*SEMI1) THEN
<               GO TO 100
<           END IF
<       END IF
583d438
< *     -----------------------------------------------------------------------
587,593d441
< *       Note that routine NEWTEV in MERGE2 replaces suppressed part.
< *     IF (KZ(19).GE.3) THEN
< *         TM = MIN(TEV(I1),TEV(I2),TEV(JCOMP),TEV(I))
< *         IF (MIN(NAME(I),NAME(JCOMP)).LT.0.AND.TM-TIME.LT.0.2) THEN
< *             GO TO 100
< *         END IF
< *     END IF
604d451
< *     -----------------------------------------------------------------------
606,612c453,462
< *       Form hierarchical stability ratio (Eggleton & Kiseleva 1995).
< *     QL = BODY(I)/BODY(JCOMP)
< *     Q1 = MAX(BODY(I2)/BODY(I1),BODY(I1)/BODY(I2))
< *     Q3 = QL**0.33333
< *     Q13 = Q1**0.33333
< *     AR = 1.0 + 3.7/Q3 - 2.2/(1.0 + Q3) + 1.4/Q13*(Q3 - 1.0)/(Q3 + 1.0)
< *     EK = AR*SEMI*(1.0D0 + ECC)
---
> *       Employ the new stability criterion (MA 1997).
>       Q = BODY(JCOMP)/BODY(I)
>       IF (ECC1.LT.1.0) THEN
>           XFAC = (1.0 + Q)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
>       ELSE
>           XFAC = 40.0*(1.0 + Q)
>       END IF
> *       Include correction at small eccentricity (f(E) = 1.0 for now).
>       FE  = 1.0
>       PCRIT = 2.8*FE*XFAC**0.4*SEMI
614a465
>       YFAC = 1.0
615a467,468
>           SFAC = (1.0 + Q)**0.4*SEMI
>           SFAC2 = (1.0 + BODY(I)/BODY(JCOMP))**0.4*SEMI2
618,619c471,473
<       ELSE
<           YFAC = 1.0
---
>           IF (SFAC2.GT.SFAC) THEN
>               PCRIT = PCRIT*(SFAC2/SFAC)
>           END IF
629d482
<               KPAIR = IPAIR
631d483
<               JPAIR = KPAIR
637,639d488
<               SEMIZ = SEMI2
<               SEMI2 = SEMI
<               SEMI = SEMIZ
643,644c492,493
< *       Resolve weakly perturbed binary (X(K,I1) = X(K,I2) for G < GMIN).
<       IF (GAMMA(IPAIR).LT.GMIN) THEN
---
> *       Resolve weakly perturbed binary (prevent X(K,I1) = X(K,I2)).
>       IF (GAMMA(IPAIR).LT.GMIN.OR.X(1,I1).EQ.X(1,I2)) THEN
658c507
< *       Determine the inclination (in radians).
---
> *       Determine the inclination (OK to use c.m. instead of inner c.m.).
661c510
< *       Employ the basic stability criterion for fast check (ECC1 < 1).
---
> *       Adopt an emperical fudge factor for the inclination.
663,666c512,519
<           Q = BODY(JCOMP)/BODY(I)
<           XFAC = (1.0 + Q)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
<           PCRIT = 2.8*XFAC**0.4*SEMI*(1.0 - 0.6*ANGLE/TWOPI)
<           IF (PCRIT.GT.1.5*PMIN) GO TO 100
---
>           YFAC = YFAC - 0.3*ANGLE/180.0
> *       Employ additional gradual reduction above ECC1 = 0.98.
> *         IF (ECC1.GT.0.98) THEN
>           IF (ECC1.GT.0.96) THEN
>               YFAC = YFAC - 10.0*(ECC1 - 0.96)
>           END IF
>       ELSE IF (RIJ.GT.RMIN) THEN
>           GO TO 100
669,672d521
< *       Evaluate the general stability function.
<       PCRIT = stability(BODY(I1),BODY(I2),BODY(JCOMP),ECC,ECC1,ANGLE)
<       PCRIT = PCRIT*SEMI
< *
674,680c523,526
<       IF (JMAX.NE.JCOMP) THEN
<           RIJ2 = (X(1,JMAX) - X(1,JCOMP))**2 +
<      &           (X(2,JMAX) - X(2,JCOMP))**2 +
<      &           (X(3,JMAX) - X(3,JCOMP))**2
<           FMAX = (BODY(JMAX) + BODY(JCOMP))/RIJ2
<           IF (FMAX.GT.(BODY(I) + BODY(JCOMP))/RJMIN2) GO TO 100
<       END IF
---
>       RIJ2 = (X(1,JMAX) - X(1,JCOMP))**2 + (X(2,JMAX) - X(2,JCOMP))**2 +
>      &                                     (X(3,JMAX) - X(3,JCOMP))**2
>       FMAX = (BODY(JMAX) + BODY(JCOMP))/RIJ2
>       IF (FMAX.GT.(BODY(I) + BODY(JCOMP))/RJMIN2) GO TO 100
683,684c529,530
<       IF (PMIN.LT.YFAC*PCRIT.AND.PMIN.GT.0.5*PCRIT.AND.
<      &    LIST(1,I1).GT.0) THEN
---
>       IF (PMIN.LT.YFAC*PCRIT.AND.PMIN.GT.0.6*PCRIT) THEN
> *    &    JCOMP.GT.N.AND.SEMI2.GT.10.0*SEMI) THEN
688c534,535
< *         WRITE (6,44)  NMARG, 360.0*ANGLE/TWOPI, YF, PMIN, YF*PCRIT, TK
---
> *         if(rank.eq.0)
> *    &    WRITE (6,44)  NMARG, ANGLE, YF, PMIN, YF*PCRIT, TK
690,691c537,538
< *    &                          I7,F7.1,F7.3,1P,3E10.2)
< *         CALL FLUSH(3)
---
> *    &                          I7,2F7.2,1P,3E10.2)
> *         CALL FLUSH(6)
695,700c542,552
<               YFAC = 0.98*PMIN*(1.0 - PERT)/PCRIT
<               WRITE (6,45)  NMARG, 360.0*ANGLE/TWOPI, Q, Q1, YFAC,
<      &                      PMIN, PCRIT, YFAC*PCRIT
<    45         FORMAT (' NEW HIERARCHY    # IN Q Q1 YF PM PC1 PC2 ',
<      &                                   I8,F7.1,3F6.2,1P,3E10.2)
<               NMARG = -1
---
>               YFAC = 0.99*PMIN*(1.0 - PERT)/PCRIT
>               if(rank.eq.0)
>      &        WRITE (6,45)  NMARG, NAME(I), NAME(JCOMP), ANGLE, Q,
>      &                      YFAC, PMIN, PCRIT, YFAC*PCRIT
>    45         FORMAT (' NEW HIERARCHY    # NAM ANGLE Q YF PM PC1 PC2 ',
>      &                                   I8,2I6,F7.1,2F6.2,1P,3E10.2)
>               NMARG = 0
>               TK1 = TWOPI*SEMI1*SQRT(SEMI1/(BODY(I) + BODY(JCOMP)))
>               if(rank.eq.0)
>      &        WRITE (6,46)  ECC1, PERT, RP, RSI, TK1
>    46         FORMAT (' WATCH!    E1 G RP RSI TK1 ',F8.4,F8.4,1P,5E10.2)
704,708d555
< *       Determine time-scale for stability (absolute or approximate).
<       PM1 = PMIN*(1.0 - 2.0*PERT)
<       CALL TSTAB(I,ECC1,SEMI1,PM1,YFAC,ITERM)
<       IF (ITERM.GT.0) GO TO 100
< *
712,749d558
< *       Obtain growth time and inclination.
<       IF (SEMI1.GT.0.0) THEN
<           ICIRC = -1
<           CALL INDUCE(IPAIR,EMAX,EMIN,ICIRC,TC,ANGLE,TG,EDAV)
<       END IF
< *
< *       Check circularization and dissipation time (exclude Roche stages).
<       IF (KZ(27).EQ.2.AND.KSTAR(I).LT.10.AND.ECC1.LT.1.0.AND.
<      &    NAME(I).GT.0) THEN
< *    &    NAME(I).GT.0.AND.ECC.GT.0.5) THEN
<           ECC0 = ECC
<           CALL DECIDE(IPAIR,SEMI,ECC,EMAX,EMIN,TC,TG,EDAV,IQ)
<           IF (IQ.GT.0.OR.IPHASE.LT.0) GO TO 100
<           TK1 = TWOPI*SEMI1*SQRT(SEMI1/(BODY(I) + BODY(JCOMP)))
< *         IF (TMDIS(NMERGE+1) - TIME.LT.TK1) GO TO 100
< *         EK = EK*(1.0 + ECC)/(1.0 + ECC0)
<           PCRIT = PCRIT*(1.0 + ECC)/(1.0 + ECC0)
<       END IF
< *
< *       Perform safety check on radii for case of no circularization.
<       IF (KZ(27).EQ.0) THEN
<           IF (SEMI*(1.0 - ECC).LT.2.0*MAX(RADIUS(I1),RADIUS(I2))) THEN
<               IF (KZ(19).EQ.0) THEN
<                   GO TO 100
<               END IF
<           END IF
<       END IF
< *
< *       Include rare case of circularizing outer binary.
<       IF (KZ(27).EQ.2.AND.JCOMP.GT.N.AND.KSTAR(JCOMP).EQ.-2) THEN
<           ECC2 = (1.0 - R(JPAIR)/SEMI2)**2 +
<      &                               TDOT2(JPAIR)**2/(BODY(JCOMP)*SEMI2)
<           ECCJ = SQRT(ECC2)
< *       See whether to reduce the look-up time TMDIS (no skip here).
<           CALL DECIDE(JPAIR,SEMI2,ECCJ,EMAXJ,EMIN,TC,TG,EDAV,IQ)
<           IF (IPHASE.LT.0) GO TO 100
<       END IF
< *
753,762c562,564
<           Q = BODY(JCOMP)/BODY(I)
<           IF (SP.LT.1.0.AND.ANGLE.LT.0.17) THEN
<               IZARE = IZARE + 1
<               IF (IZARE.LT.200) THEN
<               WRITE (7,48)  TTOT, Q, ECC, ECC1, SEMI, PMIN, PCRIT,
<      &                      YFAC, SP
<               WRITE (7,47) I,JCOMP,N,I1,I2,RIJ,SEMI1
<    47         FORMAT (' I JCOMP N I1 I2 RIJ A1   ',5I6,1P,2E10.2)
<               CALL FLUSH(7)
<               WRITE (6,48)  TTOT, Q, ECC, ECC1, SEMI, PMIN, PCRIT,
---
>           IF (SP.LT.1.0.AND.ANGLE.LT.10.0) THEN
>               if(rank.eq.0)
>      &        WRITE (6,48)  TIME+TOFF, Q, ECC, ECC1, SEMI, PMIN, PCRIT,
766,767c568
<               END IF
<               IF (PMIN.LT.PCRIT.AND.NMARG.GE.0) GO TO 100
---
>               GO TO 100
769,773c570,574
<           EK = 0.0
<           WRITE (73,49)  TTOT, Q, ECC, ECC1, SEMI, PMIN, PCRIT,
<      &                   TG, SP, 360.0*ANGLE/TWOPI, KSTAR(I)
<    49     FORMAT (' STAB    T Q E E1 A PM PCR TG SP IN K* ',
<      &                      F8.2,F5.1,2F7.3,1P,4E9.1,0P,F6.2,F7.1,I4)
---
>           if(rank.eq.0)
>      &    WRITE (73,49)  TIME+TOFF, Q, ECC, ECC1, SEMI, PMIN, PCRIT,
>      &                   SP, ANGLE, KSTAR(I)
>    49     FORMAT (' STAB    T Q E E1 A PM PCR SP IN K* ',
>      &                      F8.2,F5.1,2F7.3,1P,3E9.1,0P,F6.2,F7.1,I4)
775,776d575
< *         IF (KSTAR(I1).GE.10) TEV(I1) = 1.0E+10
< *         IF (KSTAR(I2).GE.10) TEV(I2) = 1.0E+10
782,787c581,584
<       IF (NMERGE.EQ.MMAX - 1) THEN
<           IF (NWARN.LT.1000) THEN
<           NWARN = NWARN + 1
<           WRITE (6,50)  NMERGE
<    50     FORMAT (5X,'WARNING!    MERGER LIMIT    NMERGE =',I4)
<           END IF
---
>       IF (NMERGE.EQ.MMAX) THEN
>           if(rank.eq.0)
>      &    WRITE (6,50)  NMERGE
>    50     FORMAT (5X,'WARNING!   MERGER LIMIT REACHED   NMERGE =',I4)
791d587
<       IF (NAME(I).GT.N.AND.NAME(JCOMP).GT.N.AND.ECC1.GT.1.0) GO TO 100
794a591
> *
799,800c596,623
< *     IF ((NAME(I).LT.-2*NZERO.AND.JCOMP.GT.N).OR.
< *    &     NAME(JCOMP).LT.-2*NZERO) GO TO 100
---
>       IF ((NAME(I).LT.-2*NZERO.AND.JCOMP.GT.N).OR.
>      &     NAME(JCOMP).LT.-2*NZERO) GO TO 100
> *
>       IF (NAME(I).LT.0) THEN
> *       Avoid frequent mergers due to short look-up times.
>           IF (KZ(19).GT.0) THEN
>               TM = MIN(TEV(I1),TEV(I2),TEV(JCOMP))
>               IF (TM - TIME.LT.0.05) GO TO 100
>           END IF
>           CALL HIMAX2(I1,ECC,SEMI,ECC1,SEMI1,EMAX,EMIN,ZI,TG,EDAV)
>           Q = BODY(JCOMP)/BODY(I)
>           XFAC = (1.0 + Q)*(1.0 + EMAX)/SQRT(1.0 - EMAX)
>           FE  = 1.0
>           PCRIT2 = 2.8*FE*XFAC**0.4*SEMI
>           IF (SEMI1*(1.0 - EMAX).LT.YFAC*PCRIT2) THEN
>               PM = SEMI1*(1.0 - EMAX)
>               if(rank.eq.0)
>      &        WRITE (6,58)  ECC1, EMAX, YFAC, PM, PCRIT, YFAC*PCRIT2, TG
>    58         FORMAT (' WATCH HIMAX2    E1 EX YF PM PC PC2 TG ',
>      &                                  2F7.3,1P,5E10.2)
>           ELSE
>               PM = SEMI1*(1.0 - EMAX)
>               if(rank.eq.0)
>      &        WRITE (6,59)  ECC1, EMAX, YFAC, PM, PCRIT, YFAC*PCRIT2, TG
>    59         FORMAT (' CHECK HIMAX2    E1 EX YF PMX PC PC2 TG ',
>      &                                  2F7.3,1P,5E10.2)
>           END IF
>       END IF
806c629,630
<               WRITE (6,20)  WHICH1, IPAIR, TTOT, H(IPAIR), R(IPAIR),
---
>               if(rank.eq.0)
>      &        WRITE (6,20)  WHICH1, IPAIR, TIME+TOFF, H(IPAIR),R(IPAIR),
815,819c639,641
<               WRITE (6,60)  NAME(I1), NAME(JI), NAME(I1+1), NAME(J1),
<      &                      NAME(JJ), NAME(J1+1), ECC, ECC1, SEMI,
<      &                      SEMI1, PMIN, PCRIT
<    60         FORMAT (' HI MERGE    NAM E E1 A A1 PM PC ',
<      &                              6I7,2F7.3,1P,4E10.2)
---
>               if(rank.eq.0)
>      &        WRITE (6,60)  NAME(JI), NAME(JJ), ECC, ECC1, R(JPAIR)
>    60         FORMAT (' HI MERGE    NM E E1 RJ ',2I6,2F7.3,1P,E10.2)
823,824c645,646
<           IF (JCOMP.GT.N) WHICH1 = ' QUAD   '
<           WRITE (6,20)  WHICH1, IPAIR, TTOT, H(IPAIR), R(IPAIR),
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  WHICH1, IPAIR, TIME+TOFF, H(IPAIR), R(IPAIR),
829,849c651,652
< *       Check for diagnostic output of quadruples.
<       IF (SEMI1.GT.0.0.AND.JCOMP.GT.N.AND.KZ(37).GT.0) THEN
<           ZMB = BODY(I) + BODY(JCOMP)
<           TK = DAYS*SEMI1*SQRT(SEMI1/ZMB)
<           WRITE (89,65)  TTOT, NAME(2*IPAIR-1), NAME(2*JPAIR-1),
<      &                   LISTQ(1), SQRT(RI2), ECC1, EB, EB2, EB1,
<      &                   TK, PMIN, PCRIT
<    65     FORMAT (' QUAD#   T NAM LQ RI E1 EB EB2 EB1 P1 PM PC ',
<      &                      F8.1,2I6,I4,F6.2,F8.4,1P,3E12.3,3E9.1)
<       END IF
< *
< *       Generate a diagnostic file of stable hierarchies (suppressed).
<       IF (ECC1.LT.-1.0) THEN
<           RI = SQRT(RI2)/RC
<           WRITE (80,70)  TPHYS, RI, NAME(JCOMP), QL, Q1, ECC, ECC1,
<      &                   SEMI, SEMI1, PCRIT/PMIN, 360.0*ANGLE/TWOPI,EMAX
<    70     FORMAT (F8.1,F5.1,I6,2F6.2,2F6.3,1P,2E10.2,0P,F5.2,F6.1,F6.3)
<           CALL FLUSH(80)
<       END IF
< *
< *       Copy pair index and set indicator for calling MERGE from MAIN.
---
> *       Copy RA & pair index and set indicator for calling MERGE from MAIN.
>       RMAX = RA
860a664,665
> 
> 
1,2c1,2
< 1068 2004-04-02 19:18 /work/Umi2/spurzem/5/nbody6compare-oct2006/inclin.f
< nbody6compare-oct2006/inclin.f
---
> 1077 1997-07-17 15:49 /work/Umi2/spurzem/5/nbody6++compare/inclin.f
> nbody6++compare/inclin.f
34c34
< *       Determine inclination in radians.
---
> *       Determine inclination in degrees.
36d35
<       FAC = MIN(FAC,1.0D0)
37a37
>       ALPHA = 180.0*ALPHA/3.1415926
1,2c1,2
< 449 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/inext.f
< nbody6compare-oct2006/inext.f
---
> 449 2001-08-14 19:20 /work/Umi2/spurzem/5/nbody6++compare/inext.f
> nbody6++compare/inext.f
1,2c1,2
< 2614 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/input.f
< nbody6compare-oct2006/input.f
---
> 3117 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/input.f
> nbody6++compare/input.f
0a1,4
> # 1 "input.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "input.F"
4,5c8,9
< *       Parameter input.
< *       ----------------
---
> * Parameter input.
> * ----------------
9a14
> # 19 "input.F"
11c16
< *       Make a formal call to define input parameters & counters.
---
> * Make a formal call to define input parameters & counters.
14,22c19,36
< *       Read & print the main input parameters.
<       READ (5,*)  N, NFIX, NCRIT, NRAND, NNBMAX, NRUN
<       READ (5,*)  ETAI, ETAR, RS0, DTADJ, DELTAT, TCRIT, QE, RBAR, ZMBAR
<       READ (5,*)  (KZ(J),J=1,40)
<       READ (5,*)  DTMIN, RMIN, ETAU, ECLOSE, GMIN, GMAX
< *
<       WRITE (6,10)
<    10 FORMAT (/////,15X,'N  NFIX  NCRIT  NRAND  NNBMAX  NRUN')
<       WRITE (6,12)  N, NFIX, NCRIT, NRAND, NNBMAX, NRUN
---
>       IF(rank.eq.0)THEN
> * Read & print the main input parameters.
>          READ (5,*) N, NFIX, NCRIT, NRAND, NNBOPT, NRUN
> C Termination time in physical units, TCRITp, read in nbody6.F
>          READ (5,*) ETAI, ETAR, RS0, DTADJ, DELTAT, TCRIT,
>      & QE, RBAR, ZMBAR
>          READ (5,*) (KZ(J),J=1,40)
>          READ (5,*) (BK(J),J=1,10)
>          READ (5,*) DTMIN, RMIN, ETAU, ECLOSE, GMIN, GMAX
>       END IF
> *
> # 61 "input.F"
> *
> # 70 "input.F"
>       if(rank.eq.0)then
>          WRITE (6,10)
>    10 FORMAT (
>          WRITE (6,12) N, NFIX, NCRIT, NRAND, NNBOPT, NRUN
24,32c38,52
<       WRITE (6,15)
<    15 FORMAT (//,12X,'ETAI      ETAR      RS0       DTADJ     DELTAT',
<      &                        '    TCRIT     QE        RBAR      ZMBAR')
<       WRITE (6,20)  ETAI, ETAR, RS0, DTADJ, DELTAT, TCRIT, QE, RBAR,
<      &                                                             ZMBAR
<    20 FORMAT (/,9X,1P,10E10.1)
<       WRITE (6,22)
<    22 FORMAT (//,12X,'OPTIONS')
<       WRITE (6,24)  (J,J=1,40)
---
> *
> C New: (Aug.1998, P.Kroupa)
>          WRITE(6,15)
>    15 FORMAT (
>      & '     DELTAT',
>      & '     TCRITp    TCRIT     QE',
>      & '        RBAR       ZMBAR')
>          WRITE (6,20) ETAI, ETAR, RS0, DTADJ, DELTAT, TCRITp, TCRIT,
>      & QE, RBAR,
>      & ZMBAR
>    20 FORMAT (/,10X,1P10E10.1)
> *
>          WRITE (6,22)
>    22 FORMAT (
>          WRITE (6,24) (J,J=1,40)
34c54
<       WRITE (6,26)  (KZ(J),J=1,40)
---
>          WRITE (6,26) (KZ(J),J=1,40)
36,40c56,67
<       WRITE (6,28)
<    28 FORMAT (//,12X,'DTMIN     RMIN      ETAU      ECLOSE    GMIN',
<      &                                                     '      GMAX')
<       WRITE (6,30)  DTMIN, RMIN, ETAU, ECLOSE, GMIN, GMAX
<    30 FORMAT (/,9X,1P,6E10.1)
---
>          WRITE (6,21)
>    21 FORMAT (
>          WRITE (6,25) (J,J=1,10)
>    25 FORMAT (/,9X,10I3)
>          WRITE (6,27) (BK(J),J=1,10)
>    27 FORMAT (/,9X,10I3)
>          WRITE (6,28)
>    28 FORMAT (
>      & '      GMAX')
>          WRITE (6,30) DTMIN, RMIN, ETAU, ECLOSE, GMIN, GMAX
>    30 FORMAT (/,9X,1P6E10.1)
>       end if
42c69,80
< *       Perform a simple validation check on main input parameters.
---
> * Define total particle number & neighbour membership range.
>       NTOT = N
>       NZERO = N
>       NNBMAX = MIN(N/2,LMAX - 3)
>       ZNBMIN = MAX(0.01*FLOAT(NNBMAX),1.0)
>       ZNBMAX = 0.9*FLOAT(NNBMAX)
> * Save initial ETAI.
>       ETA0 = ETAI
>       RSMIN = RS0
>       RC = RS0
> *
> * Perform a simple validation check on main input parameters.
48c86
< *       Read parameters for binary evolution analysis.
---
> * Read parameters for binary evolution analysis.
50,54c88,101
<           READ (5,*)  DELTAS, ORBITS(1), (GPRINT(J),J=1,K)
<           WRITE (6,40)  DELTAS, ORBITS(1), (GPRINT(J),J=1,K)
<    40     FORMAT (//,12X,'DELTAS =',F6.2,'  ORBITS(1) =',F6.2,
<      &                                            '  GPRINT(J) =',9F7.3)
< *       Modify binary output factor by perturbation at different levels.
---
>           if(rank.eq.0)then
>           READ (5,*) DELTAS, ORBITS(1), (GPRINT(J),J=1,K)
>           end if
> *
> 
> 
> 
> 
> 
> *
>       if(rank.eq.0)WRITE (6,40) DELTAS, ORBITS(1), (GPRINT(J),J=1,K)
>    40 FORMAT (
>      & '  GPRINT(J) =',9F7.3)
> * Modify binary output factor by perturbation at different levels.
57c104
<    50     CONTINUE
---
>    50 CONTINUE
60,61c107,119
< *       Set random number skip for routine DATA.
<       IDUM1 = NRAND
---
> C Old version:
> * Set random number skip for routine DATA.
> c IDUM1 = NRAND
> C NEW version (14.08.98, P.Kroupa):
> C* Set random number SEED for routine DATA.
>       IDUM1 = -1*NRAND
> c+++ Notify others of this change on log file:
>       if(rank.eq.0)then
>       write(6,*)
>       write(6,*)' ****** NOTE: new random number seed initialisation!'
>       write(6,*)' ****** AND new ran2 from new ed. of Press et al.'
>       write(6,*)
>       end if
63,64d120
< *       Save square of c.m. approximation parameter (coupled to GMIN).
<       CMSEP2 = GMIN**(-0.666666667)
66,75c122,123
< *       Define total particle number & neighbour membership range.
<       NTOT = N
<       NZERO = N
<       ZNBMIN = 0.2*FLOAT(NNBMAX)
<       ZNBMAX = 0.9*FLOAT(NNBMAX)
< *       Save initial ETAI.
<       ETA0 = ETAI
<       RSMIN = RS0
<       RC = RS0
< *       Temporary save of initial neighbour sphere for OUTPUT & NBLIST.
---
> * Save square of c.m. approximation parameter (coupled to GMIN).
>       CMSEP2 = GMIN**(-0.666666667)
1,2c1,2
< 2635 2004-04-02 19:26 /work/Umi2/spurzem/5/nbody6compare-oct2006/insert.f
< nbody6compare-oct2006/insert.f
---
> 2515 2001-09-30 19:50 /work/Umi2/spurzem/5/nbody6++compare/insert.f
> nbody6++compare/insert.f
39a40,42
>       IF (LSTAR.GT.NNTB) THEN
>           LSTAR = (LI + NNTB)/2
>       END IF
44,51c47,51
< *       Avoid division by zero (unperturbed steps may also be quantized).
<       IF (TBLIST.NE.TJ) THEN
<           FAC = (TI - TJ)/(TBLIST - TJ)
<           LSTAR = LSTAR + FLOAT(NNTB - LSTAR)*FAC
<           LSTAR = MAX(LSTAR,LI+1)
<           LSTAR = MIN(LSTAR,NNTB)
<           J = KBLIST(LSTAR)
<       END IF
---
>       FAC = (TI - TJ)/(TBLIST - TJ)
>       LSTAR = LSTAR + FLOAT(NNTB - LSTAR)*FAC
>       LSTAR = MAX(LSTAR,LI+1)
>       LSTAR = MIN(LSTAR,NNTB)
>       J = KBLIST(LSTAR)
67,71c67
<           IF (J.EQ.I) THEN
<               LI = LI - 1
<               GO TO 50
<           END IF
<           IF (TI.LT.T0(J) + STEP(J)) GO TO 20
---
>           IF (LSTAR.GT.LI.AND.TI.LT.T0(J) + STEP(J)) GO TO 20
86c82,84
<    50 RETURN
---
>    50 CONTINUE
> *
>       RETURN
88a87
> 
1,2c1,2
< 5846 2006-09-15 16:10 /work/Umi2/spurzem/5/nbody6compare-oct2006/instar.f
< nbody6compare-oct2006/instar.f
---
> 1980 2006-06-20 02:33 /work/Umi2/spurzem/5/nbody6++compare/instar.f
> nbody6++compare/instar.f
8,14c8,9
<       REAL*8 TSCLS(20),LUMS(10),GB(10),TM,TN
<       REAL*8 M0,M1,RM,LUM,AGE,MC,RCC,DLOGM
<       REAL*8 MENV,RENV,K2,K3
<       PARAMETER(K3=0.21D0)
<       REAL*8 JSPIN,OSPIN
<       REAL*8 VROTF
<       EXTERNAL VROTF
---
>       REAL*8  LUMS(10),TSCLS(20),GB(10),TM,TN
>       REAL*8  M0,M1,RM,LUM,AGE,MC,RCC
18,24c13,21
<       TPHYS = 0.d0
<       ZMRG = 0.d0
<       ZMHE = 0.d0
<       ZMRS = 0.d0
<       ZMWD = 0.d0
<       ZMSN = 0.d0
<       ZMDOT = 0.d0
---
>       TPHYS = 0.0D0
>       TPLOT = 0.0D0
>       ZMRG = 0.0D0
>       ZMHE = 0.0D0
>       ZMRS = 0.0D0
>       ZMWD = 0.0D0
>       ZMSN = 0.0D0
>       ZMDOT = 0.0D0
>       EMDOT = 0.0D0
31d27
<       NBH = 0
34,35c30,34
< *NB6  NKICK = 0
< *NB6  NBKICK = 0
---
>       AGE = 0.d0
>       TMDOT = 1.0E+10
>       IF (KZ(27).EQ.0) THEN
>           TSTAR = TSCALE
>       END IF
37,72c36
< *NB4 NEW
<       ZMNH = 0.d0
<       ZMBH = 0.d0
<       ZMSY = 0.d0
<       NROCHE = 0
<       NCHAOS = 0
<       IQCOLL = 0
<       IBLUE = 0
<       NCHA = 0
<       NSP = 0
<       NHG = 0
<       NNH = 0
<       NBR = 0
<       NAS = 0
<       NRO = 0
<       NDD = 0
<       NSPIR = 0
<       NCIRC = 0
<       NSLP = 0
<       NCONT = 0
<       NCOAL = 0
<       NSTAB = 0
<       NEINT = 0
<       NEMOD = 0
<       NHYP = 0
<       NGB = 0
<       NMS = N
< *
<       TMDOT = 1.0d+10
< *NB6  IF (KZ(27).EQ.0) THEN
< *         TSTAR = TSCALE
< *     END IF
< *
<       WRITE (6,9) ZPARS(11),ZPARS(12),ZMET
<  9    FORMAT(//,12X,'ABUNDANCES: X =',F6.3,' Y =',F6.3,' Z =',F6.3)
< *NB6  zpars(11)=xhyd   zpars(12)=yhel
---
> *     Set the Hydrogen & Helium abundances.
74,75c38,39
< *       Calculate scale factor for spin angular momentum.
<       SPNFAC = ZMBAR*SU**2/(1.0D+06*TSTAR)
---
>       yhel = 0.24d0 + 2.d0*zmet
>       xhyd = 1.d0 - yhel - zmet
77,78c41
<       EPOCH1 = EPOCH0
<       DO 10 I = 1,N
---
> *     Set evolution parameters which depend solely on metallicity.
80,114c43
< *       Obtain stellar parameters at current epoch.
<           IF(KZ(22).GE.3)THEN
<              READ(12,*)M1,KW,M0,EPOCH1,OSPIN
<           ELSE
<              M1 = BODY(I)*ZMBAR
<              M0 = M1
<              KW = 1
<              IF(M0.LE.0.01D0) KW = 10
<              IF(M0.GE.1000.D0) KW = 14
<           ENDIF
<           MC = 0.D0
<           AGE = TIME*TSTAR - EPOCH1
<           CALL star(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
<           CALL hrdiag(M0,AGE,M1,TM,TN,TSCLS,LUMS,GB,ZPARS,
<      &                RM,LUM,KW,MC,RCC,MENV,RENV,K2)
< *
< *       Assign initial spin angular momentum. 
<           IF(KZ(22).GE.3)THEN
<              JSPIN = (K2*(M1-MC)*RM**2 + K3*MC*RCC**2)*OSPIN
<           ELSE
<              OSPIN = 45.35d0*VROTF(M1)/RM
<              JSPIN = K2*M1*RM**2*OSPIN
<              IF(KW.GT.1) JSPIN = 0.D0
<           ENDIF
< *
< *       Convert from solar radii to scaled units (assume Sun = 1/215 AU).
<           IF (KZ(27).EQ.-2) THEN
<               RADIUS(I) = 0.d0
<               ZLMSTY(I) = 0.d0
<               SPIN(I) = 0.d0
<           ELSE
<               RADIUS(I) = RM/SU
<               ZLMSTY(I) = LUM
<               SPIN(I) = JSPIN/SPNFAC
<           END IF
---
>       CALL zcnsts(zmet,zpars)
116,124c45
<           IF (KZ(27).EQ.3.AND.KZ(28).GT.0) THEN
<               RADIUS(I) = 1.0D-12/(3.0*RBAR)
<               KW = 13
<               TEV(I) = 1000.0
<               M0 = 25.0
<               EPOCH(I) = -15.0/TSTAR
<               IF (I.EQ.1) WRITE (6,5)  M1, KW, RADIUS(I)*SU
<     5         FORMAT (/,12X,'FIRST STAR:    M K* R/SU ',F7.2,I4,1P,E9.1)
<           END IF
---
>       DO 10 I = 1,N
126,127c47,54
< *       Initialize the stellar classification type (KW = 0 - 15).
<           KSTAR(I) = KW
---
> *       Obtain stellar parameters at current epoch.
>           M1 = BODY(I)*ZMBAR
>           M0 = M1
>           KW = 1
>           AGE = 0.0
>           CALL STAR(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
>           CALL HRDIAG(M0,AGE,M1,TM,TN,TSCLS,LUMS,GB,ZPARS,
>      &                RM,LUM,KW,MC,RCC)
129,131c56,57
< *       Save the initial mass of all the stars in sequential order.
<           BODY(I) = M1/ZMBAR
<           BODY0(I) = M0/ZMBAR
---
> *       Convert from solar radii to scaled units (assume Sun = 0.005 AU).
>           RADIUS(I) = 0.005*RM/(AU*RBAR)
133,137c59,60
< *       Set initial look-up time.
<           EPOCH(I) = TIME*TSTAR - AGE
<           TEV0(I) = TIME
<           CALL TRDOT(I,DTM,M1)
<           TEV(I) = DTM
---
> *       Set initial look-up time 0.05 of main sequence time (but < 10**7 yrs).
>           TEV(I) = MIN(0.05*TM,10.0D0)/TSTAR
143a67,72
> *       Initialize the stellar classification type (KW = 1 - 8).
>           KSTAR(I) = KW
> *
> *       Save the initial mass of all the stars in sequential order.
>           BODY(I) = M1/ZMBAR
>           BODY0(I) = M0/ZMBAR
147,148c76
< *       (changed to 100 yr to be consistent with trdot: 2/8/02)
<       DT = 1.0d-04/TSCALE
---
>       DT = 1.0E-03/TSCALE
150d77
<       IF(DTN*TSCALE.LT.100.0) DTN = 2.d0*DTN
153,241d79
< *       Initialize stellar collision matrix.
< *
<       ktype(0,0) = 1
<       do 20 , j = 1,6
<          ktype(0,j) = j
<          ktype(1,j) = j
<  20   continue
<       ktype(0,7) = 4
<       ktype(1,7) = 4
<       do 25 , j = 8,12
<          if(j.ne.10)then
<             ktype(0,j) = 6
<          else
<             ktype(0,j) = 3
<          endif
<          ktype(1,j) = ktype(0,j)
<  25   continue
<       ktype(2,2) = 3
<       do 30 , i = 3,14
<          ktype(i,i) = i
<  30   continue
<       ktype(5,5) = 4
<       ktype(7,7) = 1
<       ktype(10,10) = 15
<       ktype(13,13) = 14
<       do 35 , i = 2,5
<          do 40 j = i+1,12
<             ktype(i,j) = 4
<  40      continue
<  35   continue
<       ktype(2,3) = 3
<       ktype(2,6) = 5
<       ktype(2,10) = 3
<       ktype(2,11) = 5
<       ktype(2,12) = 5
<       ktype(3,6) = 5
<       ktype(3,10) = 3
<       ktype(3,11) = 5
<       ktype(3,12) = 5
<       ktype(6,7) = 4
<       ktype(6,8) = 6
<       ktype(6,9) = 6
<       ktype(6,10) = 5
<       ktype(6,11) = 6
<       ktype(6,12) = 6
<       ktype(7,8) = 8
<       ktype(7,9) = 9
<       ktype(7,10) = 7
<       ktype(7,11) = 9
<       ktype(7,12) = 9
<       ktype(8,9) = 9
<       ktype(8,10) = 7
<       ktype(8,11) = 9
<       ktype(8,12) = 9
<       ktype(9,10) = 7
<       ktype(9,11) = 9
<       ktype(9,12) = 9
<       ktype(10,11) = 9
<       ktype(10,12) = 9
<       ktype(11,12) = 12
<       do 45 , i = 0,12
<          ktype(i,13) = 13
<          ktype(i,14) = 14
<  45   continue
<       ktype(13,14) = 14
< *
< * Increase common-envelope cases by 100.
<       do 50 , i = 0,9
<          do 55 , j = i,14
<             if(i.le.1.or.i.eq.7)then
<                if(j.ge.2.and.j.le.9.and.j.ne.7)then
<                   ktype(i,j) = ktype(i,j) + 100
<                endif
<             else
<                ktype(i,j) = ktype(i,j) + 100
<             endif
<  55      continue
<  50   continue
< *
< *       Assign the remaining values by symmetry.
<       do 60 , i = 1,14
<          do 65 , j = 0,i-1
<             ktype(i,j) = ktype(j,i)
<  65      continue
<  60   continue
< *
<       WRITE (6,75)  KTYPE
<    75 FORMAT (/,11X,' KTYPE: ',15I4,14(/,19X,15I4))
< *
242a81
> *
1,2c1,2
< 13210 2006-09-25 14:15 /work/Umi2/spurzem/5/nbody6compare-oct2006/intgrt.f
< nbody6compare-oct2006/intgrt.f
---
> 18656 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/intgrt.f
> nbody6++compare/intgrt.f
0a1,4
> # 1 "intgrt.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "intgrt.F"
4,5c8,9
< *       N-body integrator flow control.
< *       -------------------------------
---
> * N-body integrator flow control.
> * -------------------------------
8,14c12,19
<       COMMON/CLUMP/   BODYS(NCMAX,5),T0S(5),TS(5),STEPS(5),RMAXS(5),
<      &                NAMES(NCMAX,5),ISYS(5)
<       REAL*8  XI(3),XIDOT(3)
<       INTEGER  NXTLST(NMAX),IBL(LMAX),NBLIST(NMAX),LISTQ(NMAX),NL(20)
<       LOGICAL LOOP,LSTEPM
<       SAVE IQ,ICALL,NQ,LQ,LOOP,LSTEPM,STEPM,ISAVE,JSAVE
<       DATA IQ,ICALL,LQ,LOOP,LSTEPM,STEPM /0,2,11,.TRUE.,.FALSE.,0.03125/
---
>       COMMON/CLUMP/ BODYS(NCMAX,5),T0S(5),TS(5),STEPS(5),RMAXS(5),
>      & NAMES(NCMAX,5),ISYS(5)
>       INTEGER JHIST,JHISTR
>       LOGICAL LSHRNK,LSTEPM
>       EXTERNAL SHORT
>       COMMON/BLKLVL/JHIST(0:NMAX),JHISTR(0:NMAX)
>       INTEGER NXTLST(NMAX),IREG(NMAX),NBLIST(NMAX),IBL(LMAX)
>       COMMON/STSTAT/ TINIT,NIR,NIB,NRGL,NKS
15a21,25
> 
> 
> 
> 
>       INTEGER IMPI(LMAX,NMAX),JMPI(11,maxpe)
17,18c27,28
< *       Enforce level search on return, except new and terminated KS.
<       IF (IPHASE.NE.1.AND.IPHASE.NE.2) LOOP = .TRUE.
---
>       SAVE IQ,ICALL,LSTEPM,STEPM
>       DATA IQ,ICALL,LSTEPM,STEPM /0,2,.FALSE.,0.03125/
20c30
< *       Update quantized value of STEPM for large N (first time only).
---
> * Update quantized value of STEPM for large N (first time only).
27,28c37,38
< *       Search for high velocities after escape or KS/chain termination.
<   999 IF (KZ(37).GT.0.AND.(IPHASE.EQ.-1.OR.IPHASE.GE.2)) THEN
---
> * Search for high velocities after escape or KS/chain termination.
>   999 IF (KZ(18).GT.0.AND.(IPHASE.EQ.-1.OR.IPHASE.GE.2)) THEN
32c42
< *       Reset control & regularization indicators.
---
> * Reset control & regularization indicators.
35,36c45,47
<       DTM = 1.0
< *       Initialize end-point of integration times and set DTM.
---
> * Initialize end-point of integration times and set TMIN.
>       TMIN = 1.0D+10
> * Initialize end-point of integration times and set TMIN and DTM.
38,46c49,52
<           TIMENW(I) = T0(I) + STEP(I)
<           DTM = MIN(DTM,STEP(I))
<  1000 CONTINUE
< *
< *       Determine level for the smallest step (ignore extreme values).
<       LQS = 20
<       DO 1001 L = 6,20
<           IF (DTM.EQ.DTK(L)) THEN
<               LQS = L
---
>          TIMENW(I) = T0(I) + STEP(I)
>           IF(TIMENW(I).LT.TMIN)THEN
>              TMIN = TIMENW(I)
>              IMIN = I
48c54
<  1001 CONTINUE
---
>  1000 CONTINUE
50,51d55
< *       Specify upper level for optimized membership.
<       LQB = LQS - 4
54,55d57
< *       Enforce new block step search initially and on significant change.
<       TLISTQ = TIME
57,101c59,60
< *       Check updating new list of block steps with T0 + STEP =< TLISTQ.
<     1 ICALL = ICALL + 1
< *       Reset TMIN second & third time after change to catch new chain step.
<       IF (TIME.GE.TLISTQ.OR.ICALL.LE.3) THEN
< *       Update interval by optimization at major times (sqrt of N-NPAIRS).
<           IF (DMOD(TLISTQ,2.0D0).EQ.0.0D0.OR.LOOP) THEN
<               LOOP = .FALSE.
<               DO 10 L = 1,20
<                   NL(L) = 0
<    10         CONTINUE
<               DO 14 I = IFIRST,NTOT
< *       Count steps at five different levels for the smallest values.
<                   DO 12 L = LQB,LQS
<                       IF (STEP(I).LT.DTK(L)) NL(L) = NL(L) + 1
<    12             CONTINUE
<    14         CONTINUE
<               NLSUM = 0
< *       Determine interval by summing smallest steps until near sqrt(N-N_b).
<               NSQ = SQRT(FLOAT(N - NPAIRS))
<               LQ = LQS
<               DO 15 L = LQS,LQB,-1
<                   NLSUM = NLSUM + NL(L)
<                   IF (NLSUM.LE.NSQ) LQ = L
<    15         CONTINUE
< *             WRITE (6,16)  TIME+TOFF,NQ,NLSUM,LQ,(NL(K),K=LQB,LQS)
< *  16         FORMAT (' LEVEL CHECK:    T NQ NLSUM LQ NL  ',
< *    &                                  F9.3,3I5,2X,7I4)
<           END IF
< *
< *       Increase interval by optimized value.
<           NQ = 0
<           TMIN = 1.0D+10
<    18     TLISTQ = TLISTQ + DTK(LQ)
<           DO 20 I = IFIRST,NTOT
<               IF (TIMENW(I).LE.TLISTQ) THEN
<                   NQ = NQ + 1
<                   LISTQ(NQ) = I
<                   TMIN = MIN(TIMENW(I),TMIN)
<               END IF
<    20     CONTINUE
< *       Increase interval in rare case of zero membership.
<           IF (NQ.EQ.0) GO TO 18
< *       Make a slight adjustment for high levels and small membership.
<           IF (LQ.LE.15.AND.NQ.LE.2) LQ = LQ - 1
<       END IF
---
> * Find all particles due at next block time.
>     1 CONTINUE
103,111c62
< *       Find all particles in next block (TIMENW = TMIN).
<       CALL INEXT(NQ,LISTQ,TMIN,NXTLEN,NXTLST)
< *
< *       Set new time and save block time (for regularization terminations).
<       I = NXTLST(1)
<       TIME = T0(I) + STEP(I)
<       TBLOCK = TIME
<       LI = 0
<       IPRED = 0
---
>       NXTLEN = 0
113,114c64,82
< *       Re-determine list if current time exceeds boundary.
<       IF (TIME.GT.TLISTQ) GO TO 1
---
> * Reset TSMALL second time after main change to catch new small steps.
>       ICALL = ICALL + 1
>       IF (ICALL.EQ.2) GO TO 999
> *
> * determine next block particles without assuming
> * sorted time step list (R.Sp.)
> *
>       DO 5 J = IFIRST, NTOT
>          IF(DABS(TIMENW(J)-TMIN).LT.DTK(40)) THEN
>             NXTLEN = NXTLEN + 1
>             NXTLST(NXTLEN) = J
>          END IF
>   5 CONTINUE
> *
> * if(ixxxx.gt.0)then
> * if(time.gt.2.0D0)
> * *print*,' nxtlen,block=',nxtlen,(name(nxtlst(k)),k=1,nxtlen)
> * if(ixxxx.gt.3)ixxxx=0
> * end if
116c84,91
< *       Check option for advancing interstellar clouds.
---
> * Update short timestep list for regularization search.
>       CALL SHORT(NXTLEN,NXTLST)
> *
> * Set new time and save block time (for regularization terminations).
>       TIME = TMIN
>       TBLOCK = TIME
> *
> * Check option for advancing interstellar clouds.
121,138c96,103
< *       Check optional integration of cluster guiding centre.
<       IF (KZ(14).EQ.3.OR.KZ(14).EQ.4) THEN
<           IF (KZ(14).EQ.3.AND.DMOD(TIME,STEPX).EQ.0.0D0) THEN
<               CALL GCINT
<           END IF
< *       Include mass loss by gas expulsion (Kroupa et al. MN 321, 699).
<           IF (MPDOT.GT.0.0D0.AND.TIME + TOFF.GT.TDELAY) THEN
<               MP = MP0/(1.0 + MPDOT*(TIME + TOFF - TDELAY))
<           END IF
<       END IF
< *
< *       Include commensurability test (may be suppressed if no problems).
< *     IF (DMOD(TIME,STEP(I)).NE.0.0D0) THEN
< *         WRITE (6,25)  I, NAME(I), NSTEPI, TIME, STEP(I), TIME/STEP(I)
< *  25     FORMAT (' DANGER!   I NM # TIME STEP T/DT ',
< *    &                        2I6,I11,F12.5,1P,E9.1,0P,F16.4)
< *         STOP
< *     END IF
---
> * Include commensurability test (may be suppressed if no problems).
> * IF (STEP(IMIN).LT.1.0E-15.OR.DMOD(TIME,STEP(IMIN)).NE.0.0D0) THEN
> * WRITE (6,1005) IMIN, NAME(IMIN), NSTEPI, TIME, STEP(IMIN),
> * & TIME/STEP(IMIN)
> *1005 FORMAT (' DANGER!   I NM # TIME STEP T/DT ',
> * & 2I5,I11,F12.5,1P,E9.1,0P,F16.4)
> * CALL ABORT
> * END IF
140c105
< *       Check for new regularization at end of block.
---
> * Check for new regularization at end of block.
144,146d108
< *       Copy the saved component indices.
<           ICOMP = ISAVE
<           JCOMP = JSAVE
150c112
< *       Check next adjust time before beginning a new block.
---
> * Check next adjust time before beginning a new block.
157c119
< *       Check output time in case DTADJ & DELTAT not commensurate.
---
> * Also check output time in case DTADJ & DELTAT not commensurate.
164c126
< *       See whether to advance any close encounters at first new time.
---
> * See whether to advance any close encounters at first new time.
165a128
>             call cputim(tt5)
166a130,132
>             call cputim(tt6)
>             ttks = ttks + (tt6-tt5)*60.
> *
170c136,183
< *       Check regular force condition for small block memberships.
---
> * Check regularization criterion for single particles.
>       IKS = 0
>       ISMIN = 0
>       DSMIN = DTMIN
> * Search only in prepared list of short-step particles. (R.Sp.)
>       ISHORT = LSHORT(1)
>       DO 50 L = 2,ISHORT+1
>           I = LSHORT(L)
> * Search for minimum timestep candidate for not ordered steps (R.Sp.)
> * Beware that members of LSHORT may be members of KS pair (R.Sp.)
>           IF (STEP(I).LT.DTMIN.AND.STEP(I).LT.DSMIN.AND.I.LE.N.AND.
>      & I.GE.IFIRST) THEN
>               DSMIN = STEP(I)
>               ISMIN = I
>           END IF
>    50 CONTINUE
> *
> * See whether dominant body can be regularized.
>       IF(ISMIN.GT.0) THEN
>           CALL SEARCH(ISMIN,IKS)
> *
> * Include close encounter search for low-eccentric massive binaries.
>       IF (IKS.EQ.0.AND.STEP(ISMIN).LT.4.0*DTMIN) THEN
> * Consider massive single bodies in absence of subsystems.
>           IF (ISMIN.LE.N.AND.BODY(I).GT.2.0*BODYM.AND.NSUB.EQ.0) THEN
> *
> * Obtain two-body elements and relative perturbation.
>               JMIN = 0
>               CALL ORBIT(ISMIN,JMIN,SEMI,ECC,GI)
> *
>               EB = -0.5*BODY(ISMIN)*BODY(JMIN)/SEMI
>               IF (EB.LT.EBH.AND.GI.LT.0.25.AND.JMIN.GE.IFIRST) THEN
>                   APO = SEMI*(1.0 + ECC)
> * Check eccentricity (cf. max perturbation) and neighbour radius.
>                   IF (ECC.LT.0.5.AND.APO.LT.0.02*RS(ISMIN)) THEN
> * PRINT*, ' KS TRY: NAM E A EB ',
> * * NAME(ISMIN), NAME(JMIN), ECC, SEMI, EB
> * CALL FLUSH(6)
>                       IKS = IKS + 1
>                       ICOMP = ISMIN
>                       JCOMP = JMIN
>                   END IF
>               END IF
>           END IF
>       END IF
>       END IF
> *
> * Check regular force condition for small block memberships.
178c191
<    28     CONTINUE
---
>    28 CONTINUE
181,182c194,197
< *       Decide between merging of neighbour lists or full N prediction.
<       IF (NXTLEN.LE.10.AND.IR.EQ.0) THEN
---
> * Choose between predicting all neighbours or full N.
> * Warning do not distribute prediction on PEs for consistency
>           call cputim(tt1)
>       IF (NXTLEN.LT.10.AND.IR.EQ.0) THEN
184c199
< *       Initialize pointers for neighbour lists.
---
> * Initialize pointers for neighbour lists.
187c202
<    30     CONTINUE
---
>    30 CONTINUE
189c204
< *       Merge all neighbour lists (with absent members of IBL added).
---
> * Merge all neighbour lists (with absent members of NXTLST added).
192c207
< *       Predict coordinates & velocities of neighbours and #I to order FDOT.
---
> * Predict coordinates & velocities of neighbours and #I to order FDOT.
193a209,210
>           NBFLAG = 1
>           IPRED = 0
205c222
<    35     CONTINUE
---
>    35 CONTINUE
207d223
<           IPRED = 1
208a225,226
>           NBFLAG = 1
>           IPRED = 1
219c237
<    40     CONTINUE
---
>  40 CONTINUE
222c240,242
< *       Resolve perturbed KS pairs with c.m. prediction after NBSORT.
---
> * Resolve any KS coordinates & velocities using most recent c.m.
>       IF (NPAIRS.GT.0) THEN
> * Resolve perturbed KS pairs with c.m. prediction after NBSORT.
227c247
< *       Ignore c.m. prediction after full N loop (all active KS needed).
---
> * Ignore c.m. prediction after full N loop (all active KS needed).
240,243c260,263
<           ZZ = 1.0
< *       Distinguish between low and high-order prediction of U & UDOT.
<           IF (GAMMA(JPAIR).GT.1.0D-04) ZZ = 0.0
<           CALL KSRES2(JPAIR,J1,J2,ZZ)
---
>           IZZ = -1
> * Predict ALL binaries even unperturbed ones for parallel code (R.Sp.)
>           ZZ = 0.0
>           CALL KSRES2(JPAIR,J1,J2,ZZ,IZZ)
247c267,293
< *       Save new time (output time at TIME > TADJ) and increase # blocks.
---
>       END IF
> * Resolve Chain if it is in block or in neighbour lists (RS Nov. 03).
>       IF(NCH.GT.0) THEN
>       ICHPR = 0
> * First check whether chain c.m. is in current block (ICHPR = 2).
>           DO 46 L = 1,NXTLEN
>               I = NXTLST(L)
>               IF(I.EQ.ICH) ICHPR = 2
>  46 CONTINUE
> * Second check whether neighbour lists contain chain c.m. (ICHPR = 1).
>           IF (ICHPR.EQ.0) THEN
>               DO 47 L = 1,NXTLEN
>                   I = NXTLST(L)
>                   NNB1 = LIST(1,I) + 1
> * Second check whether neighbour lists contain chain c.m. (ICHPR = 1).
>                   DO 48 K = 2,NNB1
>                       J = LIST(K,I)
>                       IF (J.GT.ICH) GO TO 47
>                       IF (J.EQ.ICH) ICHPR = 1
>  48 CONTINUE
>  47 CONTINUE
>           END IF
>           IF (ICHPR.GT.1) CALL CHLIST(ICH)
>           IF (ICHPR.GT.0) CALL XCPRED(0)
>       END IF
> *
> * Save new time (output time at TIME> TADJ) and increase # of blocks.
252,262c298,375
< *       Advance the pointer (<= NXTLEN) and select next particle index.
<    50 LI = LI + 1
<       IF (LI.GT.NXTLEN) GO TO 1
<       I = NXTLST(LI)
<       TIME = T0(I) + STEP(I)
< *
< *       See whether the regular force needs to be updated (IR > 0).
<       IF (T0R(I) + STEPR(I).LE.TIME) THEN
<           IR = 1
<       ELSE
<           IR = 0
---
>                   call cputim(tt2)
>           ttnbp = ttnbp + (tt2-tt1)*60.
> *
> * Initialize counters for irregular & regular integrations.
>       NREG = 0
> *
> * Advance the irregular step for all particles in the current block.
> * Block-Step Level Diagnostics (R.Sp. 29.Apr. 1993)
>           IF(KZ(33).GT.0)JHIST(NXTLEN) = JHIST(NXTLEN) + 1
> *
> 
> 
> 
> *
>       DO 701 L = 1,NXTLEN
> *
>           I = NXTLST(L)
> *
>       CALL NBINT(I,NBFLAG)
> *
>  701 CONTINUE
> *
>           call cputim(tt3)
>           ttirr = ttirr + (tt3-tt2)*60.
> *
> # 443 "intgrt.F"
> *
>        DO 71 L = 1,NXTLEN
>           I = NXTLST(L)
> * Save new block step and update T0 & next time
>           T0(I) = TIME
>           TIMENW(I) = T0(I) + STEP(I)
> *
> * Set non-zero indicator for new regular force.
>           IF (T0R(I) + STEPR(I).LE.TIME) THEN
>               NREG = NREG + 1
>               IREG(NREG) = I
>           ELSE
> * Extrapolate regular force & first derivatives to obtain F & FDOT.
>               DTR = TIME - T0R(I)
>               DO 65 K = 1,3
>                   F(K,I) = 0.5*(FRDOT(K,I)*DTR + FR(K,I) + FI(K,I))
>                   FDOT(K,I) = ONE6*(FRDOT(K,I) + FIDOT(K,I))
> * Higher order extrapolation?
> * F(K,I) = FI(K,I) + FR(K,I) + DTR*(FRDOT(K,I)
> * * + DTR*(D2R(K,I)/2.D0 + DTR*D3R(K,I)/6.D0))
> * FDOT(K,I) = FIDOT(K,I) + FRDOT(K,I)
> * * + DTR*(D2R(K,I) + DTR*D3R(K,I)/2.D0)
> * F(K,I) = F(K,I)/2.D0
> * FDOT(K,I) = FDOT(K,I)/6.D0
>    65 CONTINUE
>           END IF
> *
>               DO 67 K = 1,3
>                   X0(K,I) = XN(K,I)
>                   X0DOT(K,I) = XNDOT(K,I)
>                   D0(K,I) = FI(K,I)
>                   D1(K,I) = FIDOT(K,I)
>    67 CONTINUE
> *
>  71 CONTINUE
> *
> * CALL nemo_savestate(n,3,time,body,x,xdot)
> *
> * See whether any KS candidates are in the same block.
>       IF (IKS.GT.0) THEN
> * Accept same time, otherwise reduce STEP(ICOMP) and/or delay.
>           IF (T0(JCOMP).EQ.T0(ICOMP)) THEN
>               I = ICOMP
>               ICOMP = MIN(ICOMP,JCOMP)
>               JCOMP = MAX(I,JCOMP)
>           ELSE IF (T0(JCOMP) + STEP(JCOMP).LT.T0(ICOMP)) THEN
>               STEP(ICOMP) = 0.5D0*STEP(ICOMP)
>               TIMENW(ICOMP) = T0(ICOMP) + STEP(ICOMP)
>               IKS = 0
>           ELSE
>               IKS = 0
>           END IF
265,267c378,380
< *       Advance the irregular step.
<       IKS0 = IKS
<       CALL NBINT(I,IKS,IR,XI,XIDOT)
---
>       NSTEPI = NSTEPI + NXTLEN
> *
> * Obtain total force for all particles due in the current block.
269,272c382,408
< *       Save indices of first KS candidates in the block.
<       IF (IKS0.EQ.0.AND.IKS.GT.0) THEN
<           ISAVE = ICOMP
<           JSAVE = JCOMP
---
>       IF(NREG.GT.0)THEN
> *
>            call cputim(tt7)
>               DO 811 J=IFIRST,NTOT
>               S = TIME - T0(J)
>               S1 = 1.5*S
>               S2 = 2.0*S
>               X(1,J) = ((FDOT(1,J)*S + F(1,J))*S +X0DOT(1,J))*S +X0(1,J)
>               X(2,J) = ((FDOT(2,J)*S + F(2,J))*S +X0DOT(2,J))*S +X0(2,J)
>               X(3,J) = ((FDOT(3,J)*S + F(3,J))*S +X0DOT(3,J))*S +X0(3,J)
>               XDOT(1,J) = (FDOT(1,J)*S1 + F(1,J))*S2 + X0DOT(1,J)
>               XDOT(2,J) = (FDOT(2,J)*S1 + F(2,J))*S2 + X0DOT(2,J)
>               XDOT(3,J) = (FDOT(3,J)*S1 + F(3,J))*S2 + X0DOT(3,J)
>  811 CONTINUE
> * Resolve any KS coordinates & velocities using most recent c.m.
>       IF (NPAIRS.GT.0) THEN
>           JJ = -1
>           DO 86 JPAIR = 1,NPAIRS
>           JJ = JJ + 2
>           IF (LIST(1,JJ).GT.0) THEN
>               ZZ = 1.0
>               IZZ = -2
> * Distinguish between low and high-order prediction of U & UDOT.
>               IF (GAMMA(JPAIR).GT.1.0D-04) ZZ = 0.0
>               CALL KSRES2(JPAIR,J1,J2,ZZ,IZZ)
>           END IF
>    86 CONTINUE
275,277c411,464
< *       See whether the regular step is due.
<       IF (IR.GT.0) THEN
<           CALL REGINT(I,XI,XIDOT)
---
>           call cputim(tt8)
>           ttpre = ttpre + (tt8-tt7)*60.
> *
> * Block-Step Level Diagnostics (R.Sp. 29.Apr. 1993)
>           IF(KZ(33).GT.1)JHISTR(NREG) = JHISTR(NREG) + 1
> *
>           call cputim(tt1)
> *
> 
> 
> 
> *
>       DO 801 L = 1,NREG
>           I = IREG(L)
> *
>           DO 655 K = 1,LMAX
>  655 IMPI(K,L) = LIST(K,I)
> *
>           NBSUM = 0
> *
>        CALL REGINT(I,IMPI(1,L))
> *
>          DO 615 K = 1,3
>               F(K,I) = 0.5D0*(FI(K,I) + FR(K,I))
>               FDOT(K,I) = ONE6*(FIDOT(K,I) + FRDOT(K,I))
>   615 CONTINUE
>   801 CONTINUE
> *
>       call cputim(tt2)
>       ttreg = ttreg + (tt2-tt1)*60.
> # 768 "intgrt.F"
> *
>       NSTEPR = NSTEPR + NREG
>       NBLCKR = NBLCKR + 1
>       LSHRNK = .FALSE.
> *
>       DO 81 L = 1,NREG
>           I = IREG(L)
> *
>               DO 816 K = 1,LMAX
>  816 LIST(K,I) = IMPI(K,L)
> *
> * Check minimum neighbor sphere since last output
>               IF(LIST(1,I).GT.0)RSMIN = MIN(RSMIN,RS(I))
> *
>  81 CONTINUE
> *
> * OPEN(98,STATUS='OLD',ERR=123)
> * print*,' last reg block t=',time,' length=',nreg
> * print*,' first 10 =',(name(ireg(l)),l=1,min(nreg,10))
> * call flush(6)
> * CLOSE(98)
> *123 CONTINUE
> *
280,306c467,473
< *       Determine next block time (note STEP may shrink in REGINT).
<       TMIN = MIN(TIMENW(I),TMIN)
< * 
< *       Copy current coordinates & velocities from corrected values.
<       IF (LI.EQ.NXTLEN) THEN
<           DO 60 L = 1,NXTLEN
<               I = NXTLST(L)
<               DO 55 K = 1,3
<                   X(K,I) = X0(K,I)
<                   XDOT(K,I) = X0DOT(K,I)
<    55         CONTINUE
<    60     CONTINUE
< *
< *       Check integration of tidal tail members.
<           IF (NTAIL.GT.0) THEN
< *       Allow large quantized interval with internal iteration.
<               IF (DMOD(TIME,0.25D0).EQ.0.0D0) THEN
<                   DO 65 J = ITAIL0,NTTOT
<                       IF (TIMENW(J).LE.TIME) THEN
<                           CALL NTINT(J)
<                       END IF
<    65             CONTINUE
<               END IF
<           END IF
<       ELSE
< *       Continue until last member has been done (improves reproducibility).
<           GO TO 50
---
> * Copy all corrected coordinates & velocities (NB! only at the end).
>       DO 85 L = 1,NXTLEN
>           I = NXTLST(L)
> *
>       IF (I.GT.N) THEN
>           IPAIR = I - N
>           IF (LIST(1,2*IPAIR-1).GT.0) NSTEPB = NSTEPB + 1
309,310c476,490
< *       Exit on KS termination, new multiple regularization or merger.
<       IF (IQ.NE.0) THEN
---
>           IF(TIMENW(I).LT.TMIN)THEN
>               TMIN = TIMENW(I)
>               IMIN = I
>           END IF
> *
>           DO 82 K = 1,3
>               X0(K,I) = XN(K,I)
>               X0DOT(K,I) = XNDOT(K,I)
>               X(K,I) = XN(K,I)
>               XDOT(K,I) = XNDOT(K,I)
>    82 CONTINUE
>    85 CONTINUE
> *
> * Exit on KS termination, new multiple regularization or merger.
>       IF (IQ.GT.0) THEN
315c495
< *       Ensure correct KS index (KSPAIR may denote second termination).
---
> * Ensure correct KS index (KSPAIR may denote second termination).
322,323c502,503
< *       Perform optional check on high-velocity particles at major times.
<       IF (KZ(37).GT.0.AND.LISTV(1).GT.0) THEN
---
> * Perform optional check on high-velocity particles at major times.
>       IF (KZ(18).GT.0.AND.LISTV(1).GT.0) THEN
325c505
<               CALL SHRINK(TMIN)
---
>               CALL SHRINK
332c512
< *       Check optional mass loss time at end of block-step.
---
> * Check optional mass loss time.
334c514
< *       Delay until time commensurate with 100-year step (new polynomials).
---
> * Delay until time commensurate with 1000-year step (new polynomials).
345,348c525,527
< *       Advance counters and check timer & optional COMMON save (NSUB = 0).
<       NTIMER = NTIMER + 1
<       IF (NTIMER.LT.NMAX) GO TO 50
< 
---
> * Advance counters and check timer & optional COMMON save (NSUB = 0).
>       NTIMER = NTIMER + NXTLEN
>       IF (NTIMER.LT.NMAX) GO TO 1
357,358c536,537
< *       Check option for general binary search.
<       IF (KZ(4).GT.0.AND.TIME - TLASTS.GT.DELTAS) THEN  
---
> * Check option for general binary search.
>       IF (KZ(4).NE.0.AND.TIME - TLASTS.GT.DELTAS) THEN
362c541,542
< *       Include facility for termination of run (create dummy file STOP).
---
> * Include facility for termination of run (create dummy file STOP).
>       IF(rank.EQ.0)THEN
366,367c546,547
<           IF (NSUB.EQ.0)  WRITE (6,70)
<    70     FORMAT  (/,9X,'TERMINATION BY MANUAL INTERVENTION')
---
>           IF (NSUM.EQ.0.and.rank.eq.0) WRITE (6,90)
>    90 FORMAT (/,9X,'TERMINATION BY MANUAL INTERVENTION')
369a550
>       END IF
371c552
< *       Repeat cycle until elapsed computing time exceeds the limit.
---
> * Repeat cycle until elapsed computing time exceeds the limit.
373c554
<       IF (TCOMP.LT.CPU) GO TO 50
---
>           TCOMP = (TCOMP-TTOTA)*60.
375c556,558
< *       Do not terminate during triple, quad or chain regularization.
---
>       IF (TCOMP.LT.CPU) GO TO 1
> *
> * Do not terminate during triple, quad or chain regularization.
377,378c560,561
< *       Specify zero step to enforce termination.
<           DO 75 L = 1,NSUB
---
> * Specify zero step to enforce termination.
>           DO 95 L = 1,NSUB
380c563
<    75     CONTINUE
---
>    95 CONTINUE
382c565
<           GO TO 50
---
>           GO TO 1
385,386c568,569
< *       Terminate run with optional COMMON save.
<       IF (KZ(1).GT.0) THEN
---
> * Terminate run with optional COMMON save.
>       IF (KZ(1).NE.0) THEN
389,392c572,577
<           WRITE (6,80)  TIME+TOFF, TCOMP, CPUTOT/60.0, ERRTOT, DETOT
<    80     FORMAT (/,9X,'COMMON SAVED AT TIME =',F8.2,'  TCOMP =',F7.1,
<      &                 '  CPUTOT =',F6.1,'  ERRTOT =',F10.6,
<      &                 '  DETOT =',F10.6)
---
>           if(rank.eq.0)
>      & WRITE (6,98) TOFF, TIME, TIME+TOFF, TCOMP, CPUTOT/60.0,
>      & ERRTOT, DETOT
>    98 FORMAT (
>      & '  TCOMP =',F7.1,'  CPUTOT =',F6.1,
>      & '  ERRTOT =',F10.6,'  DETOT =',F10.6)
395c580,581
<       STOP
---
> * Determine time interval and step numbers per time unit
>       TIMINT = TIME + TOFF - TINIT
397,398c583,633
< *       Set current global time.
<   100 TTOT = TIME + TOFF
---
> 
> 
> 
>       WRITE (6,195) rank,TIMINT,NSTEPI-NIR,NSTEPB-NIB,NSTEPR-NRGL,
>      & NSTEPU-NKS
>   195 FORMAT (
>      & ' NIRRB=',I11,' NREG=',I11,' NKS=',I11)
>       WRITE (6,196) (NSTEPI-NIR)/TIMINT,(NSTEPB-NIB)/TIMINT,
>      & (NSTEPR-NRGL)/TIMINT,(NSTEPU-NKS)/TIMINT
>   196 FORMAT (
>      & D12.5,' NREG=',D12.5,' NKS=',D12.5)
> 
> 
> 
> 
> 
> 
> 
>           STOP
> *
>  100 CONTINUE
> *
> * Set current global time.
>           TTOT = TIME + TOFF
> * Full prediction at end of intgrt to preserve consistency after
> * parallel execution
>           DO 400 J = IFIRST,NTOT
>               S = TIME - T0(J)
>               S1 = 1.5*S
>               S2 = 2.0*S
>               X(1,J) = ((FDOT(1,J)*S + F(1,J))*S +X0DOT(1,J))*S +X0(1,J)
>               X(2,J) = ((FDOT(2,J)*S + F(2,J))*S +X0DOT(2,J))*S +X0(2,J)
>               X(3,J) = ((FDOT(3,J)*S + F(3,J))*S +X0DOT(3,J))*S +X0(3,J)
>               XDOT(1,J) = (FDOT(1,J)*S1 + F(1,J))*S2 + X0DOT(1,J)
>               XDOT(2,J) = (FDOT(2,J)*S1 + F(2,J))*S2 + X0DOT(2,J)
>               XDOT(3,J) = (FDOT(3,J)*S1 + F(3,J))*S2 + X0DOT(3,J)
>  400 CONTINUE
> * Resolve any KS coordinates & velocities using most recent c.m.
>       IF (NPAIRS.GT.0) THEN
>           JJ = -1
>           DO 88 JPAIR = 1,NPAIRS
>           JJ = JJ + 2
>           IF (LIST(1,JJ).GT.0) THEN
>               ZZ = 1.0
>               IZZ = -3
> * Distinguish between low and high-order prediction of U & UDOT.
>               IF (GAMMA(JPAIR).GT.1.0D-04) ZZ = 0.0
>               CALL KSRES2(JPAIR,J1,J2,ZZ,IZZ)
>           END IF
>    88 CONTINUE
>       END IF
400c635
<       RETURN
---
>        RETURN
1,2c1,2
< 1048 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/intide.f
< nbody6compare-oct2006/intide.f
---
> 1062 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/intide.f
> nbody6++compare/intide.f
0a1,4
> # 1 "intide.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "intide.F"
4,5c8,9
< *       Input & scaling for tidal dissipation.
< *       --------------------------------------
---
> * Input & scaling for tidal dissipation.
> * --------------------------------------
8a13
> # 18 "intide.F"
10,11c15,24
< *       Read parameters for tidal capture simulation.
<       READ (5,*)  RSTAR, IMS, IEV, RMS, REV
---
> * Read parameters for tidal capture simulation.
> 
>       if(rank.eq.0)READ (5,*) RSTAR, IMS, IEV, RMS, REV
> 
> 
> 
> 
> 
> 
> 
13c26
< *       Convert radii from S.U. to internal units.
---
> * Convert radii from S.U. to internal units.
16c29
<       WRITE (6,10)  RSTAR, IMS, IEV, RMS, REV
---
>       WRITE (6,10) RSTAR, IMS, IEV, RMS, REV
18c31
<      &              '  IEV =',I4,'  RMS/R* =',F6.2,'  REV/R* =',F6.1)
---
>      & '  IEV =',I4,'  RMS/R* =',F6.2,'  REV/R* =',F6.1)
20c33
< *       Assign individual radii for main-sequence and evolved stars.
---
> * Assign individual radii for main-sequence and evolved stars.
22c35
< *       Adopt a primitive scheme in case of no stellar evolution.
---
> * Adopt a primitive scheme in case of no stellar evolution.
30,32c43,45
< *     WRITE (6,40)  BODY(1), BODY(N), RADIUS(1), RADIUS(N)
< *  40 FORMAT (/,12X,'SCALED RADII:    M(1) =',F8.4,'  M(N) =',F8.4,
< *    &                                '  R(1) =',1PE8.1,'  R(N) =',E8.1)
---
> * WRITE (6,40) BODY(1), BODY(N), RADIUS(1), RADIUS(N)
> * 40 FORMAT (/,12X,'SCALED RADII:    M(1) =',F8.4,'  M(N) =',F8.4,
> * & '  R(1) =',1PE8.1,'  R(N) =',E8.1)
1,2c1,2
< 7999 2006-08-30 10:31 /work/Umi2/spurzem/5/nbody6compare-oct2006/invert.f
< nbody6compare-oct2006/invert.f
---
> 8087 2003-06-25 19:51 /work/Umi2/spurzem/5/nbody6++compare/invert.f
> nbody6++compare/invert.f
32c32
< *       Obtain physical velocities (first absolute, then relative).
---
> *       Obtain physical two-body velocities.
48,59c48,54
< *       Determine the smallest two-body distance and chain index.
<       rm = 0.0
<       do i = 1,n-1
<           if (rinv(i).gt.rm) then
<               rm = rinv(i)
<               i1 = i
<           end if
<       end do
<       rm = 1.0/rm
< *
< *       Form semi-major axes for the two closest distances.
<       dm = 0.0
---
> *       Determine the two smallest two-body distances and chain indices.
>       R2M = 1.0
>       D2M = 1.0
>       DM = 1.0
>       i2 = 0
>       g2 = 1.0
>       V22 = 1.0
62c57,59
<           if (i.eq.i1) then
---
>           r2 = xc(L+1)**2 + xc(L+2)**2 + xc(L+3)**2
> *       Check the smallest distance and save basic parameters.
>           if (r2.lt.r2m) then
65c62,63
<               amax = 2.0*rinv(i) - w2/mb
---
>               r1 = sqrt(r2)
>               amax = 2.0/r1 - w2/mb
66a65,67
>               i1 = i
>               rm = r1
>               r2m = r2
78,79c79,80
< *       Treat the second smallest distance similarly.
<           else if (rinv(i).gt.dm) then
---
> *       Check the second distance (ignore two consecutive small distances).
>           else if (r2.lt.d2m) THEN
82c83,84
<               amax = 2.0*rinv(i) - w2/mb
---
>               r1b = sqrt(r2)
>               amax = 2.0/r1b - w2/mb
85c87,89
<               dm = rinv(i)
---
>               dm = r1b
>               d2m = r2
>               V22 = w2
97d100
<       dm = 1.0/dm
99,102c102,103
< *       Obtain reliable semi-major axis for small pericentre or large EB.
<       EB = -0.5*mc(i1)*mc(i1+1)/a1
<       EB1 = EB/ENERGY
<       IF (rm.lt.0.2*a1.or.EB1.gt.0.9) then
---
> *       Obtain reliable semi-major axis near small pericentres.
>       IF (rm.lt.0.2*a1.AND.NSTEP1.GT.0) THEN
118c119
<           IF (ABS(ERR).GT.1.0E-05.AND.IWARN.LT.10) THEN
---
>           IF (ABS(ERR).GT.1.0E-05.AND.IWARN.LT.50) THEN
124,125c125,126
<               WRITE (6,4)  NSTEP1, ZK, g1, RM, SEMI, ERR
<     4         FORMAT (' WARNING!    INVERT    # K g1 RM SEMI DA/A ',
---
>               if(rank.eq.0)WRITE (6,4)  NSTEP1, ZK, g1, RM, a1, ERR
>     4         FORMAT (' WARNING!    INVERT    # K g1 RM a1 DA/A ',
128c129,130
< *       Replace direct value by improved determination.
---
> *       Replace direct values by improved determination.
>           RM = 1.0/RINV(i1)
133c135
<       IF (a1.GT.0.0) THEN
---
>       IF (a1.GT.0.0.AND.RM.LT.DM) THEN
135,136c137,142
< *       Adopt upper limit of TKS/2 but allow genuine small DT.
<           DT = MIN(0.5*TKS,DT)
---
> *       Adopt upper limit of TKS/5 but allow genuine small DT.
>           IF (DT.GT.TKS) THEN
>               DT = 0.2*TKS
>           ELSE
>               DT = MIN(0.2*TKS,DT)
>           END IF
138,139c144,149
< *       Use crossing time for hyperbolic velocity (TPR compensates small R).
<           DT = MIN(rm/SQRT(V21),DT)
---
> *       Choose upper limit 1/20 of crossing time with hyperbolic velocity.
>           IF (a1.LT.0.0) THEN
>               DT = MIN(0.05*RSUM/SQRT(V21),DT)
>           ELSE
>               DT = MIN(0.05*RSUM/SQRT(V22),DT)
>           END IF
142,147d151
< *       Check second closest pair if bound (small period; a1 < 0 possible).
<       if (a2.gt.0.0) then
<           TKS = 6.28*KSCH(i2)*a2*SQRT(a2/(mc(i2) + mc(i2+1)))
<           DT = MIN(0.5*TKS,DT)
<       end if
< *
196d199
< *       Define the function Y0 and its derivatives (cf. Book eqns. 12.9).
200d202
< *       Adopt safety measure to avoid negative argument (Seppo Mikkola).
201a204
> *       Adopt safety measure to avoid negative argument (Seppo Mikkola).
213c216,217
<           WRITE (6,15)  IT, KSCH(i1), ECC, RM, a1, DT-DT1, DTAU
---
>           if(rank.eq.0)
>      &    WRITE (6,15)  IT, KSCH(i1), ECC, RM, a1, DT-DT1, DTAU
219c223
<       IF (i2.ne.i1.and.g2.lt.0.01) THEN
---
>       IF (i2.GT.0.AND.i2.NE.i1.AND.g2.LT.0.01) THEN
222c226
<           rm = dm
---
>           RM = DM
232,234c236,239
<               WRITE (6,16)  KSCH(i1), RM/a1, SUM1*DT0, SUM2, DTAU
<    16         FORMAT (' INVERT NEGATIVE!    KSCH R/A S1*DT0 S2 DTAU ',
<      &                                      F7.2,1P,4E10.2)
---
>               if(rank.eq.0)
>      &        WRITE (6,16)  KSCH(i1), RM/a1, SUM1*DT0, SUM2, DTAU
>    16         FORMAT (' DANGER!    INVERT    KSCH R/A S1*DT0 S2 DTAU ',
>      &                                       F7.2,1P,4E10.2)
243a249,250
> 
> 
1,2c1,2
< 1726 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/kcpert.f
< nbody6compare-oct2006/kcpert.f
---
> 1726 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/kcpert.f
> nbody6++compare/kcpert.f
1,2c1,2
< 1347 2006-03-20 05:54 /work/Umi2/spurzem/5/nbody6compare-oct2006/kepler.f
< nbody6compare-oct2006/kepler.f
---
> 2934 2003-06-23 19:34 /work/Umi2/spurzem/5/nbody6++compare/kepler.f
> nbody6++compare/kepler.f
8a9
>       COMMON/ISAVE/  LI0,LI,NS,NSLIST(LMAX)
15c16,17
< *       Set list membership & Kepler period.
---
> *       Set new close encounter index, list membership & Kepler period.
>       ICLOSE = I
41a44,90
> *
> *       Consider body #J for NSLIST if new & old step straddle TLIST.
>           A3 = T0(J) + STEP(J)
>           IF (A3.GT.TLIST) GO TO 20
> *
> *       Note that body #J may be a member if treated recently.
>           DO 5 LL = 1,NS
>               IF (NSLIST(LL).EQ.J) GO TO 20
>     5     CONTINUE
> *
> *       Include #J in NSLIST or reduce sequential position in NLIST.
>           IF (A3.GT.TLIST) THEN
>               NS = NS + 1
>               NSLIST(NS) = J
>           ELSE
>               NL = NLIST(1) + 1
> *       Skip NLIST modification if body #I is last member.
>               IF (LI.GE.NL) GO TO 20
> *
> *       Find current NLIST index (LJ = 0 is OK for next loop).
>               LJ = 0
>               DO 10 LL = LI+1,NL
>                   IF (NLIST(LL).EQ.J) THEN
>                       LJ = LL
>                       GO TO 12
>                   END IF
>    10         CONTINUE 
> *
> *       Determine new NLIST index > LI in case #J needs to be moved.
>    12         LN = 0
>               DO 14 LL = LI+1,LJ
>                   JJ = NLIST(LL)
>                   IF (A3.LT.T0(JJ) + STEP(JJ)) THEN
>                       LN = LL
>                       GO TO 16
>                   END IF
>    14         CONTINUE
> *
> *       Move NLIST members down by one and replace #J in location LN.
>    16         IF (LN.GT.0) THEN
>                   LL = LJ
>    18             NLIST(LL) = NLIST(LL-1)
>                   LL = LL - 1
>                   IF (LL.GT.LN) GO TO 18
>                   NLIST(LN) = J
>               END IF
>           END IF
46a96,97
> 
> 
1,2c1,2
< 4694 2006-09-08 14:54 /work/Umi2/spurzem/5/nbody6compare-oct2006/kick.f
< nbody6compare-oct2006/kick.f
---
> 4942 2003-06-25 20:44 /work/Umi2/spurzem/5/nbody6++compare/kick.f
> nbody6++compare/kick.f
12a13,14
> * recover random number sequence from COMMON variable IDUM1.
>       KDUM = IDUM1
42c44,45
<           WRITE (6,1)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2), ZM1,
---
>           if(rank.eq.0)
>      &    WRITE (6,1)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2), ZM1,
54,55c57,58
< *   2 VT = VCUT/V0*RAN2(IDUM1)
< *     VP = VT*(2.0*RAN2(IDUM1) - 1.0)
---
> *   2 VT = VCUT/V0*RAN2(KDUM)
> *     VP = VT*(2.0*RAN2(KDUM) - 1.0)
58c61
< *     IF (FAC.LT.RAN2(IDUM1).AND.IT.LT.10) GO TO 2
---
> *     IF (FAC.LT.RAN2(KDUM).AND.IT.LT.10) GO TO 2
65,66c68,69
<           X1 = RAN2(IDUM1)
<           X2 = RAN2(IDUM1)
---
>           X1 = RAN2(KDUM)
>           X2 = RAN2(KDUM)
88c91
< *         A(K) = 2.0*RAN2(IDUM1) - 1.0
---
> *         A(K) = 2.0*RAN2(KDUM) - 1.0
124c127,128
<           WRITE (6,20)  I, NAME(I), KSTAR(I), KC, BODY0(I)*ZMBAR, ZM,
---
>           if(rank.eq.0)
>      &    WRITE (6,20)  I, NAME(I), KSTAR(I), KC, BODY0(I)*ZMBAR, ZM,
133c137,138
<           WRITE (6,25)  I, NAME(I), VKICK*VSTAR, SQRT(VF2)*VSTAR
---
>           if(rank.eq.0)
>      &    WRITE (6,25)  I, NAME(I), VKICK*VSTAR, SQRT(VF2)*VSTAR
138,140c143,150
<       IF (KZ(37).GT.0) THEN
<           CALL HIVEL(I)
<       END IF
---
> *     IF (KZ(37).GT.0) THEN
> *         CALL HIVEL(I)
> *     END IF
> *
>    30 CONTINUE
> *
> *       Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
142c152
<    30 RETURN
---
>       RETURN
144a155,156
> 
> 
1,2c1,2
< 1960 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksapo.f
< nbody6compare-oct2006/ksapo.f
---
> 2125 2003-06-25 20:49 /work/Umi2/spurzem/5/nbody6++compare/ksapo.f
> nbody6++compare/ksapo.f
9a10,11
> * recover random number sequence from COMMON variable IDUM1.
>       KDUM = IDUM1
59a62,64
> *       Save random number sequence in COMMON for future use.
>       IDUM1 = KDUM
> *
62a68,69
> 
> 
1,2c1,2
< 6846 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/kscorr.f
< nbody6compare-oct2006/kscorr.f
---
> 6846 2001-08-24 22:40 /work/Umi2/spurzem/5/nbody6++compare/kscorr.f
> nbody6++compare/kscorr.f
1,2c1,2
< 6927 2006-03-20 04:33 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksin2.f
< nbody6compare-oct2006/ksin2.f
---
> 7154 2003-08-01 21:49 /work/Umi2/spurzem/5/nbody6++compare/ksin2.f
> nbody6++compare/ksin2.f
101a102,106
> *       See whether to include new c.m. or single components in NLIST.
>       IF (T0(ICM) + STEP(ICM).LT.TLIST) THEN
>           CALL NLMOD(ICM,1)
>       END IF
> *
152c157,158
<           WRITE (6,60)  WHICH1, TIME+TOFF, NAME(ICOMP), NAME(JCOMP),
---
>           if(rank.eq.0)
>      &    WRITE (6,60)  WHICH1, TIME+TOFF, NAME(ICOMP), NAME(JCOMP),
175c181
<       IF (KZ(8).GT.0.AND.K.EQ.0) THEN
---
>       IF ((KZ(8).GT.0 .OR. NBIN0.GT.0) .AND.K.EQ.0) THEN
182c188,189
<           WRITE (8,90)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP), K,
---
>           if(rank.eq.0)
>      &    WRITE (8,90)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP), K,
192a200
> 
1,2c1,2
< 8969 2006-09-20 13:10 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksinit.f
< nbody6compare-oct2006/ksinit.f
---
> 8910 2003-07-04 19:04 /work/Umi2/spurzem/5/nbody6++compare/ksinit.f
> nbody6++compare/ksinit.f
53a54
> *
56a58,62
> *       See whether to include new c.m. in NLIST.
>       IF (T0(NTOT) + STEP(NTOT).LT.TLIST) THEN
>           CALL NLMOD(NTOT,1)
>       END IF
> *
145c151
< *       Set large step for second component to avoid detection.
---
> *       Set large step for second component to avoid NLIST detection.
157,163d162
< *       Include suggestion for monitoring hyperbolic encounters (suppressed).
< *     IF (SEMI.LT.0.0) THEN
< *         PMIN = SEMI*(1.0 - SQRT(ECC2))
< *         WRITE (31,56)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP), PMIN
< *  56     FORMAT (' HYPERBOLIC    T NAM PMIN ',F7.2,2I6,1P,E10.2)
< *     END IF
< *
179c178,179
<           WRITE (6,60)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP),DTAU(IPAIR),
---
>           if (rank.eq.0)
>      &    WRITE (6,60)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP),DTAU(IPAIR),
182c182
<    60     FORMAT (/,' NEW KSREG    TIME =',F7.2,2I6,F12.3,1PE10.1,
---
>    60     FORMAT (/,' NEW KSREG    TIME =',1PE10.2,2I6,0PF12.3,1PE10.1,
189c189
<       IF (NPAIRS.EQ.KMAX) WRITE (6,70)  NPAIRS, TIME+TOFF
---
>       IF (NPAIRS.EQ.KMAX.and.rank.eq.0) WRITE (6,70)  NPAIRS, TIME+TOFF
225c225
<       IF (KZ(8).GT.0.AND.K.EQ.0) THEN
---
>       IF ((KZ(8).GT.0.OR.NBIN0.GT.0).AND.K.EQ.0) THEN
232,233c232,234
<           WRITE (8,90)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP), K,
<      &                  BODY(ICOMP),BODY(JCOMP), EB, SEMI, R(IPAIR),
---
>           if(rank.eq.0)
>      &    WRITE (8,90)  TIME+TOFF, NAME(ICOMP), NAME(JCOMP), K,
>      &                  BODY(ICOMP), BODY(JCOMP), EB, SEMI, R(IPAIR),
242a244,245
> 
> 
1,2c1,2
< 23909 2006-09-20 13:00 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksint.f
< nbody6compare-oct2006/ksint.f
---
> 15607 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/ksint.f
> nbody6++compare/ksint.f
0a1,4
> # 1 "ksint.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "ksint.F"
4,5c8,9
< *       Regularized integration.
< *       ------------------------
---
> * Regularized integration.
> * ------------------------
8,17c12,17
<       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAGM(MMAX)
<       COMMON/MODES/  EB0(NTMAX),ZJ0(NTMAX),ECRIT(NTMAX),AR(NTMAX),
<      &               BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
<      &               ZP(NTMAX),ES(NTMAX),CZ(2,NTMAX),IOSC(NTMAX),
<      &               NAMEC(NTMAX)
<       COMMON/SLOW0/  RANGE,ISLOW(10)
<       COMMON/GAMDOT/  DGAM
<       REAL*8  UI(4),UIDOT(4),XI(6),VI(6),FP(6),FD(6)
---
>       COMMON/BINARY/ CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
>      & HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      & NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       COMMON/SLOW0/ RANGE,ISLOW(10)
>       COMMON/GAMDOT/ DGAM
>       REAL*8 UI(4),UIDOT(4),XI(6),VI(6),FP(6),FD(6)
21c21
< *       Set second component, pair index & c.m. index.
---
> * Set second component, pair index & c.m. index.
26c26
< *       Define perturber membership & inverse c.m. mass.
---
> * Define perturber membership & inverse c.m. mass.
30c30
< *       Check for further unperturbed motion.
---
> * Check for further unperturbed motion or dissipation at pericentre.
32,74d31
< *       Include possible eccentricity modulation of hierarchical binary.
<           IF (NAME(I).LT.0) THEN
<               IM = 0
<               DO 1 K = 1,NMERGE
<                   IF (NAMEM(K).EQ.NAME(I)) IM = K
<     1         CONTINUE
<               IF (IM.GT.0.AND.TIME.GT.TMDIS(IM)) THEN
<                   SEMI = -0.5*BODY(I)/H(IPAIR)
<                   ECC2 = (1.0 - R(IPAIR)/SEMI)**2 +
<      &                                   TDOT2(IPAIR)**2/(BODY(I)*SEMI)
<                   RP = SEMI*(1.0 - SQRT(ECC2))*(1.0 - 2.0*GAMMA(IPAIR))
<                   IF (RP.LT.R0(IPAIR)) THEN
<                       WRITE (77,4)  NAME(I1), SQRT(ECC2), RP, R0(IPAIR)
<     4                 FORMAT (' TMDIS TERM    NM E RP R0',I7,1P,3E10.2)
<                       CALL FLUSH(77)
<                       NSTAB = NSTAB + 1
<                       GO TO 90
<                   ELSE IF (KZ(27).EQ.2) THEN
<                       CALL ECCMOD(I,ITERM)
< *       Update time on termination to prevent looping.
<                       IF (ITERM.GT.0) THEN
<                           T0(I1) = TIME
<                           GO TO 90
<                       END IF
<                   END IF
< *       Check any inner and outer circularizing binary using NAMEM & NAMEG.
<                   DO 3 K = 1,NCHAOS
<                       IF (NAMEC(K).EQ.NZERO - NAMEM(IM)) THEN
< *       Update unperturbed binary if T - TOSC > 10 Myr (cf. IMPACT & DECIDE).
<                           IF ((TIME - TOSC(K))*TSTAR.GT.10.0) THEN
<                               T0(I1) = TIME
<                               GO TO 90
<                           END IF
<                       END IF
<                       IF (NAMEC(K).EQ.NAMEG(IM)) THEN
<                           IF ((TIME - TOSC(K))*TSTAR.GT.10.0) THEN
<                               T0(I1) = TIME
<                               GO TO 90
<                           END IF
<                       END IF
<     3             CONTINUE
<               END IF
<           END IF
79c36
< *       Perform KS prediction of U, UDOT & H.
---
> * Perform KS prediction of U, UDOT & H.
82c39
< *       Obtain the perturbing force & derivative.
---
> * Obtain the perturbing force & derivative.
85c42
< *       Save old radial velocity & relative perturbation and set new GAMMA.
---
> * Save old radial velocity & relative perturbation and set new GAMMA.
87c44
< *     G0 = GAMMA(IPAIR)
---
>       G0 = GAMMA(IPAIR)
91c48
< *       Apply the Hermite corrector.
---
> * Apply the Hermite corrector.
94c51
< *       Increase regularization time-step counter and update the time.
---
> * Increase regularization time-step counter and update the time.
97c54,55
< *       Check for early return during termination (called from KSTERM).
---
> *
> * Check for early return during termination (called from KSTERM).
100c58
< *       Define useful scalars.
---
> * Define useful scalars.
104c62
< *       Initialize termination indicator and check for large perturbation.
---
> * Initialize termination indicator and check for large perturbation.
112,120c70,72
<       IF (ITERM.EQ.0.AND.KSTAR(I).LT.0) THEN
<           IQ = .TRUE.
<       END IF
<       IF (ITERM.EQ.1) THEN
< *       Delay chain regularization search until near end of block-step.
<           IF (TIME + STEP(I1).GT.TBLOCK) THEN
<               CALL IMPACT(I)
<               IF (IPHASE.GT.0) GO TO 100
<           END IF
---
>       IF (ITERM.EQ.1.AND.KZ(15).GT.0) THEN
>           CALL IMPACT(I)
>           IF (IPHASE.GT.0) GO TO 100
128,129c80,81
< *       Find the dominant body for large perturbations.
<     2 S = 4.0*STEP(I)
---
> * Find the dominant body for large perturbations.
>     2 S = 2.0*STEP(I)
131c83
< *       Initialize JCOMP for prediction and optional diagnostics in KSTERM.
---
> * Initialize JCOMP for optional diagnostics in KSTERM.
135c87
< *       Only search bodies within twice the c.m. time-step.
---
> * Only search bodies within twice the c.m. time-step.
137c89
< *       Compare strong perturber and either component with current pair.
---
> * Compare strong perturber and either component with current pair.
140c92
<      &                                      (X(3,J) - X(3,K))**2
---
>      & (X(3,J) - X(3,K))**2
142c94
<     5     CONTINUE
---
>     5 CONTINUE
145c97
< *       Set termination if strong perturber <= N forms dominant pair.
---
> * Set termination if strong perturber <= N forms dominant pair.
147,152c99,104
< *       Check optional binary search.
< *         IF (KZ(4).GT.0) THEN
< *             DGAM = GI - G0
< *             K = KZ(4)
< *             CALL EVOLVE(IPAIR,K)
< *         END IF
---
> * Check optional binary search.
>           IF (KZ(4).GT.0) THEN
>               DGAM = GI - G0
>               K = KZ(4)
>               CALL EVOLVE(IPAIR,K)
>           END IF
156,161c108,113
< *       Check termination of hyperbolic encounter (R > R0 or R > 2*RMIN).
<    20 IF (HI.GT.0.0D0.AND.NAME(I).GT.0) THEN
<           IF ((RI.GT.R0(IPAIR).AND.GI.GT.GMAX).OR.RI.GT.2.0*RMIN.OR.
<      &        (GI.GT.0.5.AND.TD2.GT.0.0)) THEN
< *       Skip termination delay in case of velocity kick (cf. routine KSTERM).
<               IF (HI.LT.100.0.OR.GI.GT.0.1.OR.RI.GT.5.0*RMIN) THEN
---
> * Check termination of hyperbolic encounter (R > R0 or R > RMIN).
>    20 IF (HI.GT.0.0D0) THEN
>           IF ((RI.GT.R0(IPAIR).AND.GI.GT.GMAX).OR.RI.GT.RMIN.OR.
>      & (GI.GT.0.5.AND.TD2.GT.0.0)) THEN
> * Skip termination delay in case of velocity kick (cf. routine KSTERM).
>               IF (HI.LT.100.0.OR.GI.GT.0.5) THEN
167c119
< *       Choose basic regularized step using binding energy or lower limit.
---
> * Choose basic regularized step using binding energy or lower limit.
175c127
< *       Maximum square step for soft binaries & weak hyperbolic pairs.
---
> * Modify maximum square step for soft binaries & weak hyperbolic pairs.
177c129
< *       Include case of hard binary with massive components or merger.
---
> * Consider case of hard binary with massive components or merger.
179,181d130
<               IF (NAME(I).LT.0) THEN
<                   W1 = RI*BODYIN
<               END IF
182a132
>               IF (NAME(I).LT.0) W1 = W2
186c136
< *       Include perturbation factor in predicted step.
---
> * Include perturbation factor in predicted step.
188c138
< *       Use second-order expansion of cube root for small perturbations.
---
> * Use second-order expansion of cube root for small perturbations.
196c146
< *       Form new regularized step (include inertial factor).
---
> * Form new regularized step.
200,217c150
< *       Check pericentre step reduction for perturbed spiral.
<       IF (KSTAR(I).EQ.-2.AND.TD2.LT.0.0) THEN
<           SEMI = -0.5*BODY(I)/HI
<           IF (RI.LT.SEMI) THEN
< *       Predict radial velocity for step DTU (note scaled coefficients).
<               RD = ((ONE3*TDOT5*DTU + TDOT4)*DTU +
<      &                                TDOT3(IPAIR))*DTU + 2.0*TD2
< *       Adopt pericentre step with 1% safety factor (small TDOT4 is OK).
<               IF (RD.GT.0.0) THEN
<                   A2 = 0.5*TDOT3(IPAIR)/TDOT4
<                   DTU1 = SQRT(A2**2 - 2.0*TD2/TDOT4) - A2
<                   DTU1 = 1.01*MAX(DTU1,1.0D-10)
<                   DTU = MIN(DTU1,DTU)
<               END IF
<           END IF
<       END IF
< *
< *       Reset reference energy and generate new Stumpff coefficients.
---
> * Reset reference energy and generate new Stumpff coefficients.
225c158
< *       Convert to physical time units modified by Stumpff coefficients.
---
> * Convert to physical time units modified by Stumpff coefficients.
227c160
<      &                     + TDOT3(IPAIR))*ONE6*DTU + TD2)*DTU + RI)*DTU
---
>      & + TDOT3(IPAIR))*ONE6*DTU + TD2)*DTU + RI)*DTU
229,230c162,163
< *       Ensure that regularized step is smaller than the c.m. step.
<       IF (STEP(I1).GT.STEP(I).AND.HI.LT.0) THEN
---
> * Ensure that regularized step is smaller than the c.m. step.
>       IF (STEP(I1).GT.STEP(I)) THEN
236c169
< *       See whether the KS slow-down procedure is activated.
---
> * See whether the KS slow-down procedure is activated.
243c176
< *       Check diagnostic print option.
---
> * Check diagnostic print option.
245,247c178,181
<           WRITE (6,40)  IPAIR, TIME+TOFF, H(IPAIR), RI, DTAU(IPAIR),
<      &                  GI, STEP(I1), LIST(1,I1), IMOD
<    40     FORMAT (3X,'KS MOTION',I6,2F10.4,1P,4E10.2,2I4)
---
>           if(rank.eq.0)
>      & WRITE (6,40) IPAIR, TIME+TOFF, H(IPAIR), RI, DTAU(IPAIR),
>      & GI, STEP(I1), LIST(1,I1), IMOD
>    40 FORMAT (3X,'KS MOTION',I6,2F10.4,2F10.5,1P,2E10.2,2I4)
250c184
< *       Employ special termination criterion in merger case.
---
> * Employ special termination criterion in merger case.
252c186
< *       Terminate if apocentre perturbation > 0.25 (R > SEMI) or GI > 0.25.
---
> * Terminate if apocentre perturbation > 0.25 (R > 0) or GI > 0.25.
261,263d194
<               IF (MIN(BODY(I1),BODY(I2)).LT.0.05*BODYM) THEN
<                   IF (GI.GT.2.0D-04) IQ = .TRUE.
<               END IF
265c196
<               IF (TD2.GT.0.0.AND.(GI.GT.GMAX.OR.RI.GT.RMIN)) IQ = .TRUE.
---
>               IF (GI.GT.GMAX) IQ = .TRUE.
267c198
<           IF (.NOT.IQ) GO TO 60
---
>           IF (.NOT.IQ) GO TO 70
270c201
< *       Delay termination until end of block for large perturbations.
---
> * Delay termination until end of block for large perturbation.
273,275c204,207
< *         WRITE (6,45)  IPAIR, TTOT, GI, RI, DTR, STEP(I1)
< *  45     FORMAT (' TERM TEST    KS T G R DTR DT  ',
< *    &                           I4,F10.4,F7.3,1P,E10.2,2E9.1)
---
> * if(rank.eq.0)
> * & WRITE (6,45) IPAIR, TIME+TOFF, GI, RI, DTR, STEP(I1)
> * 45 FORMAT (' TERM TEST    KS T G R DTR DT  ',
> * & I4,F10.4,F7.3,1P,E10.2,2E9.1)
279,281c211,212
< *       Check standard termination criterion (suppress on IQ = .true.).
< *     IF (RI.GT.R0(IPAIR)) THEN
<       IF (RI.GT.R0(IPAIR).AND.RI.GT.2.0*RMIN.AND..NOT.IQ) THEN
---
> * Check standard termination criterion (suppress on IQ = .true.).
>       IF (RI.GT.R0(IPAIR).AND..NOT.IQ) THEN
283,284c214,215
< *       See whether termination can be delayed for intermediate energies.
<           IF (RI.GT.RMIN) THEN
---
> * See whether termination can be delayed for intermediate energies.
>           IF (CMSEP2*RI**2.LT.RS(I)**2) THEN
288c219,225
< *       Check updating of R0 for newly hardened binary orbit.
---
>           END IF
> *
>           IF (HI.LT.0.0) THEN
>               A3 = RMIN*ABS(HI)*BODYIN
>               GIMAX = A3*A3*A3
>               IF (GI.LT.MIN(GIMAX,GMAX)) GO TO 60
> * Check updating of R0 for newly hardened binary orbit.
291c228
<                   R0(IPAIR) = MAX(RMIN,2.0D0*SEMI) 
---
>                   R0(IPAIR) = MAX(RMIN,2.0D0*SEMI)
296,306c233,243
< *         IF (KZ(4).GT.0.AND.GI.GT.GPRINT(1)) THEN
< *             DGAM = GI - G0
< *             K = KZ(4)
< *             DO 55 L = 2,K
< *                 IF (GI.LT.GPRINT(L)) THEN
< *                     CALL EVOLVE(IPAIR,L-1)
< *                     GO TO 90
< *                 END IF
< *  55         CONTINUE
< *             CALL EVOLVE(IPAIR,K)
< *         END IF
---
>           IF (KZ(4).GT.0.AND.GI.GT.GPRINT(1)) THEN
>               DGAM = GI - G0
>               K = KZ(4)
>               DO 55 L = 2,K
>                   IF (GI.LT.GPRINT(L)) THEN
>                       CALL EVOLVE(IPAIR,L-1)
>                       GO TO 90
>                   END IF
>    55 CONTINUE
>               CALL EVOLVE(IPAIR,K)
>           END IF
310c247
< *       End integration cycle for hyperbolic motion.
---
> * End integration cycle for hyperbolic motion.
313,316c250,255
< *       Determine pericentre for hyperbolic two-body motion.
<               SEMI = -0.5D0*BODY(I)/HI
<               ECC2 = (1.0 - RI/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
<               QPERI = SEMI*(1.0D0 - SQRT(ECC2))
---
> * Obtain pericentre by Mikkolas algorithm (GAMMA < 0.001).
>               IF (GI.LT.0.001) THEN
>                   CALL PERI(UI,UIDOT,RI,BODY(I1),BODY(I2),QPERI)
>               ELSE
>                   QPERI = RI
>               END IF
319,371c258,298
< *       Check optional tidal interaction or stellar collision.
<               IF (KZ(19).GE.3.AND.KSTAR(I).LT.10) THEN
<                   VINF = SQRT(2.0*HI)*VSTAR
<                   KS1 = KSTAR(I1)
<                   KS2 = KSTAR(I2)
< *       Determine maximum periastron factor for capture (VINF in km/sec).
<                   IF (KZ(27).LE.2) THEN
<                       RFAC = RPMAX2(RADIUS(I1),RADIUS(I2),BODY(I1),
<      &                              BODY(I2),KS1,KS2,VINF)
<                   ELSE
<                       DV = SQRT(2.0*HI)
<                       RFAC = RPMAX(BODY(I1),BODY(I2),VSTAR,DV,QPERI)
<                   END IF
<                   RX = MAX(RADIUS(I1),RADIUS(I2))
<                   IF (QPERI.LT.5.0*RX) THEN
<                       WRITE (54,54)  TTOT, NAME(I1), NAME(I2), KS1,
<      &                               KS2, VINF, RFAC, RX*SU, QPERI*SU
<    54                 FORMAT (' CLOSE   T NAM K* VINF RFAC RX QP  ',
<      &                                  F7.1,2I6,2I4,2F6.2,2F6.1)
<                   END IF
<                   IF (QPERI.LT.RFAC*MAX(RADIUS(I1),RADIUS(I2))) THEN
<                       J1 = I1
<                       IF (RADIUS(I2).GT.RADIUS(I1)) J1 = I2
<                       FAC = 0.5*BODY(I)/BODY(J1)
< *       Adopt collision criterion of Kochanek (Ap.J. 385, 604, 1992).
<                       IF (KZ(27).LE.2) THEN
<                           RCOLL = 1.7*FAC**0.3333*RADIUS(J1)
<                       ELSE
<                           RCOLL = 6.0*BODY(I)/CLIGHT**2
<                       END IF
<                       WRITE (55,58)  TTOT, IPAIR, NAME(I1), NAME(I2),
<      &                               KS1, KS2, KSTAR(I), VINF
<    58                 FORMAT (' RPMAX:    T KS NAM K* VINF ',
<      &                                    F7.1,I5,2I6,3I4,F7.2)
<                       WRITE (55,59)  SQRT(ECC2), HI, R(IPAIR), SEMI,
<      &                               QPERI, BODY(I1), BODY(I2),
<      &                               BODY(I)*ZMBAR
<    59                 FORMAT (' E H R A QP BODY MT ',
<      &                          F9.5,1P,6E10.2,0P,F6.1)
<                       RI2 = 0.0
<                       VI2 = 0.0
<                       DO 61 K = 1,3
<                           RI2 = RI2 + (X(K,I) - CMR(K))**2
<                           VI2 = VI2 + XDOT(K,I)**2
<    61                 CONTINUE
<                       WRITE (55,62)  SQRT(RI2)/RC, SQRT(VI2)*VSTAR,
<      &                               RHOD, RADIUS(I1)*SU, RADIUS(I2)*SU,
<      &                               RFAC, RADIUS(J1)/QPERI, RCOLL/QPERI
<    62                 FORMAT (' r/RC V* <C> R* RFAC R1/QP RCOLL/QP ',
<      &                          2F5.1,3F6.1,3F5.1)
<                       CALL FLUSH(55)
<                       IF (QPERI.LT.RCOLL) THEN
< *       Obtain KS variables at pericentre before merging into one body.
---
>               IF (rank.eq.0.and.BK(4).EQ.1) THEN
> C Added Aug.1998 b P.Kroupa:
> * If BK(4)=1 then write out relevant data
> * into unit=15 (file=per.15) [see file_init.F]
> * for statistics of closest approaches & disk destruction during
> * hyperbolic encounters. (27.08.96, P.Kroupa in nb5)
> * write out: time in Myr, periastron distance in AU
> * names and masses (Msun) of involved stars
> * distance of centre of mass (!) from cluster centre in pc:
> *
>                  peri_pk=log10(QPERI*RBAR*206264.84)
>                  cldist_pk=SQRT((x(1,I)-rdens(1))**2 +
>      + (x(2,I)-rdens(2))**2+
>      + (x(3,I)-rdens(3))**2)*RBAR
> 
> 
> 
>                  write(15,'(2F8.3,2I5,2F8.3,F9.4,F13.4)')
>      + time*tscale,peri_pk,name(I1),name(I2),
>      + body(I1)*ZMBAR,body(I2)*ZMBAR,cldist_pk
>                  call flush(15)
> 
> 
> 
> C Also write the stuff into log-file:
> * write(6,*)
> * write(6,*)' Hyperbolic encounter: (see ksint.f)'
> * write(6,*)' time[Myr] log10(Rperi[AU]) star1 star2 ',
> * + 'mass1 mass2[Msun] Rcl[pc]'
> * write(6,'(2F8.3,2I5,2F8.3,F9.4)')
> * + time*tscale,peri_pk,name(I1),name(I2),
> * + body(I1)*ZMBAR,body(I2)*ZMBAR,cldist_pk
> * write(6,*)
> * call flush(6)
>               end if
> *
> * Check optional tidal interaction or stellar collision.
>               IF (KZ(27).GT.0) THEN
>                   IF (QPERI.LT.4.0*MAX(RADIUS(I1),RADIUS(I2))) THEN
>                       IF (QPERI.LT.0.75*(RADIUS(I1) + RADIUS(I2))) THEN
> * Obtain KS variables at pericentre before merging into one body.
374d300
<                           IQCOLL = -2
376c302
<                       ELSE IF (KSTAR(I).GE.0.AND.KZ(27).GT.0) THEN
---
>                       ELSE
380,393d305
< *       Check options for artificial collisions.
<               ELSE IF (KZ(27).EQ.-1.AND.KZ(13).LT.0) THEN
<                   RFAC = 2.0*RMSTAR
<                   IF (QPERI.LT.RFAC*MAX(RADIUS(I1),RADIUS(I2))) THEN
<                       J1 = I1
<                       IF (RADIUS(I2).GT.RADIUS(I1)) J1 = I2
<                       FAC = 0.5*BODY(I)/BODY(J1)
< *       Adopt collision criterion of Kochanek (Ap.J. 385, 604, 1992).
<                       RCOLL = 1.7*FAC**0.3333*RADIUS(J1)
<                       RCOLL = RMSTAR*RCOLL
<                       IF (QPERI.LT.RCOLL) THEN
<                           CALL TOUCH(IPAIR,I1,I2,RCOLL)
<                       END IF
<                   END IF
399,400c311,312
< *       Check perturbation threshold (H < 0 & GAMMA > GMAX).
< *     IF (KZ(4).EQ.0.OR.G0.LT.GMAX) GO TO 70
---
> * Check perturbation threshold (H < 0 & GAMMA > GMAX).
>       IF (KZ(4).EQ.0.OR.G0.LT.GMAX) GO TO 70
402,427c314,339
< *     K = KZ(4)
< *     DO 65 L = 1,K
< *         IF ((G0 - GPRINT(L))*(GI - GPRINT(L)).LE.0.0) THEN
< *             IF (L.EQ.1) THEN
< *                 W1 = -0.5*BODY(I)/HI
< *                 W2 = W1*BODYIN
< *                 TK = TWOPI*W1*SQRT(W2)
< *             END IF
< *
< *       Estimate smallest permitted output interval at new level.
< *             DTCRIT = TK*ORBITS(L)
< *             IF (TIME - TLASTB(L).LT.DTCRIT) GO TO 70
< *             DGAM = GI - G0
< *             CALL EVOLVE(IPAIR,L)
< *             GO TO 70
< *         END IF
< *  65 CONTINUE
< *
< *       Check for partial reflection during approach (NB! only IMOD = 1).
< *  70 IF (GI.LT.GMIN.AND.TD2.LT.0.0D0) THEN
< *       Skip apocentre position itself.
< *         IF (RDOT.LT.0.0D0.AND.IMOD.EQ.1) THEN
< *             IF (KZ(25).GT.0) CALL FREEZE(IPAIR)
< *             GO TO 100
< *         END IF
< *     END IF
---
>       K = KZ(4)
>       DO 65 L = 1,K
>           IF ((G0 - GPRINT(L))*(GI - GPRINT(L)).LE.0.0) THEN
>               IF (L.EQ.1) THEN
>                   W1 = -0.5*BODY(I)/HI
>                   W2 = W1*BODYIN
>                   TK = TWOPI*W1*SQRT(W2)
>               END IF
> *
> * Estimate smallest permitted output interval at new level.
>               DTCRIT = TK*ORBITS(L)
>               IF (TIME - TLASTB(L).LT.DTCRIT) GO TO 70
>               DGAM = GI - G0
>               CALL EVOLVE(IPAIR,L)
>               GO TO 70
>           END IF
>    65 CONTINUE
> *
> * Check for partial reflection during approach (NB! only IMOD = 1).
> * 70 IF (GI.LT.GMIN.AND.TD2.LT.0.0D0) THEN
> * Skip apocentre position itself.
> * IF (RDOT.LT.0.0D0.AND.IMOD.EQ.1) THEN
> * IF (KZ(25).GT.0) CALL FREEZE(IPAIR)
> * GO TO 100
> * END IF
> * END IF
429c341
< *       Determine new perturbers for binary at apocentre turning point.
---
> * Determine new perturbers for binary at apocentre turning point.
433c345
< *       Check minimum two-body separation just after pericentre.
---
> * Check minimum two-body separation just after pericentre.
435c347
< *       Obtain pericentre by Mikkola's algorithm (GAMMA < 0.001).
---
> * Obtain pericentre by Mikkolas algorithm (GAMMA < 0.001).
443,463c355,363
< *       Check optional tidal interaction or stellar collision (skip merger).
<           IF (KZ(19).GE.3.AND.KSTAR(I).LE.10.AND.NAME(I).GT.0) THEN
<               RFAC = 10.0
<               IF (KZ(27).LE.2) THEN
<                   IF (KZ(27).EQ.1) RFAC = 4.0
<                   RX = RFAC*MAX(RADIUS(I1),RADIUS(I2))
<               ELSE
<                   RX = RPMIN(BODY(I1),BODY(I2),VSTAR,HI,QPERI)
<               END IF
<               IF (QPERI.LT.RX) THEN
<                   J1 = I1
<                   IF (RADIUS(I2).GT.RADIUS(I1)) J1 = I2
<                   FAC = 0.5*BODY(I)/BODY(J1)
< *       Adopt collision criterion of Kochanek (Ap.J. 385, 604, 1992).
<                   IF (KZ(27).LE.2) THEN
<                       RCOLL = 1.7*FAC**0.3333*RADIUS(J1)
<                   ELSE
<                       RCOLL = 6.0*BODY(I)/CLIGHT**2
<                   END IF
<                   IF (QPERI.LT.RCOLL) THEN
< *       Obtain KS variables at pericentre before merging into one body.
---
> * Check optional tidal interaction or stellar collision (skip merger).
>           IF (KZ(27).GT.0) THEN
>               ECC = 1.0 - QPERI/SEMI
>               ZF = 4.0
>               IF (ECC.GT.0.95) ZF = 50.0
>               IF (QPERI.LT.ZF*MAX(RADIUS(I1),RADIUS(I2)).AND.
>      & NAME(I).GT.0) THEN
>                   IF (QPERI.LT.0.75*(RADIUS(I1) + RADIUS(I2))) THEN
> * Obtain KS variables at pericentre before merging into one body.
466d365
<                       IQCOLL = -2
468,504c367,369
<                   ELSE IF (KSTAR(I).GE.0) THEN
< *       Distinguish between sequential, standard and GR circularization.
<                       IF (KZ(27).EQ.1) THEN
<                           ICIRC = 1
<                       ELSE IF (KZ(27).EQ.2) THEN
<                           ECC2 = (1.0 - RI/SEMI)**2 +
<      &                                    TDOT2(IPAIR)**2/(BODY(I)*SEMI)
<                           ECC = SQRT(ECC2)
<                           ICIRC = 0
<                           CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
<                       ELSE
<                           ICIRC = 1
<                       END IF
<                       IF (KSTAR(I).GE.10) ICIRC = 0
<                       IF (ICIRC.GT.0.AND.KZ(27).GT.0) THEN
<                           CALL KSTIDE(IPAIR,QPERI)
<                       END IF
<                   END IF
<               END IF
< *       Check for perturbed spiral or chaos case (skip collision).
<               IF (KSTAR(I).EQ.-2.AND.IPHASE.EQ.0) THEN
<                   CALL SPIRAL(IPAIR)
<               ELSE IF (KSTAR(I).EQ.-1.AND.IPHASE.EQ.0) THEN
<                   CALL KSTIDE(IPAIR,QPERI)
<               END IF
< *       Check options for artificial collisions.
<           ELSE IF (KZ(27).EQ.-1.AND.KZ(13).LT.0) THEN
<               RFAC = 2.0*RMSTAR
<               IF (QPERI.LT.RFAC*MAX(RADIUS(I1),RADIUS(I2))) THEN
<                   J1 = I1
<                   IF (RADIUS(I2).GT.RADIUS(I1)) J1 = I2
<                   FAC = 0.5*BODY(I)/BODY(J1)
< *       Adopt collision criterion of Kochanek (Ap.J. 385, 604, 1992).
<                   RCOLL = 1.7*FAC**0.3333*RADIUS(J1)
<                   RCOLL = RMSTAR*RCOLL
<                   IF (QPERI.LT.RCOLL) THEN
<                       CALL TOUCH(IPAIR,I1,I2,RCOLL)
---
> * Do not evolve synchronous orbit further.
>                   ELSE IF (KSTAR(I).NE.20) THEN
>                       CALL KSTIDE(IPAIR,QPERI)
511c376
< *       Save maximum separation of persistent binary.
---
> * Save maximum separation of persistent binary.
514c379
< *       Check binary reference radius or merger stability criterion.
---
> * Check binary reference radius or merger termination.
516c381
< *       Update termination length scale in case of initial soft binary.
---
> * Update termination length scale of hard binary if enough perturbers.
518,519c383,389
<           IF (EB.LT.EBH) R0(IPAIR) = MAX(RMIN,2.0*SEMI)
<       ELSE 
---
>           IF (EB.LT.EBH.AND.RI.LT.0.02*RS(I)) THEN
>               R0(IPAIR) = MAX(RMIN,2.0*SEMI)
>           ELSE
>               R0(IPAIR) = MAX(RMIN,0.03*RS(I))
>           END IF
>       ELSE
> * Check pericentre stability criterion of merged binary (NAME < 0).
521,556c391,435
<           RP = SEMI*(1.0 - SQRT(ECC2))*(1.0 - 2.0*GI)
< *       Find merger index.
<           IM = 0
<           DO 72 K = 1,NMERGE
<               IF (NAMEM(K).EQ.NAME(I)) IM = K
<    72     CONTINUE
<           IF (MIN(BODY(I1),BODY(I2)).LT.0.05*BODYM) THEN
<               IF (RP.LT.R0(IPAIR)) GO TO 90
<           END IF
< *       Check stability condition, eccentricity modulation or t_circ update.
<           IF (IM.GT.0.AND.TIME.GT.TMDIS(IM)) THEN
<               IF (RP.LT.R0(IPAIR)) THEN
< *                 WRITE (6,74)  TTOT, IM, NAME(I1), SQRT(ECC2), RP,RI,GI
< *  74             FORMAT (' TSTAB TERM:    T IM NM E RP APO G ',
< *    &                                     F9.2,I4,I6,f7.3,1P,3E9.1)
<                   NSTAB = NSTAB + 1
<                   GO TO 90
<               ELSE IF (KZ(27).EQ.2) THEN
<                   CALL ECCMOD(I,ITERM)
<                   IF (ITERM.GT.0) THEN
< *                     WRITE (6,76)  RP, R0(IPAIR)
< *  76                 FORMAT (' ECCMOD TERM    RP R0 ',1P,2E10.2)
<                       GO TO 90
<                   END IF
< *       Consider both inner and possible outer circularizing binary.
<                   DO 78 K = 1,NCHAOS
<                       IF (NAMEC(K).EQ.NZERO - NAMEM(IM)) THEN
< *       Update unperturbed binary if T - TOSC > 10 Myr (cf. IMPACT & DECIDE).
<                           IF ((TIME - TOSC(K))*TSTAR.GT.10.0) GO TO 90
<                       END IF
<                       IF (NAMEC(K).EQ.NAMEG(IM)) THEN
<                           IF ((TIME - TOSC(K))*TSTAR.GT.10.0) GO TO 90
<                       END IF
< *       Note: perturbed binary is treated if pericentre before next IMPACT.
<    78             CONTINUE
<               END IF
---
>           ECC1 = SQRT(ECC2)
>           RP = SEMI*(1.0 - ECC1)
>           IF (RP*(1.0 - GI).LT.R0(IPAIR)) THEN
>               Q = BODY(I2)/BODY(I)
>               XFAC = (1.0 + Q)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
>               DO 72 K = 1,NMERGE
>                   IF (NAMEM(K).EQ.NAME(I)) IM = K
>    72 CONTINUE
>               AIN = -0.5*BODY(I1)/HM(IM)
>               PCRIT = 2.8*XFAC**0.4*AIN
>               WRITE (6,73) GI, ECC1, RP, R0(IPAIR), PCRIT, AIN
>    73 FORMAT (' BASIC INSTAB    GI E1 RP R0 PCR AIN ',
>      & 2F7.3,1P,4E10.2)
>               GO TO 90
>           END IF
> * Include safety check for outer eccentricity change (GI > 0.001).
>           IF (GI.GT.0.001) THEN
>               Q = BODY(I2)/BODY(I)
>               XFAC = (1.0 + Q)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
>               DO 75 K = 1,NMERGE
>                   IF (NAMEM(K).EQ.NAME(I)) IM = K
>    75 CONTINUE
>               AIN = -0.5*BODY(I1)/HM(IM)
>               PCRIT = 2.8*XFAC**0.4*AIN
> * Adopt 60 % criterion to allow for marginally stable systems.
>               IF (RP.LT.0.6*PCRIT) THEN
>               WRITE (6,500) GI, ECC1, RP, R0(IPAIR), PCRIT, AIN
>   500 FORMAT (' PERT INSTAB!    GI E1 RP R0 PCR AIN ',
>      & 2F7.3,1P,4E10.2)
>               GO TO 90
>               END IF
>           END IF
> * Terminate merger if maximum perturber range > 2*RS & GI > GMAX.
>           IF (CMSEP2*RI**2.GT.4.0*RS(I)**2.AND.GI.GT.GMAX) GO TO 90
>       END IF
> *
> * See whether KS slow-down procedure should be (re)-checked.
>       IF (KZ(26).GT.0) THEN
> * Include case of tidal dissipation.
>           IF (KZ(27).GT.0) THEN
>               ECC2 = (1.0 - RI/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
>               QPERI = SEMI*(1.0 - SQRT(ECC2))
>               RT = 4.0*MAX(RADIUS(I1),RADIUS(I2))
> * Skip modification if predicted pericentre < 5 tidal capture radii.
>               IF (QPERI.LT.5.0*RT.AND.GI.LT.RANGE*GMIN) GO TO 80
558,573d436
<       END IF
< *
< *       Produce diagnostics for any circularizing perturbed binary.
<       IF (KSTAR(I).EQ.-2.AND.GI.GT.0.01) THEN
<           ECC = RI/SEMI - 1.0
<           QPS = SEMI*(1.0 - ECC)/MAX(RADIUS(I1),RADIUS(I2))
<           ZM = BODY(I1)/BODY(I2)
<           WRITE (21,80)  TTOT, NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
<      &                   LIST(1,I1), QPS, ZM, GI, ECC, SEMI
<    80     FORMAT (' PERT SPIRAL    T NAM K* NP QP/S M1/M2 G E A ',
<      &                             F11.4,2I6,3I3,2F5.1,2F8.4,1P,E10.2)
<           CALL FLUSH(21)
<       END IF
< *
< *       See whether KS slow-down procedure should be (re)-checked (no Chaos).
<       IF (KZ(26).GT.0.AND.KSTAR(I).GE.0) THEN
581,582c444,445
< *       Set approximate value of next period with perturbation included.
<       TK = TWOPI*SEMI*SQRT(SEMI*BODYIN)*(1.0 + GI)
---
> * Set approximate value of next period with perturbation included.
>    80 TK = TWOPI*SEMI*SQRT(SEMI*BODYIN)*(1.0D0 + GI)
587c450
< *       Use old perturber list if next apocentre is before the c.m. step.
---
> * Use old perturber list if next apocentre is before the c.m. step.
589c452,456
<           GO TO 100
---
>           IF (KZ(26).EQ.0.OR.KZ(27).EQ.0) THEN
>               GO TO 100
>           ELSE
>               IF (QPERI.LT.RT.AND.KSTAR(I).NE.20) GO TO 100
>           END IF
592c459
< *       Select new perturbers (J = N adopted for unperturbed Chaos).
---
> * Select new perturbers (adopt unperturbed period if none found).
595,602c462,463
< *       Check rectification of chaotic spiral at start of unperturbed motion.
<       IF (KSTAR(I).EQ.-2.AND.LIST(1,I1).EQ.0) THEN
<           DMR = 0.D0
<           CALL CHRECT(IPAIR,DMR)
<           IF (IPHASE.LT.0) GO TO 100
<       ELSE
<           CALL KSRECT(IPAIR)
<       END IF
---
> * Perform rectification.
>       CALL KSRECT(IPAIR)
604c465
< *       Check optional search criterion for multiple encounter or merger.
---
> * Check optional search criterion for multiple encounter or merger.
610c471
< *       Terminate regularization of current pair (IPAIR set in KSPAIR).
---
> * Terminate regularization of current pair (IPAIR set in KSPAIR).
612c473
< *       Set indicator for calling KSTERM in MAIN (permits phase overlay).
---
> * Set indicator for calling KSTERM in MAIN (permits phase overlay).
614c475
< *       Check for rare case of merged binary component.
---
> * Check for rare case of merged binary component.
1,2c1,2
< 4399 2006-08-26 15:54 /work/Umi2/spurzem/5/nbody6compare-oct2006/kslist.f
< nbody6compare-oct2006/kslist.f
---
> 3827 2002-06-12 23:24 /work/Umi2/spurzem/5/nbody6++compare/kslist.f
> nbody6++compare/kslist.f
17d16
<       IT = 0
46,47c45,46
< *       Select new perturbers from the neighbour list.
<     6 NNB1 = 1
---
> *       Select new perturbers from all particles.
>       NNB1 = 1
62,68d60
<               ELSE IF (J.GT.N) THEN
< *       Employ a more generous criterion for possible wide binary.
<                   RJ = BODY(J)/H(J-N)
<                   IF (RSEP2.LT.CMSEP2*RJ**2) THEN
<                       NNB1 = NNB1 + 1
<                       LIST(NNB1,I1) = J
<                   END IF
73,80d64
< *       Ensure at least one perturber first time (max 5 tries except CHAOS).
<       IF (NNB1.EQ.1.AND.IPHASE.GT.0.AND.NNB.GT.0.AND.TIME.GT.0.0) THEN
<           RCRIT3 = 2.0*RCRIT3
<           IT = IT + 1
< *       Skip repeat for small size (next KSLIST requires many periods).
<           IF ((SEMI*SU.GT.10.0.AND.IT.LE.5).OR.KSTAR(I).EQ.-1) GO TO 6
<       END IF
< *
82,88c66
<       IF (NNB1.EQ.1) THEN
< *       Add distant perturber for hyperbolic orbit.
<           IF (SEMI.LT.0.0) THEN
<               NNB1 = 2
<               LIST(2,I1) = LIST(2,I)
<               GO TO 20
<           END IF
---
>       IF (NNB1.EQ.1.AND.SEMI.GT.0.0) THEN
90,93c68,70
< *         IF (TDOT2(IPAIR).GT.0.0D0.AND.KZ(25).GT.0) THEN
< *             NNB1 = 2
< *         ELSE IF (KZ(27).LE.0) THEN
<           IF (KZ(27).LE.0) THEN
---
>           IF (TDOT2(IPAIR).GT.0.0D0.AND.KZ(25).GT.0) THEN
>               NNB1 = 2
>           ELSE IF (KZ(27).EQ.0) THEN
96a74,75
> *       Set GAMMA < GMIN since CMFIRR uses resolved KS otherwise (bug 4/00).
>               GAMMA(IPAIR) = 0.5*GMIN
98,101c77,80
< *       Maintain perturbed motion during Chaos or Roche event.
<               IF (KSTAR(I).EQ.-1) THEN
< *             IF (KSTAR(I).EQ.-1.OR.(KSTAR(I).GT.10.AND.
< *    &           MOD(KSTAR(I),2).EQ.1.AND.TEV(I).LT.TIME + STEP(I)))THEN
---
> *       Maintain perturbed motion during circularization (cf. KSTIDE test).
>               RP = SEMI*(1.0D0 - ECC)
>               RT = 4.0*MAX(RADIUS(I1),RADIUS(I1+1))
>               IF (RP.LT.0.99*RT.AND.KSTAR(I).NE.20) THEN
104c83,86
<                       LIST(2,I1) = N
---
>                   ELSE
> *       Adopt orbital period since current value could be small many times.
>                       STEP(I1) = TWOPI*SEMI*SQRT(SEMI/BODY(I))
>                       STEP(I1) = MIN(STEP(I1),STEP(I))
108a91
>                   GAMMA(IPAIR) = 0.5*GMIN
113,114c96
<               NNB = LIST(1,I)
<               DO 15 L = 2,NNB+1
---
>               DO 15 L = 2,NNB2
124c106
<    20 LIST(1,I1) = NNB1 - 1
---
>       LIST(1,I1) = NNB1 - 1
128a111
> 
1,2c1,2
< 3606 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksmod.f
< nbody6compare-oct2006/ksmod.f
---
> 3926 2001-08-04 17:07 /work/Umi2/spurzem/5/nbody6++compare/ksmod.f
> nbody6++compare/ksmod.f
60,61c60,61
< *       Determine the eccentric anomaly with respect to pericentre (-PI,PI).
<       THETA = ATAN2(PSI/SQRT(SEMI),ZETA)
---
> *       Determine the eccentric anomaly with respect to pericentre (0,PI).
>       THETA = ATAN2(ABS(PSI)/SQRT(SEMI),ZETA)
64,65c64,65
<       DT = SEMI*SQRT(SEMI/BODY(ICM))*(THETA - PSI/SQRT(SEMI))
<       DT = 0.5D0*TK + DT
---
>       DT = SEMI*SQRT(SEMI/BODY(ICM))*(THETA - ABS(PSI)/SQRT(SEMI))
>       DT = 0.5D0*TK - DT
68,69c68,76
< *       Evaluate regularized apocentre time (Baumgarte & Stiefel, 1974).
< *     DTU = -2.0D0*(H(IPAIR)*DT + TDOT2(IPAIR))/BODY(ICM)
---
> *       Evaluate regularized apocentre time (Stiefel & Scheifele, p. 85).
> *     DTU = -2.0D0*(H(IPAIR)*DT + 0.5D0*TDOT2(IPAIR))/BODY(ICM)
> *
> *       See whether the time interval should be modified by KSLOW procedure.
>       IF (IMOD.GT.1) THEN
>           ZMOD = FLOAT(ISLOW(IMOD))
>       ELSE
>           ZMOD = 1.0
>       END IF
73c80
<       DTU = DT/R(IPAIR)
---
>       DTU = DT/(R(IPAIR)*ZMOD)
75,76c82
< *       Note: explicit relation agrees with iterated value (bug fix 9/99).
<    40 Y0 = DT - ((ONE6*TDOT3(IPAIR)*DTU +
---
>    40 Y0 = DT - ZMOD*((ONE6*TDOT3(IPAIR)*DTU +
78a85
>       YPR = ZMOD*YPR
81a89
>       DT1 = ZMOD*DT1
96,97c104,110
< *       Predict current coordinates & velocities of ICM.
<       CALL XVPRED(ICM,0)
---
> *       Predict current coordinates & velocities for perturbers, ICM & IPAIR.
>       NNB2 = LIST(1,I1) + 2
>       LIST(NNB2,I1) = ICM
>       DO 60 L = 2,NNB2
>           J = LIST(L,I1)
>           CALL XVPRED(J,0)
>    60 CONTINUE
1,2c1,2
< 5876 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksperi.f
< nbody6compare-oct2006/ksperi.f
---
> 2705 2002-07-31 07:19 /work/Umi2/spurzem/5/nbody6++compare/ksperi.f
> nbody6++compare/ksperi.f
8d7
<       COMMON/SLOW0/  RANGE,ISLOW(10)
11,14c10
< *       Save current time and initialize integration indicator.
<       TIME0 = TIME
<       ITIME = 0
<       I1 = 2*IPAIR - 1
---
> *       Set c.m. index & semi-major axis.
16,22c12
< *
< *       Re-calculate TDOT2 which may have misleading value.
<     1 TD2 = 0.0D0
<       DO 5 K = 1,4
<           TD2 = TD2 + U0(K,IPAIR)*UDOT(K,IPAIR)
<     5 CONTINUE
<       TD2 = 2.0*TD2
---
>       SEMI = -0.5D0*BODY(ICM)/H(IPAIR)
25d14
<       SEMI = -0.5D0*BODY(ICM)/H(IPAIR)
27c16
<       PSI = TD2/SQRT(BODY(ICM))
---
>       PSI = TDOT2(IPAIR)/SQRT(BODY(ICM))
31c20
<       IF (ECC.LT.0.0001) GO TO 30
---
>       IF (ECC.LT.0.0001) GO TO 20
40c29
<           DO 8 IT = 1,10
---
>           DO 1 IT = 1,10
43c32
<     8     CONTINUE
---
>     1     CONTINUE
49a39
> *
52a43
> *       Hyperbolic case.
62,136c53,55
< *       Re-define current time (NB! not quantized; T0(I1) may be << TIME).
<       TIME = TIME - DT
< *
< *       Integrate backwards for perturbed motion (reflection gives errors).
<       IF (LIST(1,I1).GT.0.AND.ITIME.EQ.0.AND.DT.GT.STEP(I1)) THEN
<           TIME = TIME0
<           IMOD = KSLOW(IPAIR)
<           ZMOD = FLOAT(ISLOW(IMOD))
<           IPH = IPHASE
<           IPHASE = -1
< *
< *       Integrate step by step if interval is too large (note IPHASE < 0).
<    10     IF (DT.GT.STEP(I1)) THEN
<               TIME = TIME - STEP(I1)
<               DT = DT - STEP(I1)
<               H0(IPAIR) = H(IPAIR)
<               Z = -0.5D0*H(IPAIR)*DTAU(IPAIR)**2
<               CALL STUMPF(IPAIR,Z)
<               DTAU(IPAIR) = -ABS(DTAU(IPAIR))
<               CALL KSINT(I1)
<               DTU = DTAU(IPAIR)
< *       Use negative DTU and treat STEP as positive (not used elsewhere).
<               STEP(I1) = ((ONE6*TDOT3(IPAIR)*DTU + 0.5*TDOT2(IPAIR))*DTU
<      &                                                   + R(IPAIR))*DTU
<               STEP(I1) = -ZMOD*STEP(I1)
<               ITIME = ITIME + 1
<               IF (ITIME.LT.200) GO TO 10
<           END IF
< *
<           ITIME = ITIME + 1
<           DTU = DT/(R(IPAIR)*ZMOD)
<           DTU0 = DTAU(IPAIR)
<           ITER = 0
< *       Determine the regularized step by Newton-Raphson iteration (DT > 0).
<    20     Y0 = DT - ZMOD*((ONE6*TDOT3(IPAIR)*DTU +
<      &                             0.5*TDOT2(IPAIR))*DTU + R(IPAIR))*DTU
<           YPR = -((0.5*TDOT3(IPAIR)*DTU + TDOT2(IPAIR))*DTU + R(IPAIR))
<           YPR = ZMOD*YPR
<           DTU = DTU - Y0/YPR
<           DT1 = ((ONE6*TDOT3(IPAIR)*DTU + 0.5*TDOT2(IPAIR))*DTU +
<      &                                                     R(IPAIR))*DTU
<           DT1 = ZMOD*DT1
<           ITER = ITER + 1
<           IF (ABS(DT - DT1).GT.1.0D-10*STEP(I1).AND.ITER.LT.5) GO TO 20
< *
< *       Integrate back to pericentre using temporary indicator < 0 for exit.
<           TIME = TIME - DT
<           DTAU(IPAIR) = -DTU
< *       Re-initialize Stumpff functions.
<           H0(IPAIR) = H(IPAIR)
<           Z = -0.5D0*H(IPAIR)*DTAU(IPAIR)**2
<           CALL STUMPF(IPAIR,Z)
<           CALL KSINT(I1)
< *       Update energy and set positive step in case no KS initialization.
<           H0(IPAIR) = H(IPAIR)
<           DTAU(IPAIR) = ABS(DTU0)
<           STEP(I1) = ZMOD*DT
<           IPHASE = IPH
< *       Use reflection procedure to improve provisional pericentre.
<           GO TO 1
< *       Note: typically 2 iterations and final TDOT2 > 0.
<       END IF
< *
< *       Specify transformation coefficients (Seppo Mikkola's procedure).
<       IF (ZETA.GE.0.0) THEN
<           XC = SQRT(0.5D0 + 0.5D0*ZETA/ECC)
<           YS = PSI/(ECC*XC*SQRT(BODY(ICM)))
<       ELSE
< *       Employ well behaved expressions for R > A (SM 29/5/97).
<           XC = 0.5*ABS(PSI)/(SQRT(SEMI)*ECC)/SQRT(0.5D0-0.5D0*ZETA/ECC)
< *       Avoid division by small XC near apocentre (ZETA < 0 only).
<           YS = 2.0*SQRT(SEMI/BODY(ICM)*(0.5D0 - 0.5D0*ZETA/ECC))
<           IF (PSI.LT.0.0) YS = -YS
<       END IF
< *
---
> *       Specify transformation coefficients (Mikkola's procedure).
>       XC = SQRT(0.5D0 + 0.5D0*ZETA/ECC)
>       YS = PSI/(ECC*XC*SQRT(BODY(ICM)))
142,143c61
<       T0(I1) = TIME
<       DO 25 K = 1,4
---
>       DO 10 K = 1,4
149c67
<    25 CONTINUE
---
>    10 CONTINUE
156,159c74,76
< *       Predict c.m. coordinates & velocities.
<       IF (ABS(DT).LT.STEP(ICM).AND.TIME.GT.0.0) THEN
<           CALL XVPRED(ICM,0)
<       END IF
---
> *       Set pericentre time and predict c.m. coordinates & velocities.
>       TIME = TIME - DT
>       CALL XVPRED(ICM,0)
161c78
<    30 RETURN
---
>    20 RETURN
1,2c1,2
< 5931 2004-12-14 09:44 /work/Umi2/spurzem/5/nbody6compare-oct2006/kspert.f
< nbody6compare-oct2006/kspert.f
---
> 5330 2001-08-24 13:46 /work/Umi2/spurzem/5/nbody6++compare/kspert.f
> nbody6++compare/kspert.f
88c88,89
<           CALL KSRES2(J,J1,J2,RIJ2)
---
>           IZZ = KVEC(I1)
>           CALL KSRES2(J,J1,J2,RIJ2,IZZ)
154,155c155,156
< *       See whether the linearized perturbation should be included.
<       IF (KZ(14).GT.0.AND.KZ(14).LT.3) THEN
---
> *       See whether the external perturbation should be included.
>       IF (KZ(14).GT.0) THEN
170,187d170
< *       Check optional Plummer potential.
<       IF (KZ(14).EQ.4.OR.KZ(14).EQ.3) THEN
<           RI2 = AP2
<           RRDOT = 0.0
< *       Form one central distance and scalar product of relative motion.
<           DO 65 K = 1,3
<               RI2 = RI2 + XI(K)**2
<               RRDOT = RRDOT + (XI(K) - XI(K+3))*(VI(K) - VI(K+3))
<    65     CONTINUE
<           FMP = MP/(RI2*SQRT(RI2))
<           DO 70 K = 1,3
<               XREL = XI(K) - XI(K+3)
<               VREL = VI(K) - VI(K+3)
<               FP(K) = FP(K) - XREL*FMP
<               FD(K) = FD(K) - (VREL - 3.0*RRDOT*XREL/RI2)*FMP
<    70     CONTINUE
<       END IF
< *
1,2c1,2
< 648 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksphys.f
< nbody6compare-oct2006/ksphys.f
---
> 648 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/ksphys.f
> nbody6++compare/ksphys.f
1,2c1,2
< 9234 2006-09-01 16:54 /work/Umi2/spurzem/5/nbody6compare-oct2006/kspoly.f
< nbody6compare-oct2006/kspoly.f
---
> 9287 2003-06-22 19:44 /work/Umi2/spurzem/5/nbody6++compare/kspoly.f
> nbody6++compare/kspoly.f
18d17
<       SEMI = -0.5*BODY(I)/H(IPAIR)
80c79
<       IF (KZ(14).GT.0.AND.KZ(14).LT.3) THEN
---
>       IF (KZ(14).GT.0) THEN
200c199
<       IF (IMOD.GT.1.OR.H(IPAIR).GT.0.0) FAC = 1.0
---
>       IF (IMOD.GT.1) FAC = 1.0
234,235c233,234
< *       Ensure that c.m. step is not exceeded (H > 0 is OK).
<       IF (STEP(I1).GT.STEP(I).AND.H(IPAIR).LT.0.0) THEN
---
> *       Ensure that c.m. step is not exceeded.
>       IF (STEP(I1).GT.STEP(I)) THEN
252a252,256
> *       See whether to include relative motion in the time-step list.
>       IF (T0(I1) + STEP(I1).LT.TLIST) THEN
>           CALL NLMOD(I1,1)
>       END IF
> *
255a260,261
> 
> 
1,2c1,2
< 2841 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/kspred.f
< nbody6compare-oct2006/kspred.f
---
> 2858 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/kspred.f
> nbody6++compare/kspred.f
8c8
<       PARAMETER  (ONE24=1.0/24.0D0,ONE120=1.0/120.0D0)
---
>       PARAMETER  (ONE18=1.0/18.0D0,ONE24=1.0/24.0D0,ONE120=1.0/120.0D0)
1,2c1,2
< 3464 2006-09-19 18:09 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksrect.f
< nbody6compare-oct2006/ksrect.f
---
> 3564 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/ksrect.f
> nbody6++compare/ksrect.f
12c12
<       DO 1 K = 1,4
---
>       DO 5 K = 1,4
14,21c14
<     1 CONTINUE
< *
< *       Skip rectification for small eccentricity.
<       I = N + IPAIR
<       SEMI = -0.5*BODY(I)/H(IPAIR)
<       ECC2 = (1.0 - R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(SEMI*BODY(I))
<       ECC = SQRT(ECC2)
<       IF (ECC.LE.0.0001) GO TO 50
---
>     5 CONTINUE
23a17
>       EB = BODY(2*IPAIR-1)*BODY(2*IPAIR)*HI/BODY(N+IPAIR)
26a21,28
>       IF (ABS(ERR).GT.0.01) THEN
>       I1 = 2*IPAIR - 1
>       SEMI = -0.5*BODY(N+IPAIR)/H(IPAIR)
>       AF = -0.5*BODY(N+IPAIR)/HI
>       WRITE (6,4)  NAME(I1), LIST(1,I1), SEMI, AF, DB, ERR
>     4 FORMAT (' WARNING!   KSRECT    NM NP A0 AF DB DH/H  ',
>      &                               I5,I4,1P,4E10.2)
>       END IF
28,35c30,37
<           SEMI = -0.5*BODY(N+IPAIR)/H(IPAIR)
<           RA = R(IPAIR)/SEMI
<           IF (SEMI.LT.0.0) RA = R(IPAIR)
<           WRITE (16,3)  TIME+TOFF, IPAIR, RA, H(IPAIR), GAMMA(IPAIR),
<      &                  DB, ERR
<     3     FORMAT (' KSRECT:   T # R/A H G DB DH/H ',
<      &                        F8.2,I4,F8.4,F8.1,F7.3,1P,2E10.1)
<           CALL FLUSH(16)
---
>       SEMI = -0.5*BODY(N+IPAIR)/H(IPAIR)
>       RA = R(IPAIR)/SEMI
>       IF (SEMI.LT.0.0) RA = R(IPAIR)
>       WRITE (16,3)  TIME, IPAIR, RA, H(IPAIR),
>      &              GAMMA(IPAIR), DB, ERR
>     3 FORMAT (' KSRECT:   T # R/A H G DB DH/H ',
>      &                    F8.2,I4,F8.4,F7.1,F7.3,1P,2E10.1)
>       CALL FLUSH(16)
37d38
< *
103c104
<    50 RETURN
---
>       RETURN
1,2c1,2
< 4351 2006-09-09 12:27 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksreg.f
< nbody6compare-oct2006/ksreg.f
---
> 4327 2001-09-08 19:14 /work/Umi2/spurzem/5/nbody6++compare/ksreg.f
> nbody6++compare/ksreg.f
136c136
< *       Copy neighbour list for second component & c.m. (NNB1 = LIST(1,I)+1).
---
> *       Copy neighbour list for second component & c.m.
141d140
< *
1,2c1,2
< 3105 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksres2.f
< nbody6compare-oct2006/ksres2.f
---
> 3121 2001-09-30 19:44 /work/Umi2/spurzem/5/nbody6++compare/ksres2.f
> nbody6++compare/ksres2.f
1c1
<       SUBROUTINE KSRES2(J,J1,J2,RIJ2)
---
>       SUBROUTINE KSRES2(J,J1,J2,RIJ2,IZZ)
45c45
<           DTU1 = DTU/24.0D0
---
>           DTU1 = 0.0416666666666667*DTU
1,2c1,2
< 2134 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksres.f
< nbody6compare-oct2006/ksres.f
---
> 2148 2003-06-23 19:32 /work/Umi2/spurzem/5/nbody6++compare/ksres.f
> nbody6++compare/ksres.f
42c42
<           DTU1 = DTU/24.0D0
---
>           DTU1 = 0.0416666666666667*DTU
68a69,70
> 
> 
1,2c1,2
< 12398 2006-08-29 11:02 /work/Umi2/spurzem/5/nbody6compare-oct2006/ksterm.f
< nbody6compare-oct2006/ksterm.f
---
> 12802 2003-06-25 21:13 /work/Umi2/spurzem/5/nbody6++compare/ksterm.f
> nbody6++compare/ksterm.f
10,11c10,11
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
68c68
<           IF (ABS(DT0 - DT1).GT.1.0E-10*STEP(I1).AND.ITER.LT.10) GO TO 2
---
>           IF (ABS(DT0 - DT1).GT.1.0E-06*STEP(I1).AND.ITER.LT.10) GO TO 2
118c118
<       IF (KZ(8).EQ.0) GO TO 10
---
>       IF (KZ(8).EQ.0.OR.NBIN0.GT.0) GO TO 10
132c132,133
<           WRITE (8,8)  TIME+TOFF, NAME(I1), NAME(I2), K, NAME(JCOMP),
---
>           if(rank.eq.0)
>      &    WRITE (8,8)  TIME+TOFF, NAME(I1), NAME(I2), K, NAME(JCOMP),
143c144,145
<           WRITE (6,15)  TIME+TOFF, BODY(I1), BODY(I1+1), DTAU(IPAIR),
---
>           if (rank.eq.0)
>      &    WRITE (6,15)  TIME+TOFF, BODY(I1), BODY(I1+1), DTAU(IPAIR),
146c148
<    15     FORMAT (/,' END KSREG    TIME =',F7.2,2F8.4,F8.3,1PE10.1,
---
>    15     FORMAT (/,' END KSREG    TIME =',1PE10.2,0P2F8.4,F8.3,1PE10.1,
155,157c157,161
< *       Add correction term with opposite sign for conservation.
< *     ECOLL = ECOLL + (POT2 - POT1)
< *     IF (ABS(POT1-POT2).GT.0.0001) WRITE (6,16)  POT1,BE(3),POT1-POT2
---
> *       Add correction to previous and current terms for conservation.
>       BE(3) = BE(3) + (POT1 - POT2)
>       ECOLL = ECOLL + (POT1 - POT2)
> *     IF (ABS(POT1-POT2).GT.0.0001.and.rank.eq.0) 
> *    &                WRITE (6,16)  POT1,BE(3),POT1-POT2
351a356,363
> *
> *       See whether to include new c.m. or single components in NLIST.
>           IF (T0(ICOMP) + STEP(ICOMP).LT.TLIST) THEN
>               CALL NLMOD(ICOMP,1)
>           END IF
>           IF (T0(JCOMP) + STEP(JCOMP).LT.TLIST) THEN
>               CALL NLMOD(JCOMP,1)
>           END IF
1,2c1,2
< 12831 2006-09-20 13:03 /work/Umi2/spurzem/5/nbody6compare-oct2006/kstide.f
< nbody6compare-oct2006/kstide.f
---
> 8746 2003-06-25 20:59 /work/Umi2/spurzem/5/nbody6++compare/kstide.f
> nbody6++compare/kstide.f
4,5c4,5
< *       Tidal or GR interaction of KS pair.
< *       -----------------------------------
---
> *       Tidal interaction of KS pair.
> *       -----------------------------
9,14c9,10
<       CHARACTER*8  WHICH1
<       INTEGER  IS(2)
<       SAVE  TTIDE,IONE
<       DATA  ECCM,ECCM2,TTIDE,IONE  /0.002,0.00000399,0.0D0,0/
<       SAVE SUM
<       DATA SUM /0.0D0/
---
>       INTEGER IS(2)
>       DATA  ECCM,ECCM2  /0.002,0.00000399/
17c13
< *       Define indices of KS components.
---
> *       Skip procedure if |QP - 4*R| < 0.01*QP or both stars zero size.
19a16,33
>       RX = MAX(RADIUS(I1),RADIUS(I2))
>       SEMI = -0.5D0*BODY(N+IPAIR)/H(IPAIR)
>       ECC = 1.0 - QPERI/SEMI
>       ZF = 4.0
>       IF (ECC.GT.0.95) ZF = 50.0
>       IF (ABS(QPERI - ZF*RX).LT.0.01*QPERI) GO TO 50
>       IF (RADIUS(I1) + RADIUS(I2).LE.0.0D0) GO TO 50
> *
>       IF (QPERI.LT.RADIUS(I1) + RADIUS(I2)) THEN
>           if(rank.eq.0)
>      &    WRITE (6,1)  NAME(I1), QPERI, RX
>     1     FORMAT (' COLLISION TEST!    NAM QP R*  ',I5,1P,2E10.2)
>       END IF
>       IS(1) = KSTAR(I1)
>       IS(2) = KSTAR(I2)
> *
> *       Obtain kinetic energy loss due to tidal interaction (DE > 0 here).
>       CALL TIDES(QPERI,BODY(I1),BODY(I2),RADIUS(I1),RADIUS(I2),IS,DE)
21c35
< *       Set c.m. index & reduced mass and increase event counter.
---
> *       Set c.m. index & reduced mass.
24,25d37
<       NDISS = NDISS + 1
<       RKS = R(IPAIR)
27,31c39,42
< *       Form current semi-major axis & eccentricity (not at peri).
<       TD2 = 0.0
<       DO 5 K = 1,4
<           TD2 = TD2 + 2.0*U(K,IPAIR)*UDOT(K,IPAIR)
<     5 CONTINUE
---
> *       Determine pericentre variables U & UDOT by backwards reflection.
>       CALL KSPERI(IPAIR)
> *
> *       Form semi-major axis & eccentricity (TDOT2 = 0 at pericentre).
33,35c44
<       ECC2 = (1.0 - R(IPAIR)/SEMI)**2 + TD2**2/(SEMI*BODY(I))
<       ECC = SQRT(ECC2)
<       AM0 = SEMI*(1.0D0 - ECC**2)
---
>       ECC = 1.0 - R(IPAIR)/SEMI
37,65d45
<       HI = H(IPAIR)
< *
< *       Distinguish between sequential circularization, standard chaos & GR.
<       R1 = MAX(RADIUS(I1),RADIUS(I2))
<       IF (KZ(27).EQ.1) THEN
<           ZF = 4.0
<           IF (ECC.GT.0.95) ZF = 50.0
< *       Skip if penetration is not significant (prevents frequent calls).
<           IF (ABS(QPERI - ZF*R1).LT.0.01*QPERI) GO TO 50
<       ELSE IF (KZ(27).EQ.2) THEN
<           IS(1) = KSTAR(I1)
<           IS(2) = KSTAR(I2)
< *       Obtain kinetic energy loss due to tidal interaction (DE > 0).
< *        CALL TIDES(QPERI,BODY(I1),BODY(I2),RADIUS(I1),RADIUS(I2),IS,DE)
< *
< *       Evaluate chaos parameters and check for disruption.
<           CALL CHAOS(IPAIR,I1,I2,QPERI,ECC,IS,ZMU,RKS,SEMI1,ECC1,IDIS)
<           IF (IDIS.EQ.1) GO TO 45
< *
< *       Update KS variables for CHAOS or TERMINATED CHAOS (H > 0).
<           IF (KSTAR(I).EQ.-1.OR.H(IPAIR).GT.0.0) THEN
<               CALL KSPERI(IPAIR)
<               GO TO 10
<           END IF
< *       Skip on WIDE CHAOS or NEW SPIRAL.
<           GO TO 45
<       ELSE IF (KZ(27).EQ.3) THEN
<           CALL TIDES3(QPERI,BODY(I1),BODY(I2),VSTAR,H(IPAIR),ECC,DE)
<       END IF
68,69c48,49
<       IF (ECC.LE.ECCM.AND.KSTAR(I).LT.10) THEN
<           KSTAR(I) = 10
---
>       IF (ECC.LE.ECCM.AND.KSTAR(I).LT.20) THEN
>           KSTAR(I) = 20
73,92c53,56
< *       Consider sequential circularization or GR evolution.
<       IF (KZ(27).EQ.1) THEN
< *       Suppress the old PT procedure (DH => ECC from AM0 = const).
< *         ECC2 = ECC**2 + 2.0D0*AM0*DH/BODY(I)
< *         ECC2 = MAX(ECC2,ECCM2)
< *       Accept circularized orbit if ACIRC < 4*R1 (use maximum radius).
<           AM0 = SEMI*(1.0 - ECC**2)
<           ECC1 = SQRT(ECCM2)
<           ACIRC = AM0/(1.0 - ECCM2)
<           IF (ACIRC.LT.ZF*R1) THEN
<               SEMI1 = ACIRC
<           ELSE
< *       Obtain E1 from A1*(1 - E1**2) = AM0 using A1*(1 - E1) = 4*R1.
<               ECC1 = AM0/(ZF*R1) - 1.0
<               ECC1 = MAX(ECC1,ECCM)
< *       Set new semi-major axis from angular momentum conservation.
<               SEMI1 = AM0/(1.0 - ECC1**2)
<           END IF
< *       Form the corresponding energy change.
<           DH = 0.5*BODY(I)*(1.0/SEMI - 1.0/SEMI1)
---
> *       Include safety check on energy loss to prevent new SEMI < R.
>       DH = -(DE(1) + DE(2))/ZMU
>       IF (H(IPAIR) + DH.LT.-0.5*BODY(I)/R(IPAIR)) THEN
>           DH = -0.5*BODY(I)/R(IPAIR) - H(IPAIR)
94a59,81
>       END IF
> *
> *       Obtain the new eccentricity from angular momentum conservation.
>       AM0 = SEMI*(1.0D0 - ECC**2)
> *       Suppress the old instantaneous PT procedure.
> *     ECC2 = ECC**2 + 2.0D0*AM0*DH/BODY(I)
> *     ECC2 = MAX(ECC2,ECCM2)
> *
> *       Adopt sequential circularization instead of standard PT.
>       ECC2 = ECCM2
>       ACIRC = AM0/(1.0 - ECC2)
>       SEMI1 = AM0/(1.0 - ECC2)
>       ECC1 = SQRT(ECC2)
> *
> *       Check Roche conditions for decreased semi-major axis.
>       Q1 = BODY(I1)/BODY(I2)
>       RL1 = 0.49*SEMI1/(0.6 + LOG(1.0 + Q1**0.333)/Q1**0.667)
>       Q2 = 1.0/Q1
>       RL2 = 0.49*SEMI1/(0.6 + LOG(1.0 + Q2**0.333)/Q2**0.667)
> *
> *       Find the dominant Roche radius (not used yet).
>       IF (RADIUS(I1)/RL1.GE.RADIUS(I2)/RL2) THEN
>           RL = RADIUS(I1)
96,104c83,93
< *       Include safety check on energy loss to prevent new SEMI < R.
<           DH = -(DE(1) + DE(2))/ZMU
<           IF (H(IPAIR) + DH.LT.-0.5*BODY(I)/R(IPAIR)) THEN
<               DH = -0.5*BODY(I)/R(IPAIR) - H(IPAIR)
<               DE(1) = -ZMU*DH
<               DE(2) = 0.0
<           END IF
<           SEMI1 = -0.5*BODY(I)/(H(IPAIR) + DH)
<           ECC1 = 1.0 - PERI/SEMI1
---
>           RL = RADIUS(I2)
>           RL1 = RL2
>       END IF
> *
> *       Accept circularized orbit if ACIRC < 4*R1 (use maximum radius).
>       R1 = RX
>       IF (ACIRC.LT.ZF*R1) THEN
>           SEMI1 = ACIRC
>       ELSE
> *       Obtain E1 from A1*(1 - E1**2) = AM0 using A1*(1 - E1) = 4*R1.
>           ECC1 = AM0/(ZF*R1) - 1.0
105a95,97
>           ECC1 = MAX(ECC1,0.9*ECC)
> *       Set new semi-major axis from angular momentum conservation.
>           SEMI1 = AM0/(1.0 - ECC1**2)
107a100,105
> *       Form the corresponding energy change.
>       DH = 0.5*BODY(I)*(1.0/SEMI - 1.0/SEMI1)
> *     DH = (ECC2 - ECC**2)*BODY(I)/(2.0D0*AM0)
>       DE(1) = -ZMU*DH
>       DE(2) = 0.0
> *
111c109,110
< *       Update total energy loss (and H after obtaining peri).
---
> *       Increase event counter and update total energy loss.
>       NDISS = NDISS + 1
114,115c113,115
< *       Determine pericentre variables U & UDOT by backwards integration.
<       CALL KSPERI(IPAIR)
---
> *
> *       Set new energy and pericentre.
>       HI = H(IPAIR)
116a117
>       PERI1 = SEMI1*(1.0D0 - ECC1)
118,119c119,120
< *       Print first and last energy change and update indicator.
<       IF (KZ(27).EQ.1.AND.(KSTAR(I).EQ.0.OR.KSTAR(I).EQ.9)) THEN
---
> *       Print first energy change and activate indicator.
>       IF (KSTAR(I).EQ.0) THEN
121,134c122,127
<           IF (KSTAR(I).EQ.0.AND.ECC1.GT.ECCM) THEN
<               WHICH1 = 'NEW CIRC'
<               KSTAR(I) = 9
<               WRITE (6,8)  WHICH1, NAME(I1), NAME(I2), KSTAR(I1),
<      &                     KSTAR(I2), TTOT, ECC, ECC1, P, SEMI1, R1
<           ELSE IF (ECC1.LE.ECCM) THEN
<               WHICH1 = 'END CIRC'
<               KSTAR(I) = 10
<               NCIRC = NCIRC + 1
<               WRITE (6,8)  WHICH1, NAME(I1), NAME(I2), KSTAR(I1),
<      &                     KSTAR(I2), TTOT, ECC, ECC1, P, SEMI1, R1
<           END IF
<     8     FORMAT (' ',A8,'    NAM K* T E0 EF P AF R* ',
<      &                        2I6,2I4,F9.2,2F8.3,F7.1,1P,2E10.2)
---
>           if(rank.eq.0)
>      &    WRITE (6,5)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
>      &                 TIME+TOFF, ECC, ECC1, P, SEMI1, RX
>     5     FORMAT (' NEW CIRC    NAM K* T E0 EF P AF R* ',
>      &                          2I6,2I4,F9.2,2F8.3,F7.1,1P,2E10.2)
>           KSTAR(I) = 19
137,139d129
< *       Set new pericentre.
<    10 PERI1 = SEMI1*(1.0D0 - ECC1)
< *
142,149c132,133
< *
< *       Specify KS velocity scaling (conserved J, chaos or GR treatment).
<       IF (KZ(27).EQ.1) THEN
<           C2 = 1.0/C1
<       ELSE
< *       Note that PERI should not change in GR case (hence same C2).
<           C2 = SQRT((BODY(I) + H(IPAIR)*PERI1)/(BODY(I) + HI*PERI))
<       END IF
---
> *       Specify KS velocity scaling from angular momentum conservation.
>       C2 = 1.0/C1
152,155c136,137
< *     IF (ECC1.LE.ECCM) THEN
< *         AM = SEMI1*(1.0D0 - ECC1**2)
< *         C2 = SQRT(AM/AM0)/C1
< *     END IF
---
> *     AM = SEMI1*(1.0D0 - ECC1**2)
> *     IF (ECC1.LE.ECCM) C2 = SQRT(AM/AM0)/C1
159c141
<       DO 15 K = 1,4
---
>       DO 10 K = 1,4
164c146,149
<    15 CONTINUE
---
>    10 CONTINUE
> *
> *       Rectify the orbital elements.
>       CALL KSRECT(IPAIR)
170,175d154
< *       Ensure that single perturber differs from #I itself.
<           IF (NP0.EQ.0.AND.LIST(1,I1).GT.0) THEN
<               IF (LIST(2,I1).EQ.I) THEN
<                   LIST(2,I1) = IFIRST
<               END IF
<           END IF
178,197d156
< *       Ensure chaos treatment at every pericentre by perturbed motion.
<       IF (KZ(27).EQ.2.AND.LIST(1,I1).EQ.0) THEN
<           LIST(1,I1) = 1
<           LIST(2,I1) = N
<           NP0 = 1
<       END IF
< *
< *       Copy perturber list to JPERT and predict perturbers.
<       NNB = LIST(1,I1)
<       DO 16 L = 1,NNB
<           JPERT(L) = LIST(L+1,I1)
<           J = LIST(L+1,I1)
<           CALL XVPRED(J,0)
<    16 CONTINUE
< *
< *       Evaluate potential energy of perturbers.
<       JLIST(1) = I1
<       JLIST(2) = I2
<       CALL NBPOT(2,NNB,POT1)
< *
200c159
<       IF (NP0.GT.0.OR.ECC.LE.ECCM) THEN
---
>       IF (NP0.GT.0) THEN
206,221d164
< *       Obtain potential energy wrt new binary and apply tidal correction.
<       CALL NBPOT(2,NNB,POT2)
<       DP = POT2 - POT1
<       ECOLL = ECOLL + DP
< *
< *       Produce diagnostic output for interesting new case (first time).
<       IF (ECC.GT.0.99.AND.ABS(ECC - ECC1).GT.0.01.AND.IONE.EQ.0) THEN
<           WRITE (6,20)  NAME(I1), NAME(I2), SEMI1, ECC, ECC1, HI,
<      &                  QPERI, DH, DP
<    20     FORMAT (' NEW KSTIDE    NAM AF E0 EF HI QP DH DP ',
<      &                            2I5,1P,E10.2,0P,2F8.3,F9.1,1P,3E10.2)
<           TTIDE = TIME + TOFF
<           IONE = IONE + 1
<       END IF
<       IF (TIME + TOFF.GT.TTIDE + DTADJ) IONE = 0
< *
223c166
<       IF (KZ(27).EQ.2.AND.ECC.GT.0.95.AND.HI.LT.0.0) THEN
---
>       IF (ECC.GT.0.99.AND.HI.LT.0.0) THEN
233c176
<                   RDOT = RDOT + (X(K,I) - X(K,J))*(XDOT(K,I) -XDOT(K,J))
---
>                   RDOT = (X(K,I) - X(K,J))*(XDOT(K,I) - XDOT(K,J))
238c181
<               IF (1.0/A1.GT.0.1/SEMI) THEN
---
>               IF (1.0/A1.GT.0.5/RMIN) THEN
244,250c187,191
<                   ICIRC = -1
<                   JCOMP = J
<                   CALL INDUCE(IPAIR,EMAX,EMIN,ICIRC,TC,ANGLE,TG,EDAV)
<                   WRITE (6,28)  NAME(J), H(IPAIR), SEMI, A1, RP, EDAV,
<      &                          SQRT(ECC2), EMAX, SR
<    28             FORMAT (' HIERARCHY    NMJ H A0 A1 RP EDAV E1 EX SR ',
<      &                                   I6,F7.0,1P,4E9.1,0P,2F8.4,F6.1)
---
>                   if(rank.eq.0)
>      &            WRITE (6,28)  IPAIR, H(IPAIR), SEMI, A1, RP,
>      &                          SQRT(ECC2), SR
>    28             FORMAT (' HIERARCHY:    IPAIR H A0 A1 RP E1 SR ',
>      &                                    I4,F7.0,1P,3E9.1,0P,F6.2,F6.1)
255c196
< *       Set one unperturbed period for small apocentre perturbation (#27=1).
---
> *       Specify one unperturbed period for small apocentre perturbation.
257c198
<       IF (GA.LT.GMIN.AND.KZ(27).EQ.1) THEN
---
>       IF (GA.LT.GMIN.AND.SEMI1.GT.0.0) THEN
262c203
< *       Ensure T'' = 0 for pericentre test in KSINT & dissipation in UNPERT.
---
> *       Ensure T'' = 0 for pericentre test in KSINT and disspation in UNPERT.
270,273c211,215
<           QPS = QPERI/R1
<           WRITE (6,35)  TIME+TOFF, NAME(I1), NAME(I2), ECC, ECC1,QPS
<    35     FORMAT (' NEW CAPTURE    T NM EF QP E EF QP/R* ',
<      &                             F9.2,2I6,F9.4,F6.2,1P,E10.2)
---
>           QPS = QPERI/MAX(RADIUS(I1),RADIUS(I2))
>           if(rank.eq.0)
>      &    WRITE (6,35)  TIME+TOFF, NAME(I1), NAME(I2), ECC, ECC1, QPS
>    35     FORMAT (' NEW CAPTURE    T NM E EF QP/R*  ',
>      &                             F9.2,2I6,F9.4,2F6.2)
277c219
<       IF (ECC.GT.ECCM.AND.ECC1.LT.ECCM.AND.KZ(27).LE.2) THEN
---
>       IF (ECC.GT.ECCM.AND.ECC1.LE.ECCM.AND.KSTAR(I).NE.20) THEN
280,296c222,233
<           KSTAR(I) = 10
< *         WRITE (6,38)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2), SEMI1,
< *    &                  ECC, ECC1, HI, QPERI, R1
< *  38     FORMAT (' CIRCULARIZED    NAM K* AF E0 EF HI QP R* ',
< *    &                         2I6,2I3,1P,E10.2,0P,2F8.3,F9.1,1P,2E10.2)
< *       Check time interval until Roche overflow.
<           IF (KZ(34).GT.0) THEN
<               CALL TRFLOW(IPAIR,DTR)
<               TEV(I) = TIME + DTR
< *       Update TEV but leave ROCHE call for treatment in MDOT (16/08/2006). 
< *             IF (DTR.LT.STEP(I1)) THEN
< *                 CALL ROCHE(IPAIR)
< *                 GO TO 50
< *             END IF
<           END IF
<       END IF
< *
---
>           KSTAR(I) = 20
> *       Set look-up time and use KZ(34) to prevent large value in MDOT.
>           TEV(I) = TIME
>           KZ(34) = 1
>           SEMI2 = -0.5*BODY(I)/H(IPAIR)
>           P = DAYS*SEMI2*SQRT(SEMI2/BODY(I))
>           if(rank.eq.0)
>      &    WRITE (6,40)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
>      &                  TIME+TOFF, ECC, ECC1, P, SEMI1, RX
>    40     FORMAT (' END CIRC    NAM K* T E0 EF P AF R* ',
>      &                          2I6,2I4,F9.2,2F8.3,F7.1,1P,2E10.2)
>       ELSE
298,312c235,240
<       RCOLL = 0.75*(RADIUS(I1) + RADIUS(I2))
<       IF (ABS(SEMI1).LT.1.5*RCOLL.AND.ECC.LT.ECCM.AND.
<      &    KSTAR(I).LT.10) THEN
<           KSTAR(I) = 10
<           WRITE (6,40)  ECC1, SEMI1, R(IPAIR), RCOLL, R1
<    40     FORMAT (' INACTIVE PHASE    E A R RC R* ',F7.3,1P,4E10.2)
< *       Check time interval until Roche overflow.
<           IF (KZ(34).GT.0) THEN
<               CALL TRFLOW(IPAIR,DTR)
<               TEV(I) = TIME + DTR
< *       Update TEV but leave ROCHE call for treatment in MDOT (16/08/2006). 
< *             IF (DTR.LT.STEP(I1)) THEN
< *                 CALL ROCHE(IPAIR)
< *                 GO TO 50
< *             END IF
---
>           RCOLL = 0.75*(RADIUS(I1) + RADIUS(I2))
>           IF (ABS(SEMI1).LT.1.5*RCOLL.AND.ECC.LT.ECCM) THEN
>               KSTAR(I) = 20
>               if(rank.eq.0)
>      &        WRITE (6,45)  ECC1, SEMI1, R(IPAIR), RCOLL
>    45         FORMAT (' INACTIVE PHASE    E A R RCOLL ',F7.3,1P,3E9.1)
316c244
< *       Include warning in case of eccentricity increase (PT only).
---
> *       Include warning if new eccentricity exceeds old value.
318,348c246,251
<       IF (KZ(27).EQ.1.AND.ECC2.GT.MAX(ECC,ECCM)+1.0D-04) THEN
<           WRITE (6,42)  TTOT, IPAIR, ECC2, ECC, R(IPAIR), SEMI1
<    42     FORMAT (' WARNING!    E > E0    T IP E E0 R A ',
<      &                                    F10.4,I4,2F8.4,1P,2E10.2)
<       END IF
< *
< *       Reduce radius by DR/R to delay dissipation for small energy loss.
<       IF (KZ(27).EQ.1.AND.DE(1)+DE(2).LT.1.0D-07*ZMU*ABS(HI)) THEN
<           J1 = I1
<           IF (RADIUS(I2).GT.RADIUS(I1)) J1 = I2
< ***       IF (TEV(J1) - TIME.GT.0.01*TEV(J1)) TEV(J1) = TIME
<           DR = (0.99*4.0*RADIUS(J1) - QPERI)/QPERI
<           YF = MAX(ABS(DR),0.01D0)
<           RADIUS(J1) = (1.0 - MIN(YF,0.1D0))*RADIUS(J1)
<           DE1 = (DE(1) + DE(2))/(ZMU*ABS(H(IPAIR)))
<           WRITE (6,44)  TTOT, KSTAR(J1), H(IPAIR), QPERI, DR, DE1
<    44     FORMAT (' REDUCED RADIUS    T K* H QP DR/R DE/E ',
<      &                                F9.2,I3,F10.1,1P,3E9.1)
<       END IF
< *
< *       Combine the two stars inelastically in case of chaos disruption.
<    45 IF (KZ(27).EQ.2.AND.IDIS.GT.0) THEN
<           WRITE (6,48) TTOT, IPAIR, LIST(1,I1), ECC, SEMI, QPERI,
<      &                 RADIUS(I1), RADIUS(I2)
<    48     FORMAT (' DISRUPTED CHAOS    T KS NP E A QP R* ',
<      &                                 F9.2,2I4,F8.4,1P,4E10.2)
<           CALL KSPERI(IPAIR)
<           CALL XVPRED(I,0)
<           KSPAIR = IPAIR
<           IQCOLL = 1
<           CALL CMBODY(R(IPAIR),2)
---
>       IF (ECC2.GT.MAX(ECC,ECCM)) THEN
>           if(rank.eq.0)
>      &    WRITE (12,48)  TIME+TOFF, IPAIR, ECC2, ECC, R(IPAIR), SEMI1
>    48     FORMAT (' WARNING!    E > E0    T IP E E0 R A ',
>      &                                    F9.3,I4,2F8.4,1P,2E9.1)
>           CALL FLUSH(12)
353a257
> 
1,2c1,2
< 3861 2006-02-06 11:34 /work/Umi2/spurzem/5/nbody6compare-oct2006/lagr.f
< nbody6compare-oct2006/lagr.f
---
> 6730 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/lagr.f
> nbody6++compare/lagr.f
0a1,4
> # 1 "lagr.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "lagr.F"
4,5c8,9
< *       Lagrangian radii.
< *       -----------------
---
> * Lagrangian radii.
> * -----------------
8,15c12,23
<       REAL*8 R2,MRT,RT
<       COMMON/WORK1/ R2(NMAX)
<       PARAMETER (LX=11)
<       REAL*8 C(3),FLAGR(LX),RLAGR(LX),RM(LX),DENS(LX),VR(LX)
< *     DATA FLAGR/-1.9,-1.7,-1.5,-1.3,-1.1,-.9,-.7,-.5,-.3,-.1/
< *     DATA FLAGR/0.001,0.002,0.005,0.01,0.02,0.05,0.1,0.2,0.3,0.4,0.5,
< *    &           0.75,0.9/
<       DATA FLAGR/0.01,0.02,0.05,0.1,0.2,0.3,0.4,0.5,0.625,0.75,0.9/
---
>       INTEGER NPARTC(11), NCORE
>       REAL*8 R2(NMAX),RSNGL(NMAX),RBIN(NMAX)
>       REAL*8 C(3), FLAGR(11), RLAGR(11), AVMASS(11), AVMRC,VROTC
>       REAL*8 RSLAGR(11),RBLAGR(11),SIGR2(11),SIGT2(11),VROT(11)
>       INTEGER ISLIST(NMAX),IBLIST(NMAX)
>       LOGICAL FIRST
>       SAVE FIRST
>       DATA FIRST /.TRUE./
> *
> * Lagrangian radii at 1,2,5,7.5,10,15,20,50,70,90,100 % of total mass.
>       DATA FLAGR/0.01,0.02,0.05,0.10,0.20,0.30,0.40,0.50,0.70,0.90,1.00/
> * correspond to: 1%, 2% , 5% , 10%, 20%, 30%, 40%, 50%, 70%, 90%, 100%
16a25,26
> * All quantities refer to initial mass/particle distribution
>       IF(FIRST) ZMASS0 = ZMASS
18c28
< *       Set square radii of single particles & c.m. bodies.
---
> * Set square radii of all single particles & c.m. bodies.
20c30
<       DO 10 I = IFIRST,NTOT
---
>       DO 10 I = 1,N
23c33
<      &                                  (X(3,I) - C(3))**2
---
>      & (X(3,I) - C(3))**2
26,27c36
< *
< *       Sort square distances with respect to the centre C.
---
> * Sort square distances with respect to the centre C.
29,59c38,48
< 
< *       Determine Lagrangian radii for specified mass fractions.
<       ZM = 0.0
<       DO 20 IL = 1,LX
<           ZM1 = ZM
<           ZM = 0.0
<           ZMH = FLAGR(IL)*ZMASS
<           VM2 = 0.0
<           IF (IL.GT.1) THEN
<               R1 = SQRT(R2(I))
<           ELSE
<               R1 = 0.0
<           END IF
<           I = 0
<    15     I = I + 1
<           IM = JLIST(I)
<           ZM = ZM + BODY(IM)
< *       Sum mass-weighted square velocity in current shell.
<           IF (ZM.GT.ZM1) THEN
<               VM2 = VM2 + BODY(IM)*(XDOT(1,IM)**2 + XDOT(2,IM)**2 +
<      &                                              XDOT(3,IM)**2)
<           END IF
<           IF (ZM.LT.ZMH) GO TO 15
<           RLAGR(IL) = SQRT(R2(I))
<           IF (KZ(7).LT.5) GO TO 20
< *       Form mean square velocity and density (print outer shell radii).
<           DM = ZM - ZM1
<           IF (ABS(DM).LT.1.0D-10) THEN
<               VR(IL) = 0.0
<           ELSE
<               VR(IL) = SQRT(VM2/DM)
---
> *
> * Set square radii of singles and binaries for primordial binaries
>       IF (KZ(8).GT.0 .OR. NBIN0.GT.0) THEN
> *
>           IF (FIRST) THEN
>           ZMB0 = 0.0D0
>           ZMS0 = 0.0D0
>               DO 101 I = IFIRST,N
>  101 ZMS0 = ZMS0 + BODY(I)
>               DO 102 I = N+1,NTOT
>  102 ZMB0 = ZMB0 + BODY(I)
61,65d49
<           DV = 2.0*TWOPI/3.0*(R2(I)**1.5 - R1**3)
<           DENS(IL) = DM/DV
<           IF (DENS(IL).LE.0.0D0) DENS(IL) = 1.0
<           RM(IL) = 0.5*(R1 + RLAGR(IL))
<    20 CONTINUE
67c51,157
< *       Obtain half-mass radius separately.
---
>           NSNGL = 0
>           DO 103 I = IFIRST,N
>               NSNGL = NSNGL + 1
>               RSNGL(NSNGL) = (X(1,I) - C(1))**2 + (X(2,I) - C(2))**2 +
>      & (X(3,I) - C(3))**2
>               ISLIST(NSNGL) = I
>  103 CONTINUE
> * Sort square distances with respect to the centre C.
>       CALL SORT1(NSNGL,RSNGL,ISLIST)
> *
>           NBIN = 0
>           DO 104 I = N+1, NTOT
>               NBIN = NBIN + 1
>               RBIN(NBIN) = (X(1,I) - C(1))**2 + (X(2,I) - C(2))**2 +
>      & (X(3,I) - C(3))**2
>               IBLIST(NBIN) = I
>  104 CONTINUE
> * Sort square distances with respect to the centre C.
>       CALL SORT1(NBIN,RBIN,IBLIST)
> *
>       END IF
> *
> * Determine the Lagrangian radii for specified mass fractions.
> * RLAGR = Lagrangian radius
> * AVMASS = average mass of a spherical shell with radius R2(I)
> * AVMRC = average mass inside of core radius RC
> * NPARTC = particle counter within a shell
> * NCORE = particle counter for the core
> * RC = Core radius (calculated in core.f)
>       SIGR2C = 0.0D0
>       SIGT2C = 0.0D0
>       VROTC = 0.0D0
>       AVMRC = 0.D0
>       RC2 = RC*RC
>       NCORE = 0
>       ZM = 0.0D0
>       ZMH = 0.5D0*ZMASS0
>       I = 0
> *
>       DO 15 J = 1,11
>          SIGR2(J) = 0.0D0
>          SIGT2(J) = 0.0D0
>          VROT(J) = 0.0D0
>          AVMASS(J) = 0.0D0
>          NPARTC(J) = 0
> *
>  20 I = I + 1
>          IM = JLIST(I)
>          ZM = ZM + BODY(IM)
> *
>          VRI = 0.D0
>          DO 25 K = 1,3
>  25 VRI = VRI + XDOT(K,IM)*(X(K,IM)-C(K))/DSQRT(R2(I))
>          VR2I = 0.D0
>          VT2I = 0.D0
>          DO 26 K = 1,3
>          VRADK = VRI*(X(K,IM)-C(K))/DSQRT(R2(I))
>          VR2I = VR2I + VRADK**2
>  26 VT2I = VT2I + (XDOT(K,IM) - VRADK)**2
> *
>          SIGR2(J) = SIGR2(J) + BODY(IM)*VR2I
>          SIGT2(J) = SIGT2(J) + BODY(IM)*VT2I/2.D0
> *
>          RR12 = X(1,IM)**2 + X(2,IM)**2
>          XR12 = 0.D0
>          DO 27 K = 1,2
>  27 XR12 = XR12 + XDOT(K,IM)*(X(K,IM)-C(K))
> *
>          VROT1 = XDOT(1,IM) - XR12/RR12*X(1,IM)
>          VROT2 = XDOT(2,IM) - XR12/RR12*X(2,IM)
> *
>          XSIGN = VROT1*X(2,IM)/DSQRT(RR12) - VROT2*X(1,IM)/DSQRT(RR12)
>          VROTM = DSQRT(VROT1**2+VROT2**2)
> *
>          IF(XSIGN.GT.0.D0) THEN
>          VROT(J) = VROT(J) + BODY(IM)*VROTM
>          ELSE
>          VROT(J) = VROT(J) - BODY(IM)*VROTM
>          END IF
> *
>          AVMASS(J) = AVMASS(J) + BODY(IM)
>          NPARTC(J) = NPARTC(J) + 1
> *
> * Independent determination of mass in core radius.
>          IF (R2(I) .LT. RC2) THEN
>             SIGR2C = SIGR2C + BODY(IM)*VR2I
>             SIGT2C = SIGT2C + BODY(IM)*VT2I/2.D0
>             VROTC = VROTC + BODY(IM)*VROTM
>             AVMRC = AVMRC + BODY(IM)
>             NCORE = NCORE + 1
>          END IF
> *
> * Check whether mass within Langrangian radius is complete.
>          IF (I.LT.N.AND.ZM.LT.FLAGR(J)*ZMASS0) GOTO 20
> *
>          RLAGR(J) = SQRT(R2(I))
>          SIGR2(J) = SIGR2(J)/AVMASS(J)
>          SIGT2(J) = SIGT2(J)/AVMASS(J)
>          VROT(J) = VROT(J)/AVMASS(J)
>          AVMASS(J) = AVMASS(J)/NPARTC(J)
>  15 CONTINUE
>       SIGR2C = SIGR2C/AVMRC
>       SIGT2C = SIGT2C/AVMRC
>       VROTC = VROTC/AVMRC
>       AVMRC = AVMRC/NCORE
> *
> * Determine half-mass radius separately.
69c159
<       ZMH = 0.5*ZMASS
---
>       ZMH = 0.5D0*ZMASS0
71c161
<    25 I = I + 1
---
>  30 I = I + 1
74,76c164,165
<       IF (ZM.LT.ZMH) GO TO 25
< *
< *       Replace approximate half-mass radius by actual value.
---
>       IF (ZM.LT.ZMH) GO TO 30
> * Replace approximate half-mass radius by actual value.
79,99c168,171
< *       Determine tidal radius and mass if kz(14) = 2.
<       if (kz(14).eq.2.and.tidal(1).ne.0.) then
<       I = np
<       mrt = zmass
<    30 continue
<       if (mrt.gt.0.) then
<          rt = (mrt/tidal(1))**(1./3.)
<       else
<          rt = 0.0
<       endif
<       IF (sqrt(r2(i)).gt.rt.and.rt.gt.0.and.i.gt.1) then
<          IM = JLIST(I)
<          Mrt = Mrt - BODY(IM)
<          i = i - 1
<          GO TO 30
<       endif
<       endif
< 
<       IF ((KZ(7).EQ.2.OR.KZ(7).EQ.4).AND.TTOT.GE.TPRINT) THEN
<           IF (KZ(14).EQ.2) WRITE (6,*)  tphys,mrt,rt
<       END IF
---
>       IF (KZ(8).GT.0 .OR. NBIN0.GT.0) THEN
> * Determine the Lagrangian radii for singles and binaries separately.
>       ZMS = 0.0D0
>       I = 0
101,104c173,179
<       IF (KZ(7).GE.3.AND.TTOT.GE.TPRINT) THEN
<           IF (KZ(14).EQ.2) WRITE (14,*)  tphys, mrt, rt
<    35     FORMAT (3X,'TIDAL RADIUS    TPHYS MRT RT ',F8.1,1P,2E10.2)
<       END IF
---
>       DO 251 J = 1, 11
>  201 I = I + 1
>          IM = ISLIST(I)
>          ZMS = ZMS + BODY(IM)
>          IF (I.LT.N-2*NPAIRS.AND.ZMS.LT.FLAGR(J)*ZMS0) GOTO 201
>          RSLAGR(J) = SQRT(RSNGL(I))
>  251 CONTINUE
106,110c181,182
< *       Check output options (line printer or unit 7 or both).
<       IF (KZ(7).EQ.2.OR.KZ(7).EQ.4.AND.TTOT.GE.TPRINT) THEN
<           WRITE (6,40)  (LOG10(RLAGR(K)),K=1,LX)
<    40     FORMAT (/,3X,'LAGR:  ',13F7.3)
<       END IF
---
>       ZMB = 0.0D0
>       I = 0
112,116c184,190
<       IF (KZ(7).GE.3.AND.TTOT.GE.TPRINT) THEN
<           WRITE (12,50)  TTOT, (LOG10(RLAGR(K)),K=1,LX)
<    50     FORMAT ('  LAGR:  ',F7.1,13F7.3)
<           CALL FLUSH(12)
<       END IF
---
>       DO 351 J = 1, 11
>  301 I = I + 1
>          IM = IBLIST(I)
>          ZMB = ZMB + BODY(IM)
>          IF (I.LT.NPAIRS.AND.ZMB.LT.FLAGR(J)*ZMB0) GOTO 301
>          RBLAGR(J) = SQRT(RBIN(I))
>  351 CONTINUE
118,125d191
<       IF (KZ(7).EQ.5.AND.TTOT.GE.TPRINT) THEN
<           WRITE (26,60)  TTOT, (DENS(K),K=1,LX)
<    60     FORMAT ('  DENSITY (T =',F6.1,'): ',1P,13E10.2)
<           WRITE (26,65)  (RM(K),K=1,LX)
<    65     FORMAT ('  DISTANCE:  ',1P,13E10.2)
<           WRITE (27,70)  TTOT, (VR(K),K=1,LX)
<    70     FORMAT ('  VELOCITY (T =',F6.1,'): ',1P,13E10.2)
<           WRITE (27,65)  (RM(K),K=1,LX)
127a194,236
>       if(rank.eq.0)then
> * Write on diagnostics (only until r_h).
>          IF (KZ(7).EQ.2 .OR. KZ(7).EQ.4) THEN
>           WRITE (6,40) ' TIME ',(FLAGR(K),K=1,11),' <RC'
>    40 FORMAT (/,3X,A6,' M/MT:  ',1P,11(1X,D9.2),A4)
>           WRITE (6,41) TTOT, (RLAGR(K),K=1,11),RC
>    41 FORMAT (3X,F6.1,' RLAGR: ',1P,12(1X,D9.2))
> *
>          IF (KZ(8).GT.0 .OR. NBIN0.GT.0) THEN
>           WRITE (6,401) TTOT, (RSLAGR(K),K=1,11)
>   401 FORMAT (3X,F6.1,' RSLAGR: ',1P,11(1X,D9.2))
>           WRITE (6,402) TTOT, (RBLAGR(K),K=1,11)
>   402 FORMAT (3X,F6.1,' RBLAGR: ',1P,11(1X,D9.2))
>          END IF
> *
>           WRITE (6,42) TTOT, (AVMASS(K),K=1,11),AVMRC
>    42 FORMAT (3X,F6.1,' AVMASS:',1P,12(1X,D9.2))
>           WRITE (6,43) TTOT, (NPARTC(K),K=1,11),NCORE
>    43 FORMAT (3X,F6.1,' NPARTC:',12I10)
>           WRITE (6,45) TTOT, (SIGR2(K),K=1,11),SIGR2C
>    45 FORMAT (3X,F6.1,' SIGR2: ',1P,12(1X,D9.2))
>           WRITE (6,46) TTOT, (SIGT2(K),K=1,11),SIGT2C
>    46 FORMAT (3X,F6.1,' SIGT2: ',1P,12(1X,D9.2))
>           WRITE (6,47) TTOT, (VROT(K),K=1,11),VROTC
>    47 FORMAT (3X,F6.1,' VROT:  ',1P,12(1X,D9.2))
> 
> 
>          END IF
>       end if
> * Write all data in binary format on unit 7.
> *
> 
> 
> 
>          IF (KZ(7).GE.3) THEN
>             WRITE (7) TTOT, (RLAGR(K),K=1,11),
>      & (AVMASS(K),K=1,11),(NPARTC(K),K=1,11),RC,AVMRC,NCORE
>          CALL FLUSH(7)
>          END IF
> 
> 
> 
> *
1,2c1,2
< 1074 2005-02-02 13:05 /work/Umi2/spurzem/5/nbody6compare-oct2006/levels.f
< nbody6compare-oct2006/levels.f
---
> 4095 2003-06-23 21:03 /work/Umi2/spurzem/5/nbody6++compare/levels.f
> nbody6++compare/levels.f
5a6
> *       plus estimation of parallel speed-up (R.Sp.)
8c9,14
<       INTEGER  IHIST(32),IHISTR(32)
---
>       INTEGER JHIST,JHISTR,JHISTU
>       COMMON/BLKLVL/JHIST(0:NMAX),JHISTR(0:NMAX),JHISTU(0:NMAX)
>       INTEGER  IHIST(NMAX),IHISTR(NMAX),IHISTU(NMAX)
>       INTEGER IPES,IPROC(9),IY(1024),IYR(1024)
>       REAL*8 XSPEED(9),XSPEDR(9)
>       DATA IPROC/4,8,16,32,64,128,256,512,1024/
12c18
<       DO 10 J = 1,32
---
>       DO 10 J = 1,NMAX
14a21
>           IHISTU(J) = 0
18c25
<       JMAX = 0
---
>       JMAXI = 0
22d28
<           IF (BODY(I).EQ.0.0D0) GO TO 20
23a30
>           IF(J.GT.NMAX)J = NMAX
25c32
<           JMAX = MAX(J,JMAX)
---
>           JMAXI = MAX(J,JMAXI)
26a34
>           IF(J.GT.NMAX)J = NMAX
30a39,48
>       JMAXU = 0
> *       Loop over KS binaries
>       DO 25 IPAIR = 1,NPAIRS
>           I1 = 2*IPAIR - 1
>           J = 1 - LOG(STEP(I1))*FAC
>           IF(J.GT.NMAX)J = NMAX
>           IHISTU(J) = IHISTU(J) + 1
>           JMAXU = MAX(J,JMAXU)
>    25 CONTINUE
> *
32,40c50,131
<       JMAX = MIN(JMAX,27)
<       WRITE (6,30)  (IHIST(J),J=1,JMAX)
<    30 FORMAT (' #6  STEP   ',12I5,15I4)
< *
<       IF (KZ(33).GT.1) THEN
<           JMAXR = MIN(JMAXR,27)
<           WRITE (6,35)  (IHISTR(J),J=1,JMAXR)
<    35     FORMAT (' #7  STEPR  ',12I5,15I4)
<       END IF
---
>       JMAXI=MIN(JMAXI,NMAX)
>       JMAXR=MIN(JMAXR,NMAX)
>       JMAXU=MIN(JMAXU,NMAX)
>       if(rank.eq.0)then
> 	  WRITE (6,30)  (IHIST(J),J=1,JMAXI)
>    30 FORMAT (' STEP I ',22I5,(/,24I5))
>       IF (KZ(33).GT.1)WRITE (6,301)  (IHISTR(J),J=1,JMAXR)
>   301 FORMAT (' STEP R ',50I5,(/,24I5))
>       IF (KZ(8).GT.0 .OR. NBIN0.GT.0 )WRITE (6,3001)
>      *     (IHISTU(J),J=1,JMAXU)
>  3001 FORMAT (' STEP U ',50I5,(/,24I5))
>       end if
> *
> *       IPROC contains a list of possible processor numbers,
> *       presently   4 to 1024 in powers of 2.
> *
>       DO 35 NN = 1,9
>       IPES = IPROC(NN)
>       DO 36 I = 1,IPES
>       IY(I) = 0
>  36   IYR(I) = 0
> *
> *       JHIST contains accumulated frequencies from INTGRT for irr. steps. 
> *       JHIST(80) = 5 e.g. means that it occurred 5 times since the last
> *                   call of LEVELS that 80 force calculations had
> *                   to be done in parallel
> *       IY maps this information to a certain number of processors,
> *       e.g. in the above case for 64 processors it would mean that
> *       five times 64 processors could be fully used, and five times
> *       only 16 processors (to get the remaining forces).
> *       JHIST(80) = 5 results in incrementing IY(64) and IY(16) by 5.
> *
> *       (IYE, JHISTR do the same for the regular steps)
> *
>       DO 37 I = 1,NMAX
>       IF(JHIST(I).EQ.0)GOTO 37
>       J = MOD(I,IPES)
>       K = I/IPES
>       IF(J.GT.0)IY(J)=IY(J)+JHIST(I)
>       IF(K.GT.0)IY(IPES)=IY(IPES)+K*JHIST(I)
>  37   CONTINUE
> *
>       DO 371 I = 1,NMAX
>       IF(JHISTR(I).EQ.0)GOTO 371
>       J = MOD(I,IPES)
>       K = I/IPES
>       IF(J.GT.0)IYR(J)=IYR(J)+JHISTR(I)
>       IF(K.GT.0)IYR(IPES)=IYR(IPES)+K*JHISTR(I)
>  371  CONTINUE
> *
>       ISPEED = 0
>       ISPEDR = 0
>       ITOT = 0
>       ITOTR = 0
>       DO 38 I = 1,IPES
>       ISPEED = ISPEED + I*IY(I)
>       ISPEDR = ISPEDR + I*IYR(I)
>       ITOT = ITOT + IY(I)
>       ITOTR = ITOTR + IYR(I)
>  38   CONTINUE
> *
> *       Estimate theoretical speedup by (sum I*IY) / (sum IY);
> *       enumerator is the total number of force calculations necessary;
> *       denominator is the number of force calculation `cycles' necessary
> *       on a parallel machine. Separately done for regular/irregular
> *       steps. Communication not yet included in any way.
> *
>       IF(ITOT.NE.0)XSPEED(NN) = REAL(ISPEED)/REAL(ITOT)
>       IF(ITOTR.NE.0)XSPEDR(NN) = REAL(ISPEDR)/REAL(ITOTR)
>  35   CONTINUE
> *
> 	  if(rank.eq.0)then
>       WRITE (6,40)  (IPROC(J),XSPEED(J),J=1,9)
>  40   FORMAT (' Max Speedup Irr: ',1P,9(I5,D9.2))
>       WRITE (6,41)  (IPROC(J),XSPEDR(J),J=1,9)
>  41   FORMAT (' Max Speedup Reg: ',1P,9(I5,D9.2))
>       end if
> *
>       DO 50 J = 1,NMAX
>           JHIST(J) = 0
>           JHISTR(J) = 0
>    50 CONTINUE
1,2c1,2
< 443 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/matrix.f
< nbody6compare-oct2006/matrix.f
---
> 443 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/matrix.f
> nbody6++compare/matrix.f
1,2c1,2
< 43707 2006-09-20 13:35 /work/Umi2/spurzem/5/nbody6compare-oct2006/mdot.f
< nbody6compare-oct2006/mdot.f
---
> 19504 2006-06-18 08:32 /work/Umi2/spurzem/5/nbody6++compare/mdot.f
> nbody6++compare/mdot.f
5d4
< *       Updated 6/1/98 by J. Hurley
9,35c8,12
<       COMMON/BINARY/  BM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAGM(MMAX)
<       COMMON/MODES/  EB0(NTMAX),ZJ0(NTMAX),ECRIT(NTMAX),AR(NTMAX),
<      &               BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
<      &               RP(NTMAX),ES(NTMAX),CM(2,NTMAX),IOSC(NTMAX),
<      &               NAMEC(NTMAX)
<       INTEGER JX(2),KACC
<       REAL*8 MASS(2),MASSC(2),RAD(2),RADC(2),LUMIN(2)
<       REAL*8 AGE0(2),TM0(2),TBGB(2),MENV(2),RENV(2),K2STR(2)
<       REAL*8 TSCLS(20),LUMS(10),GB(10),TM,TN
<       REAL*8 M0,M1,RM,AGE,LUM,MC,RCC,ME,RE,RNEW,LNEW,MCH
<       PARAMETER (MCH=1.44d0)
<       REAL*8 M10,RXL1,RXL2,Q,ROL(2),RLPERI,RM0
<       REAL*8 EPS,ALPHA2,TOL,TINY
<       PARAMETER(EPS=1.0d-06,ALPHA2=0.09d0,TOL=1.0d-10,TINY=1.0d-14)
<       REAL*8 DTX(2),DMS(2),DMA(2),DMX(2),EPCH0(2),TEVK,DIFF
<       REAL*8 DT,DSEP,DJMB,DJGR,DJORB,DJT,DJTI,DTGR,DSPIN,JSPBRU,OSPBRU
<       REAL*8 RJ,HJ,TJ2,VORB2,VWIND2,IVSQM,OMV2,DTXMIN,DMXMAX,DELET
<       REAL*8 JSPIN(2),OSPIN(2),DJSPIN(2),JORB,OORB,AURSUN
<       PARAMETER(AURSUN=214.95d0)
<       REAL*8 RAA2,RAA6,RG2,TCQR,TC,FC
<       REAL*8 K2,K3,ACC1,ACC2,BETA,XI
<       PARAMETER(K3=0.21d0,ACC1=3.920659d+08,ACC2=1.5d0)
<       PARAMETER(BETA=0.125d0,XI=1.d0,MAXBLK=40)
<       REAL*8 MLWIND,RL
<       EXTERNAL MLWIND,RL
---
>       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       REAL*8  LUMS(10),TSCLS(20),GB(10)
>       REAL*8  M0,M1,LUM,MC,M10,MLWIND
37a15,17
>       SAVE NWARN
>       DATA NWARN /0/
>       EXTERNAL MLWIND
39c19,20
< *       Define current time (unit of million years) and update counter.
---
> *
> *       Define current time (unit of million years).
44d24
<       IBLUE = 0
48d27
<       KSPAIR = 0
50d28
<       ITRY = 0
52d29
<       I0 = 0
56d32
< *       Restore synchronized TIME in case of RESET, CHRECT & KSPERI.
58c34
<       DO 5 J = 1,NTOT
---
>       DO 10 J = 1,NTOT
61c37
<               GO TO 10
---
>               GO TO 20
63c39
<     5 CONTINUE
---
>    10 CONTINUE
67d42
<       I = 1
70,118c45,49
< *       Include braking or merger termination at time for Roche overflow.
<    10 IF (I.GT.N.AND.NAME(I).LT.0.AND.KZ(34).NE.0) THEN
<           KSPAIR = I - N
<           CALL BRAKE2(KSPAIR,ITERM)
<           IF(ITERM.GT.0)THEN
<              NWARN = NWARN + 1
<              IF (NWARN.LT.1000) THEN
<                  WRITE(14,900) KSPAIR, NAME(I), TTOT, R(KSPAIR)
<  900             FORMAT(' MDOT MERGER TERM:    KS NAM T R ',
<      &                                         I4,I6,F10.4,1P,E10.2)
<                  CALL FLUSH(14)
<              END IF
<              JCOMP = 0
<              IPHASE = 7
<              CALL RESET
<           ENDIF
<           GO TO 1
<       END IF
< *
< *       Check possible Roche overflow condition (skip any ghost c.m.).
<       IF (I.GT.N.AND.KZ(34).GT.0.AND.BODY(I).GT.0.0D0.AND.
<      &    KSTAR(I).GT.0) THEN
<           IPAIR = I - N
< *       Consider odd types (11, 13, etc.) for Roche updating or treatment.
<           IF (MOD(KSTAR(I),2).NE.0) THEN
<               CALL ROCHE(IPAIR)
<               IF (IQCOLL.NE.0.OR.IPHASE.LT.0) GO TO 1
< *       Ensure that look-up time is increased in case of no mass transfer.
<               IF (TEV(I).LE.TIME) THEN
<                  IF (MOD(KSTAR(I),2).NE.0) KSTAR(I) = KSTAR(I) + 1
<                  CALL TRFLOW(IPAIR,DTR)
<                  TEV(I) = TIME + DTR
<                  WRITE(6,902)I,NAME(I),IPAIR,KSTAR(I),TEV(I),TTOT
<  902             FORMAT(' WARNING   MDOT NO ROCHE ',3i6,i4,1x,1p,2e13.4)
<               ENDIF
<           ELSE
< *       Include other cases (even types outside 10 R_sun).
<               CALL TRFLOW(IPAIR,DTR)
<               IF (DTR.LT.STEP(I)) THEN
<                   TEV(I) = TIME + DTR
<                   CALL ROCHE(IPAIR)
<                   IF (TEV(I).LE.TIME) TEV(I) = 1.000002d0*TIME
<               ELSE
<                   IF(KZ(11).EQ.1)THEN
<                       CALL SYNCH(IPAIR)
<                   ELSE
<                       TEV(I) = TIME + DTR
<                   ENDIF
<               END IF
---
> *       Skip possible c.m. of compact subsystem or zero mass ghost.
>    20 IF (NSUB.GT.0) THEN
>           IF (BODY(I).GT.BODY1.OR.NAME(I).EQ.0.OR.BODY(I).LE.0.0) THEN
>               TEV(I) = TEV(I) + 0.01*TCR
>               GO TO 1
120d50
<           GO TO 1
127,129d56
<           I2 = 2*KSPAIR
<           IF(I2.EQ.I) I2 = I2 - 1
< *
144,162d70
< *
< *       Include Roche consistency check (single components not permitted).
<           IF (KSTAR(ICM).GT.10.AND.MOD(KSTAR(ICM),2).EQ.1) THEN
<               IF(BODY(I).EQ.0.0.OR.BODY(I2).EQ.0.0)THEN
<                  TEV(I) = TIME + MIN(0.1D0,TEV(I)-TEV0(I))
<                  TEV(I2) = TEV(I)
<                  GOTO 1
<               ENDIF
<               WRITE(6,904) I, KSTAR(ICM), TEV(I) - TEV(ICM)
<  904          FORMAT(' WARNING!    MDOT    I K* D(TEV) ',2I5,1P,E9.1)
<               CALL TRFLOW(KSPAIR,DTR)
<               TEV(ICM) = TIME + DTR
<               IF (DTR.GT.TSTAR) THEN
<                  KSTAR(ICM) = KSTAR(ICM) + 1
<               ELSE
<                  TEV(I) = 1.000002d0*TIME
<                  GO TO 1
<               END IF
<           END IF
171,175d78
<           IF(IGHOST.LT.0)THEN
<              WRITE(6,*)' MDOT GHOST NOT FOUND ',I,NAME(I),IMERGE
<              STOP
<           ENDIF
< *
179,182d81
<               IF (I.EQ.IGHOST) WRITE(6,906) I, NAME(I), KSTAR(I),
<      &                                      TEV(I), BODY(I)
<  906          FORMAT(' GHOST SWITCH:    I NAM K* TEV BODY ',
<      &                                   3I5,F9.2,1P,E10.2)
195,200c94,101
<                   WRITE(6,908) IGHOST, I0, I, NAME(I), KSTAR(I), TEV(I)
<  908              FORMAT(' OUTER GHOST:    IG I0 I NM K* TEV',5I6,F9.2)
<                   IF(KSTAR(N+KSPAIR).GE.10) THEN
<                      CALL RESET
<                      GOTO 1
<                   ENDIF
---
>                   if(rank.eq.0)
>      &            WRITE (6,22)  IGHOST, I0, I, NAME(I), KSTAR(I), TEV(I)
>    22             FORMAT (' OUTER GHOST:    IG I0 I NM K* TEV',5I5,F9.2)
>                   IF (KSTAR(N+KSPAIR).GE.10) THEN
>                       IPHASE = 7
>                       CALL RESET
>                       GO TO 1
>                   END IF
212c113
<           DO 15 K = 1,NMERGE
---
>           DO 24 K = 1,NMERGE
214c115
<    15     CONTINUE
---
>    24     CONTINUE
216c117
<               DO 20 K = N+1,NTOT
---
>               DO 25 K = N+1,NTOT
218c119
<    20         CONTINUE
---
>    25         CONTINUE
220,226d120
<               if(icm.eq.0) kspair = j - n
< *       Terminate if ghost belongs to double hierarchy (bug fix 03/2001).
<               IF (NAMEM(IMERGE).LT.-2*NZERO) THEN
<                   IPHASE = 7
<                   CALL RESET
<                   GO TO 1
<               END IF
242,246c136
<               TEV(I) = TEV(I) + 0.01d0
< *       Allow an extra amount for MS stars (depending on TEV - TEV0).
<               IF(KSTAR(I).LE.1.AND.(TEV(I)-TEV0(I))*TSTAR.LT.10.0)THEN
<                   TEV(I) = TEV(I) + 0.5*(TEV(I) - TEV0(I))
<               END IF
---
>               TEV(I) = TEV(I) + 0.01
253c143,144
<           I1 = 2*(I - N) - 1
---
>           IPAIR = I - N
>           I1 = 2*IPAIR - 1
256,263c147,157
<           IF(KSTAR(I).GT.0)THEN
<              WRITE(6,910) I, NAME(I), KSTAR(I1), KSTAR(I2), KSTAR(I),
<      &                    TTOT, TM - TEV(I)
<  910         FORMAT(' WARNING!    MDOT:    I NAM K* T D(TEV) ',
<      &                            2I6,3I4,F9.2,1P,E10.2)
<           ENDIF
<           IF (KSTAR(I).LT.10) THEN
<               TEV(I) = 1.0d+10
---
>           NWARN = NWARN + 1
>           IF (NWARN.LT.100) THEN
>               if(rank.eq.0)
>      &        WRITE (6,30)  I, NAME(I), KSTAR(I1), KSTAR(I2), KSTAR(I),
>      &                      TTOT, TM - TEV(I)
>    30         FORMAT (' WARNING!    MDOT:    I NAM K* T D(TEV) ',
>      &                              2I6,3I4,F9.2,1P,E10.2)
>           END IF
>           SEMI = -0.5*BODY(I)/H(IPAIR)
>           IF (KZ(28).GT.0.AND.SEMI*SU.LT.10.0) THEN
>               TEV(I) = TIME + 1.0/TSCALE
265,267c159
<               IPAIR = I - N
<               CALL TRFLOW(IPAIR,DTR)
<               TEV(I) = MAX(TIME + DTR,1.000002d0*TIME)
---
>               TEV(I) = 1.0E+10
271a164,168
> *       Set the initial mass and current type.
>       NMDOT = NMDOT + 1
>       M0 = BODY0(I)*ZMBAR
>       KW = KSTAR(I)
> *
273,289c170,171
< *       Also determine if the star is in a standard binary or is the inner
< *       component of a hierachy and if so set the mass accretion flag.
<       KACC = 0
<       JX(1) = I
<       ECC2 = 0.D0
<       IF(IGHOST.EQ.0.AND.IHDOT.EQ.0)THEN
<          MASS(1) = BODY(I)*ZMBAR
<          IF(I.LT.IFIRST)THEN
<             IF(NAME(ICM).GT.0)THEN
<                KACC = 1
<                JX(2) = I2
<                MASS(2) = BODY(I2)*ZMBAR
<                RJ = R(KSPAIR)
<                HJ = H(KSPAIR)
<                TJ2 = TDOT2(KSPAIR)
<             ENDIF
<          ENDIF
---
>       IF (IGHOST.EQ.0.AND.IHDOT.EQ.0) THEN
>           M1 = BODY(I)*ZMBAR
291,312c173,180
<          IF(IHDOT.EQ.1)THEN
<             K = 1
<             IF (I.GE.IFIRST) K = 2
<             IF(I.NE.2*KSPAIR)THEN
<                KACC = 2
<                J = 3 - K
<                JX(2) = IGHOST
<                IF(K.EQ.2) JX(2) = 2*KSPAIR - 1
<                MASS(2) = BM(J,IMERGE)*ZMBAR
<                RJ = 0.d0
<                TJ2 = 0.d0
<                DO 25 II = 1,4
<                   RJ = RJ + UM(II,IMERGE)*UM(II,IMERGE)
<                   TJ2 = TJ2 + 2.d0*UM(II,IMERGE)*UMDOT(II,IMERGE)
<   25           CONTINUE
<                HJ = HM(IMERGE)
<             ENDIF
<          ELSE
<             K = 3
<             IF (I.EQ.2*JPAIR) K = 4
<          END IF
<          MASS(1) = BM(K,IMERGE)*ZMBAR
---
>           IF (IHDOT.EQ.1) THEN
>               K = 1
>               IF (I.GE.IFIRST) K = 2
>           ELSE
>               K = 3
>               IF (I.EQ.2*JPAIR) K = 4
>           END IF
>           M1 = CM(K,IMERGE)*ZMBAR
314,367c182
<       IF(KACC.GT.0)THEN
<          J = N + KSPAIR
< *       Check for zero c.m. mass (i.e. NAME < 0 & > -NZERO in [[B,S],[B,S]]).
<          IF (BODY(J).EQ.0.0D0) THEN
<              IPHASE = 7
<              CALL RESET
<              GO TO 1
<          END IF
<          SEMI = -0.5d0*BODY(J)/HJ
<          SEP = SEMI*SU
<          ECC2 = (1.d0 - RJ/SEMI)**2 + TJ2**2/(BODY(J)*SEMI)
<          IF(ECC2.LT.1.0)THEN
<             KACC = 2
<             Q = MASS(1)/MASS(2)
<             ROL(1) = RL(Q)*SEP
<             RXL1 = RADIUS(JX(1))/ROL(1)
<             Q = 1.d0/Q
<             ROL(2) = RL(Q)*SEP
<             RXL2 = RADIUS(JX(2))/ROL(2)
<             IF(RXL2.GT.RXL1)THEN
<                J1 = JX(1)
<                JX(1) = JX(2)
<                JX(2) = J1
<                M10 = MASS(1)
<                MASS(1) = MASS(2)
<                MASS(2) = M10
<                RXL1 = ROL(1)
<                ROL(1) = ROL(2)
<                ROL(2) = RXL1
<             ENDIF
<             VORB2 = ACC1*(MASS(1)+MASS(2))/SEP
<             IVSQM = 1.D0/SQRT(1.D0-ECC2)
<             DIFF = ABS(TEV0(JX(2)) - TEV0(JX(1)))
<             IF(DIFF.GT.TOL)THEN
<                TEV(JX(1)) = MAX(TEV0(JX(1)),TEV0(JX(2)))
<             ELSE
<                TEV0(JX(2)) = TEV0(JX(1))
<                IF(TEV(JX(2)).NE.TEV(JX(1)))THEN
<                   TEV(JX(1)) = MIN(TEV(JX(1)),TEV(JX(2)))
<                ENDIF
<             ENDIF
<             TEV(JX(2)) = TEV(JX(1))
<             ECC = SQRT(ECC2)
<             OORB = TWOPI*SQRT((MASS(1)+MASS(2))/(SEP/AURSUN)**3)
<             JORB = MASS(1)*MASS(2)/(MASS(1)+MASS(2))
<      &             *SQRT(1.D0-ECC2)*SEP*SEP*OORB
<          ELSE
<             WRITE(6,912)JX,NAME(N+KSPAIR),SQRT(ECC2),TTOT
<  912        FORMAT(' MDOT ECC2 > 1.0 I1 I2 N(ICM) e T ', 3I6,F6.2,E9.2)
<             KACC = 1
<          ENDIF
<       ELSE
<          KACC = 1
<       ENDIF
---
>       M10 = M1
369,381c184,185
<       NMDOT = NMDOT + 1
<  195  CONTINUE
< *
<       DO 200 K = 1,KACC
< *
<          I = JX(K)
< *       Set interval since last mass update.
<          DTX(K) = 1.0D+06*(TEV(I) - TEV0(I))*TSTAR
< *       Set the initial mass and current type.
<          M0 = BODY0(I)*ZMBAR
<          M1 = MASS(K)
<          MC = 0.D0
<          KW = KSTAR(I)
---
> *       Set interval for Reimers mass loss (small value on MS).
>       DT = 1.0E+06*(TEV(I) - TEV0(I))*TSTAR
384,399c188,192
<          AGE = TEV0(I)*TSTAR - EPOCH(I)
<          AGE = MAX(AGE,0.D0)
<          AGE0(K) = AGE
<          EPCH0(K) = EPOCH(I)
<          CALL star(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
<          CALL hrdiag(M0,AGE,M1,TM,TN,TSCLS,LUMS,GB,ZPARS,
<      &               RM0,LUM,KW,MC,RCC,ME,RE,K2)
<          RAD(K) = RM0
<          LUMIN(K) = LUM
<          TM0(K) = TM
<          TBGB(K) = TSCLS(1)
<          MASSC(K) = MC
<          RADC(K) = RCC
<          MENV(K) = ME
<          RENV(K) = RE
<          K2STR(K) = K2
---
>       AGE = TEV0(I)*TSTAR - EPOCH(I)
>       EPCH0 = EPOCH(I)
>       CALL STAR(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
>       CALL HRDIAG(M0,AGE,M1,TM,TN,TSCLS,LUMS,GB,ZPARS,
>      &            RM,LUM,KW,MC,RCC)
402,570c195,209
<          IF(KW.NE.KSTAR(I))THEN
<             KW = KSTAR(I)
<             M1 = MASS(K)
<          ENDIF
< *
< *       Evaluate mass loss due to stellar wind.
<          RLPERI = 0.D0
<          IF(KACC.GT.1) RLPERI = ROL(K)*(1.D0 - ECC)
<          DMX(K) = MLWIND(KW,LUM,RM0,M1,MC,RLPERI,ZMET)
<          DMA(K) = 0.D0
< *
<          IF(KACC.GT.1)THEN
< *
< *       Calculate how much of wind mass loss will be accreted by the
< *       companion (Boffin & Jorissen, A&A 1988, 205, 155).
<             VWIND2 = 2.D0*BETA*ACC1*M1/RM0
<             OMV2 = (1.d0 + VORB2/VWIND2)**(3.D0/2.D0)
<             DMA(3-K) = IVSQM*ACC2*DMX(K)*((ACC1*MASS(3-K)/VWIND2)**2)
<      &                  /(2.D0*SEP*SEP*OMV2)
<             DMA(3-K) = MIN(DMA(3-K),0.8d0*DMX(K))
< *
<          ENDIF
< *
< *       Convert the spin angular momentum of the star to physical units.
<          JSPIN(K) = MAX(SPIN(I)*SPNFAC,1.0D-10)
< *
< *       Evaluate the spin of the star.
<          OSPIN(K) = JSPIN(K)/(K2*RM0*RM0*(M1-MC)+K3*RCC*RCC*MC)
< *
<  200  CONTINUE
< *
<       DT = DTX(1)
< *
<       DO 210 K = 1,KACC
< *
<          I = JX(K)
<          KW = KSTAR(I)
< *
< *       Check for unequal evolution times in a recently formed binary.
<          IF(K.EQ.2)THEN
<             IF(DTX(1).EQ.0.D0.OR.DTX(2).EQ.0.D0) DT = DTX(2)
<          ENDIF
< *
< *       Calculate the change in spin angular momentum due to mass loss and
< *       also due to mass accretion and/or tides if the star is in a binary.
<          DJSPIN(K) = (2.D0/3.D0)*DMX(K)*RAD(K)*RAD(K)*OSPIN(K)
< *
<          IF(KACC.GT.1)THEN
< *
<             IF(DMA(K).GT.0.D0)THEN
<                DJSPIN(K) = DJSPIN(K) - (2.d0/3.d0)*XI*DMA(K)*
<      &                     RAD(3-K)*RAD(3-K)*OSPIN(3-K)
< *
< *       Produce diagnostics for symbiotic stars.
<                IF(DMA(K).GE.3.16E-9.AND.KW.GE.10)THEN
<                   WRITE(20,913)NAME(I),NAME(JX(3-K)),KSTAR(I),
<      &                     KSTAR(JX(3-K)),TPHYS,MASS,SEP,DMX(3-K),DMA(K)
<  913              FORMAT(' WINDAC    NAM K* T M A MLOSS MACC ',
<      &                               2I6,2I4,F9.2,2F6.2,F8.1,1P,2E9.1)
<                   CALL FLUSH(20)
<                ENDIF
<             ENDIF
< *
< *       Tidal synchronisation (only operates on circular orbits).
<             Q = MASS(3-K)/MASS(K)
<             IF(K.EQ.1) DJT = 0.D0
<             IF(KZ(11).GT.1.AND.DT.GT.0.D0.AND.ECC.LE.0.01D0)THEN
<                IF((KW.LE.9.AND.RAD(K).GE.0.01D0*ROL(K)).OR.
<      &            (KW.GE.10.AND.Q.GE.1.D0))THEN
< *
<                   CALL BSETID(kw,mass(k),massc(k),menv(k),rad(k),
<      &                       radc(k),renv(k),lumin(k),ospin(k),k2str(k),
<      &                       q,sep,ecc,oorb,delet,dspin,eqspin,djti)
< *
<                   IF(ABS(DSPIN).GE.TINY)THEN
<                      DSPIN0 = DSPIN
<                      IF(DSPIN.GE.0.D0)THEN
<                         DSPIN = MIN(DT*DSPIN,OORB-OSPIN(K))/DT
<                      ELSE
<                         DSPIN = MAX(DT*DSPIN,OORB-OSPIN(K))/DT
<                      ENDIF
<                      DJTI = DJTI*DSPIN/DSPIN0
<                   ELSE
<                      DJTI = 0.D0
<                   ENDIF
<                   DJSPIN(K) = DJSPIN(K) - DJTI
<                   DJT = DJT + DJTI
< *
<                ENDIF
<             ENDIF
<          ENDIF
< *
< *       Include magnetic braking for stars with convective envelopes.
<          CALL MAGBRK(KW,MASS(K),MENV(K),RAD(K),OSPIN(K),DJMB)
< *       Limit to a 3% angular momentum change for the star owing to MB.
<          IF(DJMB.GT.0.0D0)THEN
<             DT = MIN(DT,0.03D0*JSPIN(K)/DJMB)
<             DJSPIN(K) = DJSPIN(K) + DJMB
<          ENDIF
< *
< *       Evaluate the mass loss from the star in the interval DT.
<          DMS(K) = (DMX(K) - DMA(K))*DT
<          DMR = ABS(DMS(K)/(MASS(K) + 1.0d-10))
< *
< *       Restrict accumulated mass loss to maximum of 2%.
<          IF(DMR.GT.0.02)THEN
<             DT = DT*0.02/DMR
<             DMS(K) = 0.02*MASS(K)
<          ENDIF
< *
< *       Check that mass loss does not exceed the envelope mass.
<          IF(KSTAR(I).LT.10)THEN
<             DML = MAX(MASS(K) - MASSC(K),1.0D-07)
<             IF(DML.LT.DMS(K))THEN
<                DT = (DML/DMS(K))*DT
<                DMS(K) = DML
<             ENDIF
<          ENDIF
<          DTX(K) = DT
< *
<  210  CONTINUE
< *
< *       Include angular momentum loss owing to mass loss and/or
< *       gravitational radiation for close binary systems.
<       DSEP = 0.D0
<       DJORB = 0.D0
<       DTGR = 2.0D+10
<       IF(KACC.EQ.2)THEN
< *
<          DTXMIN = MIN(DTX(1),DTX(2))
<          IF(DTXMIN.GT.0.D0)THEN
<             CALL GRRAD(MASS(1),MASS(2),SEP,ECC,JORB,DJGR,DELET)
<             DJORB = DJT + DJGR
< *
< * Limit to 2% orbital angular momentum change.
< *
<             IF(ABS(DJORB).GT.TINY)THEN
<                DTGR = 0.02D0*JORB/ABS(DJORB)
<                DTXMIN = MIN(DTXMIN,DTGR)
<                DJORB = DJORB*DTXMIN
<                DTGR = DTGR/1.0D+06
<                JORB = JORB - DJORB
<                JORB = MAX(JORB,1.D0)
<                SEP1 = (MASS(1) + MASS(2))*JORB*JORB/
<      &                ((MASS(1)*MASS(2)*TWOPI)**2*AURSUN**3*(1.D0-ECC2))
<                DSEP = SEP - SEP1
<                IF(DSEP.GT.0.D0)THEN
<                   Q = MASS(1)/MASS(2)
<                   RXL1 = 0.9D0*RAD(1)/RL(Q)
<                   SEP1 = MAX(SEP1,RXL1)
<                   DSEP = SEP - SEP1
<                ENDIF
<             ELSE
<                DJORB = 0.D0
<             ENDIF
< *
<             DTX(1) = DTXMIN
<             DTX(2) = DTX(1)
<          ENDIF
< *
< *       Orbital changes owing to mass loss dealt with in hcorr for now.
<          DMXMAX = MAX(DMX(1),DMX(2))
< *        IF(DMXMAX.GT.0.D0)THEN
< *           Q = MASS(1)/MASS(2)
< *           DJORB = DJORB + (DMX(1)+Q*DMA(1))*MASS(2)*MASS(2)*DTX(1)
< *           Q = 1.D0/Q
< *           DJORB = DJORB + (DMX(2)+Q*DMA(2))*MASS(1)*MASS(1)*DTX(2)
< *           DJORB = DJORB*SEP*SEP*OORB/(MASS(1)+MASS(2))**2
< *        ENDIF
---
>       IF (KW.NE.KSTAR(I)) THEN
>           KW = KSTAR(I)
>           M0 = BODY0(I)*ZMBAR
>           M1 = M10
>           AGE = TEV0(I)*TSTAR - EPOCH(I)
>           CALL STAR(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
>       END IF
> *
> *       Evaluate mass loss due to stellar wind during interval DT.
>       IF (KW.LT.10) THEN
>          DM = MLWIND(KW,LUM,RM,M1,MC,ZMET)*DT
>       ELSE
>          DM = 0.d0
>       END IF
>       DMR = ABS(DM/(M1 + 1.0d-10))
572c211,216
<       ENDIF
---
> *       Restrict accumulated mass loss to maximum of 2 %.
>       IF (DMR.GT.0.02) THEN
>           DT = DT*0.02/DMR
>           DM = 0.02*M1
>           DMR = 0.02
>       END IF
574,622c218,233
<       DO 220 K = 1,KACC
< *       Set the initial mass and current type.
<          I = JX(K)
<          DT = DTX(K)
<          M0 = BODY0(I)*ZMBAR
<          M10 = M0
<          M1 = MASS(K)
<          MC = MASSC(K)
<          KW = KSTAR(I)
< *       Set indicator for mass loss correction.
<          ICORR = .FALSE.
<          DMS(K) = (DMX(K) - DMA(K))*DT
<          DMR = ABS(DMS(K)/(MASS(K) + 1.0d-10))
<          IF(DMR.GT.TINY)THEN
<             ICORR = .TRUE.
<             M1 = M1 - DMS(K)
< *       Check rejuvenation of MS, HG or HE star.
<             IF(KW.LE.2.OR.KW.EQ.7)THEN
<                M0 = M1
<                CALL STAR(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
<                IF(KW.EQ.2)THEN
<                   IF(GB(9).LT.MASSC(K).OR.M10.GT.ZPARS(3))THEN
<                      M0 = M10
<                   ELSE
<                      EPCH0(K) = TM + (TSCLS(1)-TM)*(AGE0(K)-TM0(K))/
<      &                               (TBGB(K)-TM0(K))
<                      EPCH0(K) = TEV0(I)*TSTAR - EPCH0(K)
<                   ENDIF
<                ELSE
<                   EPCH0(K) = TEV0(I)*TSTAR - AGE0(K)*TM/TM0(K)
<                ENDIF
<             ENDIF
<          ENDIF
<          DJSPIN(K) = DJSPIN(K)*DT
< *
< *       Check for blue straggler formation (TM < TPHYS).
<          IF(DMR.GT.TINY.AND.KW.LE.1.AND.NAME(I).NE.IBLUE)THEN
<             TPHYS2 = (TEV0(I)+TOFF)*TSTAR - EPOCH0
<             IF(TM0(K).GT.TPHYS2.AND.TM.LT.0.98D0*TPHYS2)THEN
<                J = JX(1)
<                IF(I.EQ.J.AND.KACC.EQ.2) J = JX(2)
<                WRITE(6,914)NAME(I),M1,TM,TPHYS2,EPCH0(K)+TOFF*TSTAR,
<      &                     KSTAR(J)
<  914           FORMAT(' NEW BS (MDOT):   NAM M TM TP EP KW1 ',
<      &                                   I6,F6.2,3F8.1,I4)
<                IBLUE = NAME(I)
<                NBS = NBS + 1
<             ENDIF
<          ENDIF
---
> *       Set indicator for mass loss correction (DM/M > 0.01).
>       IF (DMR.GT.0.01) THEN
>           ICORR = .TRUE.
>           M1 = M1 - DM
> *       Check rejuvenation of MS or HE star.
>           IF (KW.LE.1.OR.KW.EQ.7) THEN
>              XX = TM
>              M0 = M1
>              CALL STAR(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
>              EPCH0 = TEV0(I)*TSTAR - (AGE*TM)/XX
>           ELSE
>              CALL STAR(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
>           END IF
>       ELSE
>           ICORR = .FALSE.
>       END IF
625,651c236,249
<          TEVK = TEV0(I) + DT/(1.0D+06*TSTAR)
< *       Set indicator for mass loss correction.
<          AGE = TEVK*TSTAR - EPCH0(K)
<          AGE0(K) = AGE
< *
< *       Determine stellar evolution time scales and luminosity.
<          CALL star(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
< *
< *## temporary error check
< *
<          IF((AGE-TN).GT.1.0d-02)THEN
< *           IF(I.GE.IFIRST.OR.(I.LT.IFIRST.AND.NAME(ICM).GT.0))THEN
<                WRITE(6,994)NAME(I), KW, DMS(K), AGE, TN
< *           ENDIF
<  994        FORMAT(' MDOT WARNING! AGE > TN   NM KW DMS AGE TN ',
<      &                                   I6,I4,F7.3,1P,2E9.1)
<             IF(KW.LE.6)THEN
<                AGE = MIN(AGE,0.9999D0*TSCLS(11))
<             ELSE
<                AGE = MIN(AGE,0.9999D0*TSCLS(5))
<                AGE = MIN(AGE,1.0001D0*TN)
<             ENDIF
<          ENDIF
< *##
< *       Obtain stellar parameters at current epoch.
<          CALL hrdiag(M0,AGE,M1,TM,TN,TSCLS,LUMS,GB,ZPARS,
<      &               RM,LUM,KW,MC,RCC,ME,RE,K2)
---
>       TEVK = TEV0(I) + DT/(1.0D+06*TSTAR)
>       AGE = TEVK*TSTAR - EPCH0
>       AGE0 = AGE
> *
>       IF (AGE.GT.TN+0.01D0) THEN
> *         if(rank.eq.0) WRITE (6,35)  NAME(I), KW, DM, AGE, TN
> *  35     FORMAT (' WARNING!    AGE > TN    NM KW DMS AGE TN ',
> *    &                                      I6,I4,F7.3,1P,2E9.1)
>           IF (KW.LE.6) THEN
>               AGE = 0.9999*TSCLS(11)
>           ELSE
>               AGE = 0.9999*TSCLS(5)
>           END IF
>       END IF
653,664c251,253
< *       Check various aspects related to a change of type.
<          IF(KW.NE.KSTAR(I))THEN
<             IF(KW.EQ.15)THEN
<                WRITE(6,915)I,NAME(I),M0,KSTAR(I),TEVK*TSTAR-EPCH0(K)
<  915           FORMAT (' MDOT WARNING! SN KW=15   I NM M0 KSTAR AGE ',
<      &                                    2I6,F7.3,I4,E9.1)
<                IF (NAME(N+KSPAIR).LT.0) THEN
<                   IPHASE = 7
<                   CALL RESET
<                   GO TO 1
<                ENDIF
<             ELSEIF(KW.GE.13)THEN
---
> *       Obtain stellar parameters at current epoch.
>       CALL HRDIAG(M0,AGE,M1,TM,TN,TSCLS,LUMS,GB,ZPARS,
>      &            RM,LUM,KW,MC,RCC)
666,676c255,272
< *       Force new NS or BH to have a period of one second.
<                OSPIN(K) = 2.0D+08
<                JSPIN(K) = K3*RCC*RCC*MC*OSPIN(K)
<             ENDIF
< *       Check inclusion of mass loss on type change.
< *       Note that if ICORR is not already true and there is no SN
< *       involved then DM should be zero.
<             DMS(K) = MASS(K) - M1
<             DMR = ABS(DMS(K)/(MASS(K) + 1.0d-10))
<             ICORR = .TRUE.
<          ENDIF
---
> *       Check inclusion of small accumulated mass loss on type change.
>       IF (KW.NE.KSTAR(I)) THEN
>           IF (KW.GE.10.OR.KW.EQ.7) THEN
>               DM = M10 - M1
>               ICORR = .TRUE.
>           ELSE IF (.NOT.ICORR) THEN
>               M1 = M1 - DM
>               ICORR = .TRUE.
>           END IF
>       ELSE IF (KW.EQ.13.AND.I.LT.IFIRST) THEN
> *       Ensure kick in FCORR for KS component unless large c.m. velocity.
>           ICM =  N + KVEC(I)
>           VI2 = XDOT(1,ICM)**2 + XDOT(2,ICM)**2 + XDOT(3,ICM)**2
> *       Skip case of existing high velocity (i.e. TZ just after NS).
>           IF (VI2.LT.100.0/VSTAR**2) THEN
>                ICORR = .TRUE.
>            END IF
>       END IF
679,683c275,278
<          DMSUN = DMS(K)
<          DM = DMS(K)/ZMBAR
<          RNEW = RM/SU
<          LNEW = LUM
<          KW0 = KSTAR(I)
---
>       DMSUN = DM
>       DM = DM/ZMBAR
>       RNEW = RM/SU
>       KW0 = KSTAR(I)
686,704c281,290
<          IF (IHDOT.GT.0) THEN
<             IF((KW.EQ.KSTAR(I).AND.AGE.GE.0.99*TN).OR.
<      &         (KSTAR(I).LE.6.AND.KW.GT.6).OR.
<      &         (KSTAR(I).LE.9.AND.KW.GT.9)) THEN
<                ITERM = 1
<             ELSE
<                IF (IHDOT.EQ.1) THEN
<                   CALL HMDOT(I,IMERGE,M1,KW,MC,DMSUN,RNEW,ITERM)
<                ELSE
<                   CALL HMDOT2(I,IGHOST,IMERGE,M1,KW,MC,DMSUN,RNEW,ITERM)
<                END IF
<             ENDIF
< *       Terminate on non-zero indicator.
<             IF (ITERM.GT.0) THEN
<                IPHASE = 7
<                CALL RESET
<                GO TO 1
<             END IF
<          END IF
---
>       IF (IHDOT.GT.0) THEN
>           IF ((KW.EQ.KW0.AND.AGE.LT.0.99*TN).OR.KW.LT.13) THEN
>               IF (IHDOT.EQ.1) THEN
>                   CALL HMDOT(IGHOST,IMERGE,M1,KW,MC,DMSUN,RNEW,ITERM)
>               ELSE
>                   CALL HMDOT2(IGHOST,IMERGE,M1,KW,MC,DMSUN,RNEW,ITERM)
>               END IF
>           ELSE
>               ITERM = 1
>           END IF
706,725c292,298
< *       Define KS index & Roche indicator and update core mass (chaos only).
<          IF (I.LT.IFIRST.AND.IHDOT.EQ.0) THEN
<             KSPAIR = KVEC(I)
<             IF (.NOT.ICORR) THEN
<                IF (NAME(N+KSPAIR).GT.0) ITRY = 2
<             END IF
<             IF (KZ(27).GT.1) THEN
<                IC = 0
< *       Search existing chaotic binaries (assign next index if none found).
<                DO 30 KK = 1,NCHAOS
<                   IF (NAMEC(KK).EQ.NAME(N+KSPAIR)) IC = KK
<    30          CONTINUE
<                IF (IC.EQ.0) IC = NCHAOS + 1
< *       Save core mass in chaos variable for the appropriate KS component.
<                KK = 1
<                IF (I.EQ.2*KSPAIR) KK = 2
< *       Note that KW <= 1 ensures initialization by MC = 0.
<                CM(KK,IC) = MC/ZMBAR
<             END IF
<          END IF
---
> *       Terminate on non-zero indicator.
>           IF (ITERM.GT.0) THEN
>               IPHASE = 7
>               CALL RESET
>               GO TO 1
>           END IF
>       END IF
728c301,302
<          IF (I.LT.IFIRST.AND.ICORR.AND.IHDOT.EQ.0) THEN
---
>       IF (I.LT.IFIRST.AND.ICORR.AND.IHDOT.EQ.0) THEN
>           SEMI = -0.5*BODY(N+KSPAIR)/H(KSPAIR)
730,731c304
<             SEMI = -0.5d0*BODY(N+KSPAIR)/H(KSPAIR)
<             IF (NAME(N+KSPAIR).GT.0) THEN
---
>           IF (NAME(N+KSPAIR).GT.0) THEN
733c306
<                IF (KSTAR(I).LT.10.AND.KW.GE.13) THEN
---
>               IF (KW.EQ.13.OR.KW.EQ.14) THEN
735d307
<                   RADIUS(I) = RNEW
738,743c310,314
<                END IF
< *       Terminate for large mass loss or soft binary and re-determine index.
<                IF ((DMR.GT.0.2.AND.R(KSPAIR).GT.RMIN).OR.
<      &            (DM.GT.0.0.AND.H(KSPAIR) + DM/SEMI.GT.-ECLOSE.AND.
<      &            KSTAR(N+KSPAIR).GE.0).OR.
<      &            (KW.NE.KSTAR(I).AND.KW.GE.13)) THEN
---
>               END IF
> *       Terminatenate for large mass loss or soft binary and re-determine index.
>               IF ((DMR.GT.0.2.AND.R(KSPAIR).GT.RMIN).OR.
>      &            (DM.GT.0.0.AND.H(KSPAIR) + DM/SEMI.GT.-ECLOSE).OR.
>      &            KW.EQ.13.OR.KW.EQ.14) THEN
745,748d315
<                   JX(K) = I
<                   IF(KACC.EQ.2)THEN
<                      JX(3-K) = JX(3-K) + 2*(NPAIRS - KSPAIR)
<                   ENDIF
755c322
<                ELSE IF (DM.NE.0.D0) THEN
---
>               ELSE IF (DM.GT.0.0) THEN
758,760c325,326
<                   ITRY = 1
<                END IF
<             ELSE
---
>               END IF
>           ELSE
762,764c328,330
<                IF (I.EQ.2*KSPAIR.AND.NAME(I).LE.NZERO.AND.
<      &             NAME(N+KSPAIR).GT.-2*NZERO.AND.DM.GT.0.0D0.AND.
<      &             H(KSPAIR) + DM/SEMI.LT.-ECLOSE.AND.KW.LT.13) THEN
---
>               IF (I.EQ.2*KSPAIR.AND.NAME(I).LE.NZERO.AND.
>      &            NAME(N+KSPAIR).GT.-2*NZERO.AND.
>      &            H(KSPAIR) + DM/SEMI.LT.-ECLOSE.AND.KW.NE.13) THEN
766c332
<                ELSEIF(DM.GT.0.D0)THEN
---
>               ELSE IF (DM.GT.0.0D0) THEN
770,772c336,338
<                END IF
<             END IF
<          END IF
---
>               END IF
>           END IF
>       END IF
774,778c340,379
< *       Check for end of blue straggler evolution (allow 5% extra).
<          IF (M1.GT.1.05*TURN.AND.KSTAR(I).EQ.1.AND.KW.EQ.2) THEN
<             WRITE(6,920) I, NAME(I), KW, TPHYS, AGE, M1, M0
<  920        FORMAT(' END BS:    I NAM KW TP AGE M1 M0 ',
<      &                          2I6,I4,2F8.1,2F6.1)
---
> *       Base new time scale for changes in radius & mass on stellar type.
>       IF (KW.LE.1) THEN
>          DTM = 0.05*TM
>          DTR = TM - AGE
>       ELSE IF (KW.EQ.2) THEN
>          DTM = 0.05*(TSCLS(1) - TM)
>          DTR = TSCLS(1) - AGE
>       ELSE IF (KW.EQ.3) THEN
>          IF (AGE.LT.TSCLS(6)) THEN
>             DTM = 0.05*(TSCLS(4) - AGE)
>          ELSE
>             DTM = 0.05*(TSCLS(5) - AGE)
>          END IF
>          DTR = MIN(TSCLS(2),TN) - AGE
>       ELSE IF (KW.EQ.4) THEN
>          DTM = 0.05*TSCLS(3)
>          DTR = MIN(TN,TSCLS(2) + TSCLS(3)) - AGE
>       ELSE IF (KW.EQ.5) THEN
>          IF (AGE.LT.TSCLS(9)) THEN
>             DTM = 0.02*(TSCLS(7) - AGE)
>          ELSE
>             DTM = 0.02*(TSCLS(8) - AGE)
>          END IF
>          DTR = MIN(TN,TSCLS(13)) - AGE
>       ELSE IF (KW.EQ.6) THEN
>          IF (AGE.LT.TSCLS(12)) THEN
>             DTM = 0.02*(TSCLS(10) - AGE)
>          ELSE
>             DTM = 0.02*(TSCLS(11) - AGE)
>          END IF
>          DTM = MIN(DTM,0.005d0)
>          DTR = TN - AGE
>       ELSE IF (KW.EQ.7) THEN
>          DTM = 0.05*TM
>          DTR = TM - AGE
>       ELSE IF (KW.EQ.8.OR.KW.EQ.9) THEN
>          IF (AGE.LT.TSCLS(6)) THEN
>             DTM = 0.02*(TSCLS(4) - AGE)
>          ELSE
>             DTM = 0.02*(TSCLS(5) - AGE)
779a381,386
>          DTR = TN - AGE
>       ELSE
> *        DTM = AGE + 1.0
>          DTM = 1.0E+04
>          DTR = DTM
>       END IF
781,782c388,389
< *       Perform neighbour force corrections on significant mass loss (no WD).
<          IF (ICORR) THEN
---
> *       Perform neighbour force corrections if mass loss is significant.
>       IF (ICORR) THEN
784,816c391,412
< *       Include optional diagnostics for mass loss orbit (filename MDOT).
< *           IF (KZ(21).GT.2) THEN
< *              CALL MTRACE(I,DM)
< *           END IF
< *
< *       Update the mass (single body, standard KS or merger).
<             IF(IGHOST.EQ.0)THEN
<                BODY(I) = M1/ZMBAR
<             ELSE
<                J = 2*KSPAIR - 2 + IHDOT
<                BODY(J) = BODY(J) - DM
<             ENDIF
<             BODY0(I) = M0/ZMBAR
<             IF(DMSUN.LT.TOL) GOTO 250
< *
< *       Accumulate total mass loss (solar units) and reduce cluster mass.
<             ZMDOT = ZMDOT + DMSUN
<             ZMASS = ZMASS - DM
< *       Update the maximum single body mass but skip compact subsystems.
<             IF(MASS(K)/ZMBAR.GE.0.99*BODY1.AND.NSUB.EQ.0)THEN
<                BODY1 = 0.d0
<                DO 35 J = 1,N
<                   BODY1 = MAX(BODY1,BODY(J))
<   35           CONTINUE
<             ENDIF
< *
< *       Check optional diagnostics.
<             IF (KZ(19).GT.3) THEN
<                WRITE(6,36) I, NAME(I), KW, KSTAR(I), BODY(I)*ZMBAR,
<      &                     DMSUN, ZMDOT, TPHYS
<   36           FORMAT(' MDOT:    I NM KW K* MS DMS ZMDOT T6 ',
<      &                           4I5,F6.1,F7.2,F7.1,F8.1)
<             END IF
---
> *       Update the masses (single body, standard KS or merger).
>           IF (IGHOST.EQ.0) THEN
>               BODY(I) = M1/ZMBAR
>           ELSE
>               J = 2*KSPAIR - 2 + IHDOT
>               BODY(J) = MAX(BODY(J) - DM,0.0D0)
>           END IF
>           BODY0(I) = M0/ZMBAR
> *
> *      Set new mass loss reference time TEV0.
>           TEV0(I) = TEV(I)
> *
> *       Accumulate the total mass loss (solar units) and reduce cluster mass.
>           ZMDOT = ZMDOT + DMSUN
>           ZMASS = ZMASS - DM
>           IF (KZ(19).GT.3) THEN
>               if(rank.eq.0)
>      &        WRITE (6,40)  I, NAME(I), KW, KSTAR(I), BODY(I)*ZMBAR,
>      &                      DMSUN, ZMDOT, TPHYS
>    40         FORMAT (' MDOT:   I NM KW K* MS DMS ZMDOT T6 ',
>      &                          4I5,F6.1,F7.2,F7.1,F8.1)
>           END IF
819,824c415,419
<             IF (I.LT.IFIRST) THEN
<                IKS = I
<                I = N + KSPAIR
<                I1 = 2*KSPAIR - 1
< *       Predict coordinates & velocities of any unperturbed KS components.
<                IF (LIST(1,I1).EQ.0) THEN
---
>           IF (I.LT.IFIRST) THEN
>               IKS = I
>               I = N + KSPAIR
>               I1 = 2*KSPAIR - 1
>               IF (LIST(1,I1).EQ.0) THEN
826,827c421,422
<                END IF
<             END IF
---
>               END IF
>           END IF
830,862c425,428
<             IF (IGHOST.GT.0) THEN
<                II = I
<                I = N + KSPAIR
<             END IF
< *
<             NNB = LIST(1,I)
<             DO 38 L = 1,NNB+1
<                 ILIST(L) = LIST(L,I)
<    38       CONTINUE
< *       Ensure at least one neighbour.
<             IF (NNB.EQ.0) THEN
<                 ILIST(2) = N
<                 IF (I.EQ.N) ILIST(2) = NTOT
<                 NNB = 1
<             END IF
< *       Include body #I at the end (counting from location #2).
<             NNB2 = NNB + 2
<             ILIST(NNB2) = I
< *
< *       Check prediction of neighbours and body #I to current time.
<             DO 40 L = 2,NNB2
<                J = ILIST(L)
<                IF (T0(J).LT.TIME) THEN
<                   CALL XVPRED(J,-2)
<                END IF
<    40       CONTINUE
< *
< *       Perform total force & energy corrections (delay dF if DMSUN > 0.1).
<             IF (DMSUN.LT.0.05.AND.KW.LE.12) THEN
<                 CALL FICORR(I,DM)
<             ELSE
<                 CALL FCORR(I,DM,KW)
<             END IF
---
>           IF (IGHOST.GT.0) THEN
>               II = I
>               I = N + KSPAIR
>           END IF
864,865c430,439
< *       Set flag to ensure new sorting after CALL FPOLY (need IPHASE < 0).
<             IF (I.GT.N) IPOLY = -1
---
> *       Predict coordinates & velocities of body #I and its neighbours.
>           NNB = LIST(1,I)
>           CALL XVPRED(I,0)
>           CALL XVPRED(I,NNB)
> *
> *       Perform irregular force & energy corrections (delay if DMSUN > 0.1).
>           IF (DMSUN.LT.0.1.AND.KW.LE.12) THEN
>               CALL FICORR(I,DM)
>           ELSE
>               CALL FCORR(I,DM,KW)
868,879c442,459
<             IF (ABS(DMSUN).GT.0.1.OR.KW.GE.13) THEN
< *
< *       Obtain new F & FDOT and time-steps.
<                DO 50 L = 2,NNB2
<                   J = ILIST(L)
<                   IF (L.EQ.NNB2) J = I
<                   CALL DTCHCK(TIME,STEP(J),DTK(MAXBLK))
<                   DO 45 KK = 1,3
<                      X0DOT(KK,J) = XDOT(KK,J)
<    45             CONTINUE
<                   CALL FPOLY1(J,J,0)
<                   CALL FPOLY2(J,J,0)
---
>               IF (DMSUN.GT.0.1.OR.KW.GE.13) THEN
>                   NNB2 = LIST(1,I) + 2
>                   LIST(NNB2,I) = I
> *
> *       Obtain new F & FDOT, then F2DOT & F3DOT and time-steps.
>                   DO 50 L = 2,NNB2
>                       J = LIST(L,I)
>                       T0(J) = TIME
>                       DO 45 K = 1,3
>                           X0DOT(K,J) = XDOT(K,J)
>    45                 CONTINUE
>                       CALL FPOLY1(J,J,0)
>    50             CONTINUE
> *
>                   DO 60 L = 2,NNB2
>                       J = LIST(L,I)
>                       CALL FPOLY2(J,J,0)
>    60             CONTINUE
881,920c461,465
<    50          CONTINUE
< *       Use current potential for energy correction delayed from FCORR.
< *              ECDOT = ECDOT + DM*PHI(I)
<                IF (KZ(14).GE.3.AND.KZ(31).GT.0) THEN
<                   CALL XVPRED(IFIRST,NTOT)
<                   CALL CMCORR
<                END IF
<             END IF
<             TPREV = TIME - STEPX
< *       Set indicator < 0 for new sorting.
<             IF (IGHOST.GT.0) I = II
<             IF(IPHASE.EQ.-3) IPHASE = 0
<          END IF
< *
< *       Ensure that massless supernova remnant will escape next output.
<          IF (KW.EQ.15) THEN
<             T0(I) = TADJ + DTADJ
<             STEP(I) = 1.0D+06
<             STEPR(I) = 1.0D+06
<             RI = SQRT(X(1,I)**2 + X(2,I)**2 + X(3,I)**2)
<             VI = SQRT(XDOT(1,I)**2 + XDOT(2,I)**2 + XDOT(3,I)**2)
<             DO 55 L = 1,3
< *       Ensure that ghost will escape next output (far from fast escapers).
<                X0(L,I) = MIN(1.0d+04+X(L,I),1000.0*RSCALE*X(L,I)/RI)
<                X(L,I) = X0(L,I)
<                X0DOT(L,I) = SQRT(0.004*ZMASS/RSCALE)*XDOT(L,I)/VI
<                XDOT(L,I) = X0DOT(L,I)
<                F(L,I) = 0.0D0
<                FDOT(L,I) = 0.0D0
<                D0(L,I) = 0.0
<                D1(L,I) = 0.0
<                D2(L,I) = 0.0D0
<                D3(L,I) = 0.0D0
<                D1R(L,I) = 0.0
<                D2R(L,I) = 0.0D0
<                D3R(L,I) = 0.0D0
<    55       CONTINUE
<          END IF
< *
<  250     CONTINUE
---
>               END IF
>               IPHASE = -1
>           END IF
>           IF (IGHOST.GT.0) I = II
>       END IF
923,925c468,469
<          IF (IKS.GT.0) THEN
<             I = IKS
<             IKS = 0
---
>       IF (IKS.GT.0) THEN
>           I = IKS
927,931c471,476
<             IF (LIST(1,I1).GT.0) THEN
<                CALL RESOLV(KSPAIR,1)
<                CALL KSPOLY(KSPAIR,1)
<             END IF
<          END IF
---
>           IF (LIST(1,I1).GT.0) THEN
>               CALL RESOLV(KSPAIR,1)
>               CALL KSPOLY(KSPAIR,1)
> *             TBLIST = TIME
>           END IF
>       END IF
933,966c478,479
< *       Update event counter & mass loss for types > 2.
<          if(kw.ne.kw0)then
<             if(kw.eq.3)then
<                nrg = nrg + 1
<                zmrg = zmrg + dmsun
<             elseif(kw.eq.4)then
<                nhe = nhe + 1
<                zmhe = zmhe + dmsun
<             elseif(kw.eq.5)then
<                nrs = nrs + 1
<                zmrs = zmrs + dmsun
<             elseif(kw.ge.7.and.kw.le.9.and.kw0.le.6)then
<                nnh = nnh + 1
<                zmnh = zmnh + dmsun
<             elseif(kw.ge.10.and.kw.le.12.and.kw0.le.9)then
<                nwd = nwd + 1
<                zmwd = zmwd + dmsun
<             elseif((kw.eq.13.or.kw.eq.15).and.kw0.le.12)then
<                nsn = nsn + 1
<                zmsn = zmsn + dmsun
<             elseif(kw.eq.14.and.kw0.le.13)then
<                nbh = nbh + 1
<                zmbh = zmbh + dmsun
<             endif
<          endif
< *
< *       Include consistency warnings.
<          IF (RNEW - RADIUS(I).GT.0.5*RADIUS(I)) THEN
<             WRITE(43,924) I, NAME(I), TPHYS, DT/1.0d+06,
<      &                    KSTAR(I), KW, M0, M1, RADIUS(I)*SU, RNEW*SU
<  924        FORMAT(' EXPAND!    I NM TP DTP K* KW M0 M R RN ',
<      &                          2I6,F7.1,F7.3,2I4,2F7.1,2F7.1)
<             CALL FLUSH(43)
<          END IF
---
> *       Choose minimum of 0.05 of evolution time and remaining interval.
>       DTM = MIN(DTM,DTR)
968,994c481,482
< *       Update R, L, classification type & spin angular momentum.
<          RADIUS(I) = RNEW
<          ZLMSTY(I) = LNEW
<          KSTAR(I) = KW
<          JSPIN(K) = MAX(JSPIN(K) - DJSPIN(K),1.0D-10)
< *
< * Ensure that the star does not spin up beyond break-up.
< *
<          OSPBRU = TWOPI*SQRT(MASS(K)*AURSUN**3/RAD(K)**3)
<          JSPBRU = (K2STR(K)*(MASS(K)-MASSC(K))*RAD(K)*RAD(K) +
<      &             K3*MASSC(K)*RADC(K)*RADC(K))*OSPBRU
<          IF(JSPIN(K).GT.JSPBRU) JSPIN(K) = JSPBRU
<          SPIN(I) = JSPIN(K)/SPNFAC
< *
< *       Update epoch and check binary diagnostics for transition to new type.
<          IF (KW.NE.KW0) THEN
< *           EPOCH(I) = AGE0(K) + EPCH0(K) - AGE
< *           IF(KW.GT.6)THEN
<             IF(KW.LT.0)THEN
<                WRITE(6,925)I,NAME(I),KW0,KW,M10,M1,DMS(K),RM,AGE
<  925           FORMAT(' MDOT CHANGE: I NM K* M0 M1 DM R AGE',
<      &                               2I6,2I4,2F6.1,F7.3,F7.2,F8.1)
<             ENDIF
<             IF (I.LT.IFIRST.AND.KZ(8).GT.3) THEN
<                CALL BINEV(KSPAIR)
<             END IF
<          END IF
---
> *       Impose a lower limit and convert time interval to scaled units.
>       DTM = MAX(DTM,1.0D-04)/TSTAR
996,1009c484,524
< *       Include optional diagnostics (new type or significant mass loss).
<          IF (KZ(19).GT.3.AND.(KW0.NE.KW.OR.ICORR)) THEN
<             IF (KW0.NE.KW) THEN
<                WHICH1 = ' TYPE   '
<             ELSE
<                WHICH1 = ' MASS   '
<             END IF
<             WRITE(6,926)WHICH1, TPHYS, I, NAME(I), DMR, KW0, KW, M0, M1,
<      &                  RADIUS(I)*SU, EMDOT
<  926        FORMAT(' NEW',A8,' TPHYS I NAM DM/M KW0 KW M0 M R EMD ',
<      &                         F7.1,2I5,F6.2,2I3,2F6.1,F7.1,F10.5)
<          END IF
< *
< *       Base new time scale for changes in radius & mass on stellar type.
---
> *       Update event counters & mass loss for new types > 2.
>       if (kw.ne.kw0) then
>          if (kw.eq.3) then
>             nrg = nrg + 1
>             zmrg = zmrg + dmsun
>          else if (kw.eq.4) then
>             nhe = nhe + 1
>             zmhe = zmhe + dmsun
>          else if (kw.eq.5) then
>             nrs = nrs + 1
>             zmrs = zmrs + dmsun
>          else if (kw.ge.7.and.kw.le.9.and.kw0.le.6) then
>             nnh = nnh + 1
>             zmnh = zmnh + dmsun
>          else if (kw.ge.10.and.kw.le.12.and.kw0.le.9) then
>             nwd = nwd + 1
>             zmwd = zmwd + dmsun
>          else if ((kw.eq.13.or.kw.eq.15).and.kw0.le.12) then
>             nsn = nsn + 1
>             zmsn = zmsn + dmsun
>          else if (kw.eq.14.and.kw0.le.13) then
>             nbh = nbh + 1
>             zmbh = zmbh + dmsun
>          end if
>       end if
> *
> *       Set new time for checking R & M and update R & classification type.
>       TEV(I) = TEVK + DTM
>       RADIUS(I) = RNEW
>       KSTAR(I) = KW
> *       Update epoch on transition to new type.
>       IF (KW.NE.KW0) THEN
>           EPOCH(I) = AGE0 + EPCH0 - AGE
>       END IF
>       IF (IHDOT.EQ.2) THEN
>           TEV(I0) = TIME + DTM
> *       Distinguish between single particle ghost and binary c.m.
>           IF (NAME(IGHOST).LT.0.OR.NAME(IGHOST).GT.NZERO) THEN
>               TEV(IGHOST) = TIME + DTM
>           END IF
>       END IF
1011,1022c526,538
<          EPOCH(I) = AGE0(K) + EPCH0(K) - AGE
<          TEV(I) = (AGE0(K) + EPCH0(K))/TSTAR
<          TEV0(I) = TEV(I)
< *        IF(I.EQ.IGHOST.OR.BODY(I).LE.0.0) RM0 = M1
<          CALL TRDOT(I,DTM,M1)
<          TEV(I) = TEV(I) + DTM
<          IF(IHDOT.EQ.2)THEN
<             TEV(I0) = TEV(I)
<             IF(NAME(IGHOST).LT.0.OR.NAME(IGHOST).GT.NZERO)THEN
<                 TEV(IGHOST) = TEV(I)
<             ENDIF
<          ENDIF
---
> *       Check optional diagnostic output.
>       IF (KZ(19).GT.3.AND.(KW0.NE.KW.OR.DMR.GT.0.01)) THEN
>           IF (KW0.NE.KW) THEN
>               WHICH1 = ' TYPE   '
>           ELSE
>               WHICH1 = ' MASS   '
>           END IF
>           if(rank.eq.0)
>      &    WRITE (6,65)  WHICH1, TPHYS, I, NAME(I), DMR, KW0, KW,
>      &                  M0, M1, RADIUS(I)/SU, EMDOT
>    65     FORMAT (' NEW',A8,' TPHYS I NAM DM/M KW0 KW M0 M R EMD ',
>      &            F7.1,2I8,1P,E10.2,2I3,0P,2F6.1,1P,E9.1,0P,F10.5)
>       END IF
1025,1038c541,551
<          IF (KS.GT.0) THEN
<             ICOMP = IFIRST
<             JCOMP = IFIRST + 1
<             RIJ2 = (X(1,ICOMP) - X(1,JCOMP))**2 +
<      &             (X(2,ICOMP) - X(2,JCOMP))**2 +
<      &             (X(3,ICOMP) - X(3,JCOMP))**2
<             IF (RIJ2.LT.RMIN22) THEN
< *       Set temporary IPHASE > 0 for KSREG.
<                IPHASE = 1
<                CALL KSREG
<                KSPAIR = NPAIRS
< *       Restore current time to prevent small subsequent steps.
<                TIME = TBLOCK
<                IF ((KW.EQ.13.OR.KW.EQ.14).AND.H(NPAIRS).LT.0.0) THEN
---
>       IF (KS.GT.0) THEN
>           ICOMP = IFIRST
>           JCOMP = IFIRST + 1
>           RIJ2 = (X(1,ICOMP) - X(1,JCOMP))**2 +
>      &           (X(2,ICOMP) - X(2,JCOMP))**2 +
>      &           (X(3,ICOMP) - X(3,JCOMP))**2
>           IF (RIJ2.LT.RMIN22) THEN
>               CALL KSREG
> *       Restore current time to prevent subsequent small steps.
>               TIME = TBLOCK
>               IF ((KW.EQ.13.OR.KW.EQ.14).AND.H(NPAIRS).LT.0.0) THEN
1040c553
<                   SEMI = -0.5d0*BODY(J)/H(NPAIRS)
---
>                   SEMI = -0.5*BODY(J)/H(NPAIRS)
1043,1063c556,564
<                   TK = DAYS*SEMI*SQRT(SEMI/BODY(J))
<                   WRITE(6,928) KW, SQRT(ECC2), RA, SEMI*SU, TK, STEP(J),
<      &                         BODY(J)*ZMBAR, (XDOT(KK,J)*VSTAR,KK=1,3)
<  928              FORMAT(' NS BINARY    KW E R/A A P DT M V ',
<      &                                  I4,2F6.2,1P,3E10.2,0P,4F7.1)
<                END IF
<                IF(KW.GE.10.AND.H(NPAIRS).LT.0.0)THEN
<                   IF(KZ(8).GT.3)THEN
<                      CALL DEGEN(NPAIRS,NPAIRS,3)
<                   ELSE
<                      J1 = 2*NPAIRS - 1
<                      J2 = J1 + 1
<                      IF(KSTAR(J1).GE.10.AND.KSTAR(J2).GE.10)THEN
<                         NDD = NDD + 1
<                      ENDIF
<                   ENDIF
<                ENDIF
<             ELSE
<                KSPAIR = 0
<             END IF
<             KS = 0
---
>                   if(rank.eq.0)
>      &            WRITE (6,66)  KW, SQRT(ECC2), RA, SEMI*SU, STEP(J),
>      &                          BODY(J)*ZMBAR, (XDOT(K,J)*VSTAR,K=1,3)
>    66             FORMAT (' NS BINARY    KW E R/A A DT M V ',
>      &                                   I4,2F6.2,1P,2E10.2,0P,4F7.1)
>               END IF
>           ELSE
>               IPHASE = -1
>           END IF
1065,1161c566,568
<             IPOLY = -1
<          END IF
< *
< *       Note any formation of black holes or TZ object.
<          IF(KW.EQ.14.AND.KSTAR(I).LT.14.AND.I.LE.N)THEN
<             WRITE(6,930) I, NAME(I), KW0, KW, KSTAR(I), M0, M1, DMR
<  930        FORMAT(' NEW BH/TZ    I NM K0 KW K* M0 M1 DM/M ',
<      &                            2I6,3I4,3F7.2)
<          END IF
< *
< *       Perform consistency check on massive WD (skip HMDOT treatment).
<          IF(I.LE.N)THEN
<             IF((KSTAR(I).GE.10.AND.KSTAR(I).LE.12).AND.IHDOT.EQ.0)THEN
<                IF(BODY(I)*ZMBAR.GT.MCH)THEN
<                WRITE(6,932)I,KW,BODY0(I)*ZMBAR,BODY(I)*ZMBAR,RADIUS(I)
<  932           FORMAT(' DANGER!  MDOT   I K* M0 M R ',2I5,2F7.2,1P,E9.1)
<                WRITE(6,934) NAME(I), TTOT, TEV0(I), TEV(I)
<  934           FORMAT(' NAM T TEV0 TEV ',I6,3F10.2)
<                STOP
<                ENDIF
<             ENDIF
<          ENDIF
< *
< *       Include stellar radius check in case of NaN.
<          IF (RADIUS(I).GE.0.0.AND.RADIUS(I).LT.1.0) GO TO 105
<          WRITE(6,936) I, KSTAR(I), M1, RADIUS(I)
<  936     FORMAT(' DANGER!    MDOT    I K* M1 R* ',I5,I4,F7.2,1P,E10.1)
<          STOP
<  105     CONTINUE
< *
< *       Check for chaotic binary.
<          IF(ITRY.GT.0.AND.IGHOST.EQ.0)THEN
<             II = I
<             I = N + KSPAIR
<             IPAIR = KSPAIR
<             IF(KSTAR(I).LT.0)THEN
<                IF(KW.GE.10.AND.DMR.GT.0.0)THEN
<                   WRITE(6,940) NAME(II), KSTAR(II), KW, DMR
<  940              FORMAT(' DEGEN SPIRAL    NAM K* DMR ',I5,2I4,1P,E9.1)
<                ENDIF
<                CALL CHRECT(IPAIR,DMR)
<                IF (IPHASE.LE.0) IPOLY = -1
<                IF(DMR.LT.0.0) GOTO 1
<             ENDIF
<             IF(KW.GE.10.AND.ICORR)THEN
<                IF(KZ(8).GT.3)THEN
<                   CALL DEGEN(IPAIR,IPAIR,3)
<                ELSE
<                   J1 = 2*IPAIR - 1
<                   J2 = J1 + 1
<                   IF(KSTAR(J1).GE.10.AND.KSTAR(J2).GE.10) NDD = NDD + 1
<                ENDIF
<             ENDIF
<             ITRY = 0
<          ENDIF
< *
<  220  CONTINUE
< *
<       IF(KSPAIR.EQ.0) KACC = 1
<       IF(KACC.GT.1)THEN
<          TEV(JX(1)) = MIN(TEV(JX(1)),TEV(JX(2)))
<          IF(DTGR.LT.1.0D+10)THEN
<             TEV(JX(1)) = MIN(TEV(JX(1)),TEV0(JX(1))+DTGR/TSTAR)
<          ENDIF
<          TEV(JX(2)) = TEV(JX(1))
<       ENDIF
< *
< *       Check for Roche overflow condition (DTR < STEP) and implement any
< *       orbit change owing to gravitational radiation, mass loss or tides.
<       IF(KSPAIR.GT.0.AND.IGHOST.EQ.0)THEN
<          I = N + KSPAIR
<          IPAIR = KSPAIR
< *        IF(H(IPAIR).LT.0.D0.AND.NAME(ICM).GT.0)THEN
<          IF(H(IPAIR).LT.0.D0.AND.NAME(I).GT.0.AND.KSTAR(I).GE.0)THEN
<             CALL BRAKE(IPAIR,DSEP)
<             IF(IQCOLL.NE.0.OR.IPHASE.LT.0) GO TO 1
<             IF(KZ(11).EQ.1.AND.KSTAR(I).GT.0.AND.
<      &         MOD(KSTAR(I),2).EQ.0)THEN
<                 CALL SYNCH(IPAIR)
<             ELSEIF(KSTAR(I).GT.0)THEN
<                IPAIR = -IPAIR
<                CALL TRFLOW(IPAIR,DTR)
<                IF(DTR.LT.STEP(I))THEN
<                   CALL ROCHE(IPAIR)
<                   IF(IQCOLL.NE.0.OR.IPHASE.LT.0) GO TO 1
<                ELSE
<                   TEV(I) = TIME + DTR
<                   IF(KSTAR(I).GT.10.AND.MOD(KSTAR(I),2).EQ.1)THEN
<                      J1 = 2*IPAIR - 1
<                      J2 = J1 + 1
<                      TEV(J1) = MAX(1.000002d0*TEV(I),TEV(J1))
<                      TEV(J2) = MAX(1.000002d0*TEV(I),TEV(J2))
<                   ENDIF
<                ENDIF
<             ENDIF
<          ENDIF
<       ENDIF
---
>           IPOLY = -1
>           KS = 0
>       END IF
1164c571
<    70 TMDOT = 1.0d+10
---
>    70 TMDOT = 1.0E+10
1166,1168c573,575
<          IF(TEV(J).LE.TMDOT)THEN
<             TMDOT = TEV(J)
<          ENDIF
---
>           IF (TEV(J).LE.TMDOT) THEN
>               TMDOT = TEV(J)
>           END IF
1172,1206c579
<   100 IF (TMDOT.LE.TIME) GO TO 1
< *
< *       Update any merged circularizing binary using TMDIS.
<       IMERGE = 1
<   104 IF (NMERGE.GT.0) THEN
<           IF (KSTARM(IMERGE).LT.0.AND.TMDIS(IMERGE).LT.TIME) THEN
<               KSPAIR = 0
< *       Determine the KS index from c.m. identification.
<               DO 106 I = N+1,NTOT
<                   IF (NAME(I).EQ.NAMEM(IMERGE)) THEN
<                       KSPAIR = I - N
<                   END IF
<   106         CONTINUE
<               IF (KSPAIR.GT.0) THEN
<                   IC = 0
<                   DO 107 K = 1,NCHAOS
<                       IF (NAMEC(K).EQ.NAME(N+KSPAIR)) IC = K
<   107             CONTINUE
<                   IC = MAX(IC,1)
<                   SEMI = -0.5*(BM(1,IMERGE) + BM(2,IMERGE))/HM(IMERGE)
<                   I1 = 2*KSPAIR - 1
<                   WRITE (6,108) NAMEG(IMERGE), NAME(N+KSPAIR),KSTAR(I1),
<      &                          ES(IC), TMDIS(IMERGE), SEMI
<   108             FORMAT (' TMDIS TERM    NAMG NAMCM K* E TMD A ',
<      &                                    2I7,I4,F8.4,F8.2,1P,E10.2)
< *       Terminate hierarchy (RESET calls SPIRAL via CHRECT).
<                   IPHASE = 7
<                   CALL RESET
< *       Consider the same merger index again.
<                   IMERGE = IMERGE - 1
<               END IF
<           END IF
<           IMERGE = IMERGE + 1
<       END IF
<       IF (IMERGE.LE.NMERGE) GO TO 104
---
>       IF (TMDOT.LT.TIME) GO TO 1
1209,1223c582,587
<       IF(NSUB.EQ.0)THEN
<          BODY1 = 0.d0
<          DO 110 J = 1,N
<             BODY1 = MAX(BODY1,BODY(J))
<   110    CONTINUE
<       ENDIF
< *
<       DO 122 J = N+1,NTOT
<          IF(KSTAR(J).EQ.0.AND.NAME(J).GT.0.AND.TEV(J).LT.9.9E+09.AND.
<      &      BODY(J).GT.0.0)THEN
<             WRITE(6,556)J,NAME(J),TEV(J)
<             TEV(J) = 1.0d+10
<  556        FORMAT(' MDOT TEV SMALL ',2I8,1P,E10.2)
<          ENDIF
<  122  CONTINUE
---
>       IF (NSUB.EQ.0) THEN
>           BODY1 = 0.0
>           DO 90 J = 1,N
>               BODY1 = MAX(BODY1,BODY(J))
>    90     CONTINUE
>       END IF
1225c589
< *       Ensure re-initialization of ICPERT (INTGRT) and KBLIST (SUBINT).
---
> *       Ensure IPHASE < 0 at the end and also enforce new KBLIST in SUBINT.
1234c598,599
< ***
---
> 
> 
1,2c1,2
< 10475 2006-09-08 15:07 /work/Umi2/spurzem/5/nbody6compare-oct2006/merge2.f
< nbody6compare-oct2006/merge2.f
---
> 9317 2003-06-25 21:22 /work/Umi2/spurzem/5/nbody6++compare/merge2.f
> nbody6++compare/merge2.f
9,10c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
39,48d38
< *       Select deepest level as primary in case of two hierarchies.
<       IF (NAME(N+KSPAIR).LT.0.AND.NAME(JCOMP).LT.0) THEN
< *       Note possibility of a quartet (or even quintet) and triple.
<           IF (NAME(JCOMP).LT.NAME(N+KSPAIR)) THEN
<               K = KSPAIR
<               KSPAIR = JCOMP - N
<               JCOMP = N + K
<           END IF
<       END IF
< *
57,58d46
<       ECC2 = (1.0 - R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
<       ECC = SQRT(ECC2)
60c48
< *       Produce diagnostics for [[B,S],B] quintuplet or sextuplet system.
---
> *       Produce diagnostics for quintuplet or sextuplet system.
65a54,55
>           E2 = (1.0 - R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
>           ECC = SQRT(E2)
67c57
<           EB = 0.5*BODY(I1)*BODY(I2)/SEMI
---
>           EB = 0.5*BODY(2*IPAIR-1)*BODY(2*IPAIR)/SEMI
71,80d60
<           CALL FINDJ(I,JG,IM)
< *       Check possible extension of next look-up time (skip GR case).
<           IF (KZ(19).GE.3.AND.KZ(27).LT.3) THEN
<               JLIST(1) = I1
<               JLIST(2) = I2
<               JLIST(3) = 2*(JCOMP - N) - 1
<               JLIST(4) = JLIST(3) + 1
<               JLIST(5) = JG
<               CALL NEWTEV(5,IX)
<           END IF
81a62
>           CALL FINDJ(I,JG,IM)
83c64,65
<           WRITE (6,5)  WHICH1, TIME+TOFF, ZM, NAME(I1), NAME(I2),
---
>           if(rank.eq.0)
>      &    WRITE (6,5)  WHICH1, TIME+TOFF, ZM, NAME(I1), NAME(I2),
89c71
< *       Check for [[B,S],S] quartet or [[B,B],S] quintuplet.
---
> *       Check formation of [[B,S],S} quartet or [[B,B],S] quintuplet.
92,98d73
<           IF (KZ(19).GE.3.AND.KZ(27).LT.3) THEN
<               JLIST(1) = I1
<               JLIST(2) = I2
<               JLIST(3) = JCOMP
<               JLIST(4) = JG
<               CALL NEWTEV(4,IX)
<           END IF
100,104c75,80
<           IF (JG.LE.N.AND.JCOMP.LE.N) THEN
<               WRITE (6,7)  TIME+TOFF, ZM, NAME(I1), NAME(I2),
<      &                     NAME(JCOMP), ECC, SEMI, PCRIT, GAMMA(IPAIR)
<     7         FORMAT (/,' NEW QUARTET    T MT NM1 NMG NM3 E0 A0 PC G0 ',
<      &                                   F9.2,F6.2,3I6,F6.2,1P,3E10.2)
---
>           IF (NAME(2*IPAIR).LE.NZERO) THEN
>               if(rank.eq.0)
>      &        WRITE (6,7)  TIME+TOFF, ZM, NAME(I2), NAME(JG),
>      &                     NAME(JCOMP), SEMI, PCRIT, GAMMA(IPAIR)
>     7         FORMAT (/,' NEW QUARTET    T MT NM1 NMG NM3 A0 PC G0 ',
>      &                                   F9.2,F6.2,3I6,1P,3E10.2)
106,109c82,86
<               WRITE (6,8)  TIME+TOFF, ZM, NAME(I1), NAME(I2),
<      &                     NAME(JCOMP), ECC, SEMI, PCRIT, GAMMA(IPAIR)
<     8         FORMAT (/,' NEW QUINTUP2    T MT NM1 NMG NM3 E0 A0 PC G0',
<      &                                    F10.2,F6.2,3I6,F6.2,1P,3E10.2)
---
>               if(rank.eq.0)
>      &        WRITE (6,8)  TIME+TOFF, ZM, NAME(I2), NAME(JG),
>      &                     NAME(JCOMP), SEMI, PCRIT, GAMMA(IPAIR)
>     8         FORMAT (/,' NEW QUINTUP2    T MT NM1 NMG NM3 A0 PC G0 ',
>      &                                    F9.2,F6.2,3I6,1P,3E10.2)
113c90
< *       Include diagnostics for double triple as [[B,S],[B,S]].
---
> *       Include diagnostics for double triple ([[B,S],[B,S]]).
119,127d95
<           IF (KZ(19).GE.3.AND.kZ(27).LT.3) THEN
<               JLIST(1) = I1
<               JLIST(2) = I2
<               JLIST(3) = J1
<               JLIST(4) = J1 + 1
<               JLIST(5) = JI
<               JLIST(6) = JJ
<               CALL NEWTEV(6,IX)
<           END IF
132,133c100,102
<           WRITE (6,10)  TIME+TOFF, ZM, NAME(I1), NAME(I2), NAME(J1),
<      &                  NAME(2*JPAIR), ECC, AI, AJ, R(IPAIR), R(JPAIR),
---
>           if(rank.eq.0)
>      &    WRITE (6,10)  TIME+TOFF, ZM, NAME(I1), NAME(I2), NAME(J1),
>      &                  NAME(2*JPAIR), AI, AJ, R(IPAIR), R(JPAIR),
135,136c104,105
<    10     FORMAT (/,' NEW HITRIP    T MT NM E0 AI AJ RI RJ PC GX ',
<      &                              F9.2,F6.2,4I6,F6.2,1P,6E10.2)
---
>    10     FORMAT (/,' NEW HITRIP    T MT NM AI AJ RI RJ PC GX ',
>      &                              F9.2,F6.2,4I6,1P,6E10.2)
143c112
<       IF ((KZ(18).EQ.1.OR.KZ(18).EQ.3).AND.KSTAR(I).LE.20) THEN
---
>       IF ((KZ(11).EQ.1.OR.KZ(11).EQ.3).AND.KSTAR(I).LE.20) THEN
170a140,144
> *       Update the primary velocity of body #JCOMP.
>       DO 15 K = 1,3
>           X0DOT(K,JCOMP) = XDOT(K,JCOMP)
>    15 CONTINUE
> *
188,192d161
< *       Predict outer component to highest order if not on the block.
<       IF (TIME - T0(JCOMP1).GT.0.0D0) THEN
<           CALL XVPRED(JCOMP1,-1)
<       END IF
< *
279c248
< *       Initialize c.m. & KS polynomials.
---
> *       Initialize c.m. & KS polynomials
299c268
< *       Set IPHASE < 0 for new time-step list in routine INTGRT.
---
> *       Set IPHASE < 0 for new NLIST in routine INTGRT.
304a274,275
> 
> 
1,2c1,2
< 9138 2006-09-18 17:51 /work/Umi2/spurzem/5/nbody6compare-oct2006/merge.f
< nbody6compare-oct2006/merge.f
---
> 9106 2003-06-25 17:29 /work/Umi2/spurzem/5/nbody6++compare/merge.f
> nbody6++compare/merge.f
9,10c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
23c23
< *       NMERG   Total number of stable mergers (exclude flybys).
---
> *       NMERG   Total number of mergers.
61c61
<       IF ((KZ(18).EQ.1.OR.KZ(18).EQ.3).AND.KSTAR(I).LE.20) THEN
---
>       IF ((KZ(11).EQ.1.OR.KZ(11).EQ.3).AND.KSTAR(I).LE.20) THEN
106a107,110
> *       Include body #J in the time-step list unless already present.
> *         IF (T0(J) + STEP(J).LT.TLIST) THEN
> *             CALL NLMOD(J,1)
> *         END IF
228,229c232
<           FAC = NNBMAX/NNB
<           FAC = MIN(FAC,4.0D0)
---
>           FAC = FLOAT(NNBMAX)/FLOAT(NNB)
246,248d248
< *       Subtract 1 for hyperbolic flybys to count stable systems only.
<       IF (H(NPAIRS).GT.0.0) NMERG = NMERG - 1
< 
253d252
< *
257c256
< *       Set phase indicator = -1 for new time-step list in routine INTGRT.
---
> *       Set phase indicator = -1 for new NLIST in routine INTGRT.
1,2c1,2
< 6120 2006-03-20 05:16 /work/Umi2/spurzem/5/nbody6compare-oct2006/mloss.f
< nbody6compare-oct2006/mloss.f
---
> 6392 2005-03-09 16:25 /work/Umi2/spurzem/5/nbody6++compare/mloss.f
> nbody6++compare/mloss.f
7,9d6
< *       Original scheme of Elena Terlevich 1983.
< *       ----------------------------------------
< *
36c33
< *       Set phase indicator = -1 for new time-step list in INTGRT.
---
> *       Set phase indicator = -1 for new NLIST in routine INTGRT.
143a141,146
> *
> *         STEP(J) = STEP(J) - 0.5*(T0(J) + STEP(J) - TIME)
> *       See whether body #J should be added to NLIST.
>           IF (T0(J) + STEP(J).LT.TLIST) THEN
>               CALL NLMOD(J,1)
>           END IF
151c154,155
<       WRITE (6,30)  NAME(IMAX), BMAX, BMAX*ZMBAR, ZMDOT, DE, BE(3),
---
>       if(rank.eq.0)
>      &WRITE (6,30)  NAME(IMAX), BMAX, BMAX*ZMBAR, ZMDOT, DE, BE(3),
164c168,169
<       WRITE (6,45)  IMAX, DE, TEV1, A0, SQRT(VI2), BE(3)
---
>       if(rank.eq.0)
>      &WRITE (6,45)  IMAX, DE, TEV1, A0, SQRT(VI2), BE(3)
175c180
< *       Reduce the steps by velocity factor.
---
> *       Reduce the steps by velocity factor and check NLIST addition.
177a183,185
>           IF (T0(IMAX) + STEP(IMAX).LT.TLIST) THEN
>               CALL NLMOD(IMAX,1)
>           END IF
1,2c1,2
< 1818 2004-10-01 11:20 /work/Umi2/spurzem/5/nbody6compare-oct2006/mlwind.f
< nbody6compare-oct2006/mlwind.f
---
> 1785 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/mlwind.f
> nbody6++compare/mlwind.f
29d28
<             p0 = MIN(p0,2000.d0)
1,2c1,2
< 2410 2006-09-16 20:34 /work/Umi2/spurzem/5/nbody6compare-oct2006/modify.f
< nbody6compare-oct2006/modify.f
---
> 2120 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/modify.f
> nbody6++compare/modify.f
0a1,4
> # 1 "modify.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "modify.F"
4,5c8,9
< *       Parameter modification at restart.
< *       ----------------------------------
---
> * Parameter modification at restart.
> * ----------------------------------
9a14
> # 19 "modify.F"
11c16
< *       Read first, second or both lines (KSTART = 3, 4, 5).
---
> * Read first, second or both lines (KSTART = 3, 4, 5).
14,15c19,22
< *       Read new DTADJ, DELTAT, TADJ, TNEXT, TCRIT, QE & KZ(J) (if > 0).
<       READ (5,*)  DTA, DT, TA, TN, TC, QE1, J, K
---
> * Read new DTADJ, DELTAT, TADJ, TNEXT, TCRIT, QE & KZ(J) (if > 0).
>       if(rank.eq.0)then
>       READ (5,*) DTA, DT, TA, TN, TC, QE1, J, K
>       end if
17c24,26
< *       Copy old parameters if corresponding input is zero.
---
> # 38 "modify.F"
> *
> * Set new parameters if corresponding input is non-zero.
19a29,30
>       ELSE
>           DTA = DTA
23a35,36
>       ELSE
>           DT = DT
43c56
< *       See whether any options should be changed.
---
> * See whether any options should be changed.
46,49c59,60
<       WRITE (6,5)  DTADJ, DELTAT, TCRIT, QE, J, K
<     5 FORMAT (///,7X,'RESTART PARAMETERS:   DTADJ =',F7.3,'  DELTAT =',
<      &                            F7.3,'  TCRIT =',F7.1,'  QE =',1PE9.1,
<      &                                            '  KZ(',I2,') =',I2,/)
---
>       if(rank.eq.0)WRITE (6,5) J, K
>     5 FORMAT (
51c62
< *       Read new ETAI, ETAR, ETAU, DTMIN, RMIN, NCRIT (if > 0 & KSTART >= 4).
---
> * Read new ETAI, ETAR, ETAU, DTMIN, RMIN (IF > 0 & KSTART = 4 or 5).
53c64,67
<           READ (5,*)  ETA1, ETA2, ETA3, DTM, RM, NEWCR
---
>           if(rank.eq.0)then
>           READ (5,*) ETA1, ETA2, ETA3, DTM, RM, NNBO
>           end if
> # 88 "modify.F"
55c69
< *       Check modification of integration parameters.
---
> * Check modification of integration parameters.
68c82
<           IF (NEWCR.GT.0) NCRIT = NEWCR
---
>           IF (NNBO.GT.0) NNBOPT = NNBO
70,73d83
<           WRITE (6,15)  ETAI, ETAR, ETAU, DTMIN, RMIN, NCRIT
<    15     FORMAT (/,7X,'RESTART PARAMETERS:   ETAI =',F6.3,'  ETAR =',
<      &                        F6.3,'  ETAU =',F6.3,'  DTMIN =',1P,E8.1,
<      &                             '  RMIN =',E8.1,'  NCRIT =',0P,I5,/)
76c86
< *       Perform a simple validation check on main input parameters.
---
> * Perform a simple validation check on main input parameters.
79c89
< *       Save the new parameters on tape/disc unit #1 just in case.
---
> * Save the new parameters on tape/disc in case a restart is needed.
1,2c1,2
< 1273 2006-08-27 13:36 /work/Umi2/spurzem/5/nbody6compare-oct2006/mydump.f
< nbody6compare-oct2006/mydump.f
---
> 1773 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/mydump.f
> nbody6++compare/mydump.f
0a1,4
> # 1 "mydump.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "mydump.F"
4,5c8,9
< *       COMMON save or read.
< *       --------------------
---
> * COMMON save or read.
> * --------------------
8,20c12,28
<       PARAMETER  (NA=96*NMAX,NB=111*KMAX+7,
<      &            NC=(LMAX+1)*NMAX+3*KMAX+MLR+MLD+MLV+65,
<      &            NF=44*MMAX,NG=17*NMAX+390,NH=20*MCL+16,
<      &            NO=24*NMAX,NP=2*NMAX+84,NM=32*NTMAX,NR=31*MMAX)
<       REAL*4  A,B,C, E,F,G,H,O,P,Q,PL,R
<       INTEGER  IC,ID,IR
< *
< *
<       COMMON/NBODY/  A(NA)
<       COMMON/PAIRS/  B(NB)
<       COMMON/NAMES/  IC(NC)
<       COMMON/COUNTS/ ID(70)
<       COMMON/PARAMS/ E(334)
---
>       IMPLICIT REAL*8 (A-H,O-Z)
>       PARAMETER (NA=(16*ID+6)*NMAX,NB=65*KMAX+4,
>      & NC=(LMAX+3)*NMAX+3*KMAX+MLR+MLD+MLV+75,ND=71,
>      & NE=163,NF=21*MMAX,NG=5*NMAX+NMAX/2+63,NH=10*MCL+8,
>      & NO=(4*ID+1)*NMAX,NP=66,NQ=2*NMAX+5*LMAX,
>      & NR=3*NMAX,NS=17)
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
>       REAL*8 A,B,E,F,G,H,O,P,R,S
>       INTEGER IC,IDD,IR,IQ
> *
>       COMMON/NBODY/ A(NA)
>       COMMON/PAIRS/ B(NB)
>       COMMON/NAMES/ IC(NC)
>       COMMON/COUNTS/ IDD(ND)
>       COMMON/PARAMS/ E(NE)
22,23c30,32
<       COMMON/STARS/  G(NG)
<       COMMON/MODES/  C(NM)
---
> C Take note that G=real*8, and some members of it (in common6.h)
> C are integer, is. these only add as half words.
>       COMMON/STARS/ G(NG)
25c34
<       COMMON/RAND2/  IR(99)
---
>       COMMON/RAND/ IR(99)
28,30c37,52
<       COMMON/GALAXY/ Q(40)
<       COMMON/PLPOT/  PL(24)
<       COMMON/RCHE/   R(NR)
---
>       COMMON/LISTS/ IQ(NQ)
>       COMMON/WORK2/ R(NR)
>       COMMON/TIMING/ S(NS)
> *
> * Open unit #J by reading dummy and rewinding.
> C GLOBAL_UNIT = J
> 
> 
> 
>          CALL FILE_INIT(J)
>          REWIND J
>          READ (J,ERR=10,END=10) DUMMY
>  10 REWIND J
> 
> 
> 
31a54,55
> * Read or save all COMMON variables (valid for tape or disc).
>       IF (I.EQ.0) THEN
33,36c57,61
< *       Open unit #J by reading dummy and rewinding.
<       REWIND J
<       READ (J,ERR=10,END=10)  DUMMY
<    10 REWIND J
---
> 
> 
> 
>             READ (J) A, B, IC, IDD, E, F, G, H, IR, O, P, IQ, R, S
> # 83 "mydump.F"
38,40d62
< *       Read or save all COMMON variables (valid for tape or disc).
<       IF (I.EQ.0) THEN
<           READ (J)   A, B, IC, ID, E, F, G, C, H, IR, O, P, Q, PL, R
42c64,68
<           WRITE (J)  A, B, IC, ID, E, F, G, C, H, IR, O, P, Q, PL, R
---
> *
> 
> 
> 
>           WRITE (J) A, B, IC, IDD, E, F, G, H, IR, O, P, IQ, R, S
44a71,74
> 
> 
> 
> *
45a76,82
> * Write transition data IC(62) = KZ(39)
> * IF(IC(62).EQ.1)THEN
> * IARG = 1
> * CALL WTRANS(IARG)
> * IARG = 2
> * CALL WTRANS(IARG)
> * END IF
1,2c1,2
< 9955 2006-09-08 14:53 /work/Umi2/spurzem/5/nbody6compare-oct2006/nbint.f
< nbody6compare-oct2006/nbint.f
---
> 8753 2005-03-09 18:57 /work/Umi2/spurzem/5/nbody6++compare/nbint.f
> nbody6++compare/nbint.f
1c1
<       SUBROUTINE NBINT(I,IKS,IR,XI,XIDOT)
---
>       SUBROUTINE NBINT(I,NBFLAG)
9a10,11
> *       Calculate potential with little extra cost.
>       COMMON/POTENT/PHII(NMAX),PHIR(NMAX),PHIR1(NMAX)
11a14,35
>           IF(NBFLAG.EQ.0)THEN
> *       Predict current state vector of body #I to order FDOT.
>           S = TIME - T0(I)
>           DO 11 K = 1,3
>            X(K,I) = ((FDOT(K,I)*S + F(K,I))*S + X0DOT(K,I))*S + X0(K,I)
>            XDOT(K,I) = (3.0*FDOT(K,I)*S + 2.0*F(K,I))*S + X0DOT(K,I)
>    11     CONTINUE
> *       Predict coordinates & velocities of neighbours to order FDOT (R.Sp.).
>           NNB1 = LIST(1,I) + 1
> *
>           DO 1 L = 2,NNB1
>               J = LIST(L,I)
>               S = TIME - T0(J)
>               S1 = 1.5*S
>               S2 = 2.0*S
>               X(1,J) = ((FDOT(1,J)*S + F(1,J))*S +X0DOT(1,J))*S +X0(1,J)
>               X(2,J) = ((FDOT(2,J)*S + F(2,J))*S +X0DOT(2,J))*S +X0(2,J)
>               X(3,J) = ((FDOT(3,J)*S + F(3,J))*S +X0DOT(3,J))*S +X0(3,J)
>               XDOT(1,J) = (FDOT(1,J)*S1 + F(1,J))*S2 + X0DOT(1,J)
>               XDOT(2,J) = (FDOT(2,J)*S1 + F(2,J))*S2 + X0DOT(2,J)
>               XDOT(3,J) = (FDOT(3,J)*S1 + F(3,J))*S2 + X0DOT(3,J)
>    1      CONTINUE
13,17d36
< *       Check regularization criterion for single particles.
<       IF (STEP(I).LT.DTMIN.AND.I.LE.N) THEN
< *       See whether dominant body can be regularized.
<           IF (IKS.EQ.0) THEN
<               CALL SEARCH(I,IKS)
19,44c38,40
<       END IF
< *
< *       Include close encounter search for low-eccentric massive binaries.
<       IF (IKS.EQ.0.AND.STEP(I).LT.4.0*DTMIN) THEN
< *       Consider massive single bodies in absence of subsystems. 
<           IF (I.LE.N.AND.BODY(I).GT.2.0*BODYM.AND.NSUB.EQ.0) THEN
< *
< *       Obtain two-body elements and relative perturbation.
<               JMIN = 0
<               CALL ORBIT(I,JMIN,SEMI,ECC,GI)
< *
<               EB = -0.5*BODY(I)*BODY(JMIN)/SEMI
<               IF (EB.LT.EBH.AND.GI.LT.0.25.AND.JMIN.GE.IFIRST) THEN
<                   APO = SEMI*(1.0 + ECC)
< *       Check eccentricity (cf. max perturbation) and neighbour radius.
<                   IF (ECC.LT.0.5.AND.APO.LT.0.02*RS(I)) THEN
< *                     WRITE (6,3)  NAME(I), NAME(JMIN), ECC, SEMI, EB
< *   3                 FORMAT (' KS TRY:    NAM E A EB ',
< *    &                                     2I6,F7.3,1P,2E10.2)
<                       IKS = IKS + 1
<                       ICOMP = I
<                       JCOMP = JMIN
<                   END IF
<               END IF
<           END IF
<       END IF
---
> *         call cputim(tt2)
> *         ttpre = ttpre + (tt2-tt1)*60.
> *         ttnbp = ttnbp + (tt2-tt1)*60.
46c42
< *       Obtain total force & first derivative.
---
> *       Obtain irregular force & first derivative.
52a49,50
>           PHII(I) = 0.D0
>           NNB0 = LIST(1,I)
55d52
<       NNB0 = LIST(1,I)
74,75d70
<       I2 = 2*IPAIR
<       I1 = I2 - 1
78c73
<       IF (LIST(1,I1).GT.0) THEN
---
>       IF (GAMMA(IPAIR).GE.GMIN) THEN
84,91d78
< *       Copy c.m. coordinates & velocities for rare unperturbed intruder.
<       DO 15 K = 1,3
<           X(K,I1) = XI(K)
<           X(K,I2) = XI(K)
<           XDOT(K,I1) = XIDOT(K)
<           XDOT(K,I2) = XIDOT(K)
<    15 CONTINUE
< *
115d101
< *
118a105
>           PHII(I) = PHII(I) - DR3I*RIJ2
147d133
< *         KDUM = 2*J - 1
177a164,165
> *       Note: in NBODY6++ CHFIRR and FCHAIN are called with IR=1 since
> *             chain prediction and perturber list are updated in integrator.
179c167
<               CALL CHFIRR(I,0,XI,XIDOT,FIRR,FD)
---
>               CALL CHFIRR(I,1,XI,XIDOT,FIRR,FD)
186c174
<                       CALL FCHAIN(I,0,XI,XIDOT,FIRR,FD)
---
>                       CALL FCHAIN(I,1,XI,XIDOT,FIRR,FD)
190c178
<       END IF 
---
>       END IF
197c185
<           CALL XTRNLF(XI,XIDOT,FIRR,FREG,FD,FDUM,0)
---
>           CALL XTRNLF(I,XI,XIDOT,FIRR,FREG,FD,FDUM,0)
200c188
< *       Include the corrector and set new T0, F, FDOT, D1, D2 & D3.
---
> *       Include the corrector and set new F, FDOT, D1, D2 & D3.
203,204c191,192
<       DT6 = 6.0D0/(DT*DTSQ)
<       DT2 = 2.0D0/DTSQ
---
>       DT6 = 6.0/(DT*DTSQ)
>       DT2 = 2.0/DTSQ
207d194
<       T0(I) = TIME
213,214c200,204
< 	  AT3 = 2.0D0*DF + DT*SUM
< 	  BT2 = -3.0D0*DF - DT*(SUM + FID)
---
> 	  AT3 = 2.0*DF + DT*SUM
> 	  BT2 = -3.0*DF - DT*(SUM + FID)
> *       Use here new variables for consistency in parallel execution (R.Sp.)
>           XN(K,I) = XI(K) + (0.6*AT3 + BT2)*DTSQ12
>           XNDOT(K,I) = XIDOT(K) + (0.75*AT3 + BT2)*DT13
216,223c206,207
< 	  X0(K,I) = XI(K) + (0.6D0*AT3 + BT2)*DTSQ12
< 	  X0DOT(K,I) = XIDOT(K) + (0.75D0*AT3 + BT2)*DT13
< *
< *         X0(K,I) = X(K,I)
< *         X0DOT(K,I) = XDOT(K,I)
< *
< 	  FI(K,I) = FIRR(K)
< 	  FIDOT(K,I) = FD(K)
---
>       FI(K,I) = FIRR(K)
>       FIDOT(K,I) = FD(K)
227,230c211,212
<           D0(K,I) = FIRR(K)
<           D1(K,I) = FD(K)
< 	  D2(K,I) = (3.0D0*AT3 + BT2)*DT2
< 	  D3(K,I) = AT3*DT6
---
>           D2(K,I) = (3.0*AT3 + BT2)*DT2
>           D3(K,I) = AT3*DT6
232c214
<    80 CONTINUE
---
>    80 continue
234,235c216,221
< *       Specify new time-step by standard criterion (STEPI version not good).
<       TTMP = TSTEP(FDUM,FD,D2(1,I),D3(1,I),ETAI)
---
> *       Specify new time-step (standard criterion or fast expression).
>         IF (KZ(37).EQ.0) THEN
>           TTMP = TSTEP(FDUM,FD,D2(1,I),D3(1,I),ETAI)
>         ELSE
>           TTMP = STEPI(FDUM,FD,D2(1,I),D3(1,I),ETAI)
>         END IF
237a224,243
> *       Winston Sweatman's suggestion
> *     DVV = (XDOT(1,I)-X0DOT(1,I))**2 + (XDOT(2,I)-X0DOT(2,I))**2 +
> *    &     (XDOT(3,I)-X0DOT(3,I))**2
> *     FFD = FIRR(1)**2 + FIRR(2)**2 + FIRR(3)**2
> *     ETAIW = ETAI
> *     TTMPW = ETAIW*DVV*BODY(I)/FFD
> *
> *     PRINT*,' irr I=',I,' TTMP,TTMPW,RATIO=',
> *    &  TTMP,TTMPW,TTMP/TTMPW
> *
> *     IF(TTMP.GT.TTMPW)THEN
> *     IGT = IGT + 1
> *     ELSE
> *     ILE = ILE + 1
> *     END IF
> *     IF(MOD(IGT+ILE,100).EQ.0)PRINT*,' irr IGT,ILE=',IGT,ILE
> *
> *     TTMP = MAX(TTMPW,TTMP)
> *     DT0 = TTMP
> *
248,260d253
< *       Include convergence test for large step (cf. Makino, Ap.J. 369, 200).
<       IF (TTMP.GT.STEPJ.AND.N.GT.1000) THEN
<          DV2 = 0.0
<          F2 = 0.0
<          DO 85 K = 1,3
<             DV2 = DV2 + (XDOT(K,I) - X0DOT(K,I))**2
<             F2 = F2 + FIRR(K)**2
<    85    CONTINUE
< *       Employ Jun's criterion to avoid over-shooting (cf. Book, 2.16).
<          DTJ = STEP(I)*(1.0D-06*STEP(I)**2*F2/DV2)**0.1
<          TTMP = MIN(TTMP,DTJ)
<       END IF
< *
263,264c256,257
<           IF (DMOD(TIME,2.0*STEP(I)).EQ.0.0D0) THEN 
<               TTMP = MIN(2.0*STEP(I),1.0D0)
---
>           IF (DMOD(TIME,2.0*STEP(I)).EQ.0.0D0) THEN
>               TTMP = MIN(2.0*STEP(I),1.D0)
266c259
<               TTMP = STEP(I) 
---
>               TTMP = STEP(I)
270,271c263,264
<           IF (TTMP.GT.DT0) THEN
<               TTMP = 0.5*TTMP
---
>             IF (TTMP.GT.DT0) THEN
>                 TTMP = 0.5*TTMP
277d269
< *       Set new block step and update next time.
279,310d270
<       TIMENW(I) = STEP(I) + T0(I)
< *
< *       See whether any KS candidates are in the same block as body #I.
<       IF (IKS.GT.0.AND.I.EQ.ICOMP) THEN
< *       Accept same time, otherwise reduce STEP(ICOMP) and/or delay.
<           IF (T0(JCOMP).EQ.T0(ICOMP)) THEN
<               ICOMP = MIN(ICOMP,JCOMP)
<               JCOMP = MAX(I,JCOMP)
<           ELSE IF (T0(JCOMP) + STEP(JCOMP).LT.T0(ICOMP)) THEN
<               STEP(ICOMP) = 0.5D0*STEP(ICOMP)
<               TIMENW(ICOMP) = STEP(ICOMP) + T0(ICOMP)
<               IKS = 0
<           ELSE
<               IKS = 0
<           END IF
<       END IF
< *
< *       See whether total force & derivative needs updating.
<       IF (IR.EQ.0) THEN
< *       Extrapolate regular force & first derivatives to obtain F & FDOT.
<           DTR = TIME - T0R(I)
<           DO 90 K = 1,3
<               F(K,I) = 0.5D0*(FRDOT(K,I)*DTR + FR(K,I) + FIRR(K))
<               FDOT(K,I) = ONE6*(FRDOT(K,I) + FD(K))
<    90     CONTINUE
<       END IF
< *
< *       Increase step counter and count perturbed c.m. steps.
<       NSTEPI = NSTEPI + 1
<       IF (I.GT.N) THEN
<           IF (LIST(1,2*IPAIR-1).GT.0) NSTEPB = NSTEPB + 1
<       END IF
1,2c1,2
< 3307 2005-05-11 04:20 /work/Umi2/spurzem/5/nbody6compare-oct2006/nblist.f
< nbody6compare-oct2006/nblist.f
---
> 3173 2003-06-24 03:52 /work/Umi2/spurzem/5/nbody6++compare/nblist.f
> nbody6++compare/nblist.f
18,23c18
< *       Note possible large RS0 set in routine MERGE at later times.
<           IF (TIME.EQ.0.0D0) THEN
<               RS2 = RS2*(1.0 + RI2)
<           ELSE
<               RS2 = (0.3*RSCALE)**2*(1.0 + RI2)
<           END IF
---
>           RS2 = RS2*(1.0 + RI2)
44c39,40
<               IF (TIME.LE.0.0D0.AND.J.LE.2*NBIN0) GO TO 6
---
>               IF (TIME.LE.0.0D0.AND.(KZ(8).GT.0 .OR. NBIN0.GT.0).AND.
>      &            J.LE.2*NBIN0) GO TO 6
105a102
> 
1,2c1,2
< 2850 2006-09-01 12:05 /work/Umi2/spurzem/5/nbody6compare-oct2006/nbody6.f
< nbody6compare-oct2006/nbody6.f
---
> 4712 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/nbody6.f
> nbody6++compare/nbody6.f
1,14c1,19
< *
< *             N B O D Y 6
< *             ***********
< *
< *       Regularized AC N-body code with triple & binary collisions.
< *       -----------------------------------------------------------
< *
< *       Hermite integration scheme with block-steps (V 7.1.0 09/06).
< *       ------------------------------------------------------------
< *
< *       Developed by Sverre Aarseth, IOA, Cambridge.
< *       ............................................
< *
<       PROGRAM NBODY6
---
> # 1 "nbody6.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "nbody6.F"
>         PROGRAM NBODY6
> *
> * N B O D Y 6++
> * *************
> *
> * Regularized AC N-body code with triple & binary collisions.
> * --------------------------------------------------------
> *
> * Hermite integration scheme with block-steps (V 4.0.0 April/99).
> * ------------------------------------------------------------------
> *
> * Developed by Sverre Aarseth, IOA, Cambridge.
> * ............................................
> * Message Passing Version NBODY6++ for Massively Parallel Systems
> * Developed by Rainer Spurzem, ARI, Heidelberg
17,20c22
<       COMMON/MODES/  EB0(NTMAX),ZJ0(NTMAX),ECRIT(NTMAX),AR(NTMAX),
<      &               BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
<      &               RP(NTMAX),ES(NTMAX),CM(2,NTMAX),IOSC(NTMAX),
<      &               NAMEC(NTMAX)
---
>       COMMON/STSTAT/ TINIT,NIR,NIB,NRGL,NKS
22a25,28
> # 39 "nbody6.F"
> *
> * Initialize the timer.
>       CALL CPUTIM(ttota)
24,25c30,32
< *       Initialize the timer.
<       CALL CPUTIM(CPU0)
---
> * Read start/restart indicator & CPU time.
>       IF(rank.eq.0)READ (5,*) KSTART, TCOMP, TCRITp,
>      * isernb,iserreg
27,28c34
< *       Read start/restart indicator & CPU time.
<       READ (5,*)  KSTART, TCOMP
---
> # 58 "nbody6.F"
32c38
< *       Read input parameters, perform initial setup and obtain output.
---
> * Read input parameters, perform initial setup and obtain output.
34a41
>           call cputim(tt7)
35a43,44
>           call cputim(tt8)
>           ttadj = ttadj + (tt8-tt7)*60.
38c47
< *       Read previously saved COMMON variables from tape/disc on unit 1.
---
> * Read previously saved COMMON variables from tape/disc on unit 1.
39a49
> *
41c51
< *       Safety indicator preventing repeated restarts set in routine CHECK.
---
> * Safety indicator preventing repeated restarts set in routine CHECK.
44c54
< *       Set IPHASE = -1 for new time-step list in routine INTGRT.
---
> * Set IPHASE = -1 for new NLIST in routine INTGRT (Hermite version).
47,50c57,58
< *       Initialize evolution parameters which depend on metallicity.
<           IF (KZ(19).GE.3) THEN
<               CALL ZCNSTS(ZMET,ZPARS)
<           END IF
---
> * Initialize evolution parameters which depend on metallicity.
>           CALL ZCNSTS(ZMET,ZPARS)
52c60
< *       Check reading modified restart parameters (KSTART = 3, 4 or 5).
---
> * Check reading modified restart parameters (KSTART = 3, 4 or 5).
55a64,85
> *
> * Open all other files.
>           CALL FILE_INIT(0)
> *
> * If no explicit new TCRIT given just go for another TCRIT of common block.
>       TTOT = TIME + TOFF
>       TCRIT = TTOT + TCRIT
>       if(rank.eq.0)then
>       WRITE (6,10) TTOT/TCR0, TIME/TCR0, TCRIT/TCR0, TTOT, TIME, TCRIT
>       WRITE (6,20) DTADJ, DELTAT, TADJ, TNEXT, TCRIT, QE
>       WRITE (6,30) ETAI, ETAR, ETAU, DTMIN, RMIN, NNBOPT
>    10 FORMAT (' START AT TTOT/TIME ',2F16.8,' STOP INTENDED AT ',
>      & F16.8,' TCR0',/,' START AT TTOT/TIME ',2F16.8,
>      & ' STOP INTENDED AT ',F16.8,' NBODY-UNITS ',/)
>    20 FORMAT (/,7X,'RESTART PARAMETERS:   DTADJ =',F7.3,'  DELTAT =',
>      & F7.3,'   TADJ =',F7.3,'   TNEXT =',
>      & F7.3,'  TCRIT =',F7.1,'  QE =',1PE9.1)
>    30 FORMAT (/,7X,'                      ETAI =',F7.3,'  ETAR =',
>      & F7.3,'  ETAU =',F7.3,'  DTMIN =',1PE9.1,
>      & '  RMIN =',E9.1,' NNBOPT =',I5,/)
>       end if
> *
58,59c88,104
< *       Advance solutions until next output or change of procedure.
<     1 CALL INTGRT
---
> * (R.Sp.)Set time flag and step number flags for beginning of run
>       TINIT = TTOT
>       NIR = NSTEPI
>       NIB = NSTEPB
>       NRGL = NSTEPR
>       NKS = NSTEPU
> *
>       call cputim(tt2)
>       ttinit = ttinit + (tt2-ttota)*60.
> * Advance solutions until next output or change of procedure.
>     1 CONTINUE
>       call cputim(tt1)
> *
>       CALL INTGRT
> *
>       call cputim(tt2)
>       ttint = ttint + (tt2-tt1)*60.
62c107,108
< *       Prepare new KS regularization.
---
> * Prepare new KS regularization.
>       call cputim(tt1)
63a110,112
>           CALL FLUSH(6)
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
66c115,116
< *       Terminate KS regularization.
---
> * Terminate KS regularization.
>       call cputim(tt1)
67a118,119
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
70c122,123
< *       Perform energy check & parameter adjustments and print diagnostics.
---
> * Perform energy check & parameter adjustments and print diagnostics.
>           call cputim(tt7)
71a125,126
>           call cputim(tt8)
>           ttadj = ttadj + (tt8-tt7)*60.
74c129,130
< *       Switch to unperturbed three-body regularization.
---
> * Switch to unperturbed three-body regularization.
>       call cputim(tt1)
76a133,134
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
79c137,138
< *       Switch to unperturbed four-body regularization.
---
> * Switch to unperturbed four-body regularization.
>       call cputim(tt1)
81a141,142
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
83c144
< *       Adopt c.m. approximation for inner binary in hierarchical triple.
---
> * Adopt c.m. approximation for inner binary in hierarchical triple.
84a146
>       call cputim(tt1)
85a148,149
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
88c152,153
< *       Restore old binary in hierarchical configuration.
---
> * Restore old binary in hierarchical configuration.
>       call cputim(tt1)
89a155,156
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
91c158
< *       Begin chain regularization.
---
> * Begin chain regularization.
92a160
>       call cputim(tt1)
94a163,164
>       call cputim(tt2)
>       ttks = ttks + (tt2-tt1)*60.
97c167
< *       Continue integration.
---
> * Continue integration.
1,2c1,2
< 1565 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/nbpot.f
< nbody6compare-oct2006/nbpot.f
---
> 1565 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/nbpot.f
> nbody6++compare/nbpot.f
1,2c1,2
< 1773 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/nbrem.f
< nbody6compare-oct2006/nbrem.f
---
> 1772 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/nbrem.f
> nbody6++compare/nbrem.f
12c12
<           I = JPERT(LL) 
---
>           I = JPERT(LL)
1,2c1,2
< 1734 2005-03-08 11:35 /work/Umi2/spurzem/5/nbody6compare-oct2006/nbrest.f
< nbody6compare-oct2006/nbrest.f
---
> 1698 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/nbrest.f
> nbody6++compare/nbrest.f
12c12
<           I = JPERT(LL) 
---
>           I = JPERT(LL)
14d13
<           IF (NNB1.EQ.1) GO TO 100
1,2c1,2
< 3451 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/nbsort.f
< nbody6compare-oct2006/nbsort.f
---
> 3689 2000-08-01 14:02 /work/Umi2/spurzem/5/nbody6++compare/nbsort.f
> nbody6++compare/nbsort.f
8c8
<       INTEGER  IBL(LMAX),NBLIST(NMAX),LP(NMAX)
---
>       INTEGER  IBL(NMAX),NBLIST(NMAX),LP(NMAX)
53a54,59
> *     IF(NNB.EQ.0)THEN
> *     PRINT*,' NBLIST L, IBL(1), IBL(L), NBL=',
> *    *   L, IBL(1), IBL(L), NBL
> *     PRINT*,' IFIRST,N,LIST(1,I),STEP=',IFIRST,N,LIST(1,I),STEP(I)
> *     PRINT*,' N,M,X=',NAME(I),BODY(I),(X(K,I),K=1,3)
> *     END IF
61c67
<           INC = (NBLIST(IG) - I)*FAC
---
> *         INC = (NBLIST(IG) - I)*FAC
1,2c1,2
< 3044 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/nbtide.f
< nbody6compare-oct2006/nbtide.f
---
> 3044 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/nbtide.f
> nbody6++compare/nbtide.f
1,2c1,2
< 2957 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/newreg.f
< nbody6compare-oct2006/newreg.f
---
> 2957 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/newreg.f
> nbody6++compare/newreg.f
1,2c1,2
< 891 2005-08-11 12:44 /work/Umi2/spurzem/5/nbody6compare-oct2006/newsys.f
< nbody6compare-oct2006/newsys.f
---
> 891 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/newsys.f
> nbody6++compare/newsys.f
8c8
<       REAL*8  M(*),X(*),XD(*)
---
>       REAL*8  M(1),X(1),XD(1)
1,2c1,2
< 1400 2005-11-23 18:36 /work/Umi2/spurzem/5/nbody6compare-oct2006/offset.f
< nbody6compare-oct2006/offset.f
---
> 1160 2001-08-23 22:24 /work/Umi2/spurzem/5/nbody6++compare/offset.f
> nbody6++compare/offset.f
39,46d38
< *       Check tidal tail members (note TIMENW also needs doing).
<       IF (NTAIL.GT.0) THEN
<           DO 30 I = ITAIL0,NTTOT
<               T0(I) = T0(I) - DTOFF
<               TIMENW(I) = TIMENW(I) - DTOFF
<    30     CONTINUE
<       END IF
< *
48c40
<       IF (TIME.GE.DTOFF) GO TO 1
---
>       IF (TIME.GE.TOFF) GO TO 1
1,2c1,2
< 1530 2005-04-01 14:20 /work/Umi2/spurzem/5/nbody6compare-oct2006/orbit.f
< nbody6compare-oct2006/orbit.f
---
> 2422 2005-03-09 15:28 /work/Umi2/spurzem/5/nbody6++compare/orbit.f
> nbody6++compare/orbit.f
8a9,15
> *       Predict current state vector of body #I to order FDOT. (R.Sp.)
>           S = TIME - T0(I)
>           DO 11 K = 1,3
>               X(K,I) = ((FDOT(K,I)*S + F(K,I))*S + X0DOT(K,I))*S +
>      &                                                           X0(K,I)
>               XDOT(K,I) = (3.0*FDOT(K,I)*S + 2.0*F(K,I))*S + X0DOT(K,I)
>    11     CONTINUE
20a28,31
> *        Predict coordinate (R.Sp.)
>           S = TIME - T0(JJ)
>           X(K,JJ) = ((FDOT(K,JJ)*S + F(K,JJ))*S + X0DOT(K,JJ))*S +
>      &                                                         X0(K,JJ)
24c35
< *       Exclude any c.m. bodies from dominant motion.
---
> *       Exclude any c.m. bodies from dominant motion (
30,31d40
< *       Avoid rare case of halo orbit with zero neighbour number.
<           IF (JM.EQ.I) JM = I - 1
43a53,57
> *       Prediction (R.Sp.)
>           S = TIME - T0(J)
>           X(K,J) = ((FDOT(K,J)*S + F(K,J))*S + X0DOT(K,J))*S +
>      &                                                         X0(K,J)
>           XDOT(K,J) = (3.0*FDOT(K,J)*S + 2.0*F(K,J))*S + X0DOT(K,J)
53a68,72
>       IF (J.LT.IFIRST.AND.TIME.GT.0.D0) THEN
>       WRITE (6,10)  I,J,IFIRST,N,(LIST(K,I),K=2,NNB+1)
>    10 FORMAT (' DANGER!   I J I* N LIST   ',4I5,2X,20(15I5,/))
>       END IF
> *
56a76
> 
1,2c1,2
< 15356 2006-08-16 10:24 /work/Umi2/spurzem/5/nbody6compare-oct2006/output.f
< nbody6compare-oct2006/output.f
---
> 12100 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/output.f
> nbody6++compare/output.f
0a1,4
> # 1 "output.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "output.F"
4,5c8,9
< *       Output and data save.
< *       ---------------------
---
> * Output and data save.
> * ---------------------
8,22c12,23
<       COMMON/BINARY/  CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
<       COMMON/GALAXY/  GMG,RG(3),VG(3),FG(3),FGD(3),TG,
<      &                OMEGA,DISK,A,B,V02,RL2
<       COMMON/ECHAIN/  ECH
<       REAL*8  X1(3,4),V1(3,4),UI(4),VI(4),XREL2(3),VREL2(3)
<       REAL*4  XS(3,NMAX),VS(3,NMAX),BODYS(NMAX),AS(20)
<       REAL*4  XJ(3,6),VJ(3,6),BODYJ(6)
<       LOGICAL  FIRST,SECOND,THIRD
<       SAVE  FIRST,SECOND,THIRD
<       DATA  FIRST,SECOND ,THIRD/.TRUE.,.TRUE.,.TRUE./
< *
< *
< *       Obtain energy error in case routine ADJUST not called recently.
---
>       COMMON/BINARY/ CM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
>      & HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      & NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
>       COMMON/ECHAIN/ ECH
>       REAL*8 X1(3,4),V1(3,4),UI(4),VI(4),XREL2(3),VREL2(3)
>       REAL*4 XS(3,NMAX),VS(3,NMAX),BODYS(NMAX),RHOS(NMAX),AS(20)
>       REAL*4 XJ(3,6),VJ(3,6),BODYJ(6)
>       REAL*4 XNS(NMAX),PHI(NMAX)
> *
> * Call Computation of Moments of Inertia (with Chr. Theis)
>           IF(KZ(39).EQ.2)CALL ELLAN
> * Obtain energy error in case routine ADJUST not called recently.
25c26
< *       Predict X & XDOT for all particles (except unperturbed pairs).
---
> * Predict X & XDOT for all particles (except unperturbed pairs).
28c29,32
< *       Obtain the total energy at current time (resolve all KS pairs).
---
> * Obtain the total energy at current time (resolve all KS pairs).
> 
> 
> 
29a34
> 
31c36
< *       Include KS pairs, triple, quad, mergers, collisions & chain.
---
> * Include KS pairs, triple, quad, mergers, collisions & chain.
33c38
<      &                                                         + ECDOT
---
>      & + ECDOT
38c43
< *       Update energies and form the relative error (divide by ZKIN or ETOT).
---
> * Update energies and form the relative error (divide by ZKIN or ETOT).
44c49
< *       Save sum of relative energy error for main output and accumulate DE.
---
> * Save sum of relative energy error for main output and accumulate DE.
47c52
< *       Find density centre & core radius (Casertano & Hut, Ap.J. 298, 80).
---
> * Find density centre & core radius (Casertano & Hut, Ap.J. 298, 80).
52c57
< *       Check optional sorting of Lagrangian radii & half-mass radius.
---
> * Check optional sorting of Lagrangian radii & half-mass radius.
57c62
< *       Initialize diagnostic variables.
---
> * Initialize diagnostic variables.
63c68
< *       Find smallest semi-major axis and count unperturbed KS pairs.
---
> * Find smallest semi-major axis and count unperturbed KS pairs.
72c77
< *       Perform time-step & neighbour statistics (NS is # single stars).
---
> * Perform time-step & neighbour statistics (NS is # single stars).
84,85c89,90
<           RHO = LIST(1,I)/RS(I)**3
<           CMAX = MAX(CMAX,RHO)
---
>           RHON = LIST(1,I)/RS(I)**3
>           CMAX = MAX(CMAX,RHON)
92c97
< *       Estimate relative cost & effective neighbour number of AC scheme.
---
> * Estimate relative cost & effective neighbour number of AC scheme.
95c100
< *       Scale maximum particle density contrast by the mean value.
---
> * Scale maximum particle density contrast by the mean value.
98c103
< *       Set average neighbour number & density centre displacement.
---
> * Set average neighbour number & density centre displacement.
102c107
< *       Check print frequency indicator & optional model counter.
---
> * Check print frequency indicator & optional model counter.
109c114
< *       Form binary & merger energy ratios and count escapers (or suppress).
---
> * Form binary & merger energy ratios.
112d116
<       CALL JACOBI(NESC)
114c118
< *       Print main output diagnostics.
---
> * Print main output diagnostics.
117,122c121,128
<       WRITE (6,40)  TTOT, N, NNB, NPAIRS, NMERGE, MULT, NS, NSTEPI,
<      &              NSTEPB, NSTEPR, NSTEPU, ERROR, BE(3)
<    40 FORMAT (//,' T =',F7.1,'  N =',I6,'  <NB> =',I3,'  KS =',I5,
<      &           '  NM =',I3,'  MM =',I2,'  NS =',I6,
<      &           '  NSTEPS =',I11,2I10,I11,'  DE =',1P,E9.1,
<      &           '  E =',0P,F10.6)
---
>       IF(rank.EQ.0)THEN
>       WRITE (6,40) rank,
>      & TTOT, N, NNB, NPAIRS, NMERGE, MULT, NS, NSTEPI, NSTEPB,
>      & NSTEPR, NSTEPU, ERROR, BE(3)
>    40 FORMAT (
>      & '  NM =',I2,' MM =',I2,' NS =',I6,' NSTEPS =',
>      & I11,2I10,I11,'  DE =',E15.6,'  E =',F17.6)
>       END IF
125c131,132
<           CALL CPUTIM(TCOMP)
---
>           CALL CPUTIM(ttotb)
>                   TCOMP = ttotb-ttota
131,135c138,144
<           WRITE (6,45)  NRUN, MODEL, TCOMP, TRC, DMIN1, DMIN2, DMIN3,
<      &                  DMIN4, AMIN, RMAX, RSMIN, NEFF
<    45     FORMAT (/,' NRUN =',I3,'  M# =',I3,'  CPU =',F8.1,'  TRC =',
<      &                        F5.1, '  DMIN =',1P,4E8.1,'  AMIN =',E8.1,
<      &                '  RMAX =',E8.1,'  RSMIN =',0P,F5.2,'  NEFF =',I6)
---
>       IF(rank.EQ.0)THEN
>           WRITE (6,45) NRUN, MODEL, TCOMP, TRC, DMIN1, DMIN2, DMIN3,
>      & DMIN4, AMIN, RMAX, RSMIN, NEFF
>    45 FORMAT (/,' NRUN =',I3,'  M# =',I3,'  CPU =',1P,E12.5,0P,
>      & '  TRC =',F5.1, '  DMIN =',1P,4E8.1,'  AMIN =',E8.1,
>      & '  RMAX =',E8.1,'  RSMIN =',0P,F5.2,'  NEFF =',I6)
>       END IF
137a147
>       IF(rank.EQ.0)THEN
139,147c149,157
<    50 FORMAT (/,'    <R>  RTIDE  RDENS   RC    NC   MC   RHOD   RHOM',
<      &                    '  CMAX   <Cn>  Ir/R   UN   NP    RCM    VCM',
<      &                 '         AZ     EB/E   EM/E   TCR     T6  NESC')
< *
<       WRITE (6,55)  RSCALE, RTIDE, RD, RC, NC, ZMC, RHOD, RHOM, CMAX,
<      &              CNNB, COST, IUNP, NP, CMR(4), CMRDOT(4), AZ, EB, EM,
<      &              TCR, I6, NESC
<    55 FORMAT (' #1',F5.2,F6.1,F7.2,F6.2,I5,F7.3,F6.0,F7.0,F6.0,F6.1,
<      &                          F6.2,2I5,F9.3,F8.4,F11.6,2F7.2,F6.2,2I6)
---
>    50 FORMAT (/,'    <R>  RTIDE  RDENS   RC      NC   MC   RHOD   RHOM',
>      & '  CMAX   <Cn>  Ir/R    UN    NP    RCM    VCM',
>      & '         AZ     EB/E   EM/E   TCR     T6')
> *
>       WRITE (6,55) RSCALE, RTIDE, RD, RC, NC, ZMC, RHOD, RHOM, CMAX,
>      & CNNB, COST, IUNP, NP, CMR(4), CMRDOT(4), AZ, EB, EM,
>      & TCR, I6
>    55 FORMAT (' #1',F5.2,F6.1,F7.2,F6.2,I7,F7.3,F6.0,F7.0,F6.0,F6.1,
>      & F6.2,2I6,F9.3,F8.4,F11.6,2F7.3,F6.2,I6)
151,156c161,166
<      &         '    NICONV  NBSMIN  NBDIS  NBDIS2  NCMDER  NBDER',
<      &           '  NFAST  NBFAST    NBLOCK     NBPRED     NBFLUX')
<       WRITE (6,65)  NNPRED, NBCORR, NBFULL, NBVOID, NRCONV, NICONV,
<      &              NBSMIN, NBDIS, NBDIS2, NCMDER, NBDER, NFAST,
<      &              NBFAST, NBLOCK, NBPRED, NBFLUX
<    65 FORMAT (' #2',I10,I10,3I8,I10,I8,I7,2I8,2I7,I8,I10,2I11)
---
>      & '    NICONV  NBSMIN  NBDIS  NBDIS2  NCMDER  NBDER',
>      & '  NFAST  NBFAST    NBLOCK     NBPRED')
>       WRITE (6,65) NNPRED, NBCORR, NBFULL, NBVOID, NRCONV, NICONV,
>      & NBSMIN, NBDIS, NBDIS2, NCMDER, NBDER, NFAST,
>      & NBFAST, NBLOCK, NBPRED
>    65 FORMAT (' #2',I10,I10,3I8,I10,I8,I7,2I8,2I7,I8,I10,I11)
159,165c169,176
<    70 FORMAT (/,5X,'NKSTRY  NKSREG  NKSHYP     NKSPER  NPRECT  NMARG ',
<      &           '  NKSMOD    NTTRY  NTRIP  NQUAD  NCHAIN  NMERG',
<      &           '  NEWHI  NSTEPT  NSTEPQ  NSTEPC')
<       WRITE (6,75)  NKSTRY, NKSREG,  NKSHYP, NKSPER, NPRECT, NMARG,
<      &              NKSMOD, NTTRY, NTRIP, NQUAD, NCHAIN, NMERG, NEWHI,
<      &              NSTEPT, NSTEPQ, NSTEPC
<    75 FORMAT (' #3',I9,I7,I8,I11,I8,I7,2I9,2I7,I8,2I7,3I8)
---
>    70 FORMAT (/,5X,'NKSTRY  NKSREG  NKSHYP     NKSPER  NPRECT  NKSREF',
>      & '  NKSMOD  NTTRY  NTRIP  NQUAD  NCHAIN  NMERG',
>      & '  NSTEPT  NSTEPQ  NSTEPC    NBLCKR    NBFLUX')
>       WRITE (6,75) NKSTRY, NKSREG, NKSHYP, NKSPER, NPRECT, NKSREF,
>      & NKSMOD, NTTRY, NTRIP, NQUAD, NCHAIN, NMERG,
>      & NSTEPT, NSTEPQ, NSTEPC, NBLCKR, NBFLUX
>    75 FORMAT (' #3',3I8,I11,3I8,3I7,I8,I7,3I8,2I10)
>       END IF
167c178
< *       Check output for mass loss or tidal capture.
---
> * Check output for mass loss or tidal capture.
172,187c183
< *       Obtain half-mass radii for two groups (NAME <= NZERO/5 & > NZERO/5).
<       IF (KZ(7).GE.2) THEN
<           CALL LAGR2(RDENS)
<       END IF
< *
< *       Include diagnostics about cluster orbit in general external field.
<       IF (KZ(14).EQ.3) THEN
<           GZ = RG(1)*VG(2) - RG(2)*VG(1)
<           SX = RBAR/1000.0
<           WRITE (6,80)  NTAIL, (RG(K)*SX,K=1,3), (VG(K)*VSTAR,K=1,3),
<      &                  GZ, ETIDE
<    80     FORMAT (/,5X,'CLUSTER ORBIT    NT RG VG JZ ET ',
<      &                                 I5,3F7.2,2X,3F7.1,1P,E16.8,E10.2)
<       END IF
< *
< *       Reset minimum encounter distances & maximum apocentre separation.
---
> * Reset minimum encounter distances & maximum apocentre separation.
195,196c191,192
< *       Check integer overflows (2^{32} or 2.1 billion).
<       IF (NSTEPI.GT.2000000000.OR.NSTEPI.LT.0) THEN
---
> * Check integer overflows (2^{32} or 2.1 billion).
>       IF (NSTEPI.GT.2000000000) THEN
199c195
<       IF (NSTEPU.GT.2000000000.OR.NSTEPU.LT.0) THEN
---
>       IF (NSTEPU.GT.2000000000) THEN
202c198
<       IF (NBPRED.GT.2000000000.OR.NBPRED.LT.0) THEN
---
>       IF (NBPRED.GT.2000000000) THEN
205,207d200
<       IF (NBFLUX.GT.2000000000.OR.NBFLUX.LT.0) THEN
<           NBFLUX = 0
<       END IF
209c202,205
< *       Exit if error exceeds restart tolerance (TIME < TADJ means no CHECK).
---
> * Ensure NLIST does not become large for block-step version.
>       IF (TIME.LT.TBLOCK) TLIST = 0.0
> *
> * Exit if error exceeds restart tolerance (TIME < TADJ means no CHECK).
212,213c208,209
< *       Check optional analysis & output of KS binaries.
<       IF (KZ(8).GT.0.AND.NPAIRS.GT.0) THEN
---
> * Check optional analysis & output of KS binaries.
>       IF ((KZ(8).GT.0 .OR. NBIN0.GT.0) .AND.NPAIRS.GT.0) THEN
217c213
< *       Include optional diagnostics of block-steps.
---
> * Include optional diagnostics of block-steps.
222c218
< *       Check optional output of single bodies & binaries.
---
> * Check optional output of single bodies & binaries.
225,226c221,222
< *       See whether to write data bank of binary diagnostics on unit 9.
<       IF (KZ(8).GE.2.AND.NPAIRS.GT.0) THEN
---
> * See whether to write data bank of binary diagnostics on unit 9.
>       IF ((KZ(8).GE.2 .OR. NBIN0.GT.0) .AND.NPAIRS.GT.0) THEN
233c229
< *       Check optional diagnostics of evolving stars.
---
> * Check optional diagnostics of evolving stars.
234a231,237
> * Update stellar evolution
>               IF (KZ(19).GE.3) THEN
>                   CALL MDOT
>               ELSE
>                   CALL MLOSS
>               END IF
> *
235a239,240
> * Update next output time.
>           TPLOT = TPLOT + DTPLOT
238c243
< *       Check optional writing of data on unit 3 (frequency NFIX). 
---
> * Check optional writing of data on unit 3 (frequency NFIX).
240d244
<       IF (KZ(3).GT.2.AND.KZ(3).NE.5) GO TO 99
242,261c246,249
<       AS(1) = TTOT
<       AS(2) = FLOAT(NPAIRS)
<       AS(3) = RBAR
<       AS(4) = ZMBAR
<       AS(5) = RTIDE
<       AS(6) = TIDAL(4)
<       AS(7) = RDENS(1)
<       AS(8) = RDENS(2)
<       AS(9) = RDENS(3)
<       AS(10) = TTOT/TCR
<       AS(11) = TSCALE
<       AS(12) = VSTAR
<       AS(13) = RC
<       AS(14) = NC
<       AS(15) = VC
<       AS(16) = RHOM
<       AS(17) = CMAX
<       AS(18) = RSCALE
<       AS(19) = RSMIN
<       AS(20) = DMIN1
---
>       DO 80 IPAIR = 1,NPAIRS
>           RHO(2*IPAIR-1) = RHO(N+IPAIR)
>           RHO(2*IPAIR) = RHO(N+IPAIR)
>  80 CONTINUE
263c251
< *       Convert masses, coordinates & velocities to single precision.
---
> * Convert masses, coordinates & velocities to single precision.
265a254,256
>           RHOS(I) = RHO(I)
>           XNS(I) = XNDBL(I)
>           PHI(I) = PHIDBL(I)
269c260
<    85     CONTINUE
---
>    85 CONTINUE
272c263
< *       Replace any ghosts by actual M, R & V (including 2 binaries).
---
> * Replace any ghosts by actual M, R & V (including 2 binaries).
277c268
< *       Determine merger & ghost index for negative c.m. name.
---
> * Determine merger & ghost index for negative c.m. name.
280c271
< *       Note: J is ghost index and IM is merger index.
---
> * Note: J is ghost index and IM is merger index.
285c276
< *       Form global coordinates and velocities from c.m. with XREL & VREL.
---
> * Form global coordinates and velocities from c.m. with XREL & VREL.
293c284
<                   XS(K,J)  = X1(K,2)
---
>                   XS(K,J) = X1(K,2)
295c286
<                   VS(K,J)  = V1(K,2)
---
>                   VS(K,J) = V1(K,2)
297,298c288,289
< *       Look for ghosts of possible second (i.e. outer) merged binary.
<               IF (NAME(J).GT.NZERO) THEN
---
> * Look for ghosts of possible second (i.e. outer) merged binary.
>               IF (NAMEG(J).GT.NZERO) THEN
300,301c291,292
<                   DO  JJ = N+1,NTOT 
<                       IF (NAME(JJ).EQ.NAME(J)) ICM2 = JJ
---
>                   DO JJ = N+1,NTOT
>                       IF (NAME(JJ).EQ.NAMEG(J)) ICM2 = JJ
303c294
< *       Treat the second binary using inactive KS variables.
---
> * Treat the second binary using inactive KS variables.
310c301
< *       Copy KS variables to local scalars.
---
> * Copy KS variables to local scalars.
315c306
< *       Transform to physical variables and multiply by 4 (momentum formula).
---
> * Transform to physical variables and multiply by 4 (momentum formula).
326c317
<                           XS(K,I2)  = X1(K,4)
---
>                           XS(K,I2) = X1(K,4)
328c319
<                           VS(K,I2)  = V1(K,4)
---
>                           VS(K,I2) = V1(K,4)
337c328
< *       Check modification for chain regularization (case NAME(ICM) = 0).
---
> * Check modification for chain regularization (case NAME(ICM) = 0).
341c332
< *       Copy global address from common JLIST (set in CHDATA).
---
> * Copy global address from common JLIST (set in CHDATA).
347,348c338,339
<    97         CONTINUE
<    98     CONTINUE
---
>    97 CONTINUE
>    98 CONTINUE
351,428c342,376
< *       Split into WRITE (3) NTOT & WRITE (3) ..  if disc instead of tape.
<       IF (FIRST) THEN
<           OPEN (UNIT=3,STATUS='NEW',FORM='UNFORMATTED',FILE='OUT3')
<           FIRST = .FALSE.
<       END IF
<       NK = 20
<       WRITE (3)  NTOT, MODEL, NRUN, NK
<       WRITE (3)  (AS(K),K=1,NK), (BODYS(J),J=1,NTOT),
<      &           ((XS(K,J),K=1,3),J=1,NTOT), ((VS(K,J),K=1,3),J=1,NTOT),
<      &           (NAME(J),J=1,NTOT)
< *     CLOSE (UNIT=3)
< *
< *       Produce output file for tidal tail members.
<    99 IF (KZ(3).LE.3.AND.NTAIL.GT.0) THEN
<           IF (SECOND) THEN
<              OPEN (UNIT=33,STATUS='NEW',FORM='UNFORMATTED',FILE='OUT33')
<              SECOND = .FALSE.
<           END IF
<           DO 110 I = ITAIL0,NTTOT
<               BODYS(I) = BODY(I)
<               DO 105 K = 1,3
<                   XS(K,I) = X(K,I) - RG(K)
<                   VS(K,I) = XDOT(K,I) - VG(K)
<   105         CONTINUE
<   110     CONTINUE
< *       Include cluster centre just in case.
<           DO 115 K = 1,3
<               AS(K) = RG(K)
<               AS(K+3) = VG(K)
<               AS(K+6) = RDENS(K)
<   115     CONTINUE
<           AS(10) = TTOT
<           AS(11) = RBAR
<           AS(12) = TSCALE
<           AS(13) = VSTAR
<           NK = 13
<           WRITE (33)  NTAIL, NK
<           WRITE (33)  (AS(K),K=1,NK), (BODYS(J),J=ITAIL0,NTTOT),
<      &                ((XS(K,J),K=1,3),J=ITAIL0,NTTOT),
<      &                ((VS(K,J),K=1,3),J=ITAIL0,NTTOT),
<      &                (NAME(J),J=ITAIL0,NTTOT)
<       END IF
< *
< *       Include all stars in same file (KZ(3) > 3; astrophysical units). 
<       IF (KZ(3).GT.3.AND.NTAIL.GT.0) THEN
<           IF (THIRD) THEN
<               OPEN (UNIT=34,STATUS='NEW',FORM='FORMATTED',FILE='OUT34')
<               THIRD = .FALSE.
<           END IF
<           NP = 0
< *       Copy cluster members with respect to density centre.
<           DO 120 I = IFIRST,NTOT
<               IF (BODY(I).LE.0.0D0) GO TO 120
<               NP = NP + 1
<               DO 118 K = 1,3
<                   XS(K,NP) = (X(K,I) - RDENS(K))*RBAR
<                   VS(K,NP) = XDOT(K,I)*VSTAR
<   118         CONTINUE
<               BODYS(NP) = BODY(I)*SMU
<   120     CONTINUE
<           N1 = NP
< *       Add tidal tail in the same frame.
<           DO 130 I = ITAIL0,NTTOT
<               NP = NP + 1
<               DO 125 K = 1,3
<                   XS(K,NP) = (X(K,I) - RG(K) - RDENS(K))*RBAR
<                   VS(K,NP) = (XDOT(K,I) - VG(K))*VSTAR
<   125         CONTINUE
<               BODYS(NP) = BODY(I)*SMU
<   130     CONTINUE
<           WRITE (34,140)  NP, N1, (TIME+TOFF)*TSCALE, RBAR, VSTAR,
<      &                    (RDENS(K),K=1,3), (RG(K),K=1,3), (VG(K),K=1,3)
<   140     FORMAT (' ',2I6,F8.1,2F6.2,3F7.3,1P,6E10.2)
<           DO 150 I = 1,NP
<               WRITE (34,145) (XS(K,I),K=1,3), (VS(K,I),K=1,3), BODYS(I)
<   145         FORMAT (' ',3F10.3,3F8.1,F7.2)
<   150     CONTINUE
<       END IF
---
>           AS(1) = TTOT
>           AS(2) = FLOAT(NPAIRS)
>           AS(3) = RBAR
>           AS(4) = ZMBAR
>           AS(5) = RTIDE
>           AS(6) = TIDAL(4)
>           AS(7) = RDENS(1)
>           AS(8) = RDENS(2)
>           AS(9) = RDENS(3)
>           AS(10) = TTOT/TCR0
>           AS(11) = I6
>           AS(12) = FLOAT(NZERO)
>           AS(13) = RC
>           AS(14) = NC
>           AS(15) = VC
>           AS(16) = RHOM
>           AS(17) = CMAX
>           AS(18) = RSCALE
>           AS(19) = RSMIN
>           AS(20) = DMIN1
>           NK = 20
> *
> * Write all data in binary format on unit 3 = conf.3.
> *
> 
> 
> 
>           WRITE (3) NTOT, MODEL, NRUN, NK
>           WRITE (3) (AS(K),K=1,NK),
>      & (BODYS(J),J=1,NTOT),(RHOS(J),J=1,NTOT),(XNS(J),J=1,NTOT),
>      & ((XS(K,J),K=1,3),J=1,NTOT), ((VS(K,J),K=1,3),J=1,NTOT),
>      & (PHI(J),J=1,NTOT),(NAME(J),J=1,NTOT)
> 
> 
> 
430c378
< *       Update next output interval and initialize the corresponding error.
---
> * Update next output interval and initialize the corresponding error.
1,2c1,2
< 882 2006-08-18 10:35 /work/Umi2/spurzem/5/nbody6compare-oct2006/params.h
< nbody6compare-oct2006/params.h
---
> 1301 2005-03-09 17:47 /work/Umi2/spurzem/5/nbody6++compare/params.h
> nbody6++compare/params.h
4,6c4,13
< *     PARAMETER  (NMAX=4010,KMAX=1010,LMAX=100,MMAX=10,
<       PARAMETER  (NMAX=5110,KMAX=1010,LMAX=150,MMAX=102,
<      &            MLD=22,MLR=22,MLV=10,MCL=10,NCMAX=10,NTMAX=100)
---
>       PARAMETER  (NMAX=140000,KMAX=5000,LMAX=128,MMAX=60,
> *     PARAMETER  (NMAX=50000,KMAX=50,LMAX=64,MMAX=60,
> *     PARAMETER  (NMAX=25000,KMAX=5000,LMAX=128,MMAX=60,
> *     PARAMETER  (NMAX=16384,KMAX=50,LMAX=64,MMAX=60,
> *     PARAMETER  (NMAX=10100,KMAX=3000,LMAX=256,MMAX=60,
> *     PARAMETER  (NMAX=5100,KMAX=2000,LMAX=256,MMAX=60,
> *     PARAMETER  (NMAX=1010,KMAX=50,LMAX=60,MMAX=1,
>      &            MLD=60,MLR=60,MLV=60,MCL=1,NCMAX=10)
>       PARAMETER  (ID=3)
>       parameter (maxpe=1024)
10c17
< *       NMAX    Maximum number of single bodies + 3*NBIN + NHI.
---
> *       NMAX    Maximum number of single bodies & c.m.
18c25
< *       NCMAX   Maximum number of chain members (do not change).
---
> *       NCMAX   Maximum members of chain members.
20c27,28
< *
---
> *       ID      First dimension of 3d-vectors (usually = 3)
> *               Has to be set to 4 on CRAY T3D for hardware reasons
1,2c1,2
< 1893 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/peri.f
< nbody6compare-oct2006/peri.f
---
> 1893 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/peri.f
> nbody6++compare/peri.f
1,2c1,2
< 1526 2005-03-08 19:28 /work/Umi2/spurzem/5/nbody6compare-oct2006/permit.f
< nbody6compare-oct2006/permit.f
---
> 912 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/permit.f
> nbody6++compare/permit.f
1c1
<       SUBROUTINE PERMIT(PERIM,IGO)
---
>       SUBROUTINE PERMIT(RPERT,IGO)
4c4
< *       Check on existing multiple regularization.
---
> *       Permission for unperturbed triple or quad.
8,9d7
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
<       REAL*8  M,MASS,MC,MIJ,MKK
12,15d9
<       COMMON/CHAIN1/  XCH(NMX3),VCH(NMX3),M(NMX),
<      &                ZZ(NMX3),WC(NMX3),MC(NMX),
<      &                XI(NMX3),PI(NMX3),MASS,RINV(NMXm),RSUM,MKK(NMX),
<      &                MIJ(NMX,NMX),TKK(NMX),TK1(NMX),INAME(NMX),NN
18c12
< *       Search any existing subsystem.
---
> *       Search any existing subsystems.
20d13
<       ICHSUB = 1
22,28c15,19
< *       Identify chain pointer for possible reduction of STEPS.
<           IF (ISYS(L).EQ.3) ICHSUB = ISYS(L)
< *       Distinguish between triple & quad case (denoted ISUB = 1 or 2).
<           IF (JCOMP.LE.N.AND.NAMES(4,L).EQ.0) THEN
<               ISUB = 1
<       ELSE IF (JCOMP.GT.N.AND.NAMES(4,L).GT.0) THEN
<               ISUB = 2
---
> *       Distinguish between triple, quad & chain case.
>           IF (JCOMP.LE.N.AND.ISYS(L).EQ.1) THEN
>               ISUB = L
>           ELSE IF (JCOMP.GT.N.AND.ISYS(L).GE.2) THEN
>               ISUB = L
34,40c25,28
< *       See whether the case ISUB = 1 or 2 is used already.
<           DO 20 L = 1,NSUB
<               IF (ISUB.EQ.ISYS(L)) IGO = 1
<    20     CONTINUE
< *       Enforce chain termination at next extension if new system < RSUM/2.
<           IF (PERIM.LT.0.5*RSUM.AND.IGO.GT.0) THEN
<               STEPS(ICHSUB) = 0.0
---
>           IGO = 1
> *       Enforce termination at next extension if new system is smaller.
>           IF (RPERT.LT.RMAXS(ISUB)) THEN
>               STEPS(ISUB) = 0.0D0
1,2c1,2
< 1313 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/pfac.f
< nbody6compare-oct2006/pfac.f
---
> 1313 1999-12-23 13:25 /work/Umi2/spurzem/5/nbody6++compare/pfac.f
> nbody6++compare/pfac.f
1,2c1,2
< 875 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/physks.f
< nbody6compare-oct2006/physks.f
---
> 875 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/physks.f
> nbody6++compare/physks.f
1,2c1,2
< 400 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/qforce.f
< nbody6compare-oct2006/qforce.f
---
> 400 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/qforce.f
> nbody6++compare/qforce.f
1,2c1,2
< 5176 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/qpmod3.f
< nbody6compare-oct2006/qpmod3.f
---
> 5177 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/qpmod3.f
> nbody6++compare/qpmod3.f
143c143
<      &                              2I5,1P,E10.2,0P,2F8.3,F9.1,1P,E10.2)
---
>      &                                 2I5,1PE10.2,0P2F8.3,F9.1,1PE10.2)
149a150
> 
1,2c1,2
< 4205 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/qpmod4.f
< nbody6compare-oct2006/qpmod4.f
---
> 4206 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/qpmod4.f
> nbody6++compare/qpmod4.f
127c127
<      &                              2I5,1P,E10.2,0P,2F8.3,F9.1,1P,E10.2)
---
>      &                                 2I5,1PE10.2,0P2F8.3,F9.1,1PE10.2)
132a133
> 
1,2c1,2
< 8889 2006-09-07 18:14 /work/Umi2/spurzem/5/nbody6compare-oct2006/qpmod.f
< nbody6compare-oct2006/qpmod.f
---
> 6999 2003-06-23 19:32 /work/Umi2/spurzem/5/nbody6++compare/qpmod.f
> nbody6++compare/qpmod.f
8a9,10
>       LOGICAL  KSLOW,KCOLL
>       REAL*8  KSCH
11a14
>       COMMON/SLOW1/   TK2(0:NMX),EJUMP,KSCH(NMX),KSLOW,KCOLL
18c21
< *       Skip for small dissipation (ISYNC > 0 delays further calls).
---
> *       Skip for small dissipation (ISYNC > 0 prevents further calls).
33d35
<       KSTARI = 0
50,58c52,53
< *       Choose between chaos treatment and PT or GR formulation.
<       IF (KZ27.EQ.2) THEN
<           IDIS = 0
<           CALL CHAOS2(K1,K2,ECC,H,IS,MB,MU,RADIUS,SEMI1,ECC1,DH,IDIS,
<      &                                                           KSTARI)
< *       Exit on reaching circular orbit or spiralling stage (also collision).
<           IF (KSTARI.EQ.-1) GO TO 2
<           GO TO 90
<       END IF
---
> *       Obtain the tidal energy change for PT.
>       CALL TIDES(QPERI,M(K1),M(K2),RADIUS(1),RADIUS(2),IS,DE)
60,82d54
< *       Consider sequential circularization or GR case.
<       IF (KZ27.EQ.1) THEN
<           AM0 = SEMI*(1.0D0 - ECC**2)
<           ECC2 = ECCM2
<           ECC1 = SQRT(ECC2)
<           ACIRC = AM0/(1.0 - ECC2)
< *       Accept circularized orbit directly if ACIRC < 4*R.
<           IF (ACIRC.LT.4.0*R1) THEN
<               SEMI1 = ACIRC
<           ELSE
< *       Obtain E1 by (1 + E1) = AM0/(4*R1) and A1 by A1*(1 - E1) = 4*R1.
<               ECC1 = 0.25*AM0/R1 - 1.0
<               ECC1 = MAX(ECC1,ECCM)
<               ECC1 = MAX(ECC1,0.9*ECC)
<               SEMI1 = AM0/(1.0 - ECC1**2)
<           END IF
< *       Form the corresponding energy change.
<           DH = 0.5*MB*(1.0/SEMI - 1.0/SEMI1)
<           DE(1) = -MU*DH
<           DE(2) = 0.0
<       ELSE
< *       Obtain the tidal energy change for GR.
<           CALL TIDES3(QPERI,M(K1),M(K2),VSTAR1,H,ECC,DE)
84,92c56,58
<           DH = -(DE(1) + DE(2))/MU
<           IF (H + DH.LT.-0.5*MB*RINV(IM)) THEN
<               DH = -0.5*MB*RINV(IM) - H
<           END IF
<           SEMI1 = -0.5*MB/(H + DH)
<           ECC1 = 1.0 - PERI/SEMI1
<           ECC1 = MAX(ECC1,0.0D0)
< *       Note: Do not impose minimum ECCM unless with 2nd alternative C2.
< *         ECC1 = MAX(ECC1,ECCM)
---
>       DH = -(DE(1) + DE(2))/MU
>       IF (H + DH.LT.-0.5*MB*RINV(IM)) THEN
>           DH = -0.5*MB*RINV(IM) - H
100,106c66,70
< *       Adopt instantaneous circularization instead of standard PT.
< *     ECC2 = ECCM2
< *     ECC1 = SQRT(ECC2)
< *     SEMI1 = AM0/(1.0 - ECC2)
< *     DH = 0.5*MB*(1.0/SEMI - 1.0/SEMI1)
< *     DE(1) = -MU*DH
< *     DE(2) = 0.0
---
> *       Adopt sequential circularization instead of standard PT.
>       ECC2 = ECCM2
>       ECC1 = SQRT(ECC2)
>       ACIRC = AM0/(1.0 - ECC2)
>       R1 = MAX(RADIUS(1),RADIUS(2))
108c72,88
< *       Skip on final hyperbolic energy.
---
> *       Accept circularized orbit directly if ACIRC < 4*R.
>       IF (ACIRC.LT.4.0*R1) THEN
>           SEMI1 = ACIRC
>       ELSE
> *       Obtain E1 by (1 + E1) = AM0/(4*R1) and A1 by A1*(1 - E1) = 4*R1.
>           ECC1 = 0.25*AM0/R1 - 1.0
>           ECC1 = MAX(ECC1,ECCM)
>           ECC1 = MAX(ECC1,0.9*ECC)
>           SEMI1 = AM0/(1.0 - ECC1**2)
>       END IF
> *
> *       Form the corresponding energy change.
>       DH = 0.5*MB*(1.0/SEMI - 1.0/SEMI1)
>       DE(1) = -MU*DH
>       DE(2) = 0.0
> *
> *       Skip on possible hyperbolic case.
112c92
<     2 PERI1 = SEMI1*(1.0D0 - ECC1)
---
>       PERI1 = SEMI1*(1.0D0 - ECC1)
120,125c100
<       IF (KZ27.EQ.1.OR.KSTARI.EQ.-2) THEN
<           C2 = 1.0/C1**2
<       ELSE
<           C2 = SQRT((MB + H*PERI1)/(MB + HI*PERI))
< *       Note: since PERI1 = PERI this is same as used for KZ27 = 2.
<       END IF
---
>       C2 = 1.0/C1**2
128,155c103,106
<       IF (ECC1.LE.ECCM.AND.KZ27.EQ.1) THEN
<           AM = SEMI1*(1.0D0 - ECC1**2)
<           C2 = (AM/AM0)/C1**2
<       END IF
< *
< *       Include alternative formulation of Mikkola (which is equivalent).
<       IF (KZ27.LT.-1) THEN
< *       Note this derivation may contain assumption of J = const (10/6/99).
<           V02 = MB*(2.0/QPERI - 1.0/SEMI)
<           A1 = MB/(QPERI*V02)
<           A2 = MB/(V02*SEMI1)
< *       Adopt reduced energy loss in case of imaginary solution.
<           IF (A1**2.GT.A2) THEN
<               A3 = A1 + SQRT(A1**2 - A2)
<           ELSE
<               A3 = A1
<               WRITE (6,5)  A1, A2, SQRT(1.0/A3), A3, C1
<     5         FORMAT (' WARNING!    QPMOD    A1 A2 SQRT(1/A3) A3 C1  ',
<      &                                       1P,2E10.2,0P,3F12.6)
<           END IF
<           C2 = A3
<       END IF
< *
< *       Derive scale factor from velocity ratio for chaotic motion.
<       IF (KZ27.EQ.2.AND.KSTARI.EQ.-1) THEN
<           C2 = SQRT((H + MB/PERI1)/(HI + MB/PERI))
< *       Note the use of physical velocity here vs UDOT in routine KSTIDE.
<       END IF
---
> *     IF (ECC1.LE.0.002) THEN
> *         AM = SEMI1*(1.0D0 - ECC1**2)
> *         C2 = (AM/AM0)/C1**2
> *     END IF
170c121
< *         P11 = A3*(M(K2)*PI(J1+K) - M(K1)*PI(J2+K))/MB
---
> *         P11 = C2*(M(K2)*PI(J1+K) - M(K1)*PI(J2+K))/MB
248,249c199
<    75     FORMAT (/,' QPMOD:   EN1 ERR DE A A1 DP ',
<      &                         F10.6,1P,5E10.2)
---
>    75     FORMAT (' QPMOD:    EN1 ERR DE A A1 DP ',F10.6,1P,5E10.2)
254a205,206
>           WRITE (6,78)  NAMEC(K1), NAMEC(K2), ECC, ECC1, QPERI/R1
>    78     FORMAT (' CHAIN CIRC    NAM E EF QP/R1 ',2I6,2F7.3,F5.1)
261c213
<      &                           2I6,1P,E10.2,0P,2F8.4,F9.1,1P,2E10.2)
---
>      &                           2I5,1P,E10.2,0P,2F8.4,F9.1,1P,2E10.2)
269a222,223
> 
> 
1,2c1,2
< 11956 2006-02-04 14:49 /work/Umi2/spurzem/5/nbody6compare-oct2006/quad.f
< nbody6compare-oct2006/quad.f
---
> 11909 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/quad.f
> nbody6++compare/quad.f
214d213
<               DMINC = MIN(RCOLL,DMINC)
318,320c317,319
<    80     FORMAT (/,' QUAD BINARY','  MB =',F7.4,'  A =',1P,E8.1,
<      &     '  E =',0P,F5.2,'  EB =',F7.4,'  GB =',1P,E8.1,'  G4 =',E8.1,
<      &     '  RB1 =',E8.1,'  EB1 =',0P,F5.2,'  E1 =',F5.2,'  ET =',F6.3)
---
>    80     FORMAT (/,' BINARY','  MB =',F7.4,'  A =',1PE8.1,
>      &       '  E =',0PF5.2,'  EB =',F5.2,'  GB =',1PE8.1,'  G4 =',E8.1,
>      &      '  RB1 =',E8.1,'  EB1 =',0PF5.2,'  E1 =',F5.2,'  ET =',F6.3)
329,330c328,329
<    90     FORMAT (/,' END QUAD   ',4I3,'  RB =',1P,E8.1,'  R13 =',E8.1,
<      &              '  R24 =',E8.1,'  RG =',E8.1,'  TC =',0P,F5.1,'  #',
---
>    90     FORMAT (/,' END QUAD   ',4I3,'  RB =',1PE8.1,'  R13 =',E8.1,
>      &              '  R24 =',E8.1,'  RG =',E8.1,'  TC =',0PF5.1,'  #',
1,2c1,2
< 652 2004-04-03 18:10 /work/Umi2/spurzem/5/nbody6compare-oct2006/r2sort.f
< nbody6compare-oct2006/r2sort.f
---
> 652 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/r2sort.f
> nbody6++compare/r2sort.f
1,2c1,2
< 749 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ran2.f
< nbody6compare-oct2006/ran2.f
---
> 1059 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/ran2.f
> nbody6++compare/ran2.f
1,32c1,34
<       FUNCTION RAN2(IDUM)
< *
< *
< *       Random number generator (Press p. 195).
< *       ---------------------------------------
< *
<       PARAMETER (M=714025,IA=1366,IC=150889,RM=1./M)
<       COMMON/RAND2/  IY,IFF,IR(97) 
< *     DATA  IFF /0/
< *
< *
<       IF (IDUM.LT.0.OR.IFF.EQ.0) THEN
<           IFF = 1
<           IDUM = MOD(IC-IDUM,M)
<           DO 11 J = 1,97
<               IDUM = MOD(IA*IDUM+IC,M)
<               IR(J) = IDUM
<    11     CONTINUE
<           IDUM = MOD(IA*IDUM+IC,M)
<           IY = IDUM
<       END IF
<       J = 1 + (97*IY)/M
<       IF (J.GT.97.OR.J.LT.1) WRITE (6,12)  J, IDUM
<    12 FORMAT (/,'  TROUBLES IN RAN2   J IDUM ',2I12)
<       IY = IR(J)
<       RAN2 = IY*RM
<       IDUM = MOD(IA*IDUM+IC,M)
<       IR(J) = IDUM
< *
<       RETURN
< *
<       END 
---
>       FUNCTION ran2(idum)
>       INTEGER idum,IM1,IM2,IMM1,IA1,IA2,IQ1,IQ2,IR1,IR2,NTAB,NDIV
>       REAL ran2,AM,EPS,RNMX
>       PARAMETER (IM1=2147483563,IM2=2147483399,AM=1./IM1,IMM1=IM1-1,
>      *IA1=40014,IA2=40692,IQ1=53668,IQ2=52774,IR1=12211,IR2=3791,
>      *NTAB=32,NDIV=1+IMM1/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
>       INTEGER idum2,j,k,iv(NTAB),iy
>       SAVE iv,iy,idum2
>       DATA idum2/123456789/, iv/NTAB*0/, iy/0/
>       if (idum.le.0) then
>         idum=max(-idum,1)
>         idum2=idum
>         do 11 j=NTAB+8,1,-1
>           k=idum/IQ1
>           idum=IA1*(idum-k*IQ1)-k*IR1
>           if (idum.lt.0) idum=idum+IM1
>           if (j.le.NTAB) iv(j)=idum
> 11      continue
>         iy=iv(1)
>       endif
>       k=idum/IQ1
>       idum=IA1*(idum-k*IQ1)-k*IR1
>       if (idum.lt.0) idum=idum+IM1
>       k=idum2/IQ2
>       idum2=IA2*(idum2-k*IQ2)-k*IR2
>       if (idum2.lt.0) idum2=idum2+IM2
>       j=1+iy/NDIV
>       iy=iv(j)-idum2
>       iv(j)=idum
>       if(iy.lt.1)iy=iy+IMM1
>       ran2=min(AM*iy,RNMX)
>       return
>       END
> C  (C) Copr. 1986-92 Numerical Recipes Software >).
1,2c1,2
< 4165 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/rchain.f
< nbody6compare-oct2006/rchain.f
---
> 4190 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/rchain.f
> nbody6++compare/rchain.f
30d29
<       JC = 0
31a31
>       JC = 0
66a67
>               DTAU0 = DS
1,2c1,2
< 7884 2006-09-01 12:10 /work/Umi2/spurzem/5/nbody6compare-oct2006/recoil.f
< nbody6compare-oct2006/recoil.f
---
> 7755 2005-03-11 11:33 /work/Umi2/spurzem/5/nbody6++compare/recoil.f
> nbody6++compare/recoil.f
18a19,21
>       INCLUDE 'mpif.h'
>       INTEGER group,rank,ierr,isize,status(MPI_STATUS_SIZE)
>       COMMON/MPIDAT/group,rank,ierr,isize,status
26a30,31
> *       Set redundant index for N = 3.
>       IF (N.EQ.3) I4 = I1
30,46d34
<       ELSE IF (N.EQ.3) THEN
<           I4 = I1
<       ELSE IF (N.GE.4) THEN
< *       Determine indices of second closest pair (avoid pair I1-I2).
<           RX1 = 1.0
<           RX0 = R2(I1,I2)
<           DO 2 J1 = 1,N
<               IF (J1.EQ.I1.OR.J1.EQ.I2) GO TO 2
<               DO 1 J2 = J1+1,N
<                   IF (J2.EQ.I1.OR.J2.EQ.I2) GO TO 1
<                   IF (R2(J1,J2).LT.RX1.AND.R2(J1,J2).GT.RX0) THEN
<                       RX1 = R2(J1,J2)
<                       I3 = J1
<                       I4 = J2
<                   END IF
<     1         CONTINUE
<     2     CONTINUE
48,49c36,45
<       K1 = I3
<       K2 = I4
---
> *
> *       Define indices (K1,K2) for the second closest distance.
>       IF (R2(I2,I3).LT.R2(I1,I3)) THEN
>           K1 = I2
>           K2 = I3
>           IF (N.EQ.2) K2 = I1
>       ELSE
>           K1 = I1
>           K2 = I3
>       END IF
136c132
< *         IF (TIMEC.GT.0.0D0) GO TO 50
---
>           IF (TIMEC.GT.0.0D0) GO TO 50
175d170
<           IF (N.GT.4) RM = MAX(R13,R24)
195c190
<       IF (NAME1 + NAME2.NE.NAMEC(I1) + NAMEC(I2).AND.EB.LT.0.0) THEN
---
>       IF (NAME1 + NAME2.NE.NAMEC(I1) + NAMEC(I2)) THEN
198c193,194
<           WRITE (6,15)  TCH, NAME1, NAME2, NAMEC(I1), NAMEC(I2), ECC0,
---
>           if (rank.eq.0)
>      &    WRITE (6,15)  TCH, NAME1, NAME2, NAMEC(I1), NAMEC(I2), ECC0,
210c206,207
<           WRITE (6,20)  NAMEC(I1), NAMEC(I2), SEMI, ECC, EB, GB, G4,
---
>           if (rank.eq.0)
>      &    WRITE (6,20)  NAMEC(I1), NAMEC(I2), SEMI, ECC, EB, GB, G4,
212,215c209,212
<    20     FORMAT (' CHAIN BINARY','  NAM =',2I6,'  A =',1P,E8.1,
<      &            '  E =',0P,F5.2,'  EB =',F5.2,'  GB =',1P,E8.1,
<      &            '  G4 =',E8.1,'  EB1 =',0P,F5.2,'  E1 =',F5.2,
<      &            '  ET =',F6.3,'  DB =',F5.1)
---
>    20     FORMAT (/,' CHAIN BINARY','  NAM =',2I6,'  A =',1P,E8.1,
>      &              '  E =',0P,F5.2,'  EB =',F5.2,'  GB =',1P,E8.1,
>      &              '  G4 =',E8.1,'  EB1 =',0P,F5.2,'  E1 =',F5.2,
>      &              '  ET =',F6.3,'  DB =',F5.1)
219c216
<       IF (IEND.EQ.2.AND.PMIN.LT.2.0*SEMI.AND.DB.GT.0.1) THEN
---
>       IF (IEND.EQ.2.AND.PMIN.LT.3.0*SEMI.AND.ECC1.GT.1.0) THEN
221,222c218,220
<           WRITE (6,25)  NAMEC(I3), ECC, ECC1, PMIN/SEMI, RCDOT/RCP,
<      &                  SEMI, A1, RCP, GB, 180.0*ALPHA/3.14
---
>           if (rank.eq.0)
>      &    WRITE (6,25)  NAMEC(I3), ECC, ECC1, PMIN/SEMI, RCDOT/RCP,
>      &                  SEMI, A1, RCP, GB, ALPHA
232c230,231
<           WRITE (6,30)  I1, I2, I3, I4, RB, R13, R24, DE, TC, NSTEP1,
---
>           if (rank.eq.0)
>      &    WRITE (6,30)  I1, I2, I3, I4, RB, R13, R24, DE, TC, NSTEP1,
234c233
<    30     FORMAT (/,' END CHAIN  ',4I3,'  RB =',1PE8.1,'  R13 =',E8.1,
---
>    30     FORMAT (/,' END CHAIN  ',4I3,'  RB =',1P,E8.1,'  R13 =',E8.1,
1,2c1,2
< 742 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/redraw.f
< nbody6compare-oct2006/redraw.f
---
> 742 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/redraw.f
> nbody6++compare/redraw.f
9c9
<       INTEGER IC(*),ICC(2),IJ(NMXM,2)
---
>       INTEGER IC(1),ICC(2),IJ(NMXM,2)
1,2c1,2
< 8649 2006-09-02 13:20 /work/Umi2/spurzem/5/nbody6compare-oct2006/reduce.f
< nbody6compare-oct2006/reduce.f
---
> 8856 2002-08-12 22:10 /work/Umi2/spurzem/5/nbody6++compare/reduce.f
> nbody6++compare/reduce.f
35c35,38
<       IF (KZ(30).GT.2) THEN
---
> *       Enforce exit from SUBINT (new value set on return to INTGRT).
>       TBLOCK = TPREV
> *
>       IF (rank.eq.0.and.KZ(30).GT.2) THEN
94c97,98
<               IF (BODY(J).GT.0.0D0) WRITE (6,35)  I, IESC, NAMEC(IESC)
---
>               IF (rank.eq.0.and.BODY(J).GT.0.0D0) 
>      &            WRITE (6,35)  I, IESC, NAMEC(IESC)
117c121
<       WRITE (6,48)  IESC, NAMEC(NEW)
---
>       if(rank.eq.0)WRITE (6,48)  IESC, NAMEC(NEW)
134c138
<       IF (KZ(30).GT.1) THEN
---
>       IF (rank.eq.0.and.KZ(30).GT.1) THEN
232d235
<           CALL FPOLY2(I,I,0)
237a241,242
>           CALL FPOLY2(I,I,0)
>           CALL HIVEL(I)
276c281
<       IF (KZ(30).GT.2) THEN
---
>       IF (rank.eq.0.and.KZ(30).GT.2) THEN
286a292,293
> 
> 
1,2c1,2
< 1006 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/reflct.f
< nbody6compare-oct2006/reflct.f
---
> 1039 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/reflct.f
> nbody6++compare/reflct.f
15c15
< *       Obtain radial velocity with respect to the inertial centre.
---
> *       Obtain radial velocity assuming small density centre displacement.
38a39,40
> *     NBREF = NBREF + 1
> *
1,2c1,2
< 21350 2006-09-08 14:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/regint.f
< nbody6compare-oct2006/regint.f
---
> 21522 2005-04-13 16:11 /work/Umi2/spurzem/5/nbody6++compare/regint.f
> nbody6++compare/regint.f
1,2c1
<       SUBROUTINE REGINT(I,XI,XIDOT)
< *
---
>       SUBROUTINE REGINT(I,KLIST)
9a9,11
> *       Calculate potential with little extra cost.
>       COMMON/POTENT/PHII(NMAX),PHIR(NMAX),PHIR1(NMAX)
>       REAL*8  W0(4),W1(4),W2(4),W3(4)
11c13,15
<       REAL*8  FRX(3),FDX(3)
---
>       INTEGER ESCFLG(NMAX)
> *
>       INTEGER KLIST(LMAX)
12a17,20
>       DO 6 K = 1,3
>           XI(K) = X(K,I)
>           XIDOT(K) = XDOT(K,I)
>    6  CONTINUE
14,15c22,23
< *       Set neighbour number, time-step & choice of central distance.
<       NNB0 = LIST(1,I)
---
> *       Copy uncorrected X and set time-step & central distance.
>       NNB0 = KLIST(1)
18,25c26,28
<       IF (KZ(39).EQ.0) THEN
<           RI2 = (XI(1) - RDENS(1))**2 + (XI(2) - RDENS(2))**2 +
<      &                                  (XI(3) - RDENS(3))**2
<           RH2 = RSCALE**2
<       ELSE
<           RI2 = XI(1)**2 + XI(2)**2 + XI(3)**2
<           RH2 = 9.0*RSCALE**2
<       END IF
---
>       RI2 = (XI(1) - RDENS(1))**2 + (XI(2) - RDENS(2))**2 +
>      &                              (XI(3) - RDENS(3))**2
>       RH2 = RSCALE**2
42a46,48
>       PHII(I) = 0.D0
>       PHIR(I) = 0.D0
>       PHIR1(I) = 0.D0
46,48c52,53
< *       Treat unperturbed KS in the single particle approximation.
<          I1 = 2*(I - N) - 1
<          IF (LIST(1,I1).GT.0) THEN
---
> *       See whether perturbation allows single particle approximation.
>           IF (GAMMA(I-N).GE.GMIN) THEN
52c57
<          END IF
---
>           END IF
55a61
>           call cputim(tt1)
56a63,65
> *RSP
>           IF (J.EQ.I) GO TO 10
> *RSP
65a75,76
>           DR2I = 1.0/RIJ2
>           DR3I = BODY(J)*DR2I*SQRT(DR2I)
66a78
>           DRDP = 3.0*DRDV*DR2I
68c80
< *       First see whether the distance exceeds the outer shell radius.
---
> *       See whether the distance exceeds the outer shell radius.
75,76d86
<           ELSE
<               IF (J.EQ.I) GO TO 10
82,84d91
<           DR2I = 1.0/RIJ2
<           DRDV = 3.0*DRDV*DR2I
<           DR3I = BODY(J)*DR2I*SQRT(DR2I)
88,90c95,99
<           FD(1) = FD(1) + (DV(1) - A1*DRDV)*DR3I
<           FD(2) = FD(2) + (DV(2) - A2*DRDV)*DR3I
<           FD(3) = FD(3) + (DV(3) - A3*DRDV)*DR3I
---
>           FD(1) = FD(1) + (DV(1) - A1*DRDP)*DR3I
>           FD(2) = FD(2) + (DV(2) - A2*DRDP)*DR3I
>           FD(3) = FD(3) + (DV(3) - A3*DRDP)*DR3I
> *       Obtain potential.
>           PHII(I) = PHII(I) - DR3I*RIJ2
94,97c103
<     8     DR2I = 1.0/RIJ2
<           DRDV = 3.0*DRDV*DR2I
<           DR3I = BODY(J)*DR2I*SQRT(DR2I)
<           FREG(1) = FREG(1) + A1*DR3I
---
>     8     FREG(1) = FREG(1) + A1*DR3I
100,102c106,111
<           FDR(1) = FDR(1) + (DV(1) - A1*DRDV)*DR3I
<           FDR(2) = FDR(2) + (DV(2) - A2*DRDV)*DR3I
<           FDR(3) = FDR(3) + (DV(3) - A3*DRDV)*DR3I
---
>           FDR(1) = FDR(1) + (DV(1) - A1*DRDP)*DR3I
>           FDR(2) = FDR(2) + (DV(2) - A2*DRDP)*DR3I
>           FDR(3) = FDR(3) + (DV(3) - A3*DRDP)*DR3I
> *       Obtain potential and derivative.
>           PHIR(I) = PHIR(I) - DR3I*RIJ2
>           PHIR1(I) = PHIR1(I) + DRDV*DR3I
103a113,114
>           call cputim(tt2)
>           ttfrc = ttfrc + (tt2-tt1)*60.
104a116,127
> *       Check total energy
>           VI2 = XIDOT(1)**2 + XIDOT(2)**2 + XIDOT(3)**2
>           EI = VI2/2.D0 + PHIR(I) + PHII(I)
>           ETIDAL = -ZMASS/RTIDE
>           IF(EI.GT.ETIDAL)THEN
>               IF(ESCFLG(NAME(I)).NE.1)
>      *        WRITE(95,1001) TIME,I,NAME(I),BODY(I),DSQRT(RI2),
>      *                       DSQRT(VI2),EI,ETIDAL
>               ESCFLG(NAME(I)) = 1
>  1001     FORMAT(1X,' T=',1P,D15.7,' I,N=',2I6,' m,r,v=',3D15.7,
>      *        ' e,et=',2D15.7)
>           END IF
123,127d145
<       END IF 
< *
< *       Check optional interstellar clouds.
<    20 IF (KZ(13).GT.0) THEN
<           CALL FCLOUD(I,FREG,FDR,1)
131,138c149
<       IF (KZ(14).GT.0) THEN
< *       Save current values for deriving work done by tides (#14 = 3).
<           IF (KZ(14).EQ.3) THEN
<               DO 22 K = 1,3
<                   FRX(K) = FREG(K)
<                   FDX(K) = FDR(K)
<    22         CONTINUE
<           END IF
---
>    20 CONTINUE
140,141c151,153
< *       Obtain the tidal perturbation (force and first derivative).
<           CALL XTRNLF(XI,XIDOT,FIRR,FREG,FD,FDR,1)
---
>       IF (KZ(14).GT.0) THEN
>           CALL XTRNLF(I,XI,XIDOT,FIRR,FREG,FD,FDR,1)
>       END IF
143,157c155,157
< *       Form rate of tidal energy change during last regular step.
<           IF (KZ(14).EQ.3) THEN
<               WDOT = 0.0
<               W2DOT = 0.0
< *             W3DOT = 0.0
<               DO 24 K = 1,3
<                   PX = FREG(K) - FRX(K)
<                   DPX = FDR(K) - FDX(K)
<                   WDOT = WDOT + XIDOT(K)*PX
<                   W2DOT = W2DOT + (FREG(K) + FIRR(K))*PX + XIDOT(K)*DPX
< *                 W3DOT = W3DOT + 2.0*(FREG(K) + FIRR(K))*DPX +
< *    &                            (FDR(K) + FD(K))*PX
<    24         CONTINUE
< *       Note: second-order term derived by Douglas Heggie (Aug/03).
<           END IF
---
> *       Check whether cloud forces should be included.
>       IF (KZ(13).GT.0) THEN
>           CALL FCLOUD(I,FREG,FDR,1)
164,165c164,165
< *       Double the neighbour sphere and try again unless RI > 10*RSCALE.
<           IF (RI2.GT.100.0*RH2.OR.LIST(1,I).EQ.0) THEN
---
> *       Double the neighbour sphere and try again unless RI > 30*RSCALE.
>           IF (RI2.GT.100.0*RH2.OR.KLIST(1).EQ.0) THEN
181,182c181,183
< *       Reduce neighbour sphere gradually but allow encounter detection.
<                   RS(I) = MAX(0.75*RS(I),0.1*RSCALE)
---
> *       Specify zero members and reduce neighbour sphere gradually (but > 0).
>                   KLIST(1) = 0
>                   RS(I) = MAX(0.75*RS(I),0.01*RSCALE)
190c191
<           IF (RS(I).GT.10.0*RSCALE.AND.KZ(39).EQ.0) IRSKIP = 1
---
>           IF (RS(I).GT.10.0*RSCALE) IRSKIP = 1
223a225
>           DRDP = 3.0*DRDV*DR2I
236,237c238
<    34     DRDV = 3.0*DRDV*DR2I
<           FIRR(1) = FIRR(1) - A1*DR3I
---
>    34     FIRR(1) = FIRR(1) - A1*DR3I
240,242c241,243
<           FD(1) = FD(1) - (DV(1) - A1*DRDV)*DR3I
<           FD(2) = FD(2) - (DV(2) - A2*DRDV)*DR3I
<           FD(3) = FD(3) - (DV(3) - A3*DRDV)*DR3I
---
>           FD(1) = FD(1) - (DV(1) - A1*DRDP)*DR3I
>           FD(2) = FD(2) - (DV(2) - A2*DRDP)*DR3I
>           FD(3) = FD(3) - (DV(3) - A3*DRDP)*DR3I
246,248c247,253
<           FDR(1) = FDR(1) + (DV(1) - A1*DRDV)*DR3I
<           FDR(2) = FDR(2) + (DV(2) - A2*DRDV)*DR3I
<           FDR(3) = FDR(3) + (DV(3) - A3*DRDV)*DR3I
---
>           FDR(1) = FDR(1) + (DV(1) - A1*DRDP)*DR3I
>           FDR(2) = FDR(2) + (DV(2) - A2*DRDP)*DR3I
>           FDR(3) = FDR(3) + (DV(3) - A3*DRDP)*DR3I
> *       Obtain potential and derivative.
>           PHII(I) = PHII(I) - DR3I*RIJ2
>           PHIR(I) = PHIR(I) - DR3I*RIJ2
>           PHIR1(I) = PHIR1(I) + DRDV*DR3I
260,262c265,278
<    40 A3 = ALPHA*SQRT(FLOAT(NNB)*RS(I))/RS2
<       NBP = A3
<       A3 = MIN(A3,ZNBMAX) 
---
> *       Include optional stabilization to increase neighbour number.
> *       Take input parameter NNBOPT as optimal neighbour number (R.Sp.)
> *       Note that it substitutes input parameter NNBMAX, which
> *       is now a parameter NNBMAX=LMAX-3
>    40 CONTINUE
> *
>       FAC = 1.D0
>       IF (KZ(40).GT.0) THEN
>           FAC = 1.0 + 0.1*(FLOAT(NNBOPT) - FLOAT(NNB))/FLOAT(NNB)
>       END IF
> *
> *     A3 = ALPHA*FAC*SQRT(FLOAT(NNB)*RS(I))/RS2
>       A3 = FLOAT(NNB)*FAC
>       A3 = MIN(A3,0.9*ZNBMAX)
269a286
> *
274c291
<       IF (RI2.GT.RC2.AND.KZ(39).EQ.0.AND.RI2.LT.9.0*RH2) THEN
---
>       IF (RI2.GT.RC2.AND.RI2.LT.100.0*RH2) THEN
309,312d325
< *       Prevent reduction of small NNB if predicted value exceeds ZNBMIN.
<           IF (NNB.LT.ZNBMIN.AND.NBP.GT.ZNBMIN) THEN
<               IF (A1.LT.1.0) A1 = 1.05
<           END IF
320c333
<       IF (NNB.LE.3.AND.RI2.LT.9.0*RH2) THEN
---
>       IF (NNB.LE.3.AND.RI2.LT.100.0*RH2) THEN
338,340d350
< *       Check minimum neighbour sphere since last output (skip NNB = 0).
<       IF (LIST(1,I).GT.0) RSMIN = MIN(RSMIN,RS(I))
< *
342,344c352,354
<       IF ((KZ(37).EQ.1.AND.LISTV(1).GT.0).OR.KZ(37).GT.1) THEN
<           CALL CHECKL(I,NNB,XI,XIDOT,RS2,FIRR,FREG,FD,FDR)
<       END IF
---
>       IF (KZ(18).EQ.0) GO TO 50
>       IF (KZ(18).EQ.1.AND.LISTV(1).EQ.0) GO TO 50
>       CALL CHECKL(I,NNB,XI,XIDOT,RS2,FIRR,FREG,FD,FDR)
350,359c360
< *       Accumulate tidal energy change for general galactic potential.
<       IF (KZ(14).EQ.3) THEN
< *       Note: Taylor series at end of interval with negative argument.
< *         ETIDE = ETIDE - BODY(I)*((ONE6*W3DOT*DTR - 0.5*W2DOT)*DTR +
< *    &                                                   WDOT)*DTR
<           ETIDE = ETIDE + BODY(I)*(0.5*W2DOT*DTR - WDOT)*DTR
< *       Note: integral of Taylor series for V*P using final values.
<       END IF
< *
< *       Check case of zero old membership (NBGAIN = NNB specifies net gain).
---
> *       Check case of zero old or new membership (skip if both are zero).
361,362c362,363
<           NBGAIN = NNB
<           GO TO 70
---
>           IF (NNB.EQ.0) GO TO 70
>           KLIST(2) = 0
370c371
<       ILIST(1) = LIST(NNB0+1,I)
---
>       ILIST(1) = KLIST(NNB0+1)
373c374
<    56 IF (LIST(L,I).EQ.ILIST(LG)) GO TO 58
---
>    56 IF (KLIST(L).EQ.ILIST(LG)) GO TO 58
376c377
<       IF (LIST(L,I).GE.ILIST(LG)) THEN
---
>       IF (KLIST(L).GE.ILIST(LG)) THEN
384c385
<           J = LIST(L,I)
---
>           J = KLIST(L)
399c400
<           LIST(L,I) = NTOT + 1
---
>           KLIST(L) = NTOT + 1
415c416
<       IF (RIJ2.GT.4.0*RS2.OR.NAME(J).EQ.0) GO TO 68
---
>       IF (RIJ2.GT.4.0*RS2) GO TO 68
428c429
<       LIST(NNB0+1,I) = ILIST(1)
---
>       KLIST(NNB0+1) = ILIST(1)
442c443,444
<       DRDV = 3.0*(A1*DV(1) + A2*DV(2) + A3*DV(3))*DR2I
---
>       DRDV = A1*DV(1) + A2*DV(2) + A3*DV(3)
>       DRDP = 3.0*DRDV*DR2I
447,449c449,451
<       FD(1) = FD(1) + (DV(1) - A1*DRDV)*DR3I
<       FD(2) = FD(2) + (DV(2) - A2*DRDV)*DR3I
<       FD(3) = FD(3) + (DV(3) - A3*DRDV)*DR3I
---
>       FD(1) = FD(1) + (DV(1) - A1*DRDP)*DR3I
>       FD(2) = FD(2) + (DV(2) - A2*DRDP)*DR3I
>       FD(3) = FD(3) + (DV(3) - A3*DRDP)*DR3I
453,455c455,461
<       FDR(1) = FDR(1) - (DV(1) - A1*DRDV)*DR3I
<       FDR(2) = FDR(2) - (DV(2) - A2*DRDV)*DR3I
<       FDR(3) = FDR(3) - (DV(3) - A3*DRDV)*DR3I
---
>       FDR(1) = FDR(1) - (DV(1) - A1*DRDP)*DR3I
>       FDR(2) = FDR(2) - (DV(2) - A2*DRDP)*DR3I
>       FDR(3) = FDR(3) - (DV(3) - A3*DRDP)*DR3I
> *       Obtain potential and derivative.
>       PHII(I) = PHII(I) - DR3I*RIJ2
>       PHIR(I) = PHIR(I) - DR3I*RIJ2
>       PHIR1(I) = PHIR1(I) + DRDV*DR3I
470,472c476,480
<    70 DTSQ = DTR**2
<       DT6 = 6.0D0/(DTR*DTSQ)
<       DT2 = 2.0D0/DTSQ
---
>    70 CONTINUE
> *
>       DTSQ = DTR**2
>       DT6 = 6.0/(DTR*DTSQ)
>       DT2 = 2.0/DTSQ
478c486
<       IF (STEP(I).LT.5.0D0*DTMIN.AND.DTR.GT.50.0*STEP(I)) THEN
---
>       IF (DTR.GT.50.0*STEP(I)) THEN
491,498c499,503
< 	  AT3 = 2.0D0*DFR + DTR*SUM
< 	  BT2 = -3.0D0*DFR - DTR*(SUM + FRD)
< *
< 	  X0(K,I) = X0(K,I) + (0.6D0*AT3 + BT2)*DTSQ12
< 	  X0DOT(K,I) = X0DOT(K,I) + (0.75D0*AT3 + BT2)*DTR13
< *
< *         X0(K,I) = X(K,I)
< *         X0DOT(K,I) = XDOT(K,I)
---
> 	  AT3 = 2.0*DFR + DTR*SUM
> 	  BT2 = -3.0*DFR - DTR*(SUM + FRD)
> *       Use here new variables for consistency in parallel execution (R.Sp.)
>           XN(K,I) = X0(K,I) + (0.6*AT3 + BT2)*DTSQ12
>           XNDOT(K,I) = X0DOT(K,I) + (0.75*AT3 + BT2)*DTR13
501,502c506
< 	  FR(K,I) = FREG(K)
<           F(K,I) = 0.5D0*(FREG(K) + FIRR(K))
---
>           FR(K,I) = FREG(K)
504,505c508
< 	  FRDOT(K,I) = FDR(K)
<           FDOT(K,I) = ONE6*(FDR(K) + FD(K))
---
>           FRDOT(K,I) = FDR(K)
509,512d511
< *         D0R(K,I) = FREG(K) - (FI(K,I) - FIRR(K))
< *         D1R(K,I) = FDR0
< *       Use actual first derivatives (2nd derivs only consistent in FPCORR).
<           D1(K,I) = FD(K)
514,516c513,514
< *       Set second & third derivatives based on old neighbours (cf. FPCORR).
< 	  D2R(K,I) = (3.0D0*AT3 + BT2)*DT2
< 	  D3R(K,I) = AT3*DT6
---
>           D3R(K,I) = AT3*DT6
>           D2R(K,I) = (3.0*AT3 + BT2)*DT2
518a517
>       NBFLUX = NBFLUX + NBLOSS + NBGAIN
521c520
<           CALL FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT)
---
>           CALL FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT,FIRR,FREG,FD,FDR,KLIST)
524c523
<               CALL FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT)
---
>           CALL FPCORR(I,NBLOSS,NBGAIN,XI,XIDOT,FIRR,FREG,FD,FDR,KLIST)
530c529
<           LIST(1,I) = NNB
---
>           KLIST(1) = NNB
532c531
<               LIST(L,I) = ILIST(L)
---
>               KLIST(L) = ILIST(L)
534d532
<           NBFLUX = NBFLUX + NBLOSS + NBGAIN
538,543c536,538
< *     IF (KZ(29).GT.0) THEN
< *         RI2 = X(1,I)**2 + X(2,I)**2 + X(3,I)**2
< *         IF (RI2.GT.RSPH2) THEN
< *             CALL REFLCT(I,RI2)
< *             IF (RI2.LT.0.0) GO TO 120 
< *         END IF
---
> *     IF (KZ(29).GT.0.AND.RI2.GT.RS2) THEN
> *         CALL REFLCT(I,RI2)
> *         IF (RI2.LT.0.0) GO TO 120
548,557c543,579
<       FR2 = FREG(1)**2 + FREG(2)**2 + FREG(3)**2
<       W1 = FDR(1)**2 + FDR(2)**2 + FDR(3)**2
<       W2 = D2R(1,I)**2 + D2R(2,I)**2 + D2R(3,I)**2
<       W3 = D3R(1,I)**2 + D3R(2,I)**2 + D3R(3,I)**2
< *
< *       Form new step by relative criterion.
<       W0 = (SQRT(FR2*W2) + W1)/(SQRT(W1*W3) + W2)
<       W0 = ETAR*W0
<       TTMP = SQRT(W0)
<       DT0 = TTMP
---
>       DO 100 K = 1,3
>           W1(K) = FDR(K)
>           W2(K) = D2R(K,I)
>           W3(K) = D3R(K,I)
>   100 CONTINUE
> *
>       W0(4) = FREG(1)**2 + FREG(2)**2 + FREG(3)**2
>       W1(4) = W1(1)**2 + W1(2)**2 + W1(3)**2
>       W2(4) = W2(1)**2 + W2(2)**2 + W2(3)**2
>       W3(4) = W3(1)**2 + W3(2)**2 + W3(3)**2
> *
> *       Form new step by relative criterion (extra SQRT for large F3DOT).
>       IF (W3(4).LT.1.0E+20) THEN
>           W0(1) = (SQRT(W0(4)*W2(4)) + W1(4))/
>      &                                       (SQRT(W1(4)*W3(4)) + W2(4))
>       ELSE
>           W0(1) = (SQRT(W0(4)*W2(4)) + W1(4))/
>      &                                 (SQRT(W1(4))*SQRT(W3(4)) + W2(4))
>       END IF
>       W0(1) = ETAR*W0(1)
>       TTMP = SQRT(W0(1))
> *       Winston Sweatman's suggestion
> *     DVV = (XDOT(1,I)-X0DOT(1,I))**2 + (XDOT(2,I)-X0DOT(2,I))**2 +
> *    &     (XDOT(3,I)-X0DOT(3,I))**2
> *     FFD = FREG(1)**2 + FREG(2)**2 + FREG(3)**2
> *     ETARW = ETAR
> *     TTMPW = ETARW*DVV*BODY(I)/FFD
> *
> *     PRINT*,' Reg I=',I,' TTMP,TTMPW,RATIO=',
> *    &  TTMP,TTMPW,TTMP/TTMPW
> *
> *     IF(TTMP.GT.TTMPW)THEN
> *     IGT = IGT + 1
> *     ELSE
> *     ILE = ILE + 1
> *     END IF
> *     IF(MOD(IGT+ILE,100).EQ.0)PRINT*,' irr IGT,ILE=',IGT,ILE
559,560c581,582
< *       Determine new regular step.
< *     TTMP = TSTEP(FREG,FDR,D2R(1,I),D3R(1,I),ETAR)
---
> *     TTMP = MAX(TTMPW,TTMP)
> *     TTR = TSTEP(FREG,FDR,D2R(1,I),D3R(1,I),ETAR)
564c586
<       IF (KZ(14).EQ.0) THEN
---
>       IF (TIDAL(1).EQ.0.0D0) THEN
566,571c588
<           DF2 = FAC**2*MIN(FR2,FI2)
< *       Ignore irregular force criterion if no neighbours.
<           IF (NNB.EQ.0) DF2 = FAC**2*FR2
<       ELSE IF (KZ(14).EQ.1) THEN
<           W0 = (TIDAL(1)*XI(1))**2
<           DF2 = FAC**2*MAX(FR2,W0)
---
>           W0(4) = FAC**2*MIN(DBLE(W0(4)),FI2)
573c590,591
<           DF2 = FAC**2*FR2
---
>           W0(1) = (TIDAL(1)*XI(1))**2
>           W0(4) = FAC**2*MAX(W0(4),W0(1))
580c598
<       W0 = 0.0
---
>       W0(1) = 0.0
582,583c600,601
<           W2 = ((D3R(K,I)*S3 + D2R(K,I))*S2 + FDR(K))*DTC
<           W0 = W0 + W2**2
---
>           W0(2) = ((W3(K)*S3 + W2(K))*S2 + W1(K))*DTC
>           W0(1) = W0(1) + W0(2)**2
587c605
<       IF (W0.LT.DF2) THEN
---
>       IF (W0(1).LT.W0(4)) THEN
598,600c616,618
<       IF (TTMP.GT.2.0*STEPR(I)) THEN
<           IF (DMOD(TIME,2.0*STEPR(I)).EQ.0.0D0) THEN 
<               TTMP = MIN(2.0*STEPR(I),1.0D0)
---
> 		IF (TTMP .GT. 2.0*STEPR(I)) THEN
> 			IF (DMOD(TIME,2.0*STEPR(I)) .EQ. 0.0D0) THEN
>               TTMP = MIN(2.0*STEPR(I),1.D0)
602c620
<               TTMP = STEPR(I) 
---
>               TTMP = STEPR(I)
604c622
<       ELSE IF (TTMP.LT.STEPR(I)) THEN
---
>       ELSE IF (TTMP .LT. STEPR(I)) THEN
606,609d623
< *       Allow a second reduction to prevent spurious contributions.
<           IF (TTMP.GT.DT0) THEN
<               TTMP = 0.5*TTMP
<           END IF
614a629
> *     PRINT*,' New Step = ',TTMP,' Old ',STEPR(I),' Quot ',TTMP/STEPR(I)
615a631,632
> *     STEPR(I) = MIN(1.4*STEPR(I),DTR1)
> *
622d638
<       NSTEPR = NSTEPR + 1
624c640
<       RETURN
---
>   120 RETURN
1,2c1,2
< 1962 2006-08-14 12:04 /work/Umi2/spurzem/5/nbody6compare-oct2006/reinit.f
< nbody6compare-oct2006/reinit.f
---
> 2258 1998-01-08 15:34 /work/Umi2/spurzem/5/nbody6++compare/reinit.f
> nbody6++compare/reinit.f
8c8,9
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
51a53,60
> *       Set maximum integration interval equal to c.m. step.
>       TMAX = STEP(ICH)
> *
> *       Check next treatment time of perturbers & output time.
>       CALL TCHAIN(ISUB,TSMIN)
>       TMAX = MIN(TMAX,TSMIN)
>       TMAX = MIN(TMAX,TADJ - TIME)
> *
55c64
< *       Set phase indicator < 0 to ensure new time-step list in INTGRT.
---
> *       Set phase indicator < 0 to ensure new NLIST in routine INTGRT.
1,2c1,2
< 3645 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/remove.f
< nbody6compare-oct2006/remove.f
---
> 3645 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/remove.f
> nbody6++compare/remove.f
1,2c1,2
< 7227 2006-03-20 05:24 /work/Umi2/spurzem/5/nbody6compare-oct2006/rename.f
< nbody6compare-oct2006/rename.f
---
> 7720 2001-08-04 17:19 /work/Umi2/spurzem/5/nbody6++compare/rename.f
> nbody6++compare/rename.f
196c196,211
<    70 RETURN
---
> *       Check removal of close encounter components from NLIST.
>    70 CALL NLMOD(ICOMP,-1)
>       CALL NLMOD(JCOMP,-1)
> *
> *       Rename exchanged particles (two stages required for special case).
>       DO 80 KCOMP = 1,2
>           NNB1 = NLIST(1) + 1
>           DO 75 L = 2,NNB1
>               IF (NLIST(L).EQ.2*NPAIRS + KCOMP - 2) THEN
>                   IF (KCOMP.EQ.1) NLIST(L) = ICOMP
>                   IF (KCOMP.EQ.2) NLIST(L) = JCOMP
>               END IF
>    75     CONTINUE
>    80 CONTINUE
> *
>       RETURN
198a214
> 
1,2c1,2
< 1921 2006-03-19 11:22 /work/Umi2/spurzem/5/nbody6compare-oct2006/renew.f
< nbody6compare-oct2006/renew.f
---
> 2062 1998-08-15 14:47 /work/Umi2/spurzem/5/nbody6++compare/renew.f
> nbody6++compare/renew.f
31a32,36
> *       See whether KS motion should be added to NLIST.
>       IF (T0(I1) + STEP(I1).LT.TLIST) THEN
>           CALL NLMOD(I1,1)
>       END IF
> *
1,2c1,2
< 13844 2006-09-20 13:15 /work/Umi2/spurzem/5/nbody6compare-oct2006/reset2.f
< nbody6compare-oct2006/reset2.f
---
> 13553 2003-06-25 21:09 /work/Umi2/spurzem/5/nbody6++compare/reset2.f
> nbody6++compare/reset2.f
9,10c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
53c53,54
<           WRITE (6,5)  WHICH1, TIME+TOFF, ZM, NAME(2*IPAIR-1),
---
>           if(rank.eq.0)
>      &    WRITE (6,5)  WHICH1, TIME+TOFF, ZM, NAME(2*IPAIR-1),
67c68,69
<               WRITE (6,9)  TIME+TOFF, ZM, NAME(I1), NAME(I2), NAME(JG),
---
>               if(rank.eq.0)
>      &        WRITE (6,9)  TIME+TOFF, ZM, NAME(I1), NAME(JG), NAME(I2),
72c74,75
<               WRITE (6,11)  TIME+TOFF, ZM, NAME(I1), NAME(I2), NAME(JG),
---
>               if(rank.eq.0)
>      &        WRITE (6,11)  TIME+TOFF, ZM, NAME(I1), NAME(JG), NAME(I2),
96c99,100
<           WRITE (6,18)  TIME+TOFF, ZM, NAME(I1), NAMEG(IM), -NAMEM(JM),
---
>           if(rank.eq.0)
>      &    WRITE (6,18)  TIME+TOFF, ZM, NAME(I1), NAMEG(IM), -NAMEM(JM),
104c108
<       IF ((KZ(18).EQ.1.OR.KZ(18).EQ.3).AND.KSTAR(IMERGE).LE.20) THEN
---
>       IF ((KZ(11).EQ.1.OR.KZ(11).EQ.3).AND.KSTAR(IMERGE).LE.20) THEN
153c157,158
<           WRITE (6,12)  IMERGE, NAMEG(IMERGE), JCOMP
---
>           if(rank.eq.0)
>      &    WRITE (6,12)  IMERGE, NAMEG(IMERGE), JCOMP
228a234,238
> *       See whether body #JCOMP1 should be included in NLIST.
>       IF (T0(JCOMP1) + STEP(JCOMP1).LT.TLIST) THEN
>           CALL NLMOD(JCOMP1,1)
>       END IF
> *
241c251,252
< *       Evaluate stability parameter from current elements (set ECC = 0).
---
> *       Evaluate stability parameter from current elements (no fudge factor).
>       Q = BODY(JCOMP)/BODY(ICOMP)
246c257,258
<       ECC = 0.0
---
>       XFAC = (1.0 + Q)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
>       RSTAB = 2.8*XFAC**0.4*SEMI0
259,262c271,273
< *       Include inclination factor in the stability criterion.
<       PCRIT = stability(CM(1,IMERGE),CM(2,IMERGE),BODY(JCOMP),ECC,ECC1,
<      &                                                    ANGLE)*SEMI0
<       R0(IPAIR) = PCRIT
---
> *       Include standard inclination factor in the stability criterion.
>       YFAC = 1.0 - 0.3*ANGLE/180.0
>       R0(IPAIR) = YFAC*RSTAB
299,308d309
< *       Update look-up times & radii and check possible Roche condition.
<       IF (KZ(19).GE.3) THEN
<           IF (KSTAR(JCOMP1).GT.0.AND.KSTAR(JCOMP1).LE.10) THEN
<               CALL TRFLOW(JPAIR,DTR)
<               TEV(JCOMP1) = TIME + DTR
<               TMDOT = MIN(TEV(JCOMP1),TMDOT)
<               TMDOT = MIN(TEV(2*JPAIR),TMDOT)
<           END IF
<       END IF
< *
331c332,333
<           WRITE (6,48)  JPAIR, H(JPAIR), BODY(2*JPAIR-1),
---
>           if(rank.eq.0)
>      &    WRITE (6,48)  JPAIR, H(JPAIR), BODY(2*JPAIR-1),
362c364,365
<           WRITE (6,65)  IMERGE, TIME+TOFF, BODY(2*IPAIR-1),
---
>           if(rank.eq.0)
>      &    WRITE (6,65)  IMERGE, TIME+TOFF, BODY(2*IPAIR-1),
371,378d373
< *       Check Roche look-up time.
<       IF (KSTAR(ICM).GT.0.AND.KSTAR(ICM).LE.10) THEN
<           K = ICM - N
<           CALL TRFLOW(K,DTR)
<           TEV(ICM) = MIN(TEV(ICM),TIME + DTR)
<           TMDOT = MIN(TEV(ICM),TMDOT)
<       END IF
< *
410c405
< *       Set IPHASE < 0 for new time-step list in INTGRT.
---
> *       Set IPHASE < 0 for new NLIST.
415a411,412
> 
> 
1,2c1,2
< 10773 2006-09-20 13:15 /work/Umi2/spurzem/5/nbody6compare-oct2006/reset.f
< nbody6compare-oct2006/reset.f
---
> 10592 2003-06-25 17:29 /work/Umi2/spurzem/5/nbody6++compare/reset.f
> nbody6++compare/reset.f
9,10c9,10
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
---
>      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),
>      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX)
36c36
<       IF ((KZ(18).EQ.1.OR.KZ(18).EQ.3).AND.KSTARM(IMERGE).LE.20) THEN
---
>       IF ((KZ(11).EQ.1.OR.KZ(11).EQ.3).AND.KSTARM(IMERGE).LE.20) THEN
86a87,90
> *       Include particle #J in time-step list unless already present.
> *             IF (T0(J) + STEP(J).LT.TLIST) THEN
> *                 CALL NLMOD(J,1)
> *             END IF
99c103,104
<           WRITE (6,12)  NAMEG(IMERGE)
---
>           if(rank.eq.0)
>      &    WRITE (6,12)  NAMEG(IMERGE)
156a162,166
> *       See whether body #JCOMP1 should be include in NLIST.
> *     IF (T0(JCOMP1) + STEP(JCOMP1).LT.TLIST) THEN
> *         CALL NLMOD(JCOMP1,1)
> *     END IF
> *
189,190d198
< *       Update look-up times & radii and check possible Roche condition.
<       IF (KZ(19).GE.3) THEN
192,200c200,201
<           IF (TEV(2*JPAIR-1).LT.TIME + 0.01*TCR) TEV(2*JPAIR-1) = TIME
<           IF (TEV(2*JPAIR).LT.TIME + 0.01*TCR) TEV(2*JPAIR) = TIME
<           IF (KSTAR(JCOMP1).GT.0.AND.KSTAR(JCOMP1).LE.10) THEN
<               CALL TRFLOW(JPAIR,DTR)
<               TEV(JCOMP1) = TIME + DTR
<               TMDOT = MIN(TEV(JCOMP1),TMDOT)
<               TMDOT = MIN(TEV(2*JPAIR),TMDOT)
<           END IF
<       END IF
---
>       IF (TEV(2*JPAIR-1).LT.TIME + 0.01*TCR) TEV(2*JPAIR-1) = TIME
>       IF (TEV(2*JPAIR).LT.TIME + 0.01*TCR) TEV(2*JPAIR) = TIME
213a215
> *
216a219
> *
225c228,229
<           WRITE (6,45)  JPAIR, H(JPAIR), BODY(2*JPAIR-1),
---
>           if(rank.eq.0)
>      &    WRITE (6,45)  JPAIR, H(JPAIR), BODY(2*JPAIR-1),
228c232
<    45     FORMAT (' END QUAD',I4,'  H =',F7.1,'  M =',2F7.4,
---
>    45     FORMAT (' END QUAD ',I4,'  H =',F7.1,'  M =',2F7.4,
257c261,262
<           WRITE (6,65)  IMERGE, TIME+TOFF, BODY(2*NPAIRS-1),
---
>           if(rank.eq.0)
>      &    WRITE (6,65)  IMERGE, TIME+TOFF, BODY(2*NPAIRS-1),
266,267d270
< *       Check Roche look-up time.
<       IF (KSTAR(NTOT).GT.0.AND.KSTAR(NTOT).LE.10) THEN
269,273c272
<           IF (TEV(2*NPAIRS-1).LT.TIME + 0.01*TCR) TEV(2*NPAIRS-1) = TIME
<           CALL TRFLOW(NPAIRS,DTR)
<           TEV(NTOT) = MIN(TEV(NTOT),TIME + DTR)
<           TMDOT = MIN(TEV(NTOT),TMDOT)
<       END IF
---
>       IF (TEV(2*NPAIRS-1).LT.TIME + 0.01*TCR) TEV(2*NPAIRS-1) = TIME
312c311,312
<               WRITE (6,95)  I, NAME(I), (NAMEM(L),L=1,NMERGE)
---
>               if(rank.eq.0)
>      &        WRITE (6,95)  I, NAME(I), (NAMEM(L),L=1,NMERGE)
318c318
< *       Set phase indicator < 0 for new time-step list in routine INTGRT.
---
> *       Set phase indicator < 0 for new NLIST in routine INTGRT (inactive).
1,2c1,2
< 4368 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/resolv.f
< nbody6compare-oct2006/resolv.f
---
> 4310 2003-06-23 19:32 /work/Umi2/spurzem/5/nbody6++compare/resolv.f
> nbody6++compare/resolv.f
47c47
<       DTU2 = DTU/24.0D0
---
>       DTU2 = 0.0416666666666667*DTU
95d94
< *       Note: Update X0 for call from KSTERM after RESOLV call in MDOT.
127a127,128
> 
> 
1,2c1,2
< 607 2005-08-11 12:44 /work/Umi2/spurzem/5/nbody6compare-oct2006/rsort.f
< nbody6compare-oct2006/rsort.f
---
> 607 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/rsort.f
> nbody6++compare/rsort.f
7c7
<       REAL*8  R(6)
---
>       REAL*8  R(1)
1,2c1,2
< 6201 2006-02-18 13:35 /work/Umi2/spurzem/5/nbody6compare-oct2006/scale.f
< nbody6compare-oct2006/scale.f
---
> 4601 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/scale.f
> nbody6++compare/scale.f
0a1,4
> # 1 "scale.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "scale.F"
4,5c8,9
< *       Scaling to new units.
< *       ---------------------
---
> * Scaling to new units.
> * ---------------------
8,13c12,28
< *
< *
< *       Read virial ratio, rotation scaling factors & tidal radius.
<       READ (5,*)  Q, VXROT, VZROT, RTIDE
<       RSPH2 = RTIDE
<       QVIR = Q
---
>       LOGICAL LSCALE
> * Scaling if initial model is constructed or King model is read
>       LSCALE = KZ(22).LT.2.OR.KZ(22).GE.6
> *
> # 21 "scale.F"
> *
> * Read virial ratio, rotation scaling factors & boundary radius.
>       if(rank.eq.0)then
>       READ (5,*) Q, VXROT, VZROT, RSPH2
>       end if
> 
> 
> 
> 
> 
> 
> 
21c36
< *       Form total mass and centre of mass displacements.
---
> * Form total mass and centre of mass displacements.
27c42
<    25     CONTINUE
---
>    25 CONTINUE
30c45,47
< *       Adjust coordinates and velocities to c.m. rest frame.
---
> * Adjust coordinates and velocities to c.m. rest frame.
> * (if start model data were read from other source do NOT scale)(R.Sp.)
>       IF (LSCALE) THEN
35c52
<    35     CONTINUE
---
>    35 CONTINUE
38,41c55
< *       Skip scaling of masses for unscaled upload or planetesimal disk.
<       IF (KZ(22).GT.2.OR.KZ(5).EQ.3) GO TO 52
< *
< *       Scale masses to standard units of <M> = 1/N and set total mass.
---
> * Scale masses to standard units of <M> = 1/N.
45d58
<       ZMASS = 1.0
47,48c60,69
< *       Obtain the total kinetic & potential energy.
<    52 CALL ENERGY
---
>       ZMASS = 1.D0
> *
>       END IF
> *
> * Obtain the total kinetic & potential energy.
> 
> 
> 
>       CALL ENERGY
> 
50,51c71,72
< *       Use generalized virial theorem for external tidal field.
<       IF (KZ(14).GT.0) THEN
---
> * Use generalized virial theorem for external tidal field.
>       IF (KZ(14).EQ.1) THEN
55,61c76,78
<    55     CONTINUE
<           IF (KZ(14).EQ.1) THEN
< *       Use Chandrasekhar eq. (5.535) for virial ratio (rotating frame only).
<               VIR = POT - 2.0*(ETIDE + 0.5*TIDAL(4)*AZ)
<           ELSE
<               VIR = POT - 2.0*ETIDE
<           END IF
---
>    55 CONTINUE
>           ZKIN1 = ZKIN + 0.5*TIDAL(4)*AZ
>           VIR = POT - 2.0*ETIDE
62a80
>           ZKIN1 = ZKIN
66,89c84,102
< *       Allow two optional ways of skipping standard velocity scaling.
<       IF (KZ(22).GT.2.OR.KZ(5).EQ.2.OR.KZ(5).EQ.3) THEN
<           QV = SQRT(Q*VIR/ZKIN)
<           E0 = ZKIN*QV**2 - POT + ETIDE
<           SX = 1.0
< *       Rescale velocities to new masses for two Plummer spheres.
<           IF (KZ(5).EQ.2) THEN
<               ZKIN = 0.0
<               DO 57 I = 1,N
<                   DO 56 K = 1,3
<                       XDOT(K,I) = XDOT(K,I)*QV
<                       ZKIN = ZKIN + 0.5*BODY(I)*XDOT(K,I)**2
<    56             CONTINUE
<    57         CONTINUE
<               E0 = ZKIN - POT + ETIDE
<               Q = ZKIN/POT
<               WRITE (6,59)  E0, ZKIN/POT
<    59         FORMAT (/,12X,'UNSCALED ENERGY    E =',F10.6,
<      &                                       '  Q =',F6.2)
<           ELSE
<               IF (KZ(5).EQ.3) E0 = ZKIN - POT
<               WRITE (6,54)  E0
<    54         FORMAT (/,12X,'UNSCALED ENERGY    E =',F10.6)
<           END IF
---
> * Scale non-zero velocities by virial theorem ratio.
> * (if start model data were read from other source do NOT scale)(R.Sp.)
>       IF (LSCALE) THEN
>       IF (ZKIN.GT.0.0D0) THEN
>           QV = SQRT(Q*VIR/ZKIN1)
>           DO 60 I = 1,N
>               DO 58 K = 1,3
>                   XDOT(K,I) = XDOT(K,I)*QV
>    58 CONTINUE
>    60 CONTINUE
>       END IF
> *
> * Scale total energy to standard units (E = -0.25 for Q < 1).
>       E0 = -0.25
>       ETOT = (Q - 1.0)*POT
> * Include case of hot system inside reflecting boundary.
>       IF (KZ(29).GT.0.AND.Q.GT.1.0) THEN
>           E0 = ETOT
>       END IF
91,132c104,128
< *       Scale non-zero velocities by virial theorem ratio.
<           IF (ZKIN.GT.0.0D0) THEN
<               QV = SQRT(Q*VIR/ZKIN)
<               DO 60 I = 1,N
<                   DO 58 K = 1,3
<                       XDOT(K,I) = XDOT(K,I)*QV
<    58             CONTINUE
<    60         CONTINUE
<           ELSE
<               QV = 1.0
<           END IF
< *
< *       Scale total energy to standard units (E = -0.25 for Q < 1).
<           E0 = -0.25
< *       Include case of hot system inside reflecting boundary.
<           IF (KZ(29).GT.0.AND.Q.GT.1.0) E0 = 0.25
< *         ETOT = (Q - 1.0)*POT
<           ETOT = ZKIN*QV**2 - POT + ETIDE
< *       Note that final ETOT will differ from -0.25 since ETIDE = 0.
<           IF (Q.LT.1.0) THEN
<               SX = E0/ETOT
<           ELSE
<               SX = 1.0
<           END IF
< *
<           WRITE (6,65)  SX, ETOT, BODY(1), BODY(N), ZMASS/FLOAT(N)
<    65     FORMAT (//,12X,'SCALING:    SX =',F6.2,'  E =',1PE10.2,
<      &                   '  M(1) =',E9.2,'  M(N) =',E9.2,'  <M> =',E9.2)
< *
< *       Scale coordinates & velocities to the new units.
<           RIJ2 = 0.0
<           DO 70 I = 1,N
<               RIJ = 0.0
<               DO 68 K = 1,3
<                   X(K,I) = X(K,I)/SX
<                   XDOT(K,I) = XDOT(K,I)*SQRT(SX)
<                   RIJ = RIJ + X(K,I)*X(K,I)
<    68         CONTINUE
<               RIJ2 = MAX(RIJ2,RIJ)
<    70     CONTINUE
<           RIJ2 = SQRT(RIJ2)
<       ENDIF
---
>       ETOT = ZKIN + POT
>       E0 = ETOT
>       END IF
> * Define scaling factor (set E0 = ETOT if energy scaling not desired).
>       SX = E0/ETOT
> *
>           if(rank.eq.0)
>      *WRITE (6,65) SX, ETOT, BODY(1), BODY(N), ZMASS/FLOAT(N)
>    65 FORMAT (
>      & '  M(1) =',E9.2,'  M(N) =',E9.2,'  <M> =',E9.2)
> *
> * Scale coordinates & velocities to the new units.
>       DO 70 I = 1,N
>           DO 68 K = 1,3
>               X(K,I) = X(K,I)/SX
>               XDOT(K,I) = XDOT(K,I)*SQRT(SX)
>    68 CONTINUE
>    70 CONTINUE
> * In case of no tidal field choose very large RTIDE (R.Sp.)
>       IF (TIDAL(1).EQ.0.0D0.AND.KZ(23).LE.2) RTIDE = 1.D8
> * In case of King model scale initial tidal radius
>       IF(KZ(23).GE.3)THEN
>       RTIDE = RTIDE/SX
>       if(rank.eq.0)PRINT*,' RTIDE =',RTIDE,' ETID=',ZMASS/RTIDE
>       END IF
134c130
< *       Check whether to include rotation (VXROT = 0 in standard case). 
---
> * Check whether to include rotation (VXROT = 0 in standard case).
137c133
< *       Set angular velocity for retrograde motion (i.e. star clusters).
---
> * Set angular velocity for retrograde motion (i.e. star clusters).
139,141c135,138
<           WRITE (6,75)  VXROT, VZROT, OMEGA
<    75     FORMAT (/,12X,'VXROT =',F6.2,'  VZROT =',F6.2,
<      &                                                 '  OMEGA =',F7.2)
---
>        if(rank.eq.0)
>      * WRITE (6,75) VXROT, VZROT, OMEGA
>    75 FORMAT (/,12X,'VXROT =',F6.2,'  VZROT =',F6.2,
>      & '  OMEGA =',F7.2)
143c140
< *       Add solid-body rotation about Z-axis (reduce random velocities).
---
> * Add solid-body rotation about Z-axis (reduce random velocities).
148,164c145
<    80     CONTINUE
<       END IF
< *
< *       Check option for writing the initial conditions on unit 10.
<       IF (KZ(22).EQ.1) THEN
<           DO 85 I = 1,N
<               WRITE (10,84)  BODY(I), (X(K,I),K=1,3), (XDOT(K,I),K=1,3)
<    84         FORMAT (1P,7E14.6)
<    85     CONTINUE
<       END IF
< *
< *       Check option for reading initial subsystems.
<       IF (KZ(24).GT.0) THEN
<           K = KZ(24)
<           DO 90 I = 1,K
<               READ (5,*)  (X(J,I),J=1,3), (XDOT(J,I),J=1,3)
<    90     CONTINUE
---
>    80 CONTINUE
167c148
< *       Set initial crossing time in scaled units.
---
> * Set initial crossing time in scaled units.
171c152
< *       Obtain approximate half-mass radius after scaling.
---
> * Obtain approximate half-mass radius after scaling.
173c154
< *       Set square radius of reflecting sphere (used with option 29).
---
> * Set square radius of reflecting sphere.
175c156
< *       Form equilibrium rms velocity (temporarily defined as VC).
---
> * Form equilibrium rms velocity (temporarily defined as VC).
178c159
< *       Check for general binary search of initial condition.
---
> * Check for general binary search of initial condition.
183c164
< *       Print half-mass relaxation time & equilibrium crossing time.
---
> * Print half-mass relaxation time & equilibrium crossing time.
186c167
<       WRITE (6,95)  TRH, TCR, 2.0*RSCALE/VC
---
>       if(rank.eq.0)WRITE (6,95) TRH, TCR, 2.0*RSCALE/VC
188c169
<      &                                            '  2<R>/<V> =',E8.1,/)
---
>      & '  2<R>/<V> =',E8.1,/)
1,2c1,2
< 4086 2005-04-18 00:24 /work/Umi2/spurzem/5/nbody6compare-oct2006/search.f
< nbody6compare-oct2006/search.f
---
> 4334 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/search.f
> nbody6++compare/search.f
14a15,22
> *       Predict current state vector of body #I to order FDOT.
>           S = TIME - T0(I)
>           DO 1 K = 1,3
>               X(K,I) = ((FDOT(K,I)*S + F(K,I))*S + X0DOT(K,I))*S +
>      &                                                           X0(K,I)
>               XDOT(K,I) = (3.0*FDOT(K,I)*S + 2.0*F(K,I))*S + X0DOT(K,I)
>     1     CONTINUE
> *
26a35,41
> *       Prediction (R.Sp.)
>           S = TIME - T0(J)
>           DO 25 K = 1,3
>               X(K,J) = ((FDOT(K,J)*S + F(K,J))*S + X0DOT(K,J))*S +
>      &                                                           X0(K,J)
>               XDOT(K,J) = (3.0*FDOT(K,J)*S + 2.0*F(K,J))*S + X0DOT(K,J)
>    25     CONTINUE
49a65,71
> *       Prediction (R.Sp.)
>           S = TIME - T0(J)
>           DO 65 KK = 1,3
>           X(KK,J) = ((FDOT(KK,J)*S + F(KK,J))*S + X0DOT(KK,J))*S +
>      &                                                         X0(KK,J)
>           XDOT(KK,J) = (3.0*FDOT(KK,J)*S + 2.0*F(KK,J))*S + X0DOT(KK,J)
>    65     CONTINUE
78,103c100
<       IF (RDOT.GT.0.02*SQRT((BODY(I) + BODY(JCOMP))*RIJMIN)) GO TO 10
< *
< *       Ensure a massive neighbour is included in perturbation estimate.
<       BCM = BODY(I) + BODY(JCOMP)
<       IF (BODY1.GT.10.0*BCM) THEN
<           JBIG = 0
<           BIG = BCM
<           NNB1 = LIST(1,I) + 1
<           DO 20 L = 2,NNB1
<               J = LIST(L,I)
<               IF (BODY(J).GT.BIG) THEN
<                   JBIG = J
<                   BIG = BODY(J)
<               END IF
<    20     CONTINUE
< *       Check whether already present, otherwise add to JLIST.
<           DO 25 L = 1,NCLOSE
<               IF (JLIST(L).EQ.JBIG) THEN
<                   JBIG = 0
<               END IF
<    25     CONTINUE
<           IF (JBIG.GT.0) THEN
<               NCLOSE = NCLOSE + 1
<               JLIST(NCLOSE) = JBIG
<           END IF
<       END IF
---
>       IF (RDOT.GT.0.1*SQRT((BODY(I) + BODY(JCOMP))*RIJMIN)) GO TO 10
109c106
<       GI = PERT*RJMIN2/BCM
---
>       GI = PERT*RJMIN2/(BODY(I) + BODY(JCOMP))
111,112c108,109
< *         IF (KZ(4).GT.0.AND.TIME-TLASTT.GT.4.44*TCR/FLOAT(N))
< *    &                                             CALL EVOLVE(JCOMP,0)
---
>           IF (KZ(4).GT.0.AND.TIME-TLASTT.GT.4.44*TCR/FLOAT(N))
>      &                                             CALL EVOLVE(JCOMP,0)
1,2c1,2
< 1108 2006-09-15 10:15 /work/Umi2/spurzem/5/nbody6compare-oct2006/select.f
< nbody6compare-oct2006/select.f
---
> 993 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/select.f
> nbody6++compare/select.f
12d11
<       SAVE
21,22d19
< *       Include masses for defining dominant interaction (09/06).
<       RIJ2(L) = RIJ2(L)/(M(I) + M(J))
1,2c1,2
< 7092 2006-08-16 10:17 /work/Umi2/spurzem/5/nbody6compare-oct2006/setsys.f
< nbody6compare-oct2006/setsys.f
---
> 5171 2003-06-25 20:04 /work/Umi2/spurzem/5/nbody6++compare/setsys.f
> nbody6++compare/setsys.f
8c8,9
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
17,21d17
<       COMMON/BINARY/  ZM(4,MMAX),XREL(3,MMAX),VREL(3,MMAX),
<      &                HM(MMAX),UM(4,MMAX),UMDOT(4,MMAX),TMDIS(MMAX),
<      &                NAMEM(MMAX),NAMEG(MMAX),KSTARM(MMAX),IFLAG(MMAX)
<       SAVE JSAVE
<       INTEGER JSAVE(3)
74,98d69
< *
< *       Check for addition of binary (NCH <= 4).
<       IF (JCMAX.GT.N.AND.NCH.LE.4) THEN
<           KSP2 = JCMAX - N
<           IF (KSP2.GT.KSPAIR) KSP2 = KSP2 - 1
<           KSPAIR = KSP2
<           JCOMP = 0
< *       Save current members to prevent over-writing in KSTERM.
<           DO 6 L = 1,NCH
<               JSAVE(L) = JLIST(L)
<     6     CONTINUE
<           CALL KSTERM
< *       Note that second binary will now come first in N-body arrays.
<           DO 7 L = 1,NCH
<               JLIST(L) = JSAVE(L)
<     7     CONTINUE
< *       Add terminated KS components to chain arrays.
<           DO 8 L = 1,2
<               NCH = NCH + 1
<               JLIST(NCH) = 2*NPAIRS + L
<               NAMEC(NCH) = NAME(2*NPAIRS+L)
<               BODYC(NCH) = BODY(2*NPAIRS+L)
<               M(NCH) = BODY(2*NPAIRS+L)
<     8     CONTINUE
<       END IF
136d106
<           JG = 0
138,152c108,110
< *       Identify merger index and ghost for addition to chain.
<               DO 12 K = 1,NMERGE
<                   IF (NAMEM(K).EQ.NAME(JCLOSE)) THEN
<                       IM = K
<                   END IF
<    12         CONTINUE
< *       Note ghost must be single for maximum chain membership of 6.
<               DO 14 J = 1,N
<                   IF (BODY(J).EQ.0.0D0.AND.NAME(J).EQ.NAMEG(IM)) THEN
<                       JG = J
<                   END IF
<    14         CONTINUE
<               WRITE (6,15)  NAME(JCLOSE), NAME(JG), RSUM,  R(JCLOSE-N)
<    15         FORMAT (' SETSYS HIARCH    NM NMG RSUM RB ',
<      &                                   I6,I5,1P,2E10.2)
---
>               WRITE (6,15)  JCLOSE, RSUM,  R(JCLOSE-N)
>    15         FORMAT (/,5X,'WARNING!    SETSYS    JCLOSE RSUM R ',
>      &                                            I5,1P,2E10.2)
174c132
< *       Terminate KS pair and copy components (JCOMP=0 excludes ghost).
---
> *       Terminate KS pair and copy components.
192,204d149
< *       See whether to include merger ghost.
<           IF (JG.GT.0) THEN
<               NCH = NCH + 1
<               JLIST(NCH) = JG
<               NAMEC(NCH) = NAME(JG)
<               BODYC(NCH) = BODY(JG)
<               M(NCH) = BODY(JG)
<           END IF
<           IF (NCH.GT.6) THEN
<               WRITE (6,30)  NCH
<    30         FORMAT (' DANGER!    NCH ',I4)
<               STOP
<           END IF
1,2c1,2
< 9126 2006-02-18 13:34 /work/Umi2/spurzem/5/nbody6compare-oct2006/setup.f
< nbody6compare-oct2006/setup.f
---
> 2801 2002-08-17 15:15 /work/Umi2/spurzem/5/nbody6++compare/setup.f
> nbody6++compare/setup.f
42c42
<       GO TO 90
---
>       GO TO 60
92,95d91
<           IF (KZ(22).EQ.1) THEN
<               WRITE (10,46)  BODY(I), (X(K,I),K=1,3), (XDOT(K,I),K=1,3)
<    46         FORMAT (1P,7E14.6)
<           END IF
97,269d92
<       IF (KZ(22).EQ.1) CALL FLUSH(10)
< *
< *       Check initial conditions for two orbiting Plummer spheres.
<       IF (KZ(5).LE.1) GO TO 90
< *
< *       Save membership of first system for colour plot (N2 = NZERO - N1).
<       N1 = N
<       IF (KZ(5).EQ.2) THEN
<       READ (5,*)  APO, ECC, N2, SCALE
<       N2 = MIN(N,N2)
<       SEMI = APO/(1.0 + ECC)
<       SEMI = MIN(SEMI,50.0D0)
<       SEMI = MAX(SEMI,2.0D0)
<       ECC = MIN(ECC,0.999D0)
<       ECC = MAX(ECC,0.0D0)
<       ZM2 = 0.0
<       KSKIP = N1/N2
<       DO 52 I = 1,N2
<           J = KSKIP*I
<           ZM2 = ZM2 + BODY(J)
<    52 CONTINUE
<       FAC1 = ZM2/(ZMASS + ZM2)
<       FAC2 = ZMASS/(ZMASS + ZM2)
< *       Restrict volume ratio to 125 (i.e. unreasonable density contrast).
<       IF (SCALE.LE.0.2D0) SCALE = 0.2
< *       Increase total mass (save in ZMTOT for possible use in XTRNL0).
<       ZMTOT = ZMTOT + ZMBAR*ZM2
<       ZMASS = ZMASS + ZM2
< *       Set apocentre velocity for new combined mass.
<       VAP = SQRT(ZMASS/SEMI)*SQRT((1.0 - ECC)/(1.0 + ECC))
<       DO 55 I = 1,N
<           IF (I.LE.N2) THEN
< *       Copy members from first system by uniform skipping (N2 <= N1).
<           J = KSKIP*I
<           BODY(I+N) = BODY(J)
<           X(1,I+N) = SCALE*X(1,J) + FAC2*APO
<           X(2,I+N) = SCALE*X(2,J)
<           X(3,I+N) = SCALE*X(3,J)
<           XDOT(1,I+N) = XDOT(1,J)/SQRT(SCALE)
<           XDOT(2,I+N) = XDOT(2,J)/SQRT(SCALE) + FAC2*VAP
<           XDOT(3,I+N) = XDOT(3,J)/SQRT(SCALE)
<           END IF
<           X(1,I) = X(1,I) - FAC1*APO
<           XDOT(2,I) = XDOT(2,I) - FAC1*VAP
<    55 CONTINUE
<       ELSE IF (KZ(5).EQ.3) THEN
< *       Prepare case of accretion disk with massive perturber.
<           READ (5,*)  APO, ECC, DMIN, SCALE
<           RIN = 0.5
<           ROUT = 1.0
<           ZMASS = 1.0
<           BODY(1) = ZMASS
<           DO 99 K = 1,3
<               X(K,1) = 0.0
<               XDOT(K,1) = 0.0
<    99     CONTINUE
< *       Generate a thin disk population in circular orbits.
<           DO 100 I = 2,N
<               BODY(I) = 1.0D-03/FLOAT(N)
<               SEMI = RIN + (ROUT - RIN)*FLOAT(I)/FLOAT(N)
<               VCIRC = SQRT((BODY(1) + BODY(I))/SEMI)
<               PHASE = TWOPI*RAN2(KDUM)
<               X(1,I) = SEMI*COS(PHASE)
<               X(2,I) = SEMI*SIN(PHASE)
<               X(3,I) = 0.01*(2.0*RAN2(KDUM) - 1.0)
<               XDOT(1,I) = -VCIRC*SIN(PHASE)
<               XDOT(2,I) = VCIRC*COS(PHASE)
<               XDOT(3,I) = 0.01*VCIRC*(2.0*RAN2(KDUM) - 1.0)
<   100     CONTINUE
< *       Define membership of perturber and ensure no external tide.
<           N2 = 1
<           KZ(14) = 0
< *       Redefine solar mass unit and astronomical length scale in AU.
<           ZMBAR = 1.0
<           RBAR = 1.0/2.05D+05
<           BODY(N+1) = SCALE*BODY(1)
<           ZMTOT = ZMASS + BODY(N+1)
< *       Set appropriate mass ratios for transforming to new c.m. frame.
<           FAC1 = BODY(N+1)/(ZMASS + BODY(N+1))
<           FAC2 = ZMASS/(ZMASS + BODY(N+1))
<           ZMASS = ZMASS + BODY(N+1)
< *       Form orbital elements for massive perturber (avoid ECC = 1).
<           IF (ABS(ECC - 1.0).GT.1.0D-05) THEN
<               SEMI = DMIN/(1.0 - ECC)
<           ELSE
<               SEMI = -1.0D+05
<           END IF
<           VM2 = ZMASS*(2.0/DMIN - 1.0/SEMI)
<           VAP2 = ZMASS*(2.0/APO - 1.0/SEMI)
< *       Determine initial y-velocity from angular momentum conservation.
<           VY = SQRT(VM2)*DMIN/APO
<           VX = SQRT(VAP2 - VY**2)
< *       Place perturber on the Y-axis with appropriate velocities.
<           X(1,N+1) = APO*FAC2
<           X(2,N+1) = 0.0
<           X(3,N+1) = 0.0
<           XDOT(1,N+1) = -VX*FAC2
<           XDOT(2,N+1) = VY*FAC2
<           XDOT(3,N+1) = 0.0
< *       Displace the disk members and include negative y-velocity.
<           DO 120 I = 1,N
<               X(1,I) = X(1,I) - FAC1*APO
<               XDOT(1,I) = XDOT(1,I) + FAC1*VX
<               XDOT(2,I) = XDOT(2,I) - FAC1*VY
<   120     CONTINUE
<       ELSE IF (KZ(5).EQ.4) THEN
< *       Include two massive bodies (ECC > 1: NAME = 1 & 2 free floating).
<           N2 = 0
<           READ (5,*)  SEMI, ECC, ZM1, ZM2
<           WRITE (6,125)  SEMI, ECC, ZM1, ZM2
<   125     FORMAT (/,12X,'MASSIVE BODIES    A =',1P,E9.1,
<      &            '  E =',0P,F6.2,'  M1/<M> =',F6.2,'  M2/<M> =',F6.2)
<           BODY(1) = ZM1
<           BODY(2) = ZM2
<           IF (ECC.LT.1.0) THEN
< *       Set apocentre velocity for new combined mass (using NAME = 1 & 2).
<               VAP = SQRT((ZM1 + ZM2)/SEMI)*SQRT((1.0 - ECC)/(1.0 + ECC))
<               FAC1 = ZM2/(ZM1 + ZM2)
<               FAC2 = ZM1/(ZM1 + ZM2)
<               DO 130 K = 1,3
<                   X(K,1) = 0.0
<                   X(K,2) = 0.0
<                   XDOT(K,2) = 0.0
<   130         CONTINUE
< *       Initialize binary with c.m. at rest (elements change in SCALE).
<               X(1,1) = -FAC1*SEMI*(1.0 + ECC)
<               X(1,2) = FAC2*SEMI*(1.0 + ECC)
<               XDOT(2,1) = -FAC1*VAP
<               XDOT(2,2) = FAC2*VAP
<           END IF
<       ELSE
<           GO TO 90
<       END IF
< *
< *       Specify new membership.
<       N = N + N2
<       NZERO = N
<       NTOT = N
<       IF (N.GE.NMAX-10) THEN
<           WRITE (6,56)  N, NMAX
<    56     FORMAT (' DANGER!    LIMIT EXCEEDED   N =',I6,'  NMAX =',I6)
<           STOP
<       END IF
< *
<       IF (KZ(5).EQ.2) THEN
<           WRITE (6,58)  SEMI, ECC, N1, N2, SCALE
<    58     FORMAT (/,12X,'PLUMMER BINARY    A =',F6.2,'  E =',F6.2,
<      &                  '  N1 =',I6,'  N2 =',I6,'  SCALE =',F6.2)
<       ELSE IF (KZ(5).EQ.3) THEN
<           WRITE (6,59)  APO, ECC, DMIN, SCALE
<    59     FORMAT (/,12X,'MASSIVE PERTURBER    APO =',F6.2,'  E =',F6.2,
<      &                  '  DMIN =',F6.2,'  MP/M1 =',F6.2)
<       END IF
< *
< *       Re-initialize centre of mass terms.
<       DO 60 K = 1,3
<           CMR(K) = 0.0D0
<           CMRDOT(K) = 0.0D0
<    60 CONTINUE
<       ZMASS = 0.0
<       DO 70 I = 1,N
<           ZMASS = ZMASS + BODY(I)
<           DO 65 K = 1,3
<               CMR(K) = CMR(K) + BODY(I)*X(K,I)
<               CMRDOT(K) = CMRDOT(K) + BODY(I)*XDOT(K,I)
<    65     CONTINUE
<    70 CONTINUE
<       DO 80 I = 1,N
<           DO 75 K = 1,3
<               X(K,I) = X(K,I) - CMR(K)/ZMASS
<               XDOT(K,I) = XDOT(K,I) - CMRDOT(K)/ZMASS
<    75     CONTINUE
<    80 CONTINUE
272c95
<    90 IDUM1 = KDUM
---
>    60 IDUM1 = KDUM
1,2c1,2
< 2414 2006-09-09 19:28 /work/Umi2/spurzem/5/nbody6compare-oct2006/shrink.f
< nbody6compare-oct2006/shrink.f
---
> 2407 2000-05-04 21:24 /work/Umi2/spurzem/5/nbody6++compare/shrink.f
> nbody6++compare/shrink.f
1c1
<       SUBROUTINE SHRINK(TMIN)
---
>       SUBROUTINE SHRINK
8c8
<       PARAMETER  (DTM = 0.03125D0)
---
>       PARAMETER  (DTM = 0.03125)
55c55
<               IF (T0R(J) + 0.5*STEPR(J).GE.TMIN.AND.IT.LT.5) THEN
---
>               IF (T0R(J) + 0.5*STEPR(J).GT.TIME.AND.IT.LT.5) THEN
73a74
> 
1,2c1,2
< 12032 2005-10-26 16:04 /work/Umi2/spurzem/5/nbody6compare-oct2006/slow.f
< nbody6compare-oct2006/slow.f
---
> 5097 1999-12-13 11:35 /work/Umi2/spurzem/5/nbody6++compare/slow.f
> nbody6++compare/slow.f
9,10c9,10
<       LOGICAL  KSLOW,KCOLL,KCASE
<       REAL*8  KSCH,KSNEW,VI(NMX3),VC(NMX3),RC1(3),RC2(3)
---
>       LOGICAL  KSLOW,KCOLL
>       REAL*8  Y(NMX8),KSCH,KSNEW
16d15
<       COMMON/CHREG/  TIMEC,TMAX,RMAXC,CM(10),NAMEC(6),NSTEP1,KZ27,KZ30
20,29c19
< *       Check for switching off slow-down at start of iteration.
<       if (GCRIT.eq.0.0d0) then
<           ksnew = 1.0
<           go to 90
<       end if
< *
< *       Set logical variable to avoid multiple copies of QK & PK.
<       KCASE = .FALSE.
< *
< *       Perform perturbation check if slow-down not active.
---
> *       Perform fast perturbation check if slow-down not active.
33c23
<           DO 1 I = 1,N-1
---
>           DO I = 1,N-1
38c28
<     1     CONTINUE
---
>           END DO
40,80c30
< *       Check carefully two possible binaries (eccentricity effect).
<           IF (N.GT.3) THEN
<               KCASE = .TRUE.
< *       Save QK & PK and copy current configuration for EREL & TRANSK.
<               DO 5 I = 1,N-1
<                   KS = 4*(I - 1)
<                   DO 4 J = 1,4
<                       QK(KS+J) = Q(KS+J)
<                       PK(KS+J) = P(KS+J)
<     4             CONTINUE
<     5         CONTINUE
< *       Evaluate first semi-major axis from non-singular variables.
<               K1 = INAME(i1)
<               K2 = INAME(i1+1)
<               CALL EREL(i1,EB,SEMI)
< *       Determine index of second smallest separation.
<               RI2 = 0.0
<               DO 10 I = 1,N-1
<                   IF (I.NE.I1.AND.RINV(I).GT.RI2) THEN
<                       I2 = I
<                       RI2 = RINV(I)
<                   END IF
<    10         CONTINUE
< *       Obtain second semi-major axis (errors only affect decision-making).
<               K1 = INAME(i2)
<               K2 = INAME(i2+1)
<               CALL EREL(i2,EB,SEMI2)
< *       Switch to #I2 if second binary is smaller or first pair is not bound.
<               IF (SEMI2.GT.0.0) THEN
<                   IF (SEMI2.LT.SEMI.OR.SEMI.LT.0.0) THEN
<                       I1 = I2
<                       SEMI = SEMI2
<                       RM = RINV(I2)
<                   END IF
< *       Exit in case of two hyperbolic two-body motions.
<               ELSE IF (SEMI.LT.0.0) THEN
<                   GO TO 100
<               END IF
<           END IF
< *
< *       Sum the perturbing forces m/r^3 next to #i1 (two terms if i1 = 2).
---
> *       Sum the perturbating forces m/r^3 next to #i1.
82c32
<           do 15 i = 1,n-1
---
>           do i = 1,n-1
88,109c38
<    15     continue
< *
< *       Include one more contribution for two consecutive perturbers.
<           if (i1.eq.1) then
<               LJ = 3*i1
<               do k = 1,3
<                   RC2(k) = XC(k+LJ+3) + XC(k+LJ)
<               end do
< *       Add perturbation from second subsequent member (i = i1 + 2).
<               RJ = SQRT(RC2(1)**2 + RC2(2)**2 + RC2(3)**2)
<               j = i1 + 3
<               sum = sum + mc(j)/RJ**3
<           else if (i1.ge.3) then
<               LJ = 3*(i1 - 2)
<               do k = 1,3
<                   RC2(k) = XC(k+LJ-3) + XC(k+LJ)
<               end do
< *       Add the previous perturbation (neglected in do 15 loop).
<               RJ = SQRT(RC2(1)**2 + RC2(2)**2 + RC2(3)**2)
<               j = i1 - 2
<               sum = sum + mc(j)/RJ**3
<           end if
---
>           end do
115c44
<               GO TO 100
---
>               GO TO 50
118a48,50
> *       Save the current variables in common (RINV is OK after switching).
>       CALL YSAVE(Y)
> *
120,178c52,55
<       IF (KSLOW.AND.N.GT.3) THEN
<           DO 20 I = 1,N-1
<               IF (KSCH(I).GT.1.0D0) i1 = i
<    20     CONTINUE
< *       See whether a closer particle pair is present (factor of 2).
<           I2 = 0
<           R1 = 1.0/RINV(I1)
<           DO 60 I = 1,N-1
<               RI2 = 1.0/RINV(I)
<               IF (I.NE.I1.AND.R1.LT.0.5*RI2) THEN
<                   I2 = I
<                   IF (R1.LT.0.1*SEMI.AND.RI2.LT.0.1*SEMI) THEN
<                       GO TO 100
<                   END IF
< *       Compare closest separation with current slow-down binary.
<                   IF (RI2.LT.0.5*SEMI.AND.R1.GT.0.5*SEMI) THEN
< *       Evaluate semi-major axis directly (cf. small RI2 in EREL).
<                       L = 3*(N-2)
<                       DO 25 K = 1,3
<                           VI(K) = -WC(K)/MC(1)
<                           VI(L+K+3) = WC(L+K)/MC(N)
<    25                 CONTINUE
<                       DO 35 II = 2,N-1
<                           L = 3*(II-1)
<                           DO 30 K = 1,3
<                               VI(L+K) = (WC(L+K-3) - WC(L+K))/MC(II)
<    30                     CONTINUE
<    35                 CONTINUE
<                       DO 40 J = 1,3*(N-1)
<                           VC(J) = VI(J+3) - VI(J)
<    40                 CONTINUE
<                       L = 3*(I1-1)
<                       R2 = XC(L+1)**2 + XC(L+2)**2 + XC(L+3)**2
<                       W2 = VC(L+1)**2 + VC(L+2)**2 + VC(L+3)**2
<                       SEMI = 2.0D0/R1 - W2/(MC(I1) + MC(I1+1))
<                       SEMI = 1.0D0/SEMI
<                       GO TO 80
<                   ELSE IF (RI2.LT.MIN(SEMI,R1).AND.R1.GT.0.5*SEMI) THEN
< *       Determine second binary by regular expression (R1 not too small).
<                       DO 50 II = 1,N-1
<                           KS = 4*(II - 1)
<                           DO 45 J = 1,4
<                               QK(KS+J) = Q(KS+J)
<                               PK(KS+J) = P(KS+J)
<    45                     CONTINUE
<    50                 CONTINUE
<                       K1 = INAME(i2)
<                       K2 = INAME(i2+1)
<                       CALL EREL(i2,EB2,SEMI2)
<                       IF (SEMI2.GT.0.0.AND.SEMI2.LT.SEMI) THEN
<                           KSNEW = 1.0D0
<                           GO TO 90
<                       ELSE
< *       Continue with the current binary (ie. small change in perturbation).
<                           GO TO 80
<                       END IF
<                   END IF
<               END IF
<    60     CONTINUE
---
>       IF (KSLOW) THEN
>           DO I = 1,N-1
>               IF (KSCH(I).GT.1.0) i1 = i
>           END DO
181,182c58,63
< *       Obtain regular semi-major axis for missing cases (including N = 3).
<       IF (.NOT.KCASE) THEN
---
> *       Check for switching off slow-down at start of iteration.
>       if (GCRIT.eq.0.0d0) then
>           ksnew = 1.0
>           go to 30
>       end if
> *
184,190c65,71
<           DO 70 I = 1,N-1
<               KS = 4*(I - 1)
<               DO 65 J = 1,4
<                   QK(KS+J) = Q(KS+J)
<                   PK(KS+J) = P(KS+J)
<    65         CONTINUE
<    70     CONTINUE
---
>       DO 10 I = 1,N-1
>           KS = 4*(I - 1)
>           DO 5 J = 1,4
>               QK(KS+J) = Q(KS+J)
>               PK(KS+J) = P(KS+J)
>     5     CONTINUE
>    10 CONTINUE
193,202c74,76
<           K1 = INAME(i1)
<           K2 = INAME(i1+1)
<           CALL EREL(i1,EB,SEMI)
< *       Exit if no current binary (set KSLOW = .false. just in case).
<           IF (SEMI.LE.0.0d0) THEN
<               KSLOW = .false.
<               TK2(0) = 0.0
<               GO TO 100
<           END IF
<       END IF
---
>       K1 = INAME(i1)
>       K2 = INAME(i1+1)
>       CALL EREL(i1,EB,SEMI)
204,216c78,82
< *       Check for switching to smaller binary (exchange leads to escape).
<       IF (KSLOW.AND.N.GT.3) THEN
<           IF (I2.GT.0) THEN
< *       Evaluate second semi-major axis (K1 & K2 can be over-written).
<               K1 = INAME(i2)
<               K2 = INAME(i2+1)
<               CALL EREL(i2,EB2,SEMI2)
<               IF (SEMI2.GT.0.0.AND.SEMI2.LT.SEMI) THEN
< *       Switch off the present pair to prepare re-activation.
<                   ksnew = 1.0
<                   go to 90
<               END IF
<           END IF
---
> *       Exit if no current binary (set KSLOW = .false. just in case).
>       IF (SEMI.LE.0.0d0) THEN
>           KSLOW = .false.
>           TK2(0) = 0.0
>           GO TO 50
219,220c85,86
< *       Sum the perturbations (on either side and non-dominant terms).
<    80 IF (KSLOW) THEN
---
> *       Sum the perturbations next to #i1 (already known if KSLOW active).
>       IF (KSLOW) THEN
223,252d88
< *
< *       Include full perturbation (non-symmetrical i1 for n = 4 or n > 4).
<               if ((n.eq.4.and.i1.ne.2).or.n.gt.4) then
<                   do k = 1,3
<                       RC1(K) = 0.0
<                   end do
< *       Save vector sum on either side of #i1 excluding closest neighbour.
<                   if (i.lt.i1-1) then
<                       do j = i+1,i1-1
<                           LJ = 3*(j-1)
<                           do k = 1,3
<                               RC1(k) = RC1(k) + XC(k+LJ)
<                           end do
<                       end do
< *       Check alternative case of subsequent distant members (i > i1 + 1).
<                   else if (i.gt.i1+1) then
<                       do j = i1+1,i-1
<                           LJ = 3*(j-1)
<                           do k = 1,3
<                               RC1(k) = RC1(k) + XC(k+LJ)
<                           end do
<                       end do
<                   end if
<               end if
< *
< *       Set chain offset and mass reference index.
<               L = 3*(I-1)
<               j = i
<               if (i.gt.i1) j = i + 1
< *       Use actual separation if perturber is next to dominant binary.
253a90,91
>                   j = i
>                   if (i.gt.i1) j = i + 1
255,262d92
<               else if (i.ne.i1) then
< *       Include chain vector to yield full distance to binary.
<                   do k = 1,3
<                       RC2(k) = RC1(k) + XC(k+L)
<                   end do
< *       Add contribution from more distant member.
<                   RJ = SQRT(RC2(1)**2 + RC2(2)**2 + RC2(3)**2)
<                   sum = sum + mc(j)/RJ**3
300c130
<    90 if (ksnew.ne.ksch(i1)) then
---
>    30 if (ksnew.ne.ksch(i1)) then
343c173
<   100 RETURN
---
>    50 RETURN
1,2c1,2
< 810 2004-05-11 10:49 /work/Umi2/spurzem/5/nbody6compare-oct2006/sort1.f
< nbody6compare-oct2006/sort1.f
---
> 817 2001-08-26 01:41 /work/Umi2/spurzem/5/nbody6++compare/sort1.f
> nbody6++compare/sort1.f
7,8c7,9
<       INTEGER  RB(N),RRB
<       REAL*8  RA(N),RRA
---
>       INTEGER  RB,RRB
>       REAL*8 RA(N),RRA
>       DIMENSION  RB(N)
14c15
<       IF (L.GT.1) THEN
---
>       IF(L.GT.1)THEN
24c25
< 	  IF (IR.EQ.1) THEN
---
> 	  IF(IR.EQ.1)THEN
32,34c33,35
<    20 IF (J.LE.IR) THEN
< 	  IF (J.LT.IR) THEN
< 	      IF (RA(J).LT.RA(J+1)) J=J+1
---
>    20 IF(J.LE.IR)THEN
> 	  IF(J.LT.IR)THEN
> 	      IF(RA(J).LT.RA(J+1))J=J+1
36c37
< 	  IF (RRA.LT.RA(J)) THEN
---
> 	  IF(RRA.LT.RA(J))THEN
1,2c1,2
< 3590 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/stabl3.f
< nbody6compare-oct2006/stabl3.f
---
> 2855 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/stabl3.f
> nbody6++compare/stabl3.f
60,61c60,61
< *     AM = (2.65 + E)*(1.0 + M(I)/MB)**0.3333
< *     FM = (2.0*M(I) - MB)/(3.0*MB)
---
>       AM = (2.65 + E)*(1.0 + M(I)/MB)**0.3333
>       FM = (2.0*M(I) - MB)/(3.0*MB)
64,83c64,65
< *     IF (ABS(FM).LT.0.67) THEN
< *         BM = FM*(1.0 - (0.5 - ONE3*FM)*FM)
< *     ELSE
< *         BM = LOG(1.0D0 + FM)
< *     END IF
< *       Define mass dependent criterion of Harrington (A.J. 80) & Bailyn.
< *     PCRIT = AM*(1.0 + 0.7*BM)*SEMI
< *
< *       Form hierarchical stability ratio (Kiseleva & Eggleton 1995).
< *     Q0 = MB/M(I)
< *     Q1 = MAX(M(3)/M(IM),M(IM)/M(3))
< *     Q3 = Q0**0.33333
< *     Q13 = Q1**0.33333
< *     AR = 1.0 + 3.7/Q3 - 2.2/(1.0 + Q3) + 1.4/Q13*(Q3 - 1.0)/(Q3 + 1.0)
< *     PCRIT = AR*SEMI*(1.0D0 + E)
< *
< *       Adopt the semi-analytical stability criterion (MA 1997).
<       Q1 = M(I)/MB
<       IF (E1.LT.1.0) THEN
<           XFAC = (1.0 + Q1)*(1.0 + E1)/SQRT(1.0 - E1)
---
>       IF (ABS(FM).LT.0.67) THEN
>           BM = FM*(1.0 - (0.5 - 0.3333*FM)*FM)
85c67
<           XFAC = 40.0*(1.0 + Q1)
---
>           BM = LOG(1.0D0 + FM)
87c69,71
<       PCRIT = 2.8*XFAC**0.4*SEMI
---
> *
> *       Adopt mass dependent criterion of Harrington (A.J. 80) & Bailyn.
>       PCRIT = AM*(1.0 + 0.7*BM)*SEMI
90,91c74,81
< *       Set negative termination index if system is stable and RB > SEMI.
<       IF (PCRIT.LT.PMIN.AND.E1.LT.1.0.AND.RB.GT.SEMI) THEN
---
> *       Obtain stability parameter by Zare's method.
>       M1 = M(IM)
>       M2 = M(3)
>       M3 = M(I)
>       CALL STABLZ(M1,M2,M3,SP)
> *
> *       Set negative termination index if system is stable.
>       IF (PCRIT.LT.PMIN) THEN
93,97d82
< *       Obtain Zare's stability parameter (valid for small inclinations).
<           M1 = M(IM)
<           M2 = M(3)
<           M3 = M(I)
<           CALL STABLZ(M1,M2,M3,SP)
99c84
<    20     FORMAT ('  STABT:    A A1 E E1 RI RATIO SP PCR PM ',
---
>    20     FORMAT ('  STABT:  A A1 E E1 RI RATIO SP PCR PM ',
101,103d85
< *       Terminate if escaper is outside 3*SEMI.
<       ELSE IF (E1.GT.1.0.AND.RI.GT.3.0*SEMI) THEN
<           ITERM = -1
1,2c1,2
< 5439 2004-05-11 10:54 /work/Umi2/spurzem/5/nbody6compare-oct2006/stabl4.f
< nbody6compare-oct2006/stabl4.f
---
> 3706 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/stabl4.f
> nbody6++compare/stabl4.f
38d37
<       RB2 = 0.0D0
41d39
<       RDOT2 = 0.0D0
45d42
<       VREL22 = 0.0D0
64d60
<           RB2 = RB2 + (RC0(K) - X(J3))**2
67d62
<           RDOT2 = RDOT2 + (RC0(K) - X(J3))*(VC0(K) - XD(J3))
71d65
<           VREL22 = VREL22 + (VC0(K) - XD(J3))**2
80c74
< *       Form semi-major axis & eccentricity of outer pair.
---
> *       Form semi-major axis & eccentricity of wide pair.
84c78
< *     E = SQRT((1.0D0 - RB/SEMI)**2 + RDOT**2/(SEMI*MB))
---
>       E = SQRT((1.0D0 - RB/SEMI)**2 + RDOT**2/(SEMI*MB))
92,98d85
< *       Consider the inner triple.
<       MB2 = MB0 + M(K3)
<       RB2 = SQRT(RB2)
<       SEMI2 = 2.0D0/RB2 - VREL22/MB2
<       SEMI2 = 1.0/SEMI2
<       E2 = SQRT((1.0D0 - RB2/SEMI2)**2 + RDOT2**2/(SEMI2*MB2))
< *
103,104c90,91
< *     AM = (2.65 + E0)*(1.0 + MB0/MB)**0.3333
< *     FM = (2.0*MB0 - MB)/(3.0*MB)
---
>       AM = (2.65 + E0)*(1.0 + MB0/MB)**0.3333
>       FM = (2.0*MB0 - MB)/(3.0*MB)
107,111c94,98
< *     IF (ABS(FM).LT.0.67) THEN
< *         BM = FM*(1.0 - (0.5 - 0.3333*FM)*FM)
< *     ELSE
< *         BM = LOG(1.0D0 + FM)
< *     END IF
---
>       IF (ABS(FM).LT.0.67) THEN
>           BM = FM*(1.0 - (0.5 - 0.3333*FM)*FM)
>       ELSE
>           BM = LOG(1.0D0 + FM)
>       END IF
114c101,102
< *     PCRIT = AM*(1.0 + 0.7*BM)*SEMI0
---
>       PCRIT = AM*(1.0 + 0.7*BM)*SEMI0
>       PMIN = SEMI1*(1.0D0 - E1)
116,158c104,112
< *       Form hierarchical stability ratio (Kiseleva & Eggleton 1995).
< *     Q0 = MB/MB0
< *     Q1 = MAX(M(K2)/M(K1),M(K1)/M(K2))
< *     Q3 = Q0**0.33333
< *     Q13 = Q1**0.33333
< *     AR = 1.0 + 3.7/Q3 - 2.2/(1.0 + Q3) + 1.4/Q13*(Q3 - 1.0)/(Q3 + 1.0)
< *     PCRIT = AR*SEMI0*(1.0D0 + E0)
< *
< *       Check stability (AM 1997; inner triple or well separated quadruple).
<       ITERM = 0
<       IF (RB1.GT.5.0*RB2.AND.E2.LT.1.0) THEN
<           Q1 = M(K3)/MB0
<           XFAC = (1.0 + Q1)*(1.0 + E2)/SQRT(1.0 - E2)
<           PCRIT = 2.8*XFAC**0.4*SEMI0
<           PMIN = SEMI2*(1.0 - E2)
<           IF (PCRIT.LT.PMIN) THEN
<               ITERM = -1
<               RATIO = SEMI2*(1.0D0 - E2)/(SEMI0*(1.0D0 + E0))
<               WRITE (6,15)  SEMI0, SEMI2, E0, E2, RATIO, RB0, RB2,
<      &                      PCRIT, PMIN
<    15         FORMAT ('  STABT:    A0 A2 E0 E2 RATIO R0 R2 PCR PM ',
<      &                             1P,2E10.2,0P,2F7.3,F6.2,1P,4E9.1)
<           END IF
<       ELSE IF (RB1.GT.5.0*MAX(RB0,RB).AND.E1.LT.1.0.AND.
<      &         MIN(SEMI0,SEMI).GT.0.0) THEN
< *       Choose smallest binary as third body and ignore fudge factor.
<           IF (SEMI.GT.SEMI0) THEN
<               Q1 = MB0/MB
<               AIN = SEMI
<           ELSE
<               Q1 = MB/MB0
<               AIN = SEMI0
<           END IF
<           XFAC = (1.0 + Q1)*(1.0 + E1)/SQRT(1.0 - E1)
<           PCRIT = 2.8*XFAC**0.4*AIN
<           PMIN = SEMI1*(1.0 - E1)
<           IF (PCRIT.LT.PMIN) THEN
<               ITERM = -1
<               WRITE (6,20)  AIN, SEMI1, E0, E1, RATIO, RB0, RB1,
<      &                      PCRIT, PMIN
<    20         FORMAT ('  STABQ:    AIN A1 E0 E1 RATIO R0 R1 PCR PM ',
<      &                             1P,2E10.2,0P,2F7.3,F6.2,1P,4E9.1)
<           END IF
---
> *       Set negative termination index if system is stable or SEMI < 0.
>       IF (PCRIT.LT.PMIN) THEN
>           ITERM = -1
>           WRITE (6,20)  SEMI, SEMI1, E, E1, RB1, RATIO, PCRIT, PMIN,
>      &                  SEMI0, RB0
>    20     FORMAT ('  STABQ:  A A1 E E1 R1 RATIO PCR PM A0 RB0 ',
>      &                            1P,2E10.2,0P,2F6.2,F9.5,F6.2,1P,4E9.1)
>       ELSE
>           ITERM = 0
1,2c1,2
< 5136 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/stablc.f
< nbody6compare-oct2006/stablc.f
---
> 5136 1999-12-17 10:14 /work/Umi2/spurzem/5/nbody6++compare/stablc.f
> nbody6++compare/stablc.f
1,2c1,2
< 2172 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/stablz.f
< nbody6compare-oct2006/stablz.f
---
> 2172 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/stablz.f
> nbody6++compare/stablz.f
1,2c1,2
< 12734 2006-08-16 10:19 /work/Umi2/spurzem/5/nbody6compare-oct2006/star.f
< nbody6compare-oct2006/star.f
---
> 12006 2006-06-18 03:51 /work/Umi2/spurzem/5/nbody6++compare/star.f
> nbody6++compare/star.f
13,14c13,15
<       real*8 tgb,tbagb,mch,mcmax,mc1,mc2,mcbagb,dx,am
<       real*8 lambda,tau,mtc,mass0
---
>       real*8 tgb,tbagb,mch,mcmax,mc1,mc2,mcbagb,dx,me,am
>       real*8 lambda,tau
>       real*8 mtc
50c51
< *              7; Mx               8; A(He)         9; Mc,BGB
---
> *              7; Mx               8; A(He) 
55,57d55
<       mass0 = mass
<       if(mass0.gt.100.d0) mass = 100.d0
< *
75c73
<       GB(2) = 1.27d-05
---
>       GB(2) = 1.18d-05
95d92
< *
99a97
> *
102,109d99
< *
<       if(mass.lt.0.1d0.and.kw.le.1)then
<          tscls(2) = 1.1d0*tscls(1)
<          tscls(3) = 0.1d0*tscls(1)
<          lums(3) = lbgbf(mass) 
<          goto 96
<       endif
< *
131a122
>             me = MAX(mass - mc1,0.d0)
150,159d140
< * Set the core mass at the BGB.
< *
<       if(mass.le.zpars(2))then
<          GB(9) = mcgbf(lums(3),GB,lums(6))
<       elseif(mass.le.zpars(3))then
<          GB(9) = mcheif(mass,zpars(2),zpars(9))
<       else
<          GB(9) = mcheif(mass,zpars(2),zpars(10))
<       endif
< *
170c151
< * Now to find Ltp and ttp using Mc,He,tp
---
> * Now to fing Ltp and ttp using Mc,He,tp
174c155
<       if(mc1.ge.0.8d0.and.mc1.lt.2.25d0)then
---
>       if(mc1.ge.0.8.and.mc1.lt.2.25)then
207d187
< *
230,233d209
<       if(mass.ge.100.d0)then
<          tn = tscls(2)
<          goto 100
<       endif
242c218
<       if(ABS(mt-mcbagb).lt.1.0d-14.and.kw.lt.5)then
---
>       if(mt.eq.mcbagb.and.kw.lt.5)then
301c277
<       goto 100
---
>       goto 95
308d283
<       tscls(1) = tm
318c293
<       GB(8) = 8.0d-05
---
>       GB(8) = 1.02d-04
339d313
<       if(mtc.le.0.d0) mtc = mt
351,352d324
<       goto 100
< *
354,359d325
<       tm = 1.0d+10
<  96   continue
<       tn = 1.0d+10
< *
<  100  continue
<       mass = mass0
1,2c1,2
< 10432 2006-03-20 05:31 /work/Umi2/spurzem/5/nbody6compare-oct2006/start3.f
< nbody6compare-oct2006/start3.f
---
> 10764 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/start3.f
> nbody6++compare/start3.f
226a227,231
> *       Reduce time-step and check NLIST membership.
> *         STEP(J) = MAX(0.5D0*STEP(J),TIME - T0(J))
> *         IF (T0(J) + STEP(J).LT.TLIST) THEN
> *             CALL NLMOD(J,1)
> *         END IF
299a305,309
> *       See whether body #I should be added to NLIST.
> *     IF (T0(I) + STEP(I).LT.TLIST) THEN
> *         CALL NLMOD(I,1)
> *     END IF
> *
323c333
< *       Set phase indicator = -1 to ensure new time-step list in INTGRT.
---
> *       Set phase indicator = -1 to ensure new NLIST in routine INTGRT.
1,2c1,2
< 10855 2006-03-20 05:32 /work/Umi2/spurzem/5/nbody6compare-oct2006/start4.f
< nbody6compare-oct2006/start4.f
---
> 11282 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/start4.f
> nbody6++compare/start4.f
218a219,223
> *       Reduce time-step and check NLIST membership.
> *         STEP(J) = MAX(0.5D0*STEP(J),TIME - T0(J))
> *         IF (T0(J) + STEP(J).LT.TLIST) THEN
> *             CALL NLMOD(J,1)
> *         END IF
308a314,323
> *       See whether body #I3 or #I4 should be added to NLIST.
> *     I = I3
> * 165 IF (T0(I) + STEP(I).LT.TLIST) THEN
> *         CALL NLMOD(I,1)
> *     END IF
> *     IF (I.EQ.I3) THEN
> *         I = I4
> *         GO TO 165
> *     END IF
> *
332c347
< *       Set phase indicator = -1 to ensure new time-step list in INTGRT.
---
> *       Set phase indicator = -1 to ensure new NLIST in routine INTGRT.
1,2c1,2
< 4470 2006-09-08 15:08 /work/Umi2/spurzem/5/nbody6compare-oct2006/start.f
< nbody6compare-oct2006/start.f
---
> 5678 2006-10-03 16:14 /work/Umi2/spurzem/5/nbody6++compare/start.f
> nbody6++compare/start.f
0a1,4
> # 1 "start.F"
> # 1 "<built-in>"
> # 1 "<command line>"
> # 1 "start.F"
4,5c8,9
< *       Initialization of data & polynomials.
< *       ------------------------------------
---
> * Initialization of data & polynomials.
> * ------------------------------------
8,9c12,13
<       EXTERNAL SCALE,MERGE
<       PARAMETER  (NS=12)
---
>       EXTERNAL SCALE
>       PARAMETER (NS=12)
12c16
< *       Initialize global scalars, counters & useful constants.
---
> * Initialize global scalars, counters & useful constants.
15c19
< *       Read input parameters.
---
> * Read input parameters.
18c22,25
< *       Set initial conditions: BODY(I), X(K,I), XDOT(K,I); I=1,N & K=1,3.
---
> * Open all Files.
>       CALL FILE_INIT(0)
> *
> * Set initial conditions: BODY(I), X(K,I), XDOT(K,I); I=1,N & K=1,3.
21c28
< *       Scale initial conditions to new units.
---
> * Scale initial conditions to new units.
24c31
< *       Set total mass in case routines DATA & SCALE are not used.
---
> * Set total mass in case routines DATA & SCALE are not used.
30c37
< *       Define mean mass in scaled units and solar mass conversion factor.
---
> * Define mean mass in scaled units and solar mass conversion factor.
32,34c39
<       IF (KZ(5).NE.3) THEN
<           ZMBAR = ZMBAR/BODYM
<       END IF
---
>       ZMBAR = ZMBAR/BODYM
36c41
< *       Introduce scaling factors DAYS, YRS, SU, RAU, SMU, TSTAR & VSTAR.
---
> * Introduce scaling factors DAYS, YRS, SU, RAU, SMU, TSTAR & VSTAR.
39,40c44,45
< *       Check option for external force.
<       IF (KZ(14).GT.0) THEN 
---
> * Check option for external force.
>       IF (KZ(14).GT.0) THEN
42c47
<       END IF 
---
>       END IF
44c49
< *       Check optional scaling to hot system.
---
> * Check optional scaling to hot system.
49c54
< *       Check option for initial binaries.
---
> * Check option for initial binaries.
54,57c59,62
< *       Include stable primordial triples.
< *     IF (KZ(18).GT.1.AND.KZ(8).GT.0) THEN
< *         CALL HIPOP
< *     END IF
---
> * Include stable primordial triples.
>       IF (KZ(11).GT.1.AND.KZ(8).GT.0) THEN
>           CALL HIPOP
>       END IF
59c64
< *       Check optional initialization for tidal two-body capture.
---
> * Check optional initialization for tidal two-body capture.
64c69
< *       Set sequential name, maximum mass & primary velocity.
---
> * Set sequential name, maximum mass & primary velocity.
71c76
<    15     CONTINUE
---
>    15 CONTINUE
74c79
< *       Initialize fixed block steps (40 levels).
---
> * Initialize fixed block steps (64 levels).
77c82
< *       Create table of inverse Stumpff coefficients.
---
> * Create table of inverse Stumpff coefficients.
79c84
<           SCOEFF(I) = 1.0D0/((I + 1)*(I + 2))
---
>           SCOEFF(I) = 1.0/((I + 1)*(I + 2))
82c87
< *       Set optional stellar evolution parameters or define STEPX.
---
> * Set optional stellar evolution parameters.
85,88d89
<       ELSE IF (KZ(14).GT.1) THEN
<           DT = 1.0E-03/TSCALE
<           CALL STEPK(DT,DTN)
<           STEPX = DTN
91c92
< *       Initialize optional cloud parameters.
---
> * Initialize optional cloud parameters.
96c97
< *       Set initial neighbour list & corresponding radius.
---
> * Set initial neighbour list & corresponding radius.
98a100
> *
104c106,110
< *       Obtain force & first derivative.
---
> * Obtain force & first derivative.
>       call cputim(tt1)
> 
> 
> 
106,107c112,120
< *
< *       Obtain second & third force derivatives and set time-steps.
---
> 
>       call cputim(tt2)
>       if(rank.eq.0)print*,' fpoly1 time=',(tt2-tt1)*60.
> *
> * Obtain second & third force derivatives and set time-steps.
>       call cputim(tt1)
> 
> 
> 
108a122,124
> 
>       call cputim(tt2)
>       if(rank.eq.0)print*,' fpoly2 time=',(tt2-tt1)*60.
110c126
< *       Regularize any hard primordial binaries (assume sequential ordering).
---
> * Regularize any hard primordial binaries (assume sequential ordering).
111a128,134
>           SMMIN = 1.D30
>           SMMAX = 0.D0
>           XMMIN = 1.D30
>           XMMAX = 0.D0
>           TMMIN = 1.D30
>           TMMAX = 0.D0
> *
116c139
< *       Include standard distance criterion.
---
> * Include standard distance criterion.
119c142,150
<    45         CONTINUE
---
>    45 CONTINUE
>         IF(RIJ2.LT.SMMIN)SMMIN=RIJ2
>         IF(RIJ2.GT.SMMAX)SMMAX=RIJ2
>               XMBIN = BODY(ICOMP) + BODY(JCOMP)
>               PERIOD = RIJ2**0.75/DSQRT(XMBIN)
>         IF(XMBIN.LT.XMMIN)XMMIN=XMBIN
>         IF(XMBIN.GT.XMMAX)XMMAX=XMBIN
>         IF(PERIOD.LT.TMMIN)TMMIN=PERIOD
>         IF(PERIOD.GT.TMMAX)TMMAX=PERIOD
121c152,173
<                   CALL KSREG
---
>                  CALL KSREG
>               ELSE
>         if(rank.eq.0)PRINT*,' Pair ',IPAIR,' not regularised '
>               END IF
>         if(rank.eq.0)PRINT*,' rij/AU, tcross/YRS=',
>      * DSQRT(RIJ2)*RAU,PERIOD*YRS
>                   CALL FLUSH(6)
>    50 CONTINUE
> *
> * Adjust NNBMAX (R.Sp.)
>       NNBMAX = MIN(N/2,LMAX - 3)
>       ZNBMIN = MAX(0.01*FLOAT(NNBMAX),1.0)
>       ZNBMAX = 0.9*FLOAT(NNBMAX)
> *
> * Check initial neighbour lists again.
>           DO 55 I = IFIRST,NTOT
>               IF(I.GT.N)THEN
>               ICOMP = 2*IPAIR - 1
>               JCOMP = 2*IPAIR
>                   RS0 = RS(ICOMP)
>               ELSE
>                   RS0 = RC
123c175,177
<    50     CONTINUE
---
>                   CALL NBLIST(I,RS0)
>    55 CONTINUE
> *
126,150c180,195
< *       Include optional regularization of primordial triples.
<       IF (KZ(18).GT.1.AND.NHI0.GT.0) THEN
<           KSPAIR = 1
< *       Note that each KS pair will move to the top of the queue.
<    60     ICOMP = 2*KSPAIR - 1
<           ICM = KSPAIR + N
<           RX2 = 1.0
< *       Find index of closest outer component without any assumption.
<           DO 70 J = IFIRST,N
<               RIJ2 = 0.0
<               DO 65 K = 1,3
<                   RIJ2 = RIJ2 + (X(K,ICM) - X(K,J))**2
<    65         CONTINUE
<               IF (RIJ2.LT.RX2) THEN
<                   RX2 = RIJ2
<                   JCOMP = J
<               END IF
<    70     CONTINUE
< *       Evaluate PCRIT for R0(NPAIRS) in MERGE since IMPACT is bypassed.
<           CALL HISTAB(KSPAIR,JCOMP,PMIN,RSTAB)
< *       Initialize the triple (constructed to be stable in HIPOP).
<           IPHASE = 6
<           CALL MERGE
<           IF (NMERGE.LT.NHI0) THEN
<               GO TO 60
---
> * Initialize the time-step list used to find next body.
>       DTLIST = 100.0
>       DO 60 I = IFIRST,NTOT
>           DTLIST = MIN(DTLIST,STEP(I))
>    60 CONTINUE
> *
> * Set initial time-step list interval twice the smallest step.
>       DTLIST = 2.0*DTLIST
>    70 NNB = 1
>       TLIST = TLIST + DTLIST
> *
> * Select all members due in the interval (0,TLIST).
>       DO 80 J = IFIRST,NTOT
>           IF (T0(J) + STEP(J).LT.TLIST) THEN
>               NNB = NNB + 1
>               NLIST(NNB) = J
151a197,205
>    80 CONTINUE
> *
> * Check whether membership range is acceptable.
>       IF (NNB.EQ.1) GO TO 70
> *
>       IF (NNB.GT.LMAX) THEN
>           TLIST = TLIST - DTLIST
>           DTLIST = 0.66*DTLIST
>           GO TO 70
154c208,212
< *       Check the average neighbour number.
---
> * Reduce new DTLIST to prevent early crowding and set membership.
>       DTLIST = 0.2*DTLIST
>       NLIST(1) = NNB - 1
> *
> * Check the average neighbour number.
157,159c215,226
<           WRITE (6,90)  ZNB
<    90     FORMAT (/,12X,'WARNING!   SMALL NEIGHBOUR NUMBERS   <NNB> =',
<      &                                                             F5.1)
---
>           if(rank.eq.0)WRITE (6,90) ZNB
>    90 FORMAT (/,12X,'WARNING!   SMALL NEIGHBOUR NUMBERS   <NNB> =',
>      & F5.1)
>       END IF
> *
> * Check option for writing the initial conditions on unit 10.
>       if(rank.eq.0)then
>       IF (KZ(22).EQ.1) THEN
>           DO 85 I = 1,N
>              WRITE (10,100) BODY(I),(X(K,I),K=1,3),(XDOT(K,I),K=1,3)
>    85 CONTINUE
>   100 FORMAT(1X,1P,7(1X,D18.10))
160a228
>       end if
1,2c1,2
< 1768 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/status.f
< nbody6compare-oct2006/status.f
---
> 1768 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/status.f
> nbody6++compare/status.f
1,2c1,2
< 773 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/stepi.f
< nbody6compare-oct2006/stepi.f
---
> 762 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/stepi.f
> nbody6++compare/stepi.f
19c19
< *       Obtain time-step by simplified relative criterion.           
---
> *       Obtain time-step by simplified relative criterion.
1,2c1,2
< 780 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/stepk.f
< nbody6compare-oct2006/stepk.f
---
> 752 2000-04-13 02:52 /work/Umi2/spurzem/5/nbody6++compare/stepk.f
> nbody6++compare/stepk.f
8,9c8
<       DATA  ONE32 /0.03125/
< *     DATA  ONE16,ONE32 /0.0625D0,0.03125/
---
>       DATA  ONE16,ONE32 /0.0625D0,0.03125/
1,2c1,2
< 3569 2005-02-15 13:48 /work/Umi2/spurzem/5/nbody6compare-oct2006/steps.f
< nbody6compare-oct2006/steps.f
---
> 3325 2003-06-26 03:20 /work/Umi2/spurzem/5/nbody6++compare/steps.f
> nbody6++compare/steps.f
9d8
< *
16,17c15
< *       Include precaution for small force or velocity (i.e. DT = ETA*TCR0).
<           IF (FI2.LT.BODYM**2/RS(I)**4) FI2 = BODYM**2/RS(I)**4
---
> *       Include precaution for small velocities (i.e. DT = ETA*TCR0).
19c17
<           DT = 0.5*ETAI*SQRT(FI2/FD2)
---
>           DT = ETAI*SQRT(FI2/FD2)
21,29c19,21
<           FD2 = D1R(1,I)**2 + D1R(2,I)**2 + D1R(3,I)**2
<           IF (FD2.LT.FR2) FD2 = FR2/TCR0**2
< *       Prescribe safe value for small or zero regular force.
<           IF (FR2.LT.0.1*BODYM/RS(I)**2) THEN
<               DTR = ETAR*TCR0
<           ELSE
<               DTR = ETAR*SQRT(FR2/FD2)
<           END IF
<  
---
>           FDR2 = D1R(1,I)**2 + D1R(2,I)**2 + D1R(3,I)**2
>           IF (FDR2.LT.FR2) FDR2 = FR2/TCR0**2
>           DTR = ETAR*SQRT(FR2/FDR2)
43a36
> *
55,56c48
<                   IF (ITER.LT.16.OR.STEP(I).GT.DTK(40)) GO TO 10
<                   STEP(I) = DTK(40)
---
>                   IF (ITER.LT.40.OR.STEP(I).GT.DTK(40)) GO TO 10
59a52
>                   STEP(I) = DTK(40)
65,66c58
<                   IF (ITER.LT.16.OR.STEPR(I).GT.DTK(40)) GO TO 18
<                   STEPR(I) = DTK(40)
---
>                   IF (ITER.LT.40.OR.STEPR(I).GT.DTK(40)) GO TO 18
69a62
>                   STEPR(I) = DTK(40)
82c75
< *             WRITE (7,28)  I, NAME(I), TIME, DT, STEP(I), STEPR(I)
---
> *             WRITE (77,28)  I, NAME(I), TIME, DT, STEP(I), STEPR(I)
85c78
< *             CALL FLUSH(7)
---
> *             CALL FLUSH(77)
98a92
> 
1,2c1,2
< 1088 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/stumpf.f
< nbody6compare-oct2006/stumpf.f
---
> 1088 2001-08-24 23:08 /work/Umi2/spurzem/5/nbody6++compare/stumpf.f
> nbody6++compare/stumpf.f
1,2c1,2
< 6207 2005-06-01 17:53 /work/Umi2/spurzem/5/nbody6compare-oct2006/subint.f
< nbody6compare-oct2006/subint.f
---
> 6216 2003-06-25 17:26 /work/Umi2/spurzem/5/nbody6++compare/subint.f
> nbody6++compare/subint.f
10c10
<       REAL*8  TSLIST(KMAX)
---
>       REAL*8  TSLIST(10*KMAX)
32,33d31
<           LI = LI - 1
<           DTB = 0.0
40c38
<               IF (DTB.EQ.0.0D0.OR.DTB.GT.1.0D+06) THEN
---
>               IF (DTB.EQ.0.0D0.OR.DTB.GT.1.0D0) THEN
43c41,43
<     2         TBLIST = TPREV + DTB
---
>     2         CONTINUE
> *
>               TBLIST = TPREV + DTB
55c55
<               IF (NNTB.EQ.0) THEN
---
>               IF (NNTB.EQ.0.AND.DTB.LT.1.0D0) THEN
98,99c98
<                   IF (NNTB.GE.KMAX-5) THEN
<                       TBLIST = TIME
---
>                   IF (NNTB.GE.10*(KMAX-5)) THEN
105a105
>                       TBLIST = TIME
189a190,192
> 
> 
> 
1,2c1,2
< 2568 2006-03-20 05:27 /work/Umi2/spurzem/5/nbody6compare-oct2006/subsys.f
< nbody6compare-oct2006/subsys.f
---
> 2591 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/subsys.f
> nbody6++compare/subsys.f
76c76
< *       Construct force polynomials for c.m. motion.
---
> *       Construct force polynomials for c.m. motion (NLIST mod not needed).
1,2c1,2
< 1304 2005-03-14 11:12 /work/Umi2/spurzem/5/nbody6compare-oct2006/swcond.f
< nbody6compare-oct2006/swcond.f
---
> 1289 1996-12-14 02:13 /work/Umi2/spurzem/5/nbody6++compare/swcond.f
> nbody6++compare/swcond.f
8d7
<       COMMON/SWCALL/ NCALL
10,11c9,10
<       SAVE NSW
<       DATA NSW/20000/
---
>       SAVE NCALL,NSW
>       DATA NCALL,NSW/0,200/
1,2c1,2
< 4096 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/switch.f
< nbody6compare-oct2006/switch.f
---
> 4096 1999-11-15 14:57 /work/Umi2/spurzem/5/nbody6++compare/switch.f
> nbody6++compare/switch.f
1,2c1,2
< 1206 2005-03-05 12:48 /work/Umi2/spurzem/5/nbody6compare-oct2006/tchain.f
< nbody6compare-oct2006/tchain.f
---
> 1162 2003-06-23 19:33 /work/Umi2/spurzem/5/nbody6++compare/tchain.f
> nbody6++compare/tchain.f
30c30
< *       Include safety check for large c.m. step (TPREV = TBLOCK first time).
---
> *       Include safety check in case of large c.m. step (exclude first time).
33,34d32
<       ELSE
<           TSMIN = MIN(TSMIN,DTMIN)
44a43,44
> 
> 
1,2c1,2
< 4203 2006-09-01 17:39 /work/Umi2/spurzem/5/nbody6compare-oct2006/tcirc.f
< nbody6compare-oct2006/tcirc.f
---
> 2511 1999-11-28 17:12 /work/Umi2/spurzem/5/nbody6++compare/tcirc.f
> nbody6++compare/tcirc.f
4,5c4,5
< *       Circularization time.
< *       ---------------------
---
> *       Pre-main sequence circularization.
> *       ----------------------------------
12,13c12,13
<       REAL*8  WW(3),QQ(3),W(2),Q(2),AT0(2),M21,WG(2),QG(2),
<      &        WSCALE(2),QSCALE(2),A(2),B(2),C(6)
---
>       REAL*8  WW(3),QQ(3),W(2),Q(2),AT0(2),M21,
>      &        A(2),B(2),C(6)
20c20
<       DATA  ECCM,ECCM1 /0.002,0.002001/
---
>       DATA  ECCM /0.002/
23,28d22
< *       Set large circularization time for merged binary.
<       IF (RADIUS(I1).EQ.0.0D0.OR.RADIUS(I2).EQ.0.0D0) THEN
<           TC = 1.0D+10
<           GO TO 30
<       END IF
< *
39d32
<       XN = 0.0
47,62c40,46
<           IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
<      &        KSTAR(IK).EQ.6.OR.KSTAR(IK).EQ.9) THEN
<               IPAIR = KVEC(I1)
<               CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,XN,QL)
<               W(K) = WG(1)
<               Q(K) = QG(1)
<           ELSE
<               QL = 1.0D+04
<               IP = 3
<               IF (KSTAR(IK).GE.3) IP = 2
<               IF (KSTAR(IK).EQ.4.OR.KSTAR(IK).EQ.7) IP = 3
<               IF (KSTAR(IK).EQ.8) IP = 3
<               IF (KSTAR(IK).EQ.0) IP = 1
<               W(K) = WW(IP)
<               Q(K) = QQ(IP)
<           END IF
---
>           QL = 1.0D+04
>           IP = 3
>           IF (KSTAR(IK).GE.3) IP = 2
>           IF (KSTAR(IK).EQ.4) IP = 3
>           IF (KSTAR(IK).EQ.0) IP = 1
>           W(K) = WW(IP)
>           Q(K) = QQ(IP)
84,88d67
< *       Adopt WD scaling for any NS to avoid numerical problem.
<       IF (KSTAR(I1).EQ.13.OR.KSTAR(I2).EQ.13) THEN
<           CONST = 1.0D-04*CONST
<       END IF
< *
92,95d70
< *     FF = MIN(FF,0.999D0)
< *
< *       See whether we only want the modified eccentricity (routine BINPOP).
<       IF (ICIRC.LE.0) GO TO 10
97a73,74
>       IF (TC.LT.0.0) TIME0 = TC
> *
106,128d82
<       GO TO 30
< *
< *       Evaluate circularization time (in units of 10**6 yrs).
<    10 TC = TSTAR*(1.0 - FF)/CONST
< *
< *       Activate tidal indicator if TC < 2x10**9 yrs or hyperbolic orbit.
<       IF (TC.LT.2000.0.OR.ES0.GT.1.0) THEN
<           IP = KVEC(I1)
<           IF (ICIRC.EQ.0.AND.KZ(27).EQ.2) THEN
<               SEMI = -0.5*BODY(N+IP)/H(IP)
<               WRITE (6,20)  I1, NCHAOS, ES0, RP1, M21, TC, SEMI, XN
<    20         FORMAT (' TCIRC:    I1 NCH E RP M21 TC A n ',
<      &                            2I5,F8.4,F8.1,F6.2,1P,2E10.2,0P,F5.1)
<           END IF
<           ICIRC = 1
< *       Define Roche search indicator for circularized orbit (ECCM1 > 0.002).
<           IF (ES0.LE.ECCM1.AND.KSTAR(N+IP).EQ.0) THEN
<               KSTAR(N+IP) = 10
<           END IF
<       ELSE
< *       Note ICIRC = -1 for some calls.
<           ICIRC = 0
<       END IF
130c84
<    30 RETURN
---
>       RETURN
1,2c1,2
< 1469 2006-02-18 17:38 /work/Umi2/spurzem/5/nbody6compare-oct2006/tides.f
< nbody6compare-oct2006/tides.f
---
> 1460 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/tides.f
> nbody6++compare/tides.f
4,5c4,5
< *       Tidal energy loss for interacting stars.
< *       ----------------------------------------
---
> *       Tidal energy loss for interacting bodies.
> *       -----------------------------------------
21c21
<           IF (KST.EQ.3.OR.KST.EQ.5.OR.KST.EQ.6) THEN
---
>           IF (KST.EQ.3.OR.KST.EQ.5) THEN
54a55
> 
1,2c1,2
< 2436 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/tperi.f
< nbody6compare-oct2006/tperi.f
---
> 2450 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/tperi.f
> nbody6++compare/tperi.f
13c13
< *       DT = pericentre time interval (DT < 0 before peri).
---
> *       DT = pericentre time interval (DT > 0 after peri).
51,52c51,53
< *       Determine the eccentric anomaly with respect to pericentre (-PI,PI).
<           THETA = DATAN2(PSI/SQRT(SEMI),ZETA)
---
> *       Determine the eccentric anomaly with respect to pericentre (0,PI).
>           THETA = DATAN2(ABS(PSI)/SQRT(SEMI),ZETA)
> *
54c55
<           DT = SEMI*SQRT(SEMI/MB)*(THETA - PSI/SQRT(SEMI))
---
>           DT = SEMI*SQRT(SEMI/MB)*(THETA - ABS(PSI)/SQRT(SEMI))
63c64
<           DT = A0*SQRT(A0/MB)*(PSI/SQRT(A0) - THETA)
---
>           DT = A0*SQRT(A0/MB)*(ABS(PSI)/SQRT(A0) - THETA)
1,2c1,2
< 2338 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/tpert.f
< nbody6compare-oct2006/tpert.f
---
> 2315 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/tpert.f
> nbody6++compare/tpert.f
14d13
<       JCLOSE = 0
47c46
<               JCLOSE = J
---
>               JMIN = J
72c71
<       IF (JCRIT.NE.JCLOSE) THEN
---
>       IF (JCRIT.NE.JMIN) THEN
74c73
<           DR = SQRT(RJMIN2) - RI*(BODY(JCLOSE)*A1)**0.3333
---
>           DR = SQRT(RJMIN2) - RI*(BODY(JMIN)*A1)**0.3333
80c79
<       DT = MIN(DT,4.0D0*STEP(I))
---
>       DT = MIN(DT,2.0D0*STEP(I))
1,2c1,2
< 6353 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/trans3.f
< nbody6compare-oct2006/trans3.f
---
> 6353 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/trans3.f
> nbody6++compare/trans3.f
1,2c1,2
< 2221 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/trans4.f
< nbody6compare-oct2006/trans4.f
---
> 2221 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/trans4.f
> nbody6++compare/trans4.f
1,2c1,2
< 1864 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/transk.f
< nbody6compare-oct2006/transk.f
---
> 1864 1996-03-26 22:20 /work/Umi2/spurzem/5/nbody6++compare/transk.f
> nbody6++compare/transk.f
1,2c1,2
< 1799 2004-10-22 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/transq.f
< nbody6compare-oct2006/transq.f
---
> 1701 1998-08-21 15:59 /work/Umi2/spurzem/5/nbody6++compare/transq.f
> nbody6++compare/transq.f
73,75d72
< *       Include artificial STOP to get round compiler bug.
<       IF (XI(4)-XI(1).EQ.0.0D0) STOP
< *
1,2c1,2
< 1167 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/transx.f
< nbody6compare-oct2006/transx.f
---
> 1167 1999-12-15 12:00 /work/Umi2/spurzem/5/nbody6++compare/transx.f
> nbody6++compare/transx.f
1,2c1,2
< 16855 2006-02-04 14:46 /work/Umi2/spurzem/5/nbody6compare-oct2006/triple.f
< nbody6compare-oct2006/triple.f
---
> 16215 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/triple.f
> nbody6++compare/triple.f
16c16
<       COMMON/CLOSE/  RIJ(4,4),RCOLL,QPERI,SIZE(4),ECOLL3,IP(4)
---
>       COMMON/CLOSE/  RIJ(4,4),RCOLL,QPERI,SIZE(4),ECOLL3
19d18
<       COMMON/EBSAVE/  EBS
39d37
< *       IP      Polytropic index (=1: n = 3/2; =2: n = 2; =3: n = 3).
107a106
>       IQ = 0
144,154d142
< *       Determine the smallest two-body time-scale from parabolic orbit.
<       IM = 1
<       RM = R1
<       IF (R2.LT.R1) THEN
<           IM = 2
<           RM = R2
<       END IF
<       VP2 = 2.0*(M(IM) + M(3))/RM
<       TP = RM/SQRT(VP2)
<       TSTAR = MIN(TP,TSTAR)
< *
242c230
<       NEXT = NSTEP3 + 2 
---
>       NEXT = NSTEP3 + 2
247c235
<       IF (QPERI.LT.4.0*MAX(SIZE(IM),SIZE(3))) THEN
---
>       IF (QPERI.LT.2.7*MAX(SIZE(IM),SIZE(3))) THEN
262,265d249
< *       Evaluate the two-body energy for diagnostic purposes.
<               CALL EREL3(IM,EBS,SEMI)
<               DMINC = MIN(RCOLL,DMINC)
< *
316,318d299
<       I3 = IP(3)
<       IP(3) = IP(IMIN)
<       IP(IMIN) = I3
387,389c368,370
<           IM = 1
<           IF (R2.LT.R1) IM = 2
<           I = 3 - IM
---
>           IMIN = 1
>           IF (R2.LT.R1) IMIN = 2
>           I = 3 - IMIN
402c383
<           RDOT = RDOT + 
---
>           RDOT = RDOT +
428d408
<       DB = (EB*ENERGY - EB0)/EB0
430,437c410,415
< *       Print final configuration for significant energy increase.
<       IF (DB.GT.0.1) THEN
<           WRITE (6,80)  NAME3(IMIN), NAME3(3), MB, SEMI, E, EB, GB, RB,
<      &                  M(I), RI, ET
<    80     FORMAT (/,' TRIPLE BINARY ',2I5,'  MB =',F7.4,'  A =',1P,E8.1,
<      &     '  E =',0P,F5.2,'  EB =',F5.2,'  GB =',1P,E8.1,'  RB =',E8.1,
<      &               '  MI =',0P,F7.4,'  RI =',1P,E8.1,'  ET =',0P,F6.3)
<       END IF
---
> *       Print final configuration and terminate integration of escaper.
>       WRITE (6,80)  NAME3(IMIN), NAME3(3), MB, SEMI, E, EB, GB, RB,
>      &              M(I), RI, ET
>    80 FORMAT (/,' BINARY ',2I5,'  MB =',F7.4,'  A =',1PE8.1,'  E =',
>      &               0PF5.2,'  EB =',F5.2,'  GB =',1PE8.1,'  RB =',E8.1,
>      &                  '  MI =',0PF7.4,'  RI =',1PE8.1,'  ET =',0PF6.3)
474c452
<       IF (KZ15.GT.1.OR.DB.GT.0.1) THEN
---
>       IF (KZ15.GT.1) THEN
480,482c458,460
<    95     FORMAT (/,' END TRIPLE    NREG =',I3,'  MIN(RB&R3) =',1P,E8.1,
<      &                E9.1,'  R3 =',E8.1,'  RG =',E8.1,'  TC =',0P,F5.1,
<      &                      '  STEPS =',I4,'  DB =',F6.2,'  NMESC =',I5)
---
>    95     FORMAT (/,' END TRIPLE    NREG =',I3,'  MIN(RB&R3) =',1PE8.1,
>      &                 E9.1,'  R3 =',E8.1,'  RG =',E8.1,'  TC =',0PF5.1,
>      &                          '  STEPS =',I4,'  DB =',F6.2,'  I =',I5)
1,2c1,2
< 678 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/tstep.f
< nbody6compare-oct2006/tstep.f
---
> 678 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/tstep.f
> nbody6++compare/tstep.f
1,2c1,2
< 1966 2006-09-01 19:33 /work/Umi2/spurzem/5/nbody6compare-oct2006/units.f
< nbody6compare-oct2006/units.f
---
> 1786 2003-08-12 04:29 /work/Umi2/spurzem/5/nbody6++compare/units.f
> nbody6++compare/units.f
9c9
< *
---
>       
15a16
>       IF(ZMBAR.GT.0.D0)THEN
17a19,22
>       ELSE
>       YRS = 0.D0
>       DAYS = 0.D0
>       END IF
45,57c50,55
<       WRITE (6,10)  RBAR, ZMBAR, VSTAR, TSTAR, BODYM*ZMBAR, SU
<    10 FORMAT (/,12X,'PHYSICAL SCALING:    R* =',F5.2,'  M* =',F8.1,
<      &              '  V* =',F6.3,'  T* =',F6.3,'  <M> =',F5.2,
<      &              '  SU =',1P,E8.1)
< *
< *       Print relevant parameter for the GR case (RZ = 6*<m>/c^2).
<       IF (KZ(27).EQ.3) THEN
<           CLIGHT = 3.0D+05/VSTAR
<           RZ = 6.0*ZMASS/(FLOAT(N)*CLIGHT**2)
<           WRITE (6,20)  VSTAR, CLIGHT, RZ
<    20     FORMAT (/,12X,'GR SCALING:    V* =',1P,E10.2,'  C =',E10.2,
<      &                                  '  RZ =',E10.2)
<       END IF
---
>       if(rank.eq.0)then
>       WRITE (6,10) RBAR, ZMBAR, VSTAR, TSTAR, BODYM*ZMBAR, SU, RAU, YRS
>    10 FORMAT (/,5X,'PHYSICAL SCALING:    R* =',1PE11.4,'  M* =',E11.4,
>      &              '  V* =',E11.4,'  T* =',E11.4,'  <M> =',E11.4,/,
>      &           26X, 'SU =',E11.4,'  AU =',E11.4,'  YRS =',E11.4,/)
>       end if
1,2c1,2
< 10744 2006-09-18 13:31 /work/Umi2/spurzem/5/nbody6compare-oct2006/unpert.f
< nbody6compare-oct2006/unpert.f
---
> 6158 2003-06-23 19:33 /work/Umi2/spurzem/5/nbody6++compare/unpert.f
> nbody6++compare/unpert.f
8d7
<       REAL*8  UI(4),UIDOT(4)
39c38
< *       Ensure perturbation check at least once every c.m. step (KSTAR < 11).
---
> *       Ensure frequent perturbation checks for circularized binaries.
41,50c40,47
<               IF (KSTAR(I).LT.11) THEN
<                   IF (STEP(I1).LT.TK) THEN
<                       IF (STEP(I1).LT.0.0001*STEP(I)) GO TO 9
<                   END IF
<                   IF (TIME - T0(I).GT.2.0*STEP(I1)) THEN
<                       DT = MIN(3.0D0*STEP(I1),STEP(I))
<                       KPERT = 0
<                       JCLOSE = 0
<                       GO TO 20
<                   END IF
---
>               IF (STEP(I1).LT.TK) THEN
>                   IF (STEP(I1).LT.0.0001*STEP(I)) GO TO 9
>               END IF
>               IF (TIME - T0(I).GT.2.0*STEP(I1)) THEN
>                   DT = MIN(3.0D0*STEP(I1),STEP(I))
>                   KPERT = 0
>                   JCLOSE = 0
>                   GO TO 20
65,70c62
<               IF (R(IPAIR).LT.SEMI) THEN
<                   NP = LIST(1,I1)
<                   LIST(1,I1) = 0
< *       Do not allow backwards integration on switch from unperturbed motion.
<                   CALL KSPERI(IPAIR)
<                   LIST(1,I1) = NP
---
>               IF (KZ(27).GT.0.AND.R(IPAIR).LT.SEMI) THEN
76c68
< *       Include differential correction (experimental 10/02).
---
> *       Include differential correction for switching to perturbed motion.
86,87d77
< *             WRITE (6,13)  NAME(I1), POT1-POT2, GAMMA(IPAIR)
< *  13         FORMAT ('  CORRECT    NAM DPHI G ',I6,1P,2E10.2)
89,90d78
<               BE(3) = BE(3) + (POT2 - POT1)
<               GO TO 30
92,93c80
<           IR = 1
<           GO TO 28
---
>           GO TO 30
96c83
< *       Check for tidal dissipation (peri & apocentre included; skip merger).
---
> *       Consider case of tidal capture (both peri and apo included).
98,100c85,86
<      &   (SEMI.LT.RMIN.OR.TDOT2(IPAIR).GT.0.0D0).AND.
<      &   (KSTAR(I).EQ.0.OR.KSTAR(I).EQ.-1).AND.
<      &   (NAME(I).GT.0)) THEN
---
>      &   (SEMI.LT.0.01*RMIN.OR.TDOT2(IPAIR).GT.0.0D0).AND.
>      &    KSTAR(I).NE.20.AND.NAME(I).GT.0) THEN
109,118d94
< *       Specify circularization index (skip SPIRAL but include CHAOS).
<           ICIRC = 0
<           IF (KZ(27).EQ.1) THEN
<               IF (RP.LT.RT) ICIRC = 1
<           ELSE IF (RP.LT.2.5*RT.AND.KSTAR(I).EQ.0) THEN
<               CALL TCIRC(RP,ECC,I1,I1+1,ICIRC,TC)
<           ELSE IF (KSTAR(I).EQ.-1) THEN
<               ICIRC = 1
<           END IF
< *
120,121c96
< *         IF (RP.LT.0.99*RT.AND.ECC.GT.0.002) THEN
<           IF (ICIRC.GT.0.AND.ECC.GT.0.002) THEN
---
>           IF (RP.LT.0.99*RT.AND.ECC.GT.0.0022) THEN
126c101
< *       Implement energy loss at pericentre (exit on collision).
---
> *       Implement energy loss at pericentre.
128d102
<               IF (IPHASE.LT.0) GO TO 30
132c106
<               IF (R(IPAIR).LT.0.99*RT.AND.KSTAR(I).NE.10) THEN
---
>               IF (R(IPAIR).LT.0.99*RT.AND.KSTAR(I).NE.20) THEN
140,147c114,118
<                   IF (ABS(RT - RP)/RT.GT.0.1.AND.KZ(27).LE.1) THEN
<                       WRITE(6,25)  ECC, SEMI, R(IPAIR), RP, RADIUS(I1)
<    25                 FORMAT (' INACTIVE PHASE    E A R RP R* ',
<      &                                            F7.3,1P,4E10.2)
<                   END IF
<                   IF (ECC.LT.0.002.AND.SEMI.LT.0.01*RMIN) THEN
<                       KSTAR(I) = 10
<                       TEV(I) = TIME
---
>                   ECC = R(IPAIR)/SEMI - 1.0
> *                 WRITE (6,25)  ECC, SEMI, R(IPAIR), SEMI*(1.0 - ECC)
> *  25             FORMAT (' INACTIVE PHASE    E A R RP ',F7.3,1P,3E9.1)
>                   IF (ECC.LT.0.0022.AND.SEMI.LT.0.01*RMIN) THEN
>                       KSTAR(I) = 20
154,195c125,127
< *       Check for Roche overflow from synchronous orbit (but KSTAR < 13).
<       IR = 0
<       IF (KSTAR(I).EQ.13.AND.MIN(TEV(I1),TEV(I1+1)).LT.TIME + DT) THEN
<           IR = -1
<       END IF
<       IF (KSTAR(I).GT.13) IR = 1
<       IF (KZ(34).GT.0.AND.(KSTAR(I).GE.10.AND.KSTAR(I).LE.12)) THEN
<           TM = MIN(TEV(I1),TEV(I1+1),TEV(I))
<           IF (TM.LT.TIME) THEN
<               CALL TRFLOW(IPAIR,DTR)
< * Exit if ROCHE is indicated (change 16/08/2006).
< *             IF (DTR.LT.STEP(I1)) THEN
< *                 CALL ROCHE(IPAIR)
< *       Exit on coalescence (KPERT > 0 would cause trouble).
< *                 IF (IPHASE.LT.0) GO TO 30
< *             ELSE
< *                 IR = 1
< *             END IF
<               IR = 1
<               IF (DTR.LT.STEP(I1)) GO TO 30
< *
<               IF (DTR.GT.TK) THEN
<                   DT = MIN(DTR,DT)
<                   KPERT = 2
<               END IF
<           ELSE
<               IR = 1
<           END IF
<       END IF
< *
< *       Perform general two-body collision test.
<       IF (KZ(19).GE.3.AND.NAME(I).GT.0) THEN
<           RI = 0.0
<           DO 26 K = 1,4
<               UI(K) = U0(K,IPAIR)
<               UIDOT(K) = UDOT(K,IPAIR)
<               RI = RI + UI(K)**2
<    26     CONTINUE
<           CALL PERI(UI,UIDOT,RI,BODY(I1),BODY(I1+1),QPERI)
<           IF (QPERI.LT.0.75*(RADIUS(I1) + RADIUS(I1+1))) THEN
< *       Obtain KS variables at pericentre before coalescence to one body.
<               CALL KSPERI(IPAIR)
---
> *       Include test for contact binary in the absence of Roche treatment.
>       IF (KZ(27).GT.0.AND.KSTAR(I).EQ.20) THEN
>           IF (R(IPAIR).LT.0.75*(RADIUS(I1) + RADIUS(I1+1))) THEN
197,198c129,133
< *       Set indicator for skipping ECOLL updating in COAL.
<               IQCOLL = -2
---
>               QPERI = R(IPAIR)
>               WRITE (6,28)  NAME(I1), NAME(I1+1), KSTAR(I1),
>      &                      KSTAR(I1+1), QPERI*SU
>    28         FORMAT (' CONTACT BINARY    NAM K* R* ',2I6,2I4,F7.1)
> *       Enforce coalescence.
205,221c140
<       IF (KPERT.GT.0.AND.DT.GT.0.0) THEN
< *       Ensure that next look-up time is not exceeded (option #27).
<           IF (KZ(27).GT.0.AND.KPERT.GT.1) THEN
<               TM = MIN(TEV(I1),TEV(I1+1))
<               IF (TM - T0(I1).GT.0.0.AND.TM - T0(I1).LT.0.5*DT) THEN
<                   NWARN = NWARN + 1
<                   IF (NWARN.LT.1000) THEN
<                       WRITE (25,27)  IPAIR, KSTAR(I1), KSTAR(I1+1),
<      &                             KSTAR(I), TM-T0(I1), 0.5*DT, STEP(I1)
<    27                 FORMAT (' WARNING!     KS K* TM-T0 DT/2 STEP0 ',
<      &                                       4I4,1P,3E10.2)
<                       CALL FLUSH(25)
<                   END IF
<                   DT = MIN(2.0*(TM - T0(I1)),DT)
<                   DT = MAX(DT,TK,STEPX)
<               END IF
<           END IF
---
>       IF (KPERT.GT.0) THEN
223c142
<           IF (DT.LT.2.0E+09*TK) THEN
---
>           IF (DT.LT.2.0D+09*TK) THEN
225,226c144,145
< *       Restrict Kepler period to c.m. step (case of very wide orbit).
<               STEP(I1) = FLOAT(K)*MIN(TK,STEP(I))
---
> *       Restrict Kepler period to c.m. step (case of wide orbit).
>               STEP(I1) = FLOAT(K)*MIN(TK,DT)
230,242c149,154
< *       Include optional treatment for spiralling of chaotic binary orbit.
<           IF (KZ(27).GT.1.AND.KSTAR(I).EQ.-2) THEN
< *       Ensure pericentre position after possible perturbed motion.
<               IF (R(IPAIR).GT.SEMI) THEN
<                   CALL KSRECT(IPAIR)
< *       Reduce eccentric anomaly by pi for inward motion.
<                   IF (TDOT2(IPAIR).LT.0.0D0) THEN
<                       CALL KSAPO(IPAIR)
<                   END IF
< *       Transform from outward motion (anomaly < pi) to exact pericentre.
<                   CALL KSPERI(IPAIR)
<               END IF
<               CALL SPIRAL(IPAIR)
---
>       END IF
> *
> *       Check for optional magnetic braking or gravitational radiation.
>       IF (KZ(28).GT.0.AND.SEMI*SU.LT.10.0.AND.KSTAR(I).GT.19) THEN
>           IF (TIME.GT.TEV(I)) THEN
>               CALL BRAKE(IPAIR)
247,249c159,162
< *       Check merger condition before continuing (skip small Roche steps).
<    28 IF (KZ(15).GT.0.AND.IR.GE.0.AND.TIME+STEP(I1).GT.TBLOCK) THEN
<           IF (STEP(I).LT.DTMIN) THEN
---
> *       Check merger condition before continuing unperturbed motion.
>       IF (KZ(15).GT.0.AND.STEP(I).LT.DTMIN) THEN
> *       Skip possible second call during termination.
>           IF (IPHASE.EQ.0) THEN
251c164
<           ELSE IF (JCLOSE.GT.0.AND.STEP(I).LT.10.0*DTMIN) THEN
---
>           ELSE IF (JCLOSE.GT.0.AND.STEP(I).LT.4.0*DTMIN) THEN
256,285d168
< *       Include a more generous test for massive quadruples.
<           ELSE IF (JCLOSE.GT.N) THEN
<               FAC = 2.0*(BODY(I) + BODY(JCLOSE))/BODYM
<               IF (STEP(I).LT.FAC*DTMIN) THEN
<                   CALL HISTAB(IPAIR,JCLOSE,PMIN,RSTAB)
<                   IF (RSTAB.LT.PMIN) THEN
<                       CALL IMPACT(I)
<                   END IF
<               END IF
<           END IF
<       END IF
< *
< *       Check collision criterion for special case.
<       IF (KZ(27).EQ.-1.AND.KZ(13).LT.0) THEN
<           ECC2 = (1.0 - R(IPAIR)/SEMI)**2 +
<      &                                TDOT2(IPAIR)**2/(BODY(I)*SEMI)
<           ECC = SQRT(ECC2)
<           QPERI = SEMI*(1.0 - ECC)
<           RFAC = 2.0*RMSTAR
<           I2 = I1 + 1
<           IF (QPERI.LT.RFAC*MAX(RADIUS(I1),RADIUS(I2))) THEN
<               J1 = I1
<               IF (RADIUS(I2).GT.RADIUS(I1)) J1 = I2
<               FAC = 0.5*BODY(I)/BODY(J1)
< *       Adopt collision criterion of Kochanek (Ap.J. 385, 604, 1992).
<               RCOLL = 1.7*FAC**0.3333*RADIUS(J1)
<               RCOLL = RMSTAR*RCOLL
<               IF (QPERI.LT.RCOLL) THEN
<                   CALL TOUCH(IPAIR,I1,I2,RCOLL)
<               END IF
291a175,176
> 
> 
1,2c1,2
< 6072 2006-03-20 05:29 /work/Umi2/spurzem/5/nbody6compare-oct2006/update.f
< nbody6compare-oct2006/update.f
---
> 6213 2002-02-20 20:28 /work/Umi2/spurzem/5/nbody6++compare/update.f
> nbody6++compare/update.f
69c69
<               LIST(L,J) = LIST(L+1,J) 
---
>               LIST(L,J) = LIST(L+1,J)
100c100
<           IF (KCASE.EQ.1) WRITE (6,78)  NNB, J, JCOMP
---
>           IF (rank.eq.0.and.KCASE.EQ.1) WRITE (6,78)  NNB, J, JCOMP
161c161,162
<       IF (IFLAG.NE.-1) WRITE (8,104)  IPAIR, IFLAG, JLIST(1), JLIST(2)
---
>       IF (rank.eq.0.and.IFLAG.NE.-1) 
>      &   WRITE (8,104)  IPAIR, IFLAG, JLIST(1), JLIST(2)
164,178c165,179
< *       Update list of high velocity particles containing c.m. members.
<   110 NNB = LISTV(1)
<       DO 130 L = 2,NNB+1
<           IF (LISTV(L).EQ.ICM) THEN
< *       Remove old c.m. and reduce the membership.
<               DO 125 K = L,NNB
<                   LISTV(K) = LISTV(K+1)
<   125         CONTINUE
<               LISTV(1) = LISTV(1) - 1
<           END IF
< *       Reduce higher particle locations by one.
<           IF (LISTV(L).GT.ICM) THEN
<               LISTV(L) = LISTV(L) - 1
<           END IF
<   130 CONTINUE
---
> *       Remove first component of old KS pair and c.m. body from NLIST.
>   110 I = 2*IPAIR - 1
>       CALL NLMOD(I,-1)
>       CALL NLMOD(ICM,-1)
> *
> *       Rename any older single KS components and more recent c.m. bodies.
>       IF (IPAIR.LE.NPAIRS) THEN
>           NNB1 = NLIST(1) + 1
>           DO 120 L = 2,NNB1
> *       Reduce index of any subsequent c.m. and first components by 1 & 2.
>               IF (NLIST(L).GT.ICM) NLIST(L) = NLIST(L) - 1
>               IF (NLIST(L).LE.JCOMP.AND.NLIST(L).GT.2*IPAIR - 1)
>      &                                           NLIST(L) = NLIST(L) - 2
>   120     CONTINUE
>       END IF
1,2c1,2
< 462 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/vector.f
< nbody6compare-oct2006/vector.f
---
> 462 1995-11-27 12:52 /work/Umi2/spurzem/5/nbody6++compare/vector.f
> nbody6++compare/vector.f
1,2c1,2
< 1698 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/verify.f
< nbody6compare-oct2006/verify.f
---
> 1732 2001-08-05 23:17 /work/Umi2/spurzem/5/nbody6++compare/verify.f
> nbody6++compare/verify.f
9d8
< *
11,14c10,13
<       IF (N.GE.NMAX - 2.OR.NNBMAX.GT.LMAX - 3) THEN
<           WRITE (6,10)  N, NNBMAX
<    10     FORMAT (/,5X,'FATAL ERROR!   BAD INPUT   N =',I5,
<      &                                                  '  NNBMAX =',I4)
---
>       IF (N.GE.NMAX - 2.OR.NNBMAX.GT.LMAX - 3.OR.NNBOPT.GT.NNBMAX) THEN
>           WRITE (6,10)  N, NNBMAX, NNBOPT
>    10     FORMAT (/,5X,'FATAL ERROR!   BAD INPUT   N =',I5,' NNBMAX =',
>      &                                           I5,'  NNBOPT =',I5)
33,34c32,33
<       IF (N.LE.0.OR.NNBMAX.LE.0.OR.ETAI.LE.0.0.OR.ETAR.LE.0.0) THEN
<           WRITE (6,40)  N, NNBMAX, ETAI, ETAR
---
>       IF (N.LE.0.OR.NNBOPT.LE.0.OR.ETAI.LE.0.0.OR.ETAR.LE.0.0) THEN
>           WRITE (6,40)  N, NNBOPT, ETAI, ETAR
36c35
<      &                  '  NNBMAX =',I4,'  ETAI =',F6.2,'  ETAR =',F6.2)
---
>      &                  '  NNBOPT =',I4,'  ETAI =',F6.2,'  ETAR =',F6.2)
1,2c1,2
< 1542 2004-05-12 17:38 /work/Umi2/spurzem/5/nbody6compare-oct2006/xcpred.f
< nbody6compare-oct2006/xcpred.f
---
> 1594 1999-10-09 12:04 /work/Umi2/spurzem/5/nbody6++compare/xcpred.f
> nbody6++compare/xcpred.f
9c9,10
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
1,2c1,2
< 1225 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/xtf.f
< nbody6compare-oct2006/xtf.f
---
> 1225 1999-01-24 11:05 /work/Umi2/spurzem/5/nbody6++compare/xtf.f
> nbody6++compare/xtf.f
1,2c1,2
< 2597 2004-05-12 17:39 /work/Umi2/spurzem/5/nbody6compare-oct2006/xtpert.f
< nbody6compare-oct2006/xtpert.f
---
> 2649 1999-10-02 15:07 /work/Umi2/spurzem/5/nbody6++compare/xtpert.f
> nbody6++compare/xtpert.f
9c9,10
<       PARAMETER  (NMX=10,NMX3=3*NMX,NMXm=NMX*(NMX-1)/2)
---
>       PARAMETER  (NMX=10,NMX2=2*NMX,NMX3=3*NMX,NMX4=4*NMX,
>      &            NMX8=8*NMX,NMXm=NMX*(NMX-1)/2)
1,2c1,2
< 8482 2005-11-30 16:29 /work/Umi2/spurzem/5/nbody6compare-oct2006/xtrnl0.f
< nbody6compare-oct2006/xtrnl0.f
---
> 2042 2003-06-26 02:49 /work/Umi2/spurzem/5/nbody6++compare/xtrnl0.f
> nbody6++compare/xtrnl0.f
8,9d7
<       COMMON/GALAXY/ GMG,RG(3),VG(3),FG(3),FGD(3),TG,
<      &               OMEGA,DISK,A,B,V02,RL2
19c17
<       RHO = 0.11
---
>       RHON = 0.11
35,40c33
<       TIDAL(3) = -(2.0*TWOPI*RHO + 2.0*(A - B)*(A + B)*(PC/GM))
< *
<       FAC = 1.0E-10/(PC/GM)
<       WRITE (6,5)  ZMBAR*ZMASS, FAC*TIDAL(1), FAC*TIDAL(3), PC/GM
<     5 FORMAT (/,12X,'TOTAL MASS =',F7.1,'  TIDAL(1&3) =',1P,2E10.2,
<      &              '  PC/GM =',E10.2)
---
>       TIDAL(3) = -(2.0*TWOPI*RHON + 2.0*(A - B)*(A + B)*(PC/GM))
45c38,39
< *       Define time scale in seconds and velocity scale in km/sec.
---
> *       Define time scale in seconds using pc as length unit.
> *          and velocity scale in km/sec (Aug.1998, P.Kroupa)
47,48d40
<       VSTAR = 1.0E-05*SQRT(GM/PC)
< *
51a44,47
> *       Ensure ZMBAR & RBAR > 0 (=0: assume <M>/Sun = 1, RBAR = 1 pc).
>       IF (ZMBAR.LE.0.0D0) ZMBAR = FLOAT(N)/ZMASS
>       IF (RBAR.LE.0.0D0) RBAR = 1.0
> *
58d53
<       VSTAR = VSTAR*SQRT(ZMASS*ZMBAR/RBAR)
60,229c55,61
< *       Consider alternatives: circular point-mass orbit or 3D galaxy model.
<    20 ZMTOT = ZMASS*ZMBAR
<       IF (KZ(14).EQ.2) THEN
< *
< *       Read galaxy mass and central distance (solar units and kpc).
<           READ (5,*)  GMG, RG0
< *
< *       Set circular velocity in km/sec and angular velocity in cgs units.
<           VG0 = 1.0D-05*SQRT(GMG/(1000.0*RG0))*SQRT(GM/PC)
<           OMEGA = 100.0*VG0/RG0
< *
< *       Obtain King tidal radius in pc (eq. (9) of Fukushige & Heggie, 1995).
<           RT = (ZMTOT/(3.0*GMG))**0.3333*(1000.0*RG0)
< *
<           IF (RTIDE.GT.0.0) THEN
< *       Determine RBAR (N-body units) from RT (pc) and King model (see SCALE).
<               IF(KZ(22).EQ.2) RBAR = RT/RTIDE
<           ELSE
<               RTIDE = RT/RBAR
<           END IF
< *
< *       Convert from cgs to N-body units.
<           OMEGA = OMEGA*SQRT(PC/GM)*SQRT(RBAR**3/ZMBAR)
< *
< *       Specify the galactic parameters for equations of motion.
<           TIDAL(1) = 3.0*OMEGA**2
<           TIDAL(2) = 0.0D0
<           TIDAL(3) = -OMEGA**2
<           TIDAL(4) = 2.0*OMEGA
<           GMG = GMG/ZMTOT
< *
< *       Check re-scaling units to current RBAR (i.e. TSCALE, TSTAR & VSTAR).
<           IF (KZ(22).EQ.2) THEN
<               CALL UNITS
<           END IF
< *
<           WRITE (6,35)  GMG, RG0, OMEGA, RTIDE, RBAR
< *
< *       Treat the general case of 3D orbit for point-mass, disk and/or halo.
<       ELSE IF (KZ(14).EQ.3) THEN
< *
< *       Read all parameters (NB! Do not confuse with Oort's constants A, B).
<           READ (5,*)  GMG, DISK, A, B, VCIRC, RCIRC, (RG(K),K=1,3),
<      &                                               (VG(K),K=1,3)
< *
< *       Specify planar motion from SEMI & ECC for no disk & halo if VZ = 0.
<           IF (DISK + VCIRC.EQ.0.0.AND.VG(3).EQ.0.0D0) THEN
<               RAP = RG(1)
<               ECC = RG(2)
<               SEMI = RAP/(1.0 + ECC)
<               VG2 = GMG/(1000.0*SEMI)*(1.0 - ECC)/(1.0 + ECC)
<               DO 25 K = 1,3
<                   RG(K) = 0.0
<                   VG(K) = 0.0
<    25         CONTINUE
< *       Initialize 2D orbit with given eccentricity at apocentre.
<               RG(1) = RAP
<               VG(2) = 1.0D-05*SQRT(VG2)*SQRT(GM/PC)
<           END IF
< *
< *       Convert from kpc and km/sec to N-body units.
<           DO 30 K = 1,3
<               RG(K) = 1000.0*RG(K)/RBAR
<               VG(K) = VG(K)/VSTAR
<    30     CONTINUE
< *
< *       Define the angular velocity (z-component) and mass in N-body units.
<           R02 = RG(1)**2 + RG(2)**2
<           OMEGA = (RG(1)*VG(2) - RG(2)*VG(1))/R02
<           TIDAL(4) = 2.0*OMEGA
<           GMG = GMG/ZMTOT
< *       Adopt a tidal radius of 50 pc unless specified by routine SCALE.
<           IF (RTIDE.EQ.0.0D0) RTIDE = 50.0/RBAR
< *
<           WRITE (6,35)  GMG, SQRT(R02), OMEGA, RTIDE, RBAR
<    35     FORMAT (/,12X,'POINT-MASS MODEL:    MG =',1P,E9.1,
<      &                  '  RG =',E9.1,'  OMEGA =',E9.1,
<      &                  '  RT =',0P,F6.2,'  RBAR =',F6.2)
< *       Define disk and/or logarithmic halo parameters in N-body units.
<           IF (DISK.GT.0.0D0) THEN
<               DISK = DISK/ZMTOT
<               A = 1000.0*A/RBAR
<               B = 1000.0*B/RBAR
<               WRITE (6,40)  DISK, A, B
<    40         FORMAT (/,12X,'DISK MODEL:    MD =',1P,E9.1,
<      &                                   '  A =',E9.1,'  B =',E9.1)
<           END IF
< *
< *       Determine local halo velocity from total circular velocity.
<           IF (VCIRC.GT.0.0D0) THEN
<               VCIRC = VCIRC/VSTAR
<               RCIRC = 1000.0*RCIRC/RBAR
<               A2 = RCIRC**2 + (A + B)**2
<               V02 = VCIRC**2 - (GMG/RCIRC + DISK*RCIRC**2/A2**1.5)
<               IF (V02.LT.0.0D0) THEN
<                   WRITE (6,45)  V02, 0.001*RCIRC*RBAR
<    45             FORMAT (' ',' NEGATIVE HALO VELOCITY!    V02 RCIRC ',
<      &                                                     1P,2E10.2)
<                   STOP
<               END IF
< *       Specify the corresponding scale length of logarithmic halo.
<               RL2 = RCIRC**2*(VCIRC**2 - V02)/V02
< *       Define the asymptotic circular velocity due to halo.
<               V02 = VCIRC**2
< *
< *       Include table of circular velocity on unit #17 (km/sec & kpc).
<               RI = 1000.0/RBAR
<               DR = 1000.0/RBAR
<               DO 60 K = 1,30
<                   RI2 = RI**2
<                   A2 = RI2 + (A + B)**2
<                   VCIRC2 = GMG/SQRT(RI2) + DISK*RI2/A2**1.5 +
<      &                                     V02*RI2/(RL2 + RI2)
<                   WRITE (17,50)  SQRT(VCIRC2)*VSTAR, RI*RBAR/1000.0
<    50             FORMAT (' CIRCULAR VELOCITY:    VC R ',F7.1,F7.2)
<                   RI = RI + DR
<    60         CONTINUE
<               CALL FLUSH(17)
< *
<               A2 = R02 + (A + B)**2
<               VCIRC2 = GMG/SQRT(R02) + DISK*R02/A2**1.5 +
<      &                                 V02*R02/(RL2 + R02)
<               VCIRC = SQRT(VCIRC2)*VSTAR
<               WRITE (6,62)  VCIRC, SQRT(R02)/1000.0, SQRT(RL2)/1000.0
<    62         FORMAT (/,12X,'CIRCULAR VELOCITY:    VC RG RL',F7.1,2F7.2)
<           ELSE
<               V02 = 0.0
<           END IF
< *
< *       Initialize F & FDOT of reference frame (point-mass galaxy is OK).
<           CALL GCINIT
< *
<           WRITE (6,65)  (RG(K),K=1,3), (VG(K),K=1,3), SQRT(V02)
<    65     FORMAT (/,12X,'SCALED ORBIT:    RG =',1P,3E10.2,
<      &                                '  VG = ',3E10.2,'  V0 =',0P,F6.1)
<       END IF
< *
< *       Include Plummer potential for 2D and 3D (set MP = 0 if not needed).
<       IF (KZ(14).EQ.3.OR.KZ(14).EQ.4) THEN
< *       Check input for Plummer potential.
<           READ (5,*)  MP, AP2, MPDOT, TDELAY
<           WRITE (6,70)  MP, AP2, MPDOT, TDELAY
<    70     FORMAT (/,12X,'PLUMMER POTENTIAL:    MP =',F7.1,'  AP =',F6.2,
<      &                  '  MPDOT =',F7.3,'  TDELAY =',F6.1)
<           MP0 = MP
<           AP2 = AP2**2
< *       Rescale velocities by including the Plummer virial energy.
<           CALL ENERGY
<           IF (ZKIN.GT.0.0D0) THEN
< *       Note that QVIR = Q is saved in routine SCALE and VIR < 0.
<               VIR = POT - VIR
<               QV = SQRT(QVIR*VIR/ZKIN)
<               DO 74 I = 1,N
<                   DO 72 K = 1,3
<                       XDOT(K,I) = XDOT(K,I)*QV
<    72             CONTINUE
<    74         CONTINUE
<           END IF
<       ELSE
<           MP = 0.0
<       END IF
<       RTIDE0 = RTIDE
< *
< *       Define tidal radius in scaled units for linearized field.
<       IF (KZ(14).LE.2) THEN
<           RTIDE = (ZMASS/TIDAL(1))**0.3333
<           WRITE (6,75)  (TIDAL(K),K=1,4), TSCALE, RTIDE
<    75     FORMAT (/,12X,'TIDAL PARAMETERS:  ',1P,4E10.2,
<      &                  '  TSCALE =',E9.2,'  RTIDE =',0P,F6.2,/)
<       END IF
---
> *       Define tidal radius in scaled units.
>       RTIDE = (ZMASS/TIDAL(1))**0.3333
> *
>       if(rank.eq.0) WRITE (6,15)  (TIDAL(K),K=1,4), TSCALE, RTIDE
>    15 FORMAT (/,12X,'TIDAL PARAMETERS:  ',1P4E10.2,'  TSCALE =',E9.2,
>      &                               ' (10**6 YRS)','  RTIDE =',
>      &                                  0PF6.2,/)
231c63
<       RETURN
---
>    20 RETURN
1,2c1,2
< 2233 2004-10-19 17:57 /work/Umi2/spurzem/5/nbody6compare-oct2006/xtrnld.f
< nbody6compare-oct2006/xtrnld.f
---
> 1478 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/xtrnld.f
> nbody6++compare/xtrnld.f
8d7
<       REAL*8  XI(3),XIDOT(3),FIRR(3),FREG(3),FD(3),FDR(3)
11,12c10,11
< *       See whether to include the standard or point-mass tidal force.
<       IF (KZ(14).LE.2.AND.KCASE.EQ.1) THEN
---
> *       See whether to include the galactic tidal force.
>       IF (TIDAL(1).GT.0.0.AND.KCASE.EQ.1) THEN
26c25
<       IF (KZ(14).LE.2.AND.KCASE.EQ.2) THEN
---
>       IF (TIDAL(1).GT.0.0.AND.KCASE.EQ.2) THEN
40,60d38
< *       Check options for galactic potential (called from FPOLY1).
<       IF (KZ(14).GE.3.AND.KCASE.EQ.1) THEN
< *       Obtain regular force components for 3D galaxy or Plummer model.
<           DO 30 I = I1,I2
<               DO 25 K = 1,3
<                   XI(K) = X(K,I)
<                   XIDOT(K) = XDOT(K,I)
<                   FIRR(K) = 0.0
<                   FD(K) = 0.0
<                   FREG(K) = 0.0
<                   FDR(K) = 0.0
<    25         CONTINUE
<               CALL XTRNLF(XI,XIDOT,FIRR,FREG,FD,FDR,1)
<               DO 28 K = 1,3
<                   FR(K,I) = FR(K,I) + FREG(K)
<                   D1R(K,I) = D1R(K,I) + FDR(K)
<    28         CONTINUE
<    30     CONTINUE
< *
<       END IF
< *
1,2c1,2
< 2876 2004-12-14 09:40 /work/Umi2/spurzem/5/nbody6compare-oct2006/xtrnlf.f
< nbody6compare-oct2006/xtrnlf.f
---
> 893 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/xtrnlf.f
> nbody6++compare/xtrnlf.f
1c1
<       SUBROUTINE XTRNLF(XI,XIDOT,FIRR,FREG,FD,FDR,KCASE)
---
>       SUBROUTINE XTRNLF(I,XI,XIDOT,FIRR,FREG,FD,FDR,KCASE)
8,11c8
<       COMMON/GALAXY/ GMG,RG(3),VG(3),FG(3),FGD(3),TG,
<      &               OMEGA,DISK,A,B,V02,RL2
<       REAL*8  XI(3),XIDOT(3),FIRR(3),FREG(3),FD(3),FDR(3),
<      &        XG(3),XGDOT(3),FM(3),FMD(3),FS(3),FSD(3)
---
>       REAL*8  XI(3),XIDOT(3),FIRR(3),FREG(3),FD(3),FDR(3)
14,15c11,12
< *       See whether to include a linearized galactic tidal force (two cases).
<       IF (KZ(14).LE.2) THEN
---
> *       See whether to include the galactic tidal force.
>       IF (TIDAL(1).GT.0.0) THEN
29,80d25
< *       Consider point-mass, disk and/or logarithmic halo model.
<       IF (KZ(14).EQ.3.AND.KCASE.GT.0) THEN
<           DO 5 K = 1,3
<               XG(K) = RG(K) + XI(K)
<               XGDOT(K) = VG(K) + XIDOT(K)
<     5     CONTINUE
< *       Employ differential instead of linearized forms for better accuracy.
<           IF (GMG.GT.0.0D0) THEN
<               CALL FNUC(RG,VG,FS,FSD)
<               CALL FNUC(XG,XGDOT,FM,FMD)
<               DO 10 K = 1,3
<                   FREG(K) = FREG(K) + (FM(K) - FS(K))
<                   FDR(K) = FDR(K) + (FMD(K) - FSD(K))
<    10         CONTINUE
<           END IF
< *
< *       Include Miyamoto disk for positive disk mass.
<           IF (DISK.GT.0.0D0) THEN
<               CALL FDISK(RG,VG,FS,FSD)
<               CALL FDISK(XG,XGDOT,FM,FMD)
<               DO 20 K = 1,3
<                   FREG(K) = FREG(K) + (FM(K) - FS(K))
<                   FDR(K) = FDR(K) + (FMD(K) - FSD(K))
<    20         CONTINUE
<           END IF
< *
< *       Check addition of logarithmic halo potential to regular force.
<           IF (V02.GT.0.0D0) THEN
<               CALL FHALO(RG,VG,FS,FSD)
<               CALL FHALO(XG,XGDOT,FM,FMD)
<               DO 30 K = 1,3
<                   FREG(K) = FREG(K) + (FM(K) - FS(K))
<                   FDR(K) = FDR(K) + (FMD(K) - FSD(K))
<    30         CONTINUE
<           END IF
<       END IF
< *
< *       Include optional Plummer potential in the regular force.
<       IF ((KZ(14).EQ.4.OR.MP.GT.0.0D0).AND.KCASE.GT.0) THEN
<           RI2 = AP2
<           RRDOT = 0.0
<           DO 40 K = 1,3
<               RI2 = RI2 + XI(K)**2
<               RRDOT = RRDOT + XI(K)*XIDOT(K)
<    40     CONTINUE
<           FMP = MP/(RI2*SQRT(RI2))
<           DO 50 K = 1,3
<               FREG(K) = FREG(K) - XI(K)*FMP
<               FDR(K) = FDR(K) - (XIDOT(K) - 3.0*RRDOT*XI(K)/RI2)*FMP
<    50     CONTINUE
<       END IF
< *
1,2c1,2
< 501 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/xtrnlp.f
< nbody6compare-oct2006/xtrnlp.f
---
> 501 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/xtrnlp.f
> nbody6++compare/xtrnlp.f
1,2c1,2
< 314 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/xtrnlu.f
< nbody6compare-oct2006/xtrnlu.f
---
> 314 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/xtrnlu.f
> nbody6++compare/xtrnlu.f
1,2c1,2
< 2163 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/xtrnlv.f
< nbody6compare-oct2006/xtrnlv.f
---
> 590 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/xtrnlv.f
> nbody6++compare/xtrnlv.f
4,5c4,5
< *       External potential energy.
< *       --------------------------
---
> *       External potential.
> *       -------------------
8,13d7
<       COMMON/GALAXY/ GMG,RG(3),VG(3),FG(3),FGD(3),TG,
<      &               OMEGA,DISK,A,B,V02,RL2
<       REAL*8 XI(3)
<       SAVE FIRST
<       LOGICAL FIRST
<       DATA FIRST /.TRUE./
15a10
> *       See whether to include the galactic tidal force.
17,27c12
< *       Skip external potential during scaling (parameters not defined).
<       IF (FIRST.AND.TIME.EQ.0.0D0) THEN
<           FIRST = .FALSE.
<           GO TO 30
<       ELSE IF (KZ(14).GT.2) THEN
< *       Ignore the general case for now.
<           GO TO 30
<       END IF
< *
< *       See whether to include a linearized galactic tidal force.
<       IF (KZ(14).LE.2) THEN
---
>       IF (TIDAL(1).GT.0.0) THEN
32,63d16
<       ELSE IF (KZ(14).EQ.3) THEN
<           I = I1
<           RG2 = 0.0
<           RI2 = 0.0
<           DO 20 K = 1,3
<               XI(K) = X(K,I)
<               RG2 = RG2 + RG(K)**2
<               RI2 = RI2 + (RG(K) + XI(K))**2
<    20     CONTINUE
< *
< *       Include galaxy point mass term for body #I in differential form.
<           IF (GMG.GT.0.0D0) THEN
<               ET = ET + GMG*(1.0/SQRT(RI2) - 1.0/SQRT(RG2))
<           END IF
< *
< *       Add optional Miyamoto disk potential.
<           IF (DISK.GT.0.0D0) THEN
<               R2 = (RG(1) + XI(1))**2 + (RG(2) + XI(2))**2
<               BZ = SQRT(B**2 + (RG(3) + XI(3))**2)
<               AZ = SQRT(R2 + (A + BZ)**2)
<               R20 = RG(1)**2 + RG(2)**2
<               BZ0 = SQRT(B**2 + RG(3)**2)
<               AZ0 = SQRT(R20 + (A + BZ0)**2)
<               ET = ET + DISK*(1.0/AZ - 1.0/AZ0)
<           END IF
< *
< *       Check addition of differential logarithmic potential.
<           IF (V02.GT.0.0D0) THEN
<               ET = ET + 0.5*V02*(LOG(RI2) - LOG(RG2))
<           END IF
< *       Form the differential potential energy due to tides.
<           ET = BODY(I)*ET
67c20
<    30 IF (I2.GT.I1) THEN
---
>       IF (I2.GT.I1) THEN
1,2c1,2
< 3364 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/xvpred.f
< nbody6compare-oct2006/xvpred.f
---
> 3375 2000-04-14 16:35 /work/Umi2/spurzem/5/nbody6++compare/xvpred.f
> nbody6++compare/xvpred.f
9d8
< *
63c62
<       IF ((DT.EQ.0.0D0.AND.IPHASE.LT.4).OR.BODY(I).EQ.0.0D0) GO TO 35
---
>       IF (DT.EQ.0.0D0.OR.BODY(I).EQ.0.0D0) GO TO 35
77c76
<      &                   X0(K,I)
---
>      &                                                  X0(K,I)
1,2c1,2
< 519 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ycopy.f
< nbody6compare-oct2006/ycopy.f
---
> 519 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/ycopy.f
> nbody6++compare/ycopy.f
1,2c1,2
< 515 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/ysave.f
< nbody6compare-oct2006/ysave.f
---
> 515 1995-11-14 11:13 /work/Umi2/spurzem/5/nbody6++compare/ysave.f
> nbody6++compare/ysave.f
1,2c1,2
< 3427 2004-03-08 11:50 /work/Umi2/spurzem/5/nbody6compare-oct2006/zare.f
< nbody6compare-oct2006/zare.f
---
> 3317 1999-12-15 16:43 /work/Umi2/spurzem/5/nbody6++compare/zare.f
> nbody6++compare/zare.f
27a28,33
> *       Predict unperturbed KS to avoid identical coordinates (cf. NBINT).
> *     IF (LIST(1,I1).EQ.0) THEN
> *         IPAIR = KVEC(I1)
> *         CALL KSRES(IPAIR,J1,J2,0.0D0)
> *     END IF
> *
76,78c82
< *     A(4) = - A(3)
< *       Note bug fix by Douglas Heggie 1/11/2000.
<       A(4) = - (3.0D0*M2 + M1)
---
>       A(4) = - A(3)
85,94c89,94
< *  50 F1 = A(1)
< *     FP1 = F1*5.0D0
< *     DO 60 I = 2,5
< *         F1 = F1*S + A(I)
< *         FP1 = FP1*S + (6-I)*A(I)
< *  60 CONTINUE
< *
< *       Replace by iteration of f(s)/s**2 = 0 for faster convergence (DCH).
<    50 F1 = ((A(1)*S + A(2))*S + A(3))*S + A(4) + A(5)/S + A(6)/S**2
<       FP1 = (3.0*A(1)*S + 2.0*A(2))*S + A(3) - (2.0*A(6)/S + A(5))/S**2
---
>    50 F1 = A(1)
>       FP1 = F1*5.0D0
>       DO 60 I = 2,5
>           F1 = F1*S + A(I)
>           FP1 = FP1*S + (6-I)*A(I)
>    60 CONTINUE
96c96
< *     F1 = F1*S + A(6)
---
>       F1 = F1*S + A(6)
1,2c1,2
< 16419 2006-08-16 10:20 /work/Umi2/spurzem/5/nbody6compare-oct2006/zcnsts.f
< nbody6compare-oct2006/zcnsts.f
---
> 16217 2006-06-20 02:34 /work/Umi2/spurzem/5/nbody6++compare/zcnsts.f
> nbody6++compare/zcnsts.f
9c9,11
<       real*8 lzs,dlzs,lz,lzd,dum1,m1,m2,rr,rb,mhefl,lhefl,thefl,lx
---
>       real*8 lzs,lz,lzd,dum1,m1,m2,rr,rb,mhefl,lhefl,thefl,lx,c(5)
>       real*8 xz(76),xt(31),xl(72),xr(119),xg(112),xh(99)
>       real*8 msp(200),gbp(200)
14,16c16,21
< *
<       include 'zdata.h'
<       real*8 msp(200),gbp(200),c(5)
---
>       common /ZAMS/ xz
>       common /TBGB/ xt
>       common /LTMS/ xl
>       common /RTMS/ xr
>       common /GAGB/ xg
>       common /CHEB/ xh
42d46
<       dlzs = 1.d0/(z*log(10.d0))
53,54c57,58
<       zpars(8) = MAX(0.95d0,MAX(0.95d0-(10.d0/3.d0)*(z-0.01d0),
<      &           MIN(0.99d0,0.98d0-(100.d0/7.d0)*(z-0.001d0))))
---
>       zpars(8) = MAX(0.95d0,MAX(0.95d0-(10./3.)*(z-0.01d0),
>      &           MIN(0.99d0,0.98d0-(100./7.)*(z-0.001d0))))
74c78
< * Tbgb 
---
> * Tbgb
80,84d83
< * dTbgb/dz
<       msp(117) = dlzs*(xt(2)+lzs*(2.d0*xt(3)+3.d0*lzs*xt(4)))
<       msp(118) = dlzs*(xt(6)+lzs*(2.d0*xt(7)+3.d0*lzs*xt(8)))
<       msp(119) = dlzs*(xt(10)+lzs*(2.d0*xt(11)+3.d0*lzs*xt(12)))
<       msp(120) = dlzs*(xt(14)+lzs*(2.d0*xt(15)+3.d0*lzs*xt(16)))
108c107
<       if(z.gt.0.01d0)then
---
>       if(z.gt.0.01)then
116,117c115
<       msp(42) = (msp(33)+msp(34)*m2**msp(36))/
<      &          (m2**0.4d0+msp(35)*m2**1.9d0)
---
>       msp(42) = (msp(33)+msp(34)*m2**msp(36))/(m2**0.4+msp(35)*m2**1.9)
152c150
<      &           msp(59)*m2**(msp(61)+1.5d0))/(msp(60)+m2**5)
---
>      &           msp(59)*m2**(msp(61)+1.5))/(msp(60)+m2**5)
165,166c163,164
<       if(z.lt.0.004d0) msp(74) = MIN(0.055d0,msp(74))
<       msp(75) = MAX(0.091d0,MIN(0.121d0,0.136d0+0.0352d0*lzs))
---
>       if(z.lt.0.004) msp(74) = MIN(0.055d0,msp(74))
>       msp(75) = MAX(0.091d0,MIN(0.121d0,0.136d0+0.0352*lzs))
178c176
<       if(z.gt.0.01d0) msp(81) = MAX(msp(81),0.95d0)
---
>       if(z.gt.0.01) msp(81) = MAX(msp(81),0.95d0)
187c185
<       msp(86) = MIN(xr(102)+lzs*xr(103),MAX(2.d0,-13.3d0-18.6d0*lzs))
---
>       msp(86) = MIN(xr(102)+lzs*xr(103),MAX(2.d0,-66.47d0-90.45d0*lzs))
238,240c236
<       if(z.gt.0.004d0)then
<          gbp(19) = MAX(gbp(19),0.7307d0+14265.1d0*z**3.395d0)
<       endif
---
>       if(z.gt.0.004)gbp(19) = MAX(gbp(19),0.7307d0+14265.1d0*z**3.395d0)
360c356
<       rr = MAX(rr,1.0d-12)
---
>       rr = max(rr,1.0d-12)
378c374
<       zpars(14) = z**0.4d0
---
>       zpars(14) = z**0.4
file /work/Umi2/spurzem/5/nbody6++compare/zdata.h does not exist
1,2c1,2
< 2145 2006-08-31 17:29 /work/Umi2/spurzem/5/nbody6compare-oct2006/zero.f
< nbody6compare-oct2006/zero.f
---
> 2222 2003-06-25 21:20 /work/Umi2/spurzem/5/nbody6++compare/zero.f
> nbody6++compare/zero.f
16d15
<       TPLOT = 0.0D0
20a20
>       TLIST = 0.0D0
46,49d45
<       ETIDE = 0.0D0
<       ESESC = 0.0D0
<       EBESC = 0.0D0
<       EMESC = 0.0D0
54,55d49
<       NBPREV = 0
<       NNTB = 0
61a56,57
>       NBPREV = 0
>       NNTB = 0
65a62,63
>       ICLOSE = 0
>       JCLOSE = 0
71a70
>       NLIST(1) = 0
75,76c74,75
<       NTAIL = 0
< *
---
> *         small value should be smaller than 1/(4*KMAX), plus security (RS)
>       TINY = MIN(1.D-4,0.01D0/FLOAT(KMAX))
79c78
<           KVEC(J) = 0.50001*FLOAT(J + 1)
---
>           KVEC(J) = (0.5+TINY)*FLOAT(J + 1)
1,2c1,2
< 24674 2006-08-16 10:20 /work/Umi2/spurzem/5/nbody6compare-oct2006/zfuncs.f
< nbody6compare-oct2006/zfuncs.f
---
> 21334 2000-04-11 15:30 /work/Umi2/spurzem/5/nbody6++compare/zfuncs.f
> nbody6++compare/zfuncs.f
4c4
<       real*8 m,mx,a(200)
---
>       real*8 m,a(100)
10,11c10
<       mx = SQRT(m)
<       lzamsf = (a(1)*m**5*mx + a(2)*m**11)/
---
>       lzamsf = (a(1)*m**5.5 + a(2)*m**11)/
13c12
<      &          a(6)*m**8 + a(7)*m**9*mx)
---
>      &          a(6)*m**8 + a(7)*m**9.5)
20c19
<       real*8 m,mx,a(200)
---
>       real*8 m,a(100)
26,30c25,28
<       mx = SQRT(m)
<       rzamsf = ((a(8)*m**2 + a(9)*m**6)*mx + a(10)*m**11 +
<      &          (a(11) + a(12)*mx)*m**19)/
<      &         (a(13) + a(14)*m**2 + 
<      &          (a(15)*m**8 + m**18 + a(16)*m**19)*mx)
---
>       rzamsf = (a(8)*m**2.5 + a(9)*m**6.5 + a(10)*m**11 +
>      &          a(11)*m**19 + a(12)*m**19.5)/
>      &         (a(13) + a(14)*m**2 + a(15)*m**8.5 +
>      &          m**18.5 + a(16)*m**19.5)
37c35
<       real*8 m,a(200)
---
>       real*8 m,a(100)
44c42
<       tbgbf = (a(17) + a(18)*m**4 + a(19)*m**(11.d0/2.d0) + m**7)/
---
>       tbgbf = (a(17) + a(18)*m**4 + a(19)*m**5.5 + m**7)/
52c50
<       real*8 m,mx,f,df,g,dg,a(200)
---
>       real*8 m,f,df,g,dg,a(100)
55,56c53,54
< * A function to evaluate the derivitive of the lifetime to the BGB
< * (or to Helium ignition if no FGB exists) wrt mass.
---
> * A function to evaluate the derivitive lifetime to the BGB
> * or to Helium ignition if no FGB exists.
59,61c57,58
<       mx = SQRT(m)
<       f = a(17) + a(18)*m**4 + a(19)*m**5*mx + m**7
<       df = 4.d0*a(18)*m**3 + 5.5d0*a(19)*m**4*mx + 7.d0*m**6
---
>       f = a(17) + a(18)*m**4 + a(19)*m**5.5 + m**7
>       df = 4.d0*a(18)*m**3 + 5.5d0*a(19)*m**4.5 + 7.d0*m**6
69,87d65
<       real*8 FUNCTION tbgdzf(m)
<       implicit none
<       real*8 m,mx,f,df,g,dg,a(200)
<       common /MSCFF/ a
< *
< * A function to evaluate the derivitive of the lifetime to the BGB
< * (or to Helium ignition if no FGB exists) wrt Z.
< * (JH 14/12/98)
< *
<       mx = m**5*SQRT(m)
<       f = a(17) + a(18)*m**4 + a(19)*mx + m**7
<       df = a(117) + a(118)*m**4 + a(119)*mx
<       g = a(20)*m**2 + a(21)*m**7
<       dg = a(120)*m**2
<       tbgdzf = (df*g - f*dg)/(g*g)
< *
<       return
<       end
< ***
90c68
<       real*8 m,a(200)
---
>       real*8 m,a(100)
107c85
<       real*8 m,a(200)
---
>       real*8 m,a(100)
121c99
<       real*8 m,mcut,a(200)
---
>       real*8 m,mcut,a(100)
129c107
<          lalphf = (a(33) + a(34)*m**a(36))/(m**0.4d0 + a(35)*m**1.9d0)
---
>          lalphf = (a(33) + a(34)*m**a(36))/(m**0.4 + a(35)*m**1.9)
149c127
<       real*8 m,a1,a(200)
---
>       real*8 m,a1,a(100)
168c146
<       real*8 m,a(200)
---
>       real*8 m,a(100)
188c166
<       real*8 m,mhook,a2,a(200)
---
>       real*8 m,mhook,a2,a(100)
202c180
<          lhookf = a2*((m-mhook)/(a(51)-mhook))**0.4d0
---
>          lhookf = a2*((m-mhook)/(a(51)-mhook))**0.4
210c188
<       real*8 m,m2,rchk,a(200)
---
>       real*8 m,m2,a(100)
212,213d189
<       real*8 rzamsf
<       external rzamsf
216,217d191
< * Note that a safety check is added to ensure Rtms > Rzams
< * when extrapolating the function to low masses. 
222,223c196
<          rchk = 1.5d0*rzamsf(m)
<          rtmsf = MAX(rchk,(a(52) + a(53)*m**a(55))/(a(54) + m**a(56)))
---
>          rtmsf = (a(52) + a(53)*m**a(55))/(a(54) + m**a(56))
225c198
<          rtmsf = (a(57)*m**3+a(58)*m**a(61)+a(59)*m**(a(61)+1.5d0))/
---
>          rtmsf = (a(57)*m**3 + a(58)*m**a(61) + a(59)*m**(a(61)+1.5))/
236c209
<       real*8 m,a5,a(200)
---
>       real*8 m,a5,xx,a(100)
254c227,228
<          ralphf = a5 + a(69)*(m - a(72))
---
>          xx = a5 - a(69)*a(72)
>          ralphf = xx + a(69)*m
262c236
<       real*8 m,m2,m3,b2,b3,a(200)
---
>       real*8 m,m2,m3,b2,b3,xx,a(100)
275c249
<          b2 = (a(77)*m2**(7.d0/2.d0))/(a(78) + m2**a(79))
---
>          b2 = (a(77)*m2**3.5)/(a(78) + m2**a(79))
278c252
<          rbetaf = (a(77)*m**(7.d0/2.d0))/(a(78) + m**a(79))
---
>          rbetaf = (a(77)*m**3.5)/(a(78) + m**a(79))
280,281c254,256
<          b3 = (a(77)*m3**(7.d0/2.d0))/(a(78) + m3**a(79))
<          rbetaf = b3 + a(80)*(m - m3)
---
>          b3 = (a(77)*m3**3.5)/(a(78) + m3**a(79))
>          xx = b3 - a(80)*m3
>          rbetaf = xx + a(80)*m
290c265
<       real*8 m,m1,b1,a(200)
---
>       real*8 m,m1,b1,a(100)
302c277
<             rgammf = a(83) + a(84)*ABS(m-a(85))**a(86)
---
>             rgammf = a(83) + a(84)*(m-a(85))**a(86)
317c292
<       real*8 m,mhook,m2,b2,a(200)
---
>       real*8 m,mhook,m2,b2,a(100)
328c303
<          rhookf = a(95)*SQRT((m-mhook)/(a(94)-mhook))
---
>          rhookf = a(95)*((m-mhook)/(a(94)-mhook))**0.5
331,332c306
<          b2 = (a(90) + a(91)*m2**(7.d0/2.d0))/
<      &        (a(92)*m2**3 + m2**a(93)) - 1.d0
---
>          b2 = (a(90) + a(91)*m2**3.5)/(a(92)*m2**3 + m2**a(93)) - 1.d0
335,336c309
<          rhookf = (a(90) + a(91)*m**(7.d0/2.d0))/
<      &            (a(92)*m**3 + m**a(93)) - 1.d0
---
>          rhookf = (a(90) + a(91)*m**3.5)/(a(92)*m**3 + m**a(93)) - 1.d0
343c316
<       real*8 m,a(200)
---
>       real*8 m,a(100)
358c331
<       real*8 m,a(200)
---
>       real*8 m,a(100)
378c351
<       real*8 m,mhefl,a4,a(200)
---
>       real*8 m,mhefl,a4,a(100)
398c371
<       real*8 m,lum,a1,a(200)
---
>       real*8 m,lum,a1,a(100)
410,424d382
<       real*8 FUNCTION rgbdf(m,lum)
<       implicit none
<       real*8 m,lum,a1,a(200)
<       common /GBCFF/ a
< *
< * A function to evaluate radius derivitive on the GB (as f(L)).
< * (JH 24/11/97)
< *
<       a1 = MIN(a(20)/m**a(21),a(22)/m**a(23))
<       rgbdf = a1*(a(18)*lum**(a(18)-1.d0) + 
<      &            a(17)*a(19)*lum**(a(19)-1.d0))
< *
<       return
<       end
< ***
427c385
<       real*8 m,lum,mhelf,m1,a1,a4,xx,a(200)
---
>       real*8 m,lum,mhelf,m1,a1,a4,xx,a(100)
455,499d412
<       real*8 FUNCTION ragbdf(m,lum,mhelf)
<       implicit none
<       real*8 m,lum,mhelf,m1,a1,a4,xx,a(200)
<       common /GBCFF/ a
< *
< * A function to evaluate radius derivitive on the AGB (as f(L)).
< * (JH 24/11/97)
< *
<       m1 = mhelf - 0.2d0
<       if(m.ge.mhelf)then
<          xx = a(24)
<       elseif(m.ge.m1)then
<          xx = 1.d0 + 5.d0*(a(24)-1.d0)*(m-m1)
<       else
<          xx = 1.d0
<       endif
<       a4 = xx*a(19)
<       if(m.le.m1)then
<          a1 = a(29) + a(30)*m
<       elseif(m.ge.mhelf)then
<          a1 = MIN(a(25)/m**a(26),a(27)/m**a(28))
<       else
<          a1 = a(31) + 5.d0*(a(32)-a(31))*(m-m1)
<       endif
< *
<       ragbdf = a1*(a(18)*lum**(a(18)-1.d0) + 
<      &             a(17)*a4*lum**(a4-1.d0))
< *
<       return
<       end
< ***
<       real*8 FUNCTION mctmsf(m)
<       implicit none
<       real*8 m,m525
< *
< * A function to evaluate core mass at the end of the MS as a 
< * fraction of the BGB value, i.e. this must be multiplied by 
< * the BGB value (see below) to give the actual core mass (JH 5/9/99)
< *
<       m525 = m**(21.d0/4.d0)
<       mctmsf = (1.586d0 + m525)/(2.434d0 + 1.02d0*m525)
< *
<       return
<       end
< ***
502c415
<       real*8 m,mhefl,mchefl,mcbagb,a3,a(200)
---
>       real*8 m,mhefl,mchefl,mcbagb,a3,a(100)
512c425
<       mcheif = MIN(0.95d0*mcbagb,(a3 + a(33)*m**a(34))**(1.d0/4.d0))
---
>       mcheif = MIN(0.95d0*mcbagb,(a3 + a(33)*m**a(34))**0.25)
519c432
<       real*8 mc,mhefl,mchefl,m1,m2,a3,a(200)
---
>       real*8 mc,mhefl,mchefl,m1,m2,a3,a(100)
538c451
<       real*8 m,a(200)
---
>       real*8 m,a(100)
543c456
<       mcagbf = (a(37) + a(35)*m**a(36))**(1.d0/4.d0)
---
>       mcagbf = (a(37) + a(35)*m**a(36))**0.25
550c463
<       real*8 mc,mc4,a(200)
---
>       real*8 mc,mc4,a(100)
631c544
<       real*8 m,mhefl,a(200)
---
>       real*8 m,mhefl,a(100)
649c562
<       real*8 m,a(200)
---
>       real*8 m,a(100)
663c576
<       real*8 m,mx,a(200)
---
>       real*8 m,mx,a(100)
677c590
<       real*8 m,mc,mhefl,mm,a(200)
---
>       real*8 m,mc,mhefl,mm,a(100)
693,694c606
<          mm = m**5
<          tHef = (a(58)*m**a(61) + a(59)*mm)/(a(60) + mm)
---
>          tHef = (a(58)*m**a(61) + a(59)*m**5)/(a(60) + m**5)
702c614
<       real*8 m,mhefl,mfgb,mr,m1,m2,r1,a(200)
---
>       real*8 m,mhefl,mfgb,mr,m1,m2,r1,a(100)
729c641
<       real*8 m,mc,mhefl,mm,a4,a5,a(200)
---
>       real*8 m,mc,mhefl,mm,a4,a5,a(100)
742,743c654,655
<       lzahbf = a5 + (1.d0 + a(72))*a(69)*mm**a(70)/
<      &         ((1.d0 + a(72)*mm**a(73))*(1.d0 + a4*EXP(m*a(71))))
---
>       lzahbf = a5 + (1.0 + a(72))*a(69)*mm**a(70)/
>      &         ((1.0 + a(72)*mm**a(73))*(1.0 + a4*exp(m*a(71))))
750c662
<       real*8 m,mc,mhefl,rx,ry,mm,f,a(200)
---
>       real*8 m,mc,mhefl,rx,ry,mm,f,a(100)
775c687
<       lzhef = 1.5262d+04*m**(41.d0/4.d0)/
---
>       lzhef = 1.5262d+04*m**10.25/
787c699
<       rzhef = 0.2391d0*m**4.6d0/(0.0065d0 + (0.162d0 + m)*m**3)
---
>       rzhef = 0.2391d0*m**4.6/(0.0065d0 + (0.162d0 + m)*m**3)
798c710
<       themsf = (0.4129d0 + 18.81d0*m**4 + 1.853d0*m**6)/m**(13.d0/2.d0)
---
>       themsf = (0.4129d0 + 18.81d0*m**4 + 1.853d0*m**6)/m**6.5
803c715
<       real*8 FUNCTION rhehgf(m,lum,rx,lx)
---
>       real*8 FUNCTION rhelmf(kw,m,lum,rx,lx)
805,818c717,718
<       real*8 m,lum,rx,lx,cm
< *
< * A function to evaluate Helium star radius on the Hertzsprung gap 
< * from its mass and luminosity. 
< *
<       cm = 2.0d-03*m**(5.d0/2.d0)/(2.d0 + m**5)
<       rhehgf = rx*(lum/lx)**0.2d0 + 0.02d0*(EXP(cm*lum) - EXP(cm*lx))
< *
<       return
<       end
< ***
<       real*8 FUNCTION rhegbf(lum)
<       implicit none
<       real*8 lum
---
>       integer kw
>       real*8 m,lum,rx,lx,ragb,rhe,cm
820c720
< * A function to evaluate Helium star radius on the giant branch. 
---
> * A function to evaluate Helium star radius from its mass and luminosity
822c722,730
<       rhegbf = 0.08d0*lum**(3.d0/4.d0)
---
>       ragb = 0.08d0*lum**0.75
>       cm = 2.0d-03*m**2.5/(2.d0 + m**5)
>       rhe = rx*(lum/lx)**0.2 + 0.02d0*(EXP(cm*lum) - EXP(cm*lx))
>       if(rhe.lt.ragb)then
>          kw = 8
>          rhelmf = rhe
>       else
>          rhelmf = ragb
>       endif
834,835c742,743
<       b = 0.002d0*MAX(1.d0,2.5d0/m)
<       c = 3.d0
---
>       b = 0.002*MAX(1.d0,2.5d0/m)
>       c = 3.0
848,850c756,758
<       a = 0.1d0
<       b = 0.006d0*MAX(1.d0,2.5d0/m)
<       c = 3.d0
---
>       a = 0.1
>       b = 0.006*MAX(1.d0,2.5d0/m)
>       c = 3.0
858c766
<       real*8 FUNCTION vrotf(m)
---
>       real*8 FUNCTION renvf(kw,m,r,rc,aj,tm,tbgb)
860,862c768,807
<       real*8 m
< *
<       vrotf = 330.d0*m**3.3d0/(15.d0 + m**3.45d0)
---
>       integer kw
>       real*8 m,r,rc,aj,tm,tbgb,taumin
>       parameter(taumin=5.0d-08)
>       real*8 mx,rx,rzams,rtms,gamma,tau,xx,a(100)
>       common /MSCFF/ a
>       real*8 rzamsf,rgammf
>       external rzamsf,rgammf
> *
> * A function to estimate the depth of the convective envelope.
> *
>       mx = 0.35d0
>       if(kw.le.1)then
>          tau = aj/tm
>          if(m.le.mx)then
>             renvf = r
>          elseif(m.ge.1.25)then
>             renvf = 0.d0
>          else
>             rzams = rzamsf(mx)
>             rtms = (a(52) + a(53)*mx**a(55))/(a(54) + mx**a(56))
>             gamma = rgammf(mx)
>             rx = LOG10(rtms/rzams)
>             if(tau.gt.taumin)then
>                xx = a(73)*tau + 1.06d0*tau**10 + gamma*tau**40 +
>      &              (rx - a(73) - 1.06d0 - gamma)*tau**3
>             else
>                xx = a(73)*tau + (rx - a(73))*tau**3
>             endif
>             rx = rzams*10.d0**xx
>             renvf = rx*SQRT((1.25d0 - m)/0.9d0)
>             renvf = MIN(renvf,r)
>          endif
>          renvf = renvf*(1.d0-tau)**0.25
>       elseif(kw.eq.2)then
>          tau = (aj-tm)/(tbgb-tm)
>          renvf = SQRT(tau)*(r-rc)
>       else
>          renvf = r - rc
>       endif
>       renvf = MAX(renvf,1.0d-10)
867c812
<       real*8 FUNCTION celamf(kw,m,lum,rad,rzams,menv,fac)
---
>       real*8 FUNCTION menvf(kw,m,mc,aj,tm,tbgb)
870,876c815
<       real*8 m,lum,rad,rzams,menv,fac
<       real*8 lam1,lam2,m1,logm,logl
<       real*8 aa,bb,cc,dd
< *
< * A function to estimate lambda for common-envelope.
< *
<       if(fac.ge.0.d0)then
---
>       real*8 m,mc,aj,tm,tbgb,tau
878,883c817
< * No fits yet for naked He stars...
< *
<          if(kw.gt.6)then
<             celamf = 0.5d0
<             goto 90
<          endif
---
> * A function to estimate the mass of the convective envelope.
885,943c819,823
<          if(menv.gt.0.d0)then
< * Formulae for giant-like stars; also used for HG and CHeB stars close
< * to the Hayashi track.
<             logl = log10(lum)
<             logm = log10(m)
<             if(kw.le.5)then
<                m1 = m
<                if(kw.gt.3) m1 = 100.d0
<                lam1 = 3.d0/(2.4d0 + 1.d0/m1**(3.d0/2.d0)) - 0.15d0*logl
<                lam1 = MIN(lam1,0.8d0)
<             else
<                lam1 = -3.5d0 - 0.75d0*logm + logl
<             endif
<             if(kw.gt.3)then
<                lam2 = MIN(0.9d0,0.58d0 + 0.75d0*logm) - 0.08d0*logl
<                if(kw.lt.6)then
<                   lam1 = MIN(lam2,lam1)
<                else
<                   lam1 = MAX(lam2,lam1)
<                   lam1 = MIN(lam1,1.d0)
<                endif
<             endif
<             lam1 = 2.d0*lam1
<             if(fac.gt.0.d0)then
< * Use a fraction FAC of the ionization energy in the energy balance.
<                if(kw.le.3)then
<                   aa = MIN(1.2d0*(logm - 0.25d0)**2 - 0.7d0,-0.5d0)
<                else
<                   aa = MAX(-0.2d0 - logm,-0.5d0)
<                endif
<                bb = MAX(3.d0 - 5.d0*logm,1.5d0)
<                cc = MAX(3.7d0 + 1.6d0*logm,3.3d0 + 2.1d0*logm)
<                lam2 = aa + ATAN(bb*(cc - logl))
<                if(kw.le.3)then
<                   dd = MAX(0.d0,MIN(0.15d0,0.15d0 - 0.25d0*logm))
<                   lam2 = lam2 + dd*(logl - 2.d0)
<                endif
<                lam2 = MAX(lam2,1.d-2)
<                lam2 = MAX(1.d0/lam2,lam1)
<                if(fac.ge.1.d0)then
<                   lam1 = lam2
<                else
<                   lam1 = lam1 + fac*(lam2 - lam1)
<                endif
<             endif
<          endif
< *
<          if(menv.lt.1.d0)then
< * Formula for HG stars; also reasonable for CHeB stars in blue loop.
<             lam2 = 0.42d0*(rzams/rad)**0.4d0
< * Alternatively:
< *           lam2 = 0.3d0*(rtms/rad)**0.4d0
<             lam2 = 2.d0*lam2
<          endif
< *
<          if(menv.le.0.d0)then
<             celamf = lam2
<          elseif(menv.ge.1.d0)then
<             celamf = lam1
---
>       if(kw.le.1)then
>          if(m.le.0.35)then
>             menvf = m
>          elseif(m.ge.1.25)then
>             menvf = 0.d0
945,946c825
< * Interpolate between HG and GB values depending on conv. envelope mass.
<             celamf = lam2 + sqrt(menv)*(lam1 - lam2)
---
>             menvf = 0.35d0*((1.25d0 - m)/0.9d0)**2
948,950c827,831
< *
<  90      continue
< *
---
>          tau = aj/tm
>          menvf = menvf*(1.d0-tau)**0.25
>       elseif(kw.eq.2)then
>          tau = (aj-tm)/(tbgb-tm)
>          menvf = tau*(m-mc)
952c833
<          celamf = -1.d0*fac
---
>          menvf = m - mc
953a835
>       menvf = MAX(menvf,1.0d-10)
