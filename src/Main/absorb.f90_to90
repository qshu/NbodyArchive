SUBROUTINE absorb(isub)
 
! Code converted using TO_F90 by Alan Miller
! Date: 2020-10-18  Time: 16:04:31


!       Absorption of chain member(s).
!       -----------------------------

INCLUDE 'common6.h'

INTEGER, INTENT(IN OUT)                  :: isub
INTEGER, PARAMETER :: nmx=10
INTEGER, PARAMETER :: nmx3=3*nmx
INTEGER, PARAMETER :: nmx4=4*nmx
INTEGER, PARAMETER :: nmxm=nmx*(nmx-1)/2
REAL*8  m,mass,mc,mij,mkk,xcm(3),vcm(3)
COMMON/chain1/  xch(nmx3),vch(nmx3),m(nmx), zz(nmx3),wc(nmx3),mc(nmx),  &
    xi(nmx3),pi(nmx3),mass,rinv(nmxm),rsum,mkk(nmx),  &
    mij(nmx,nmx),tkk(nmx),tk1(nmx),iname(nmx),nn
COMMON/chainc/  xc(3,ncmax),uc(3,ncmax),bodyc(ncmax),ich, listc(lmax)
COMMON/chreg/  timec,tmax,rmaxc,cm(10),namec(6),nstep1,kz27,kz30
COMMON/clump/   bodys(ncmax,5),t0s(5),ts(5),steps(5),rmaxs(5),  &
    names(ncmax,5),isys(5)
COMMON/ccoll2/  qk(nmx4),pk(nmx4),rik(nmx,nmx),size(nmx),vstar1,  &
    ecoll1,rcoll,qperi,istar(nmx),icoll,isync,ndiss1
COMMON/incond/  x4(3,nmx),xdot4(3,nmx)


!       Define discrete time for new polynomial (DT2 < 0 is OK).
dt2 = t0s(isub) + timec - tprev
dt8 = (tblock - tprev)/8.0D0
!       Avoid zero since TBLOCK = TPREV during the first block-step.
IF (ABS(dt8)<1.d-14) dt8 = step(ich)/8.0D0

!       Adopt the nearest truncated step (at most 8 subdivisions).
IF (dt2 > 0.0D0) THEN
  CALL stepk(dt2,dtn2)
  dtn = nint(dtn2/dt8)*dt8
ELSE
!       Choose negative step if pericentre time < TPREV.
  dt2 = -dt2
  CALL stepk(dt2,dtn2)
  dtn = -nint(dtn2/dt8)*dt8
END IF

!       Update time for new polynomial initializations (but check T - T0).
time = tprev + dtn

!       Avoid prediction skip by XVPRED in case TIME - T0 = 0.0.
IF (ABS(time - t0(ich))<1.d-14) time = time + dt8/16.0D0

!       Re-define initial epoch for consistency (ignore phase error).
t0s(isub) = time - timec

IF (kz(30) > 2) THEN
  WRITE (6,1)  time+toff, dt2, dt8
  1     FORMAT (' ABSORB:    TIME DT2 DT8 ',f12.6,1P,2E10.2)
END IF

!       Increase membership of chain (JCLOSE: single body or KS pair).
nch0 = nch
CALL setsys

!       Improve coordinates & velocities of c.m. body to order F3DOT.
CALL xvpred(ich,-1)

sum = 0.d0
DO  k = 1,3
  xcm(k) = 0.d0
  vcm(k) = 0.d0
END DO

!       Accumulate mass-weighted moments of absorbed particle(s).
DO  l = nch0+1,nch
  j = jlist(l)
  CALL jpred(j,time,time)
  sum = sum + body(j)
  DO  k = 1,3
    xcm(k) = xcm(k) + body(j)*x(k,j)
    vcm(k) = vcm(k) + body(j)*xdot(k,j)
  END DO
END DO

!       Form combined c.m. of old chain and new perturber(s).
DO  k = 1,3
  xcm(k) = (body(ich)*x(k,ich) + xcm(k))/(body(ich) + sum)
  vcm(k) = (body(ich)*xdot(k,ich) + vcm(k))/(body(ich) + sum)
END DO

!       Define new relative coordinates & velocities and add to chain.
lk = 3*nch0
DO  l = nch0+1,nch
  j = jlist(l)
  size(l) = radius(j)
  istar(l) = kstar(j)
  rij2 = 0.d0
  DO  k = 1,3
    lk = lk + 1
    x4(k,l) = x(k,j) - xcm(k)
    xdot4(k,l) = xdot(k,j) - vcm(k)
    xch(lk) = x4(k,l)
    vch(lk) = xdot4(k,l)
    rij2 = rij2 + (x4(k,l) - x4(k,l-1))**2
  END DO
!       Initialize new inverse distance(s) (some value needed in chpert.f).
  rinv(l-1) = 1.d0/SQRT(rij2)
END DO

!       Re-define old chain variables with respect to new c.m.
lk = 0
DO  l = 1,nch0
  DO  k = 1,3
    lk = lk + 1
    xch(lk) = xch(lk) - (xcm(k) - x(k,ich))
    vch(lk) = vch(lk) - (vcm(k) - xdot(k,ich))
  END DO
END DO

!       Create ghost particle(s) and remove from neighbour lists.
DO  l = nch0+1,nch
  j = jlist(l)
  CALL ghost(j)
!     Remove ghosts from NXTLST and add to ghost list
  CALL delay_remove_tlist(j,step,dtk)
  step(j) = 2*dtk(1)
  CALL add_tlist(j,step,dtk)
END DO

!       Update total mass and initialize new c.m. body variables.
body(ich) = body(ich) + sum
cm(7) = body(ich)
t0(ich) = time
DO  k = 1,3
  x(k,ich) = xcm(k)
  x0(k,ich) = xcm(k)
  xdot(k,ich) = vcm(k)
  x0dot(k,ich) = vcm(k)
END DO

!       Remove ghost particle(s) from neighbour list of #ICH.
jpert(1) = ich
jlast = ntot + 1
DO  l = nch0+1,nch
  jlist(1) = jlist(l)
  CALL nbrem(jlast,1,1)
END DO

!       Perform re-initialization of c.m. polynomials & perturber list.
CALL reinit(isub)

!       Check optional output for centre of mass condition.
IF (kz(30) > 2) THEN
  DO  k = 1,6
    cm(k) = 0.d0
  END DO
  
  lk = 0
  DO  l = 1,nch
    DO  k = 1,3
      lk = lk + 1
      cm(k) = cm(k) + bodyc(l)*xch(lk)
      cm(k+3) = cm(k+3) + bodyc(l)*vch(lk)
    END DO
  END DO
  
  DO  k = 1,6
    cm(k) = cm(k)/cm(7)
  END DO
  
  WRITE (6,99)  (cm(k),k=1,6)
  99     FORMAT (' ABSORB:   CM ',1P,6E9.1)
END IF

RETURN

END SUBROUTINE absorb
