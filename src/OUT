8d7
<       COMMON/POTDEN/  RHO(NMAX),XNDBL(NMAX),PHIDBL(NMAX)
12c11
<       REAL*8  EB(KMAX),ECC(KMAX),RCM(KMAX),ECM(KMAX),PB(KMAX),AS(30)
---
>       REAL*4  EB(KMAX),ECC(KMAX),RCM(KMAX),ECM(KMAX),PB(KMAX),AS(30)
14,16c13,15
<       CHARACTER*27 OUTFILE
<       CHARACTER*29 OUTFILE2
<       CHARACTER*20 TCHAR
---
>       LOGICAL  FIRST
>       SAVE  FIRST
>       DATA  FIRST /.TRUE./
17a17,19
> *
> *       Decide between regularized and/or soft binaries (#9 <= 2 for KS).
>       IF (KZ(9).GE.3.OR.NPAIRS.EQ.0) GO TO 50
45c47
< C              RM = MIN(RM,99.9D0)
---
>               RM = MIN(RM,99.9D0)
55a58
> *
57,58c60,62
<               PCR = stability(CM(1,IMERGE),CM(2,IMERGE),BODY(ICM),E0,E1,
<      &                                                       ALPH)*SEMI
---
>               QST = QSTAB(E0,E1,ALPH,CM(1,IMERGE),CM(2,IMERGE),
>      &                                            BODY(ICM))
>               PCR = QST*SEMI
60,61c64
<               if(rank.eq.0)
<      &        WRITE (84,3) TTOT, NAME(J1), NAME(J), KSTAR(J1), KSTAR(J),
---
>               WRITE (84,3) TTOT, NAME(J1), NAME(J), KSTAR(J1), KSTAR(J),
63,66c66,67
<     3         FORMAT ('BINDAT: Time[NB] NAME[I1] NAME[I3] K*[I1]',
<      &             'K*[I3] K*[IM] ECC0 ECC1 PERI(I3)/PCR ',
<      &             'PERI(INCM)[RSM] P0[days] P1[days] SEMI1[NB] ',
<      &             1P,E12.5,0P,2I12,3I4,2F7.3,2F12.5,1P,3E14.5,0P)
---
>     3         FORMAT (' BINDAT:    T NM K* E0 E1 PM/PC PM0/R* P0 P1 A1',
>      &                             F8.1,2I5,3I4,2F7.3,2F6.1,1P,3E9.1)
83d83
<               IF (IM.EQ.0) GO TO 10
93c93
< C          EB(JPAIR) = MAX(EB(JPAIR),-9.99999)
---
>           EB(JPAIR) = MAX(EB(JPAIR),-9.99999)
95c95
< *          PB(JPAIR) = MIN(PB(JPAIR),99999.9)
---
>           PB(JPAIR) = MIN(PB(JPAIR),999999.9)
100,107c100,107
< c$$$          POTJ = 0.0
< c$$$          DO 9 J = IFIRST,NTOT
< c$$$              IF (J.EQ.ICM) GO TO 9
< c$$$              RIJ2 = (X(1,ICM) - X(1,J))**2 + (X(2,ICM) - X(2,J))**2 +
< c$$$     &                                        (X(3,ICM) - X(3,J))**2 
< c$$$              POTJ = POTJ + BODY(J)/SQRT(RIJ2)
< c$$$    9     CONTINUE
<           ECM(JPAIR) = 0.5*VJ2 - phidbl(ICM)
---
>           POTJ = 0.0
>           DO 9 J = IFIRST,NTOT
>               IF (J.EQ.ICM) GO TO 9
>               RIJ2 = (X(1,ICM) - X(1,J))**2 + (X(2,ICM) - X(2,J))**2 +
>      &                                        (X(3,ICM) - X(3,J))**2 
>               POTJ = POTJ + BODY(J)/SQRT(RIJ2)
>     9     CONTINUE
>           ECM(JPAIR) = 0.5*VJ2 - POTJ
144a145,155
>       IF (FIRST) THEN
>           OPEN (UNIT=9,STATUS='NEW',FORM='FORMATTED',FILE='OUT9')
>           FIRST = .FALSE.
>       END IF
> *
>       WRITE (9,30)  NPAIRS, MODEL, NRUN, N, NC, NMERGE, (AS(K),K=1,7)
>    30 FORMAT (3I4,I6,2I4,2X,F7.1,2F7.2,F7.3,F8.1,2F9.4)
>       WRITE (9,35)  (AS(K),K=8,17)
>    35 FORMAT (10F11.6)
>       WRITE (9,40)  (AS(K),K=18,30)
>    40 FORMAT (13F10.5)
146,170c157
<       if(rank.eq.0)then
< *     Split the bdat.9 by time
<          call string_left(TCHAR,TTOT,DELTAT)
<          write(OUTFILE,118) TCHAR
<  118     format('bdat.9_',A20)
<          OPEN (UNIT=9,STATUS='UNKNOWN',FORM='FORMATTED',FILE=OUTFILE)
<          
<          WRITE (9,30)  NPAIRS, MODEL, NRUN, N, NC, NMERGE, (AS(K),K=1,7)
<  30      FORMAT (3I4,I6,2I4,2X,F7.1,2F7.2,F7.3,F8.1,2F9.4)
<          WRITE (9,35)  (AS(K),K=8,17)
<  35      FORMAT (10F11.6)
<          WRITE (9,40)  (AS(K),K=18,30)
<  40      FORMAT (13F10.5)
<          WRITE (9,*) 'NAME(I1)    NAME(I2)    ',
<      &        'M1[M*]                    M2[M*]                    ',
<      &        'EB[NB]                    ECC                       ',
<      &        'P[Days]                   SEMI[AU]                  ',
<      &        'RI[PC]                    VI[km/s]                  ',
<      &        'K*(I1)      K*(I2)      ',
<      &        'ZN[NB]                    RP[NB]                    ',
<      &        'STEP(I1)[NB]              NAME(ICM)                 ',
<      &        'ECM[NB]                   K*(ICM)      '
<       end if
< *
<       DO 50 JPAIR = 1,NPAIRS
---
>       DO 48 JPAIR = 1,NPAIRS
177,192c164,168
<           ICM = N + JPAIR
<           SEMI = -0.5*(BODY(J1) + BODY(J2))/H(JPAIR)
<           ZN = SQRT((BODY(J1) + BODY(J2))/SEMI**3)
<           RP = U(1,JPAIR)**2 + U(2,JPAIR)**2 + U(3,JPAIR)**2 +
<      &                                         U(4,JPAIR)**2
<           RI = SQRT((X(1,ICM) - RDENS(1))**2 +
<      &              (X(2,ICM) - RDENS(2))**2 +
<      &              (X(3,ICM) - RDENS(3))**2)
<           VI = SQRT(XDOT(1,ICM)**2 + XDOT(2,ICM)**2 + XDOT(3,ICM)**2)
<           if(rank.eq.0)
<      &    WRITE (9,*)  NAME(J1), NAME(J2), BODY(J1)*ZMBAR,
<      &         BODY(J2)*ZMBAR, EB(JPAIR), ECC(JPAIR), PB(JPAIR), 
<      &         SEMI*RAU, RI*RBAR, VI*VSTAR, KSTAR(J1), KSTAR(J2),
<      &         ZN, RP, STEP(J1), NAME(N+JPAIR), ECM(JPAIR), KCM
< *   45     FORMAT (2I8,1P,8E13.5,0P,3I8,3I4)
<    50 CONTINUE
---
>           WRITE (9,45)  EB(JPAIR), ECC(JPAIR), ECM(JPAIR), RCM(JPAIR),
>      &                  BODY(J1)*ZMBAR, BODY(J2)*ZMBAR, PB(JPAIR),
>      &                  NAME(J1), NAME(J2), KSTAR(J1), KSTAR(J2), KCM
>    45     FORMAT (F8.5,F7.3,F7.2,F6.2,2F5.1,F9.1,2I6,3I4)
>    48 CONTINUE
194d169
<       CLOSE(9)
197,212c172,174
< 
<       if(rank.eq.0) then
< *     Split the bwdat.9 by time
<          write(OUTFILE2,119) TCHAR
<  119     format('bwdat.19_',A20)
<          OPEN (UNIT=19,STATUS='UNKNOWN',FORM='FORMATTED',FILE=OUTFILE2)
< 
<          WRITE (19,55)  TIME+TOFF, (TIME+TOFF)*TSTAR, N
<  55      FORMAT(' WIDE PAIRS    T TPHYS N ',1P,E27.16,E27.16,0P,I12)
<          WRITE (19,*) 'NAME(I1)    NAME(I2)    ',
<      &        'M(I1)[M*]                 M(I2)[M*]                 ',
<      &        'EB[NB]                    ECC                       ',
<      &        'P[Days]                   SEMI[AU]                  ',
<      &        'RI[PC]                    VI[km/s]                  ',
<      &        'K*(I1)      K*(I2)      '
<       end if
---
>    50 IF (KZ(9).EQ.1) GO TO 100
>       WRITE (19,55)  TIME+TOFF, (TIME+TOFF)*TSTAR, N
>    55 FORMAT(' WIDE PAIRS    T TPHYS N ',F9.1,F7.1,I8)
218,220c180,182
<          NNB = LIST(1,I)
<          RCL2 = RB2
<          JMIN = I
---
>           NNB = LIST(1,I)
>           RCL2 = RB2
>           JMIN = I
222,223c184,185
<          DO 65 L = 2,NNB+1
<             J = LIST(L,I)
---
>           DO 65 L = 2,NNB+1
>               J = LIST(L,I)
225,280c187,229
<             IF (ABS(X(1,I) - X(1,J)).GT.RB1) GO TO 65
<             IF (ABS(X(2,I) - X(2,J)).GT.RB1) GO TO 65
<             IF (ABS(X(3,I) - X(3,J)).GT.RB1) GO TO 65
<             RIJ2 = 0.0
<             DO 60 K = 1,3
<                RIJ2 = RIJ2 + (X(K,I) - X(K,J))**2
<  60         CONTINUE
<             IF (RIJ2.LT.RCL2) THEN
<                JMIN = J
<                RCL2 = RIJ2
<             END IF
<  65      CONTINUE
<          IF (RCL2.GE.RB2) GO TO 80
<          VREL2 = 0.0
<          RDOT = 0.0
<          DO 70 K = 1,3
<             VREL2 = VREL2 + (XDOT(K,I) - XDOT(K,JMIN))**2
<             RDOT = RDOT + (X(K,I)-X(K,JMIN))*(XDOT(K,I)-XDOT(K,JMIN))
<  70      CONTINUE
<          RIJ = SQRT(RCL2)
<          ZMB = BODY(I) + BODY(JMIN)
<          SEMI = 2.0/RIJ - VREL2/ZMB
<          SEMI = 1.0/SEMI
<          IF (SEMI.GT.0.0.AND.SEMI.LT.RB1) THEN
< *     Exclude duplicates by examining current list of NEWI components.
<             DO 72 L = 1,NEWI
<                IF (I.EQ.JLIST(L).OR.JMIN.EQ.JLIST(L)) GO TO 80
<  72         CONTINUE
<             JLIST(NEWI+1) = I
<             JLIST(NEWI+2) = JMIN
<             NEWI = NEWI + 2
<             ECC2 = (1.0 - RIJ/SEMI)**2 + RDOT**2/(ZMB*SEMI)
<             ECC1 = SQRT(ECC2)
<             HB = -0.5D0*BODY(I)*BODY(JMIN)/SEMI
<             
<             TK = DAYS*SEMI*SQRT(SEMI/ZMB)
<             RI = 0.0
<             VI = 0.0
<             DO K = 1,3
<                XCM = (BODY(I)*X(K,I) + BODY(JMIN)*X(K,JMIN))/ZMB
<      &              - RDENS(K)
<                VCM = (BODY(I)*XDOT(K,I) + BODY(JMIN)*XDOT(K,JMIN))/ZMB
<                RI = RI + XCM**2
<                VI = VI + VCM**2
<             END DO
<             RI = SQRT(RI)
<             VI = SQRT(VI)
< *     Print basic binary parameters (SEMI in AU, period in years).
<             if(rank.eq.0) then
<                WRITE (19,*)  NAME(I), NAME(JMIN), BODY(I)*ZMBAR,
<      &              BODY(JMIN)*ZMBAR, HB, ECC1, TK, SEMI*RAU, RI*RBAR,
<      &              VI*VSTAR, KSTAR(I), KSTAR(JMIN)
<             end if
< * 75         FORMAT (F8.3,F9.1,1P,E9.1,0P,2F6.1,2I7,2I4)
<          END IF
<  80   CONTINUE
---
>               IF (ABS(X(1,I) - X(1,J)).GT.RB1) GO TO 65
>               IF (ABS(X(2,I) - X(2,J)).GT.RB1) GO TO 65
>               IF (ABS(X(3,I) - X(3,J)).GT.RB1) GO TO 65
>               RIJ2 = 0.0
>               DO 60 K = 1,3
>                   RIJ2 = RIJ2 + (X(K,I) - X(K,J))**2
>    60         CONTINUE
>               IF (RIJ2.LT.RCL2) THEN
>                   JMIN = J
>                   RCL2 = RIJ2
>               END IF
>    65     CONTINUE
>           IF (RCL2.GE.RB2) GO TO 80
>           VREL2 = 0.0
>           RDOT = 0.0
>           RI = 0.0
>           DO 70 K = 1,3
>               VREL2 = VREL2 + (XDOT(K,I) - XDOT(K,JMIN))**2
>               RDOT = RDOT + (X(K,I)-X(K,JMIN))*(XDOT(K,I)-XDOT(K,JMIN))
>               RI = RI + (X(K,I) - RDENS(K))**2
>    70     CONTINUE
>           RIJ = SQRT(RCL2)
>           ZMB = BODY(I) + BODY(JMIN)
>           SEMI = 2.0/RIJ - VREL2/ZMB
>           SEMI = 1.0/SEMI
>           IF (SEMI.GT.0.0.AND.SEMI.LT.RB1) THEN
> *       Exclude duplicates by examining current list of NEWI components.
>               DO 72 L = 1,NEWI
>                   IF (I.EQ.JLIST(L).OR.JMIN.EQ.JLIST(L)) GO TO 80
>    72         CONTINUE
>               JLIST(NEWI+1) = I
>               JLIST(NEWI+2) = JMIN
>               NEWI = NEWI + 2
>               ECC2 = (1.0 - RIJ/SEMI)**2 + RDOT**2/(ZMB*SEMI)
>               ECC1 = SQRT(ECC2)
>               TK = YRS*SEMI*SQRT(SEMI/ZMB)
>               RI = SQRT(RI)
> *       Print basic binary parameters (SEMI in AU, period in years).
>               WRITE (19,75)  ECC1, SEMI*RAU, TK, RI, ZMB*SMU, NAME(I),
>      &                       NAME(JMIN), KSTAR(I), KSTAR(JMIN)
>    75         FORMAT (F8.3,F9.1,1P,E9.1,0P,2F6.1,2I7,2I4)
>           END IF
>    80 CONTINUE
282,284c231,232
<       CLOSE(19)
< *     
<       RETURN
---
> *
>   100 RETURN
54c54
<           IF (RI2.LT.RC2) JC = JC + 1
---
>           IF (RI2.LT.RC22) JC = JC + 1
59c59
<               K = INT(2 + LOG10(A0/SEMI)/LOG10(2.0))
---
>               K = 2 + LOG10(A0/SEMI)/LOG10(2.0)
71c71
<           K = INT(1 + 10.0*SQRT(ECC2))
---
>           K = 1 + 10.0*SQRT(ECC2)
77c77
<               K = INT(2 + LOG10(EB/EB0)/LOG10(2.0))
---
>               K = 2 + LOG10(EB/EB0)/LOG10(2.0)
97,98c97
<               if(rank.eq.0)
<      &        WRITE (6,35)  J, LIST(1,J1), LIST(1,J2), LIST(2,J2),
---
>               WRITE (6,35)  J, LIST(1,J1), LIST(1,J2), LIST(2,J2),
112,113c111
<               if(rank.eq.0)
<      &        WRITE (18,40)  TTOT, NAME(J1), NAME(J2), LIST(2,J2), K,
---
>               WRITE (18,40)  TTOT, NAME(J1), NAME(J2), LIST(2,J2), K,
116,121c114,116
<  40           FORMAT ('Time[NB] ',1P,E16.7,0P,'  NAME(I1) ',I11,
<      &             '  NAME(I2) ',I11,'  FLAG-PB ',I3,'  FLAG-H ',I3,
<      &             '  M(I1)[NB] ',1P,E13.4,'  M(I2)[NB] ',E13.4,
<      &             '  EB[NB] ',E16.7,'  SEMI[NB] ',E15.6,'  ECC ',
<      &             E15.6,'  GX[NB] ',E13.4,'  RI[NB] ',E15.6,
<      &             '  VR[NB] ',E15.6,0P)
---
>    40         FORMAT (' T =',F7.1,'  NAME = ',2I6,2I3,'  M =',2F9.4,
>      &                       '  EB =',F10.5,'  A =',F8.5,'  E =',F5.2,
>      &                      '  GX =',F6.3,'  RI =',F6.2,'  VR =',F4.1)
141,142c136
<       if(rank.eq.0)
<      &WRITE (6,60)  JOR, JEX, DB, SBCOLL, BBCOLL, CHCOLL, JC, NCHAOS,
---
>       WRITE (6,60)  JOR, JEX, DB, SBCOLL, BBCOLL, CHCOLL, JC, NCHAOS,
150,152c144,145
<       if(rank.eq.0)
<      &WRITE (6,65)  DISP, EMAX, (NPOP(J),J=1,8), (JEB(K),K=1,KLAST)
<    65 FORMAT (' <E> =',F5.2,'  EMAX =',F7.4,'  NPOP =',I5,I3,2I6,I4,3I3,
---
>       WRITE (6,65)  DISP, EMAX, (NPOP(J),J=1,8), (JEB(K),K=1,KLAST)
>    65 FORMAT (' <E> =',F5.2,'  EMAX =',F7.4,'  NPOP =',I5,I5,2I6,I4,3I3,
172c165
<       if(rank.eq.0) WRITE (6,90)  (E(J),J=1,10), ETOT, DETOT, DEGRAV
---
>       WRITE (6,90)  (E(J),J=1,10), ETOT, DETOT, DEGRAV
8d7
< *     Safe for parallel! used variables: CM, HM, UM
14d12
< *     Unsafe for parallel!
20,21c18,19
<       IF (rank.eq.0.and.FIRST.AND.KSTART.EQ.1) THEN
< *          OPEN (UNIT=17,STATUS='UNKNOWN',FORM='FORMATTED',FILE='BINEV')
---
>       IF (FIRST) THEN
>           OPEN (UNIT=17,STATUS='NEW',FORM='FORMATTED',FILE='BINEV')
24,30c22,23
<     5     FORMAT ('Time[Myr]                 NAME(I1)    NAME(I2)    ',
<      &         'K*(I1)      K*(I2)      K*(ICM)     ',
<      &         'M(I1)[M*]                 M(I2)[M*]                 ',
<      &         'RS(I1)[R*]                RS(I2)[R*]                ',
<      &         'RI[PC]                    ECC                       ',
<      &         'SEMI[R*]                  P[days]                   ',
<      &         'IQCOLL      ',/)
---
>     5     FORMAT ('   TPHYS  NAM1  NAM2  K1  K2  KC   M1   M2     R1',
>      &            '    R2   RI    ECC    SEMI   PERIOD  C',/)
64,68c57,60
< C      P = MIN(P,99999.9D0)
< C      P = MAX(P,-1.0D0)
<       A0 = SEMI*SU
< C      A0 = MIN(SEMI*SU,9999.9D0)
< C      A0 = MAX(A0,-1.0D0)
---
>       P = MIN(P,99999.9D0)
>       P = MAX(P,-1.0D0)
>       A0 = MIN(SEMI*SU,9999.9D0)
>       A0 = MAX(A0,-1.0D0)
71,74c63,65
<       RI = SQRT(RI2)*RBAR
< C      RI = MIN(SQRT(RI2),99.9D0)
< C      R1 = MIN(R1,999.9D0)
< C      R2 = MIN(R2,999.9D0)
---
>       RI = MIN(SQRT(RI2),99.9D0)
>       R1 = MIN(R1,999.9D0)
>       R2 = MIN(R2,999.9D0)
77,78c68
<       if(rank.eq.0)then
<       WRITE (17,*)  TPHYS, NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
---
>       WRITE (17,10)  TPHYS, NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
80c70
< C   10 FORMAT (F8.1,2I6,3I4,2F5.1,F7.1,F6.1,F5.1,F7.3,F8.1,F9.1,I3)
---
>    10 FORMAT (F8.1,2I6,3I4,2F5.1,F7.1,F6.1,F5.1,F7.3,F8.1,F9.1,I3)
82d71
<       end if
30a31,47
> *       Include circularization check (otherwise unperturbed KS missed).
>       IF (KZ(27).GT.0.AND.ECC.GT.0.01) THEN
>           QPERI = SEMI*(1.0 - ECC)
>           ICIRC = -1
>           CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
>           IF (TC.LT.100.0) THEN
>               KX = MAX(KSTAR(I1),KSTAR(I2))
>               WRITE (6,3)  ICIRC, KX, ECC, QPERI*SU, TC, MAX(R1,R2)
>     3         FORMAT (' TCIRC CHECK   IC K* E QP TC R* ',2I5,1P,4E10.2)
>               CALL FLUSH(6)
>           END IF
>           IF (ICIRC.GT.0.AND.TC.LT.100.0) THEN
>               CALL KSTIDE(IPAIR,QPERI)
>               GO TO 50
>           END IF
>       END IF
> *
47c64
<       IF (rank.eq.0.and.KZ(28).GT.1.AND.DSEP.GT.0.0) THEN
---
>       IF (KZ(28).GT.1.AND.DSEP.GT.0.0) THEN
53,61c70,71
< *       Check collision condition for degenerate objects.
< *     --09/20/13 19:49-lwang-bug-fix------------------------------------*
< ***** Note:It can be seen that the second condition used N-body and
< ***** solar units which resulted in additional collisions involving BHs
< ***** when using option #28 > 0.
< *      If (RP.LE.(R1 + R2).OR.
< *     &   (KSX.GE.13.AND.R(IPAIR).LT.RCOAL)) THEN
<       IF(RP.LT.RCOAL) THEN
< *     --09/20/13 19:51-lwang-end----------------------------------------*
---
> *       Check collision condition for stars or degenerate objects.
>       IF (RP.LT.RCOAL) THEN
65c75
<          CALL CMBODY(2)
---
>          CALL CMBODY(R(IPAIR),2)
133,134c143
<             if(rank.eq.0)
<      &      WRITE (6,25)  TTOT, IPAIR, M1, M2, R1, R2, R(IPAIR),
---
>             WRITE (6,25)  TTOT, IPAIR, M1, M2, R1, R2, R(IPAIR),
128c128,132
<       SEMI1 = SEMI - ADOT*DT
---
>       IF (ADOT*DT.GT.0.1*SEMI) THEN
>           SEMI1 = 0.9*SEMI
>       ELSE
>           SEMI1 = SEMI - ADOT*DT
>       END IF
129a134,135
>       WRITE (6,71)  SEMI, SEMI1, ADOT, DT
>    71 FORMAT (' BRAKE2 !!    A A1 AD DT  ',1P,4E10.2)
173d178
<       DTMS = 0.D0
148c148
<       IF (KSX.GE.13.AND.KZ(28).GT.0) THEN
---
>       IF (KSX.GE.13) THEN
150,151d149
<       ELSE
<          RCOAL = 0.0
81,82c81
<               if(rank.eq.0)
<      &        WRITE (6,6)  NAME(I1), NCHAOS, ECC
---
>               WRITE (6,6)  NAME(I1), NCHAOS, ECC
91c90
<          J = K + 2
---
> 	  J = K + 2
98c97
<               CALL GIANT2(K,IK,WG,QG,WSCALE,QSCALE,ZN,QD)
---
>               CALL GIANT2(K,IK,WG,QG,WSCALE,QSCALE,XN,QD)
111c110
<               W(J) = WW(IP+3)
---
> 	      W(J) = WW(IP+3)
138,139c137
<               if(rank.eq.0)
<      &        WRITE (6,12)  IS(1), IS(2), M(I1), M(I2), RSTAR(1),
---
>               WRITE (6,12)  IS(1), IS(2), M(I1), M(I2), RSTAR(1),
144c142
<               KSTARI = -2
---
> 	      KSTARI = -2
163,164c161
<           if(rank.eq.0)
<      &    WRITE (6,15)  WHICH1, NAMEX(I1), NAMEX(I2), IS(1), IS(2),
---
>           WRITE (6,15)  WHICH1, NAMEX(I1), NAMEX(I2), IS(1), IS(2),
235c232
<           ZJOSC = ZJOSC + ALF(K)*EOSC(K,IC) + ALF(J)*EOSC(J,IC)
---
> 	  ZJOSC = ZJOSC + ALF(K)*EOSC(K,IC) + ALF(J)*EOSC(J,IC)
264,265c261
<           if(rank.eq.0)
<      &    WRITE (6,25)  NAMEX(I1), NAMEX(I2), NDEC, KICKS, ECC, ECC1,
---
>           WRITE (6,25)  NAMEX(I1), NAMEX(I2), NDEC, KICKS, ECC, ECC1,
272,273c268
<           if(rank.eq.0)
<      &    WRITE (6,26)  TIME+TOFF, NAMEX(I1), NAMEX(I2), ECC, ECC1,
---
>           WRITE (6,26)  TIME+TOFF, NAMEX(I1), NAMEX(I2), ECC, ECC1,
283,284c278
<               if(rank.eq.0)
<      &        WRITE (6,30)  NAMEX(I1), NAMEX(I2), NDEC, KICKS, ECC1,
---
>               WRITE (6,30)  NAMEX(I1), NAMEX(I2), NDEC, KICKS, ECC1,
302,303c296
<                       if(rank.eq.0)
<      &                WRITE (6,32)  NDEC, EPS, ECCM, ECC1
---
>                       WRITE (6,32)  NDEC, EPS, ECCM, ECC1
55,56c55,56
<          IDIS = -1
<          RETURN
---
>           IDIS = -1
> 	  RETURN
2,10c2,9
< *     
< *     
< *     Chaotic tidal interactions.
< *     ---------------------------
< *     
< *     Theory of Rosemary Mardling, Ap. J. XX, YYY, 1995.
< *     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
< *     
<       Include 'kspars.h'
---
> *
> *
> *       Chaotic tidal interactions.
> *       ---------------------------
> *
> *       Theory of Rosemary Mardling, Ap. J. XX, YYY, 1995.
> *       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
> *
12,13d10
< *     Unsafe for parallel!
< *     Update value: EB0,ZJ0,ecrit,AR,BR,eosc,edec,tosc,rp,es,cm,iosc,namec
15,17c12,14
<      &     BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
<      &     RP(NTMAX),ES(NTMAX),CM(2,NTMAX),IOSC(NTMAX),
<      &     NAMEC(NTMAX)
---
>      &               BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
>      &               RP(NTMAX),ES(NTMAX),CM(2,NTMAX),IOSC(NTMAX),
>      &               NAMEC(NTMAX)
19,20c16,17
<      &     WG(2),QG(2),WSCALE(2),QSCALE(2),A0(3),A2(3),EOSC0(2),
<      &     QL(2),TD(2)
---
>      &        WG(2),QG(2),WSCALE(2),QSCALE(2),A0(3),A2(3),EOSC0(2),
>      &        QL(2),TD(2)
24d20
< *     Unsafe for parapllel
28,30c24,26
< *     
< *     
< *     Define c.m. index and search current names for chaos index.
---
> *
> *
> *       Define c.m. index and search current names for chaos index.
35c31
<          IF (NAMEC(K).EQ.NAME(I)) IC = K
---
>           IF (NAMEC(K).EQ.NAME(I)) IC = K
37,38c33,34
< *     
< *     See whether new case could be an old SPIRAL exchanged in chain.
---
> *
> *       See whether new case could be an old SPIRAL exchanged in chain.
40,45c36,41
< *     Remove tables and re-initialize on large epoch or standard binary.
<          IF (TIME - TOSC(IC).GT.1.0.OR.KSTAR(I).EQ.0) THEN
<             II = -I
<             CALL SPIRAL(II)
<             IC = 0
<          END IF
---
> *       Remove tables and re-initialize on large epoch or standard binary.
>           IF (TIME - TOSC(IC).GT.1.0.OR.KSTAR(I).EQ.0) THEN
>               II = -I
>               CALL SPIRAL(II)
>               IC = 0
>           END IF
47,48c43,44
< *     
< *     Increase counter for new chaos and initialize index & variables.
---
> *
> *       Increase counter for new chaos and initialize index & variables.
50,76c46,70
<          NCHAOS = NCHAOS + 1
<          IC = NCHAOS
<          NAMEC(IC) = NAME(I)
<          KICKS = 0
<          NDEC = 0
<          IOSC(IC) = 0
<          KSTAR(I) = -1
< *     ks MPI communication
<          call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<          TOSC(IC) = TIME
< *     Ensure next location contains zero core mass (avoids confusion).
<          CM(1,NCHAOS+1) = 0.0
<          CM(2,NCHAOS+1) = 0.0
<          DO 5 K = 1,4
<             EOSC(K,IC) = 0.0D0
<  5       CONTINUE
<          IF (KZ(9).GE.2.AND.H(IPAIR).LT.0.0) THEN
<             CALL BINEV(IPAIR)
<          END IF
<          IF (NCHAOS.GT.NTMAX) THEN
<             if(rank.eq.0)WRITE (6,6)  NAME(I1), NCHAOS, ECC, QPERI
<  6          FORMAT (' FATAL ERROR!    CHAOS    NM NCH E QP ',
<      &           I6,I4,F8.4,1P,E9.1)
<             if(rank.eq.0)WRITE (6,7)  (NAMEC(K),K=1,NCHAOS)
<  7          FORMAT (' NAMEC  ',12I6,(/,12I6))
<             STOP
<          END IF
---
>           NCHAOS = NCHAOS + 1
>           IC = NCHAOS
>           NAMEC(IC) = NAME(I)
>           KICKS = 0
>           NDEC = 0
>           IOSC(IC) = 0
>           KSTAR(I) = -1
>           TOSC(IC) = TIME
> *       Ensure next location contains zero core mass (avoids confusion).
>           CM(1,NCHAOS+1) = 0.0
>           CM(2,NCHAOS+1) = 0.0
>           DO 5 K = 1,4
>               EOSC(K,IC) = 0.0D0
>     5     CONTINUE
>           IF (KZ(8).GT.3.AND.H(IPAIR).LT.0.0) THEN
>               CALL BINEV(IPAIR)
>           END IF
>           IF (NCHAOS.GT.NTMAX) THEN
>               WRITE (6,6)  NAME(I1), NCHAOS, ECC, QPERI
>     6         FORMAT (' FATAL ERROR!    CHAOS    NM NCH E QP ',
>      &                                           I6,I4,F8.4,1P,E9.1)
>               WRITE (6,7)  (NAMEC(K),K=1,NCHAOS)
>     7         FORMAT (' NAMEC  ',12I6,(/,12I6))
>               STOP
>           END IF
78,79c72,73
< *     
< *     Check termination for rare case of wide chaos (minimum 1000 calls).
---
> *
> *       Check termination for rare case of wide chaos (minimum 1000 calls).
82,102c76,94
< *     Activate spiral indicator and save time, pericentre & eccentricity.
<          KSTAR(I) = -2
< *     ks MPI communication
<          call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<          TOSC(IC) = TIME
<          RP(IC) = QPERI
<          ES(IC) = ECC
<          IOSC(IC) = 2
<          NSP = NSP + 1
<          SEMI = -0.5*BODY(I)/H(IPAIR)
<          if(rank.eq.0)WRITE (6,8)  NAME(I1), NAME(I2), NDEC, 
<      &        LIST(1,I1), QP, ECC, SEMI
<  8       FORMAT (' WIDE CHAOS    NAM NDEC NP QP/S E A ',
<      &        3I6,I4,F5.1,F8.4,1P,E10.2)
<          NDEC = 0
<          KICKS = 0
<          GO TO 34
<       END IF
< *     
< *     Define oscillation period (dimensionless time) and damping constants.
<       ZN = 0.0
---
> *       Activate spiral indicator and save time, pericentre & eccentricity.
>           KSTAR(I) = -2
>           TOSC(IC) = TIME
>           RP(IC) = QPERI
>           ES(IC) = ECC
>           IOSC(IC) = 2
>           NSP = NSP + 1
>           SEMI = -0.5*BODY(I)/H(IPAIR)
>           WRITE (6,8)  NAME(I1), NAME(I2), NDEC, LIST(1,I1), QP, ECC,
>      &                 SEMI
>     8     FORMAT (' WIDE CHAOS    NAM NDEC NP QP/S E A ',
>      &                            3I6,I4,F5.1,F8.4,1P,E10.2)
>           NDEC = 0
>           KICKS = 0
>           GO TO 34
>       END IF
> *
> *       Define oscillation period (dimensionless time) and damping constants.
>       XN = 0.0
105,109c97,101
<          J = K + 2
<          IK = I1 + K - 1
<          TDYN(K) = RADIUS(IK)*SQRT(RADIUS(IK)/BODY(IK))
< *     Specify polytropic index for each star (n = 2, 3 or 3/2).
<          IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
---
> 	  J = K + 2
>           IK = I1 + K - 1
>           TDYN(K) = RADIUS(IK)*SQRT(RADIUS(IK)/BODY(IK))
> *       Specify polytropic index for each star (n = 2, 3 or 3/2).
>           IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
111,132c103,124
<             CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,ZN,QD)
<             W(K) = WG(1)
<             W(J) = WG(2)
<             QL(K) = QD
<             KG(K) = 1
<          ELSE
<             QL(K) = 1.0D+04
<             KG(K) = 0
<             IP = 3
<             IF (KSTAR(IK).GE.3) IP = 2
<             IF (KSTAR(IK).EQ.4.OR.KSTAR(IK).EQ.7) IP = 3
<             IF (KSTAR(IK).EQ.8) IP = 3
<             IF (KSTAR(IK).EQ.0) IP = 1
<             W(K) = WW(IP)
<             W(J) = WW(IP+3)
<          END IF
<          ALF(K) = 2.0*TDYN(K)/SQRT(W(K))
<          ALF(J) = 3.0*TDYN(K)/SQRT(W(J))
<          TL(K) = TWOPI*TDYN(K)/SQRT(W(K))
<  10   CONTINUE
< *     
< *     Save initial eccentricity, binding energy & J0 the first time.
---
>               CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,XN,QD)
>               W(K) = WG(1)
>               W(J) = WG(2)
>               QL(K) = QD
>               KG(K) = 1
>           ELSE
>               QL(K) = 1.0D+04
>               KG(K) = 0
>               IP = 3
>               IF (KSTAR(IK).GE.3) IP = 2
>               IF (KSTAR(IK).EQ.4.OR.KSTAR(IK).EQ.7) IP = 3
>               IF (KSTAR(IK).EQ.8) IP = 3
>               IF (KSTAR(IK).EQ.0) IP = 1
>               W(K) = WW(IP)
> 	      W(J) = WW(IP+3)
>           END IF
>           ALF(K) = 2.0*TDYN(K)/SQRT(W(K))
>           ALF(J) = 3.0*TDYN(K)/SQRT(W(J))
>           TL(K) = TWOPI*TDYN(K)/SQRT(W(K))
>    10 CONTINUE
> *
> *       Save initial eccentricity, binding energy & J0 the first time.
135,173c127,143
<          SEMI = -0.5*BODY(I)/H(IPAIR)
<          ECC0 = ECC
<          EB0(IC) = ZMU*H(IPAIR)
<          ZJ0(IC) = CJ*SQRT(QPERI*(1.0 + ECC0))
<          EDEC(IC) = 0.0
<          IOSC(IC) = 1
< *     Reset diagnostic indicator for CHAOS0 (output only first time).
<          IF (NDEC.GT.0) IDIS = KSTAR(I)
< *     
< *     Initialize chaos boundary parameters (ECRIT, AR & BR).
<          CALL CHAOS0(QPERI,ECC,EB0(IC),ZJ0(IC),BODY(I1),BODY(I2),
<      &        RADIUS(I1),RADIUS(I2),W,ECRIT(IC),AR(IC),BR(IC),IDIS)
< *     
< *     Begin spiralling stage if chaos boundary has been crossed.
<          IF (IDIS.EQ.-1) THEN
< *     Include safety check on skipping rare case of hyperbolic orbit.
<             IF (ECC.GT.1.0) THEN
<                NCHAOS = NCHAOS - 1
<                KSTAR(I) = 0
< *     ks MPI communication
<                call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<                GO TO 80
<             END IF
< *     Restrict tidal circularization to short time-scales (< 100 Myr).
<             ICIRC = -1
<             CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
<             IF (TC.GT.100.0) THEN
<                NCHAOS = NCHAOS - 1
<                KSTAR(I) = 0
< *     ks MPI communication
<                call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<                GO TO 80
<             END IF
< *     Skip initialization for difficult hierarchy and small EMAX.
<             IF (LIST(1,I1).EQ.1) THEN
<                ICIRC = -1
<                J1 = LIST(2,I1)
<                CALL INDUCE(IPAIR,J1,EMAX,EMIN,ICIRC,TC,ANGLE,TG,EDAV)
<                IF (EMAX.LT.0.9) THEN
---
>           SEMI = -0.5*BODY(I)/H(IPAIR)
>           ECC0 = ECC
>           EB0(IC) = ZMU*H(IPAIR)
>           ZJ0(IC) = CJ*SQRT(QPERI*(1.0 + ECC0))
>           EDEC(IC) = 0.0
>           IOSC(IC) = 1
> *       Reset diagnostic indicator for CHAOS0 (output only first time).
>           IF (NDEC.GT.0) IDIS = KSTAR(I)
> *
> *       Initialize chaos boundary parameters (ECRIT, AR & BR).
>           CALL CHAOS0(QPERI,ECC,EB0(IC),ZJ0(IC),BODY(I1),BODY(I2),
>      &             RADIUS(I1),RADIUS(I2),W,ECRIT(IC),AR(IC),BR(IC),IDIS)
> *
> *       Begin spiralling stage if chaos boundary has been crossed.
> 	  IF (IDIS.EQ.-1) THEN
> *       Include safety check on skipping rare case of hyperbolic orbit.
>               IF (ECC.GT.1.0) THEN
176,177d145
< *     ks MPI communication
<                   call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
179,229c147,211
<                END IF
<             END IF
<             IOSC(IC) = 2
<             if(rank.eq.0)
<      &           WRITE (6,12)  TTOT, NAME(I1), NAME(I2), KSTAR(I1),
<      &           KSTAR(I2), LIST(1,I1), BODY(I1)*ZMBAR,
<      &           BODY(I2)*ZMBAR, RADIUS(I1)*SU,
<      &           RADIUS(I2)*SU, QPERI, SEMI, ECC, ZN, QD
<  12         FORMAT (' NEW SPIRAL    T NM K* NP M1 M2 R* QP A E n Q ',
<      &           F9.2,2I6,3I3,2F5.1,2F6.1,
<      &           1P,2E10.2,0P,F7.3,F5.1,F7.1)
< *     Activate spiral indicator and save time, pericentre & eccentricity.
<             KSTAR(I) = -2
< *     ks MPI communication
<             call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<             TOSC(IC) = TIME
<             RP(IC) = QPERI
<             ES(IC) = ECC0
<             NSP = NSP + 1
< *     Rectify the KS solution on transition to standard circularization.
<             CALL KSRECT(IPAIR)
< *     Initialize perturbed KS (small STEP after integration in KSPERI).
<             IF (LIST(1,I1).GT.0) THEN
<                IMOD = 1
<                CALL KSPOLY(IPAIR,IMOD)
<                KSLOW(IPAIR) = 1
<             END IF
<             GO TO 34
<          END IF
< *     
< *     Reduce chaos index on disruption if current case is last.
<          IF (IDIS.GT.0.AND.IC.EQ.NCHAOS) THEN
<             NCHAOS = NCHAOS - 1
<             GO TO 80
<          END IF
< *     
< *     Print NEW CHAOS/CAPTURE the first time.
<          IF (NDEC.EQ.0) THEN
<             NCHA = NCHA + 1
<             WHICH1 = ' CHAOS  '
<             IF (SEMI.LT.0.0) WHICH1 = ' CAPTURE'
<             GA = GAMMA(IPAIR)*(RMIN/RKS)**3
<             if(rank.eq.0)
<      &           WRITE (6,15)  WHICH1, TTOT, NAME(I1), NAME(I2), 
<      &           KSTAR(I1), KSTAR(I2), LIST(1,I1), BODY(I1)*ZMBAR,
<      &           BODY(I2)*ZMBAR, RADIUS(I1)*SU,
<      &           RADIUS(I2)*SU, QPERI, SEMI, ECC, GA, ZN, QD
<  15         FORMAT (' NEW',A8,'  T NM K* NP M1 M2 R* QP A E G n Q ',
<      &           F9.2,2I6,3I3,2F5.1,2F6.1,1P,2E10.2,
<      &           0P,F9.5,F7.3,F5.1,F7.1)
<          END IF
---
>               END IF
> *       Restrict tidal circularization to short time-scales (< 100 Myr).
>               ICIRC = -1
>               CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
>               IF (TC.GT.100.0) THEN
>                   NCHAOS = NCHAOS - 1
>                   KSTAR(I) = 0
>                   GO TO 80
>               END IF
> *       Skip initialization for difficult hierarchy and small EMAX.
>               IF (LIST(1,I1).EQ.1) THEN
>                   ICIRC = -1
>                   JCL = LIST(2,I1)
>                  CALL INDUCE(IPAIR,JCL,EMAX,EMIN,ICIRC,TC,ANGLE,TG,EDAV)
>                   IF (EMAX.LT.0.9) THEN
>                       NCHAOS = NCHAOS - 1
>                       KSTAR(I) = 0
>                       GO TO 80
>                   END IF
>               END IF
>               IOSC(IC) = 2
>               WRITE (6,12)  TTOT, NAME(I1), NAME(I2), KSTAR(I1),
>      &                      KSTAR(I2), LIST(1,I1), BODY(I1)*ZMBAR,
>      &                      BODY(I2)*ZMBAR, RADIUS(I1)*SU,
>      &                      RADIUS(I2)*SU, QPERI, SEMI, ECC, XN, QD
>    12         FORMAT (' NEW SPIRAL    T NM K* NP M1 M2 R* QP A E n Q ',
>      &                                F9.2,2I6,3I3,2F5.1,2F6.1,
>      &                                1P,2E10.2,0P,F7.3,F5.1,F7.1)
> *       Activate spiral indicator and save time, pericentre & eccentricity.
>               KSTAR(I) = -2
>               TOSC(IC) = TIME
>               RP(IC) = QPERI
> 	      ES(IC) = ECC0
>               NSP = NSP + 1
> *       Rectify the KS solution on transition to standard circularization.
>               CALL KSRECT(IPAIR)
> *       Initialize perturbed KS (small STEP after integration in KSPERI).
>               IF (LIST(1,I1).GT.0) THEN
>                   IMOD = 1
>                   CALL KSPOLY(IPAIR,IMOD)
>                   KSLOW(IPAIR) = 1
>               END IF
>               GO TO 34
>           END IF
> *
> *       Reduce chaos index on disruption if current case is last.
>           IF (IDIS.GT.0.AND.IC.EQ.NCHAOS) THEN
>               NCHAOS = NCHAOS - 1
>               GO TO 80
>           END IF
> *
> *       Print NEW CHAOS/CAPTURE the first time.
>           IF (NDEC.EQ.0) THEN
>               NCHA = NCHA + 1
>               WHICH1 = ' CHAOS  '
>               IF (SEMI.LT.0.0) WHICH1 = ' CAPTURE'
>               GA = GAMMA(IPAIR)*(RMIN/RKS)**3
>               WRITE (6,15)  WHICH1, TTOT, NAME(I1), NAME(I2), KSTAR(I1),
>      &                      KSTAR(I2), LIST(1,I1), BODY(I1)*ZMBAR,
>      &                      BODY(I2)*ZMBAR, RADIUS(I1)*SU,
>      &                      RADIUS(I2)*SU, QPERI, SEMI, ECC, GA, XN, QD
>    15         FORMAT (' NEW',A8,'  T NM K* NP M1 M2 R* QP A E G n Q ',
>      &                             F9.2,2I6,3I3,2F5.1,2F6.1,1P,2E10.2,
>      &                             0P,F9.5,F7.3,F5.1,F7.1)
>           END IF
231,232c213,214
< *     
< *     Obtain energy dissipation from separate modes.
---
> *
> *       Obtain energy dissipation from separate modes.
234,236c216,218
<      &     KG,WSCALE,QSCALE,DE2,DE3)
< *     
< *     Employ an emergency procedure for zero energy change (TIDES2 bug).
---
>      &                                         KG,WSCALE,QSCALE,DE2,DE3)
> *
> *       Employ an emergency procedure for zero energy change (TIDES2 bug).
238,243c220,228
<          EB = BODYM*H(IPAIR)
<          DE2(1) = -0.001*EB*RAN2(IDUM)
<          DE2(2) = -0.001*EB*RAN2(IDUM)
<       END IF
< *     
< *     Evaluate time-scale for Kochanek-type damping (linear & non-linear).
---
>           EB = BODYM*H(IPAIR)
>           DE2(1) = -0.001*EB*RAN2(IDUM)
>           DE2(2) = -0.001*EB*RAN2(IDUM)
>       END IF
> *
> *       Exit for circular orbit (possible mass loss problem).
>       IF (ECC.LE.0.002) GO TO 80
> *
> *       Evaluate time-scale for Kochanek-type damping (linear & non-linear).
248c233
< *     Adopt non-linear dissipation time scale of Kumar & Goodman 1995.
---
> *       Adopt non-linear dissipation time scale of Kumar & Goodman 1995.
256c241
< *     
---
> *
259,262c244,247
<          DO 18 K = 1,2
<             DE2(K) = 1000.0*DE2(K)
<             DE3(K) = 1000.0*DE3(K)
<  18      CONTINUE
---
>           DO 18 K = 1,2
>               DE2(K) = 1000.0*DE2(K)
>               DE3(K) = 1000.0*DE3(K)
>    18     CONTINUE
264c249
< *     Sum old and new oscillation energies for all modes.
---
> *       Sum old and new oscillation energies for all modes.
271,300c256,285
<          J = K + 2
<          AT(K) = -TD(K)/TL(K)
<          E20 = E20 + EOSC(K,IC)
<          E30 = E30 + EOSC(J,IC)
<          EOSC(K,IC) = EOSC(K,IC)*EXP(AT(K))
<          EOSC(J,IC) = EOSC(J,IC)*EXP(AT(K))
<          EDEC(IC) = EDEC(IC) - (EOSC(K,IC) + EOSC(J,IC))
<          IF (IOSC(IC).EQ.-1) THEN
<             DELTA = 0.5*TWOPI
<          ELSE
<             DELTA = TWOPI*RAN2(IDUM1)
<          END IF
<          EOSC(K,IC) = EOSC(K,IC) +
<      &        2.0*SQRT(EOSC(K,IC)*DE2(K))*COS(DELTA) + DE2(K)
<          IF (IOSC(IC).EQ.-1) THEN
<             IF (K.EQ.2) IOSC(IC) = 1
<          ELSE
<             DELTA = TWOPI*RAN2(IDUM1)
<          END IF
<          EOSC(J,IC) = EOSC(J,IC) +
<      &        2.0*SQRT(EOSC(J,IC)*DE3(K))*COS(DELTA) + DE3(K)
< *     Ensure that oscillation energies are not negative.
<          EOSC(K,IC) = MAX(EOSC(K,IC),0.0D0)
<          EOSC(J,IC) = MAX(EOSC(J,IC),0.0D0)
<          E2T = E2T + EOSC(K,IC)
<          E3T = E3T + EOSC(J,IC)
<          ZJOSC = ZJOSC + ALF(K)*EOSC(K,IC) + ALF(J)*EOSC(J,IC)
<  20   CONTINUE
< *     
< *     Specify change in oscillation energy and sum decayed energy.
---
>           J = K + 2
>           AT(K) = -TD(K)/TL(K)
>           E20 = E20 + EOSC(K,IC)
>           E30 = E30 + EOSC(J,IC)
>           EOSC(K,IC) = EOSC(K,IC)*EXP(AT(K))
>           EOSC(J,IC) = EOSC(J,IC)*EXP(AT(K))
>           EDEC(IC) = EDEC(IC) - (EOSC(K,IC) + EOSC(J,IC))
>           IF (IOSC(IC).EQ.-1) THEN
>               DELTA = 0.5*TWOPI
>           ELSE
>               DELTA = TWOPI*RAN2(IDUM1)
>           END IF
>           EOSC(K,IC) = EOSC(K,IC) +
>      &                2.0*SQRT(EOSC(K,IC)*DE2(K))*COS(DELTA) + DE2(K)
>           IF (IOSC(IC).EQ.-1) THEN
>               IF (K.EQ.2) IOSC(IC) = 1
>           ELSE
>               DELTA = TWOPI*RAN2(IDUM1)
>           END IF
>           EOSC(J,IC) = EOSC(J,IC) +
>      &                 2.0*SQRT(EOSC(J,IC)*DE3(K))*COS(DELTA) + DE3(K)
> *       Ensure that oscillation energies are not negative.
>           EOSC(K,IC) = MAX(EOSC(K,IC),0.0D0)
>           EOSC(J,IC) = MAX(EOSC(J,IC),0.0D0)
>           E2T = E2T + EOSC(K,IC)
>           E3T = E3T + EOSC(J,IC)
> 	  ZJOSC = ZJOSC + ALF(K)*EOSC(K,IC) + ALF(J)*EOSC(J,IC)
>    20 CONTINUE
> *
> *       Specify change in oscillation energy and sum decayed energy.
304,305c289,290
< *     
< *     Set new binding energy & semi-major axis.
---
> *
> *       Set new binding energy & semi-major axis.
309,310c294,295
< *     
< *     Calculate the new eccentricity.
---
> *
> *       Calculate the new eccentricity.
316,317c301,302
< *     
< *     Switch off chaos indicator on transition to hyperbolic orbit.
---
> *
> *       Switch off chaos indicator on transition to hyperbolic orbit.
319,329c304,313
<          KSTAR(I) = 0
< *     Reduce index if current case is last (otherwise updated in KSTERM).
<          IF (IC.EQ.NCHAOS) THEN
<             NCHAOS = NCHAOS - 1
<          END IF
<          if(rank.eq.0)
<      &        WRITE (6,25)  IPAIR, NDEC, KICKS, ECC, ECC1, SEMI1, QPERI,
<      &        HNEW - HI
<  25      FORMAT (' TERMINATED CHAOS    IPAIR NDEC KICK E E1 A1 QP DH ',
<      &        3I4,2F9.5,1P,3E10.2)
<          GO TO 80
---
>           KSTAR(I) = 0
> *       Reduce index if current case is last (otherwise updated in KSTERM).
>           IF (IC.EQ.NCHAOS) THEN
>               NCHAOS = NCHAOS - 1
>           END IF
>           WRITE (6,25)  IPAIR, NDEC, KICKS, ECC, ECC1, SEMI1, QPERI,
>      &                  HNEW - HI
>    25     FORMAT (' TERMINATED CHAOS    IPAIR NDEC KICK E E1 A1 QP DH ',
>      &                                  3I4,2F9.5,1P,3E10.2)
>           GO TO 80
331,332c315,316
< *     
< *     Update total energy loss due to change in binding energy.
---
> *
> *       Update total energy loss due to change in binding energy.
339,344c323,324
< *     ks MPI communication ECOLL EGRAV E(10)
<       call ksparmpi(K_store,K_real8,K_ECOLL,0,0,DEB)
<       call ksparmpi(K_store,K_real8,K_EGRAV,0,0,DEB)
<       call ksparmpi(K_store,K_real8,K_E10,0,0,DEB)
< *     
< *     Check energy or eccentricity criterion for chaotic case.
---
> *
> *       Check energy or eccentricity criterion for chaotic case.
346,433c326,410
<          IF (EDEC(IC).GT.-(ECRIT(IC) - EB0(IC))) THEN
<             IOSC(IC) = 2
<             if(rank.eq.0)
<      &           WRITE (6,30)  TTOT, NAME(I1), NAME(I2), NDEC, KICKS,
<      &           ECC1, SEMI1, ECRIT(IC), EDEC(IC)
<  30         FORMAT (' END CHAOS    T NM NDEC KICKS E A ECRIT EDEC ',
<      &           F9.2,4I6,F8.4,1P,3E10.2)
< *     Activate spiral indicator and save time, pericentre & eccentricity.
<             KSTAR(I) = -2
<             TOSC(IC) = TIME
<             RP(IC) = PERI1
<             ES(IC) = ECC1
<             NSP = NSP + 1
<             NDEC = 0
<             KICKS = 0
<          ELSE
<             EPS = (2.0*ECRIT(IC) - EB0(IC) + EDEC(IC))/(ZMU*BODY(I))
<             ECCM = (1.0 + EPS*BR(IC))/(1.0 - EPS*AR(IC))
<             IF (ECC1.LT.ECCM) THEN
<                IOSC(IC) = -1
<                KICKS = KICKS + 1
<                IF (KICKS.LT.3) THEN
<                   if(rank.eq.0)WRITE (6,32)  NDEC, EPS, ECCM, ECC1
<  32               FORMAT (' NEW CHAOS KICK     NDEC EPS ECCM E ',
<      &                 I5,1P,E10.2,0P,2F8.4)
<                END IF
<             END IF
<          END IF
<       END IF
< *     
< *     Check for hierarchical configuration on first call.
<  34   IF (NDEC.LE.1.AND.SEMI.GT.0.0.AND.SEMI.LT.2.0*RMIN) THEN
<          NP1 = LIST(1,I1) + 1
<          DO 39 L = 2,NP1
<             J = LIST(L,I1)
<             RIJ2 = 0.0
<             VIJ2 = 0.0
<             RDOT = 0.0
<             A12 = 0.0
<             A22 = 0.0
<             A1A2 = 0.0
<             DO 35 K = 1,3
<                RIJ2 = RIJ2 + (X(K,I) - X(K,J))**2
<                VIJ2 = VIJ2 + (XDOT(K,I) - XDOT(K,J))**2
<                RDOT = RDOT + (X(K,I) - X(K,J))*(XDOT(K,I) -XDOT(K,J))
<                K1 = K + 1
<                IF (K1.GT.3) K1 = 1
<                K2 = K1 + 1
<                IF (K2.GT.3) K2 = 1
<                A0(K) = (X(K1,I1)-X(K1,I2))*(XDOT(K2,I1)-XDOT(K2,I2))
<      &              - (X(K2,I1)-X(K2,I2))*(XDOT(K1,I1)-XDOT(K1,I2))
<                A2(K) = (X(K1,J) - X(K1,I))*(XDOT(K2,J) - XDOT(K2,I))
<      &              - (X(K2,J) - X(K2,I))*(XDOT(K1,J) - XDOT(K1,I))
<                A12 = A12 + A0(K)**2
<                A22 = A22 + A2(K)**2
<                A1A2 = A1A2 + A0(K)*A2(K)
<  35         CONTINUE
<             RIP = SQRT(RIJ2)
<             A1 = 2.0/RIP - VIJ2/(BODY(I) + BODY(J))
<             A1 = 1.0/A1
< *     Include impact parameter test for recoil check.
<             A4 = RDOT**2/(A1*(BODY(I) + BODY(J)))
<             ECCP = SQRT((1.0D0 - RIP/A1)**2 + A4)
<             PMIN = A1*(1.0D0 - ECCP)
<             IF (PMIN.LT.3.0*SEMI) THEN
<                TM = MIN(TEV(I1),TEV(I2)) - TIME
<                if(rank.eq.0)
<      &              WRITE (6,36)  IPAIR, NAME(J), ECCP, PMIN/SEMI,
<      &              RDOT/RIP, SEMI, A1, RIP, TM
<  36            FORMAT (' RECOIL:    KS NMJ E1 PM/A RD A0 A1 RP TM ',
<      &              I4,I6,F7.3,F5.1,F6.1,1P,4E10.2)
<             END IF
< *     Accept semi-major axis ratio below 25.
<             IF (1.0/A1.GT.0.04/SEMI.AND.IDIS.LE.0) THEN
<                RA = SEMI*(1.0 + ECC)
<                SR = PMIN/RA
<                GA = 2.0*BODY(J)*(RA/PMIN)**3/BODY(I)
< *     Determine inclination (8 bins of 22.5 degrees).
<                FAC = A1A2/SQRT(A12*A22)
<                FAC = ACOS(FAC)
<                IN = INT(1 + FAC*360.0/(TWOPI*22.5))
<                if(rank.eq.0)
<      &              WRITE (6,38)  IPAIR, NAME(J), H(IPAIR), SEMI, A1,
<      &              PMIN, GA, ECCP, SR, IN
<  38            FORMAT (' HIERARCHY:    KS NMJ H A0 A1 RP GA E1 SR ',
<      &              'IN',I5,I6,F7.0,1P,3E9.1,0P,2F6.2,F6.1,I3)
<             END IF
<  39      CONTINUE
---
>           IF (EDEC(IC).GT.-(ECRIT(IC) - EB0(IC))) THEN
>               IOSC(IC) = 2
>               WRITE (6,30)  TTOT, NAME(I1), NAME(I2), NDEC, KICKS,
>      &                      ECC1, SEMI1, ECRIT(IC), EDEC(IC)
>    30         FORMAT (' END CHAOS    T NM NDEC KICKS E A ECRIT EDEC ',
>      &                               F9.2,4I6,F8.4,1P,3E10.2)
> *       Activate spiral indicator and save time, pericentre & eccentricity.
>               KSTAR(I) = -2
>               TOSC(IC) = TIME
>               RP(IC) = PERI1
>               ES(IC) = ECC1
>               NSP = NSP + 1
>               NDEC = 0
>               KICKS = 0
>           ELSE
>               EPS = (2.0*ECRIT(IC) - EB0(IC) + EDEC(IC))/(ZMU*BODY(I))
>               ECCM = (1.0 + EPS*BR(IC))/(1.0 - EPS*AR(IC))
>               IF (ECC1.LT.ECCM) THEN
>                   IOSC(IC) = -1
>                   KICKS = KICKS + 1
>                   IF (KICKS.LT.3) THEN
>                       WRITE (6,32)  NDEC, EPS, ECCM, ECC1
>    32                 FORMAT (' NEW CHAOS KICK     NDEC EPS ECCM E ',
>      &                                             I5,1P,E10.2,0P,2F8.4)
>                   END IF
>               END IF
>           END IF
>       END IF
> *
> *       Check for hierarchical configuration on first call.
>    34 IF (NDEC.LE.1.AND.SEMI.GT.0.0.AND.SEMI.LT.2.0*RMIN) THEN
>           NP1 = LIST(1,I1) + 1
>           DO 39 L = 2,NP1
>               J = LIST(L,I1)
>               RIJ2 = 0.0
>               VIJ2 = 0.0
>               RDOT = 0.0
>               A12 = 0.0
>               A22 = 0.0
>               A1A2 = 0.0
>               DO 35 K = 1,3
>                   RIJ2 = RIJ2 + (X(K,I) - X(K,J))**2
>                   VIJ2 = VIJ2 + (XDOT(K,I) - XDOT(K,J))**2
>                   RDOT = RDOT + (X(K,I) - X(K,J))*(XDOT(K,I) -XDOT(K,J))
>                   K1 = K + 1
>                   IF (K1.GT.3) K1 = 1
>                   K2 = K1 + 1
>                   IF (K2.GT.3) K2 = 1
>                   A0(K) = (X(K1,I1)-X(K1,I2))*(XDOT(K2,I1)-XDOT(K2,I2))
>      &                  - (X(K2,I1)-X(K2,I2))*(XDOT(K1,I1)-XDOT(K1,I2))
>                   A2(K) = (X(K1,J) - X(K1,I))*(XDOT(K2,J) - XDOT(K2,I))
>      &                  - (X(K2,J) - X(K2,I))*(XDOT(K1,J) - XDOT(K1,I))
>                   A12 = A12 + A0(K)**2
>                   A22 = A22 + A2(K)**2
>                   A1A2 = A1A2 + A0(K)*A2(K)
>    35         CONTINUE
>               RIP = SQRT(RIJ2)
>               A1 = 2.0/RIP - VIJ2/(BODY(I) + BODY(J))
>               A1 = 1.0/A1
> *       Include impact parameter test for recoil check.
>               A4 = RDOT**2/(A1*(BODY(I) + BODY(J)))
>               ECCP = SQRT((1.0D0 - RIP/A1)**2 + A4)
>               PMIN = A1*(1.0D0 - ECCP)
>               IF (PMIN.LT.3.0*SEMI) THEN
>                   TM = MIN(TEV(I1),TEV(I2)) - TIME
>                   WRITE (6,36)  IPAIR, NAME(J), ECCP, PMIN/SEMI,
>      &                          RDOT/RIP, SEMI, A1, RIP, TM
>    36             FORMAT (' RECOIL:    KS NMJ E1 PM/A RD A0 A1 RP TM ',
>      &                                 I4,I6,F7.3,F5.1,F6.1,1P,4E10.2)
>               END IF
> *       Accept semi-major axis ratio below 25.
>               IF (1.0/A1.GT.0.04/SEMI.AND.IDIS.LE.0) THEN
>                   RA = SEMI*(1.0 + ECC)
>                   SR = PMIN/RA
>                   GA = 2.0*BODY(J)*(RA/PMIN)**3/BODY(I)
> *       Determine inclination (8 bins of 22.5 degrees).
>                   FAC = A1A2/SQRT(A12*A22)
>                   FAC = ACOS(FAC)
>                   IN = 1 + FAC*360.0/(TWOPI*22.5)
>                   WRITE (6,38)  IPAIR, NAME(J), H(IPAIR), SEMI, A1,
>      &                          PMIN, GA, ECCP, SR, IN
>    38             FORMAT (' HIERARCHY:    KS NMJ H A0 A1 RP GA E1 SR ',
>      &                        'IN',I5,I6,F7.0,1P,3E9.1,0P,2F6.2,F6.1,I3)
>               END IF
>    39     CONTINUE
435,436c412,413
< *     
< *     Check for terminated or escaped chaotic binaries first time.
---
> *
> *       Check for terminated or escaped chaotic binaries first time.
438,486c415,463
<          J = 1
< *     See whether case #J indicates current or escaped/disrupted KS binary.
<  40      DO 45 JPAIR = 1,NPAIRS
<             IF (NAMEC(J).EQ.NAME(N+JPAIR)) THEN
< *     Update #J if KSTAR > 0, otherwise consider next member.
<                IF (KSTAR(N+JPAIR).GT.0) THEN
<                   GO TO 50
<                ELSE
<                   GO TO 70
<                END IF
<             END IF
<  45      CONTINUE
< *     
< *     Skip during mergers or multiple regularizations (KSTAR not visible).
<          IF (NMERGE.GT.0.OR.NSUB.GT.0) GO TO 70
< *     
< *     Update chaos variables for #IC and any disrupted or escaped binaries.
<  50      NCHAOS = NCHAOS - 1
<          DO 60 L = J,NCHAOS
<             L1 = L + 1
<             DO 55 K = 1,4
<                EOSC(K,L) = EOSC(K,L1)
<  55         CONTINUE
<             EB0(L) = EB0(L1)
<             ZJ0(L) = ZJ0(L1)
<             ECRIT(L) = ECRIT(L1)
<             AR(L) = AR(L1)
<             BR(L) = BR(L1)
<             EDEC(L) = EDEC(L1)
<             TOSC(L) = TOSC(L1)
<             RP(L) = RP(L1)
<             ES(L) = ES(L1)
<             CM(1,L) = CM(1,L1)
<             CM(2,L) = CM(2,L1)
<             IOSC(L) = IOSC(L1)
<             NAMEC(L) = NAMEC(L1)
<  60      CONTINUE
< *     Consider the same location again after each removal (J <= NCHAOS).
<          J = J - 1
<  70      J = J + 1
<          IF (J.LE.NCHAOS) GO TO 40
<       END IF
< *     
< *     Check optional binary diagnostics on transition from chaotic state.
<  80   IF (KZ(9).GE.2.AND.KSTAR(I).NE.-1) THEN
< *     Skip output for unperturbed case (CALL KSTIDE from UNPERT).
<          IF (LIST(1,I1).GT.0.AND.H(IPAIR).LT.0.0) THEN
<             CALL BINEV(IPAIR)
<          END IF
---
>           J = 1
> *       See whether case #J indicates current or escaped/disrupted KS binary.
>    40     DO 45 JPAIR = 1,NPAIRS
>               IF (NAMEC(J).EQ.NAME(N+JPAIR)) THEN
> *       Update #J if KSTAR > 0, otherwise consider next member.
>                   IF (KSTAR(N+JPAIR).GT.0) THEN
>                       GO TO 50
>                   ELSE
>                       GO TO 70
>                   END IF
>               END IF
>    45     CONTINUE
> *
> *       Skip during mergers or multiple regularizations (KSTAR not visible).
>           IF (NMERGE.GT.0.OR.NSUB.GT.0) GO TO 70
> *
> *       Update chaos variables for #IC and any disrupted or escaped binaries.
>    50     NCHAOS = NCHAOS - 1
>           DO 60 L = J,NCHAOS
>               L1 = L + 1
>               DO 55 K = 1,4
>                   EOSC(K,L) = EOSC(K,L1)
>    55         CONTINUE
>               EB0(L) = EB0(L1)
>               ZJ0(L) = ZJ0(L1)
>               ECRIT(L) = ECRIT(L1)
>               AR(L) = AR(L1)
>               BR(L) = BR(L1)
>               EDEC(L) = EDEC(L1)
>               TOSC(L) = TOSC(L1)
>               RP(L) = RP(L1)
>               ES(L) = ES(L1)
>               CM(1,L) = CM(1,L1)
>               CM(2,L) = CM(2,L1)
>               IOSC(L) = IOSC(L1)
>               NAMEC(L) = NAMEC(L1)
>    60     CONTINUE
> *       Consider the same location again after each removal (J <= NCHAOS).
>           J = J - 1
>    70     J = J + 1
>           IF (J.LE.NCHAOS) GO TO 40
>       END IF
> *
> *       Check optional binary diagnostics on transition from chaotic state.
>    80 IF (KZ(8).GT.3.AND.KSTAR(I).NE.-1) THEN
> *       Skip output for unperturbed case (CALL KSTIDE from UNPERT).
>           IF (LIST(1,I1).GT.0.AND.H(IPAIR).LT.0.0) THEN
>               CALL BINEV(IPAIR)
>           END IF
488c465
< *     
---
> *
490c467
< *     
---
> *
1c1
<       SUBROUTINE CMBODY(NSYS)
---
>       SUBROUTINE CMBODY(ENERGY,NSYS)
20,26d19
<       call xbpredall
< *     --12/29/13 22:37-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$      print*,rank,time,'Call cmbody!!'
< c$$$      call flush(6)
< c$$$      call abort()
< *     --12/29/13 22:37-lwang-end----------------------------------------*
41,44d33
< *          CALL JPRED(I,TIME,TIME)
< *     --12/13/13 10:49-lwang-update-------------------------------------*
< ***** Note: From sverre code Sep.4,2013, More accurate dt
< *          DT = 0.1*STEP(I)
46,56c35,42
< *     --12/13/13 10:49-lwang-end----------------------------------------*
< *         Suppress the TIME determination to fix TIME = TBLOCK
< c$$$          IF (DT.GT.2.4E-11) THEN
< c$$$              TIME2 = TIME - TPREV
< c$$$              CALL STEPK(DT,DTN)
< c$$$              TIME = TPREV + INT((TIME2 + DT)/DTN)*DTN
< c$$$              TIME = MIN(TBLOCK,TIME)
< c$$$          ELSE
< c$$$              TIME = MIN(T0(I) + STEP(I),TBLOCK)
< c$$$          END IF
<           TIME = TBLOCK
---
>           IF (DT.GT.2.4E-11) THEN
>               TIME2 = TIME - TPREV
>               CALL STEPK(DT,DTN)
>               TIME = TPREV + INT((TIME2 + DT)/DTN)*DTN
>               TIME = MIN(TBLOCK,TIME)
>           ELSE
>               TIME = MIN(T0(I) + STEP(I),TBLOCK)
>           END IF
68d53
< *              CALL JPRED(J,TIME,TIME)
106,107c91
<                   if(rank.eq.0)
<      &            WRITE (6,4)  KSPAIR, NAME(J), H(KSPAIR), ECC, SEMI,
---
>                   WRITE (6,4)  KSPAIR, NAME(J), H(KSPAIR), ECC, SEMI,
134c118
<           IF (rank.eq.0.and.RX.LT.20.0*RMIN) THEN
---
>           IF (RX.LT.20.0*RMIN) THEN
147,148c131
<                   if(rank.eq.0)
<      &            WRITE (6,6)  NAM1, NAM2, LISTD(K), K
---
>                   WRITE (6,6)  NAM1, NAM2, LISTD(K), K
176,187c159,167
< *     --12/13/13 10:50-lwang-update-------------------------------------*
< ***** Note: From Sverre Sep.4,2013 (suppressed)------------------------**
< *     PreMS collision scheme: -1, -1 ==> -1; -1, 0 ==> -1; -1, x ==> x.
<               ICASE = KTYPE(K1,K2)
< c$$$             IF (K1.LT.0.OR.K2.LT.0) THEN
< c$$$                 ICASE = -1
< c$$$                 IF (MAX(K1,K2).EQ.0) ICASE = -1
< c$$$                 IF (MAX(K1,K2).GT.0) ICASE = MAX(K1,K2)
< c$$$             ELSE
< c$$$                 ICASE = KTYPE(K1,K2)
< c$$$             END IF
< *     --12/13/13 10:51-lwang-end-update---------------------------------*
---
> *       PreMS collision scheme: -1, -1 ==> -1; -1, 0 ==> -1; -1, x ==> x.
>               IF (K1.LT.0.OR.K2.LT.0) THEN
>                   ICASE = -1
>                   IF (MAX(K1,K2).EQ.0) ICASE = -1
>                   IF (MAX(K1,K2).GT.0) ICASE = MAX(K1,K2)
>               ELSE
>                   ICASE = KTYPE(K1,K2)
>                   IF (MAX(K1,K2).EQ.14) ICASE = 200
>               END IF
201,202d180
< *       Remove from NXTLST
<               call delay_remove_tlist(JCL,STEP,DTK)
204,205d181
< *       Add to NLSTDELAY
<               call delay_store_tlist(JCL)
213c189
<           IF(KZ(9).GE.3.AND.MAX(KSTAR(I1),KSTAR(I2)).GE.10)THEN
---
>           IF(KZ(8).GT.3.AND.MAX(KSTAR(I1),KSTAR(I2)).GE.10)THEN
220c196
<           IF (KZ(9).GE.2) THEN
---
>           IF (KZ(8).GT.3) THEN
237,238d212
< *       Remove from NXTLST
< C          call delay_remove_tlist(I1,STEP,DTK)
240,241d213
< *       Add to NLSTDELAY
< C          call delay_store_tlist(I1)
258c230,233
<           ECC = 1.0 + 2.0*EBS*DMINC/(BODY(I1)*BODY(I2))
---
>           DMINC = MIN(DMINC,RCOLL)
>           SEMI = -0.5*BODY(I1)*BODY(I2)/EBS
> *       Note the QUAD common also used for TRIPLE.
>           ECC = 1.0 - RCOLL4/SEMI
274,280c249
< *     --12/13/13 10:54-lwang-update-------------------------------------*
< ***** Note: From Sverre Sep.4. 2013------------------------------------**
< c$$$              ECC = 1.0 + 2.0*EBS*DMINC/(BODY(I1)*BODY(I2))
< c$$$              ECC = MAX(ECC,0.0D0)
< *     --12/13/13 10:54-lwang-end----------------------------------------*
<               if(rank.eq.0)
<      &        WRITE (86,9)  TPHYS, NAME(I1), NAME(I2), KSTAR(I1),
---
>               WRITE (86,9)  TPHYS, NAME(I1), NAME(I2), KSTAR(I1),
307,308c276
<                           if(rank.eq.0)
<      &                    WRITE (6,10)  KSTAR(I1), KSTAR(I2), DTMAX
---
>                           WRITE (6,10)  KSTAR(I1), KSTAR(I2), DTMAX
344c312
< *     Set T0 = TIME for correct potential energy correction in FCORR.
---
> *       Set T0 = TIME for correct potential energy correction in FCORR.
349,350d316
< *       Remove from NXTLST
<               call delay_remove_tlist(J,STEP,DTK)
352,353d317
< *       Add to NLSTDELAY
<               call delay_store_tlist(J)
357,367d320
< *     --12/13/13 10:55-lwang-update-------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$*     Ensure the heaviest body is new progenitor (only ICOMP is needed).
< c$$$      IF (BODY(I2).GT.BODY(I1)) THEN
< c$$$          I1S = I1
< c$$$          I1 = I2
< c$$$          I2 = I1S
< c$$$          ICOMP = I1
< c$$$          JCOMP = I2
< c$$$      END IF
< c$$$*
370,372c323,325
<          NAM1 = NAME(I1)
<          NAME(I1) = NAME(I2)
<          NAME(I2) = NAM1
---
>           NAM1 = NAME(I1)
>           NAME(I1) = NAME(I2)
>           NAME(I2) = NAM1
374,375c327
<       
< *     --12/13/13 10:56-lwang-end----------------------------------------*
---
> *
396c348
< *       Compensate EGRAV for any chain mass loss.
---
> *       Compensate EGRAV for any chain (or TRIPLE/QUAD) mass loss.
401d352
< *                  CALL JPRED(J,TIME,TIME)
409,412c360,362
<               if(rank.eq.0)
<      &        WRITE (6,19)  NSYS, EGRAV, EGRAV - EG0
<    19         FORMAT (' CMAIN MASS LOSS    NSYS EGRAV DEGR ',
<      &                                     I4,1P,2E10.2)
---
>               WRITE (6,19)  NSYS, EGRAV, EGRAV - EG0
>    19         FORMAT (' CHAIN/TRIPLE MASS LOSS    NSYS EGRAV DEGR ',
>      &                                            I4,1P,2E10.2)
426,431c376
< *     Remove ghost particle and old particle
<       call delay_remove_tlist(I2,STEP,DTK)
< C     STEP(I2) = DTMAX
<       STEP(I2) = 2*DTK(1)
< *     Add ghost particle into NXTLST
<       call add_tlist(I2,STEP,DTK)
---
>       STEP(I2) = DTMAX
483c428
< *       Determine index and set neighbour membership of original chain c.m.
---
> *       Determine index and set neighbour membership of original c.m.
494c439
< *       Update neighbour lists of current chain c.m. and remove ghost I2.
---
> *       Update neighbour lists of current c.m. and remove ghost I2.
503a449,454
> *       Determine new neighbour list for first CHAIN/TRIPLE member #I1.
>       IF (NSYS.GT.2) THEN
>           RSI = RSCALE*(10.0/FLOAT(N - NPAIRS))**0.3333
>           CALL NBLIST(I1,RSI)
>       END IF
> *
507,512d457
< *       Determine neighbour list for chain member.
<           IF (NSYS.GT.2) THEN
<               RSI = RSCALE*(10.0/FLOAT(N - NPAIRS))**0.3333
<               CALL NBLIST(I1,RSI)
<           END IF
< *
538d482
< *              call xbpredall
541d484
< *                  CALL JPRED(J,TIME,TIME)
544d486
<                       X0(K,J) = X(K,J)
546,547d487
< *     Remove J particle first from NXTLST
<                   call delay_remove_tlist(J,STEP,DTK)
550,551d489
< *     Add J particle into NLSTDELAY
<                   call delay_store_tlist(J)
554c492,493
<           TPREV = TIME - STEPX
---
> *       Note danger of multiple collisions on same block-step (early times).
> *         TPREV = TIME - STEPX
560,561d498
< *     Remove I1 particle first from NXTLST
<           call delay_remove_tlist(I1,STEP,DTK)
563,564d499
< *     Add J particle into NLSTDELAY
<           call delay_store_tlist(I1)
591,592c526
<               if(rank.eq.0)
<      &        WRITE (6,38)  NAME(I1)
---
>               WRITE (6,38)  NAME(I1)
622,623d555
< *     Remove ICOMP particle first from NXTLST
<       call delay_remove_tlist(ICOMP,STEP,DTK)
626,628d557
< *     Add new particle into NLSTDELAY
<       call delay_store_tlist(ICOMP)
< 
630d558
<           call delay_remove_tlist(I5,STEP,DTK)
633,636c561
< *     Add new particle into NLSTDELAY
<           call delay_store_tlist(I5)
<           if(rank.eq.0)
<      &    WRITE (6,42)  NAME(I5), STEP(I5)
---
>           WRITE (6,42)  NAME(I5), STEP(I5)
683c608
<           OPEN (UNIT=26,STATUS='UNKNOWN',FORM='FORMATTED',FILE='COAL2')
---
>           OPEN (UNIT=26,STATUS='NEW',FORM='FORMATTED',FILE='COAL2')
687d611
<           if(rank.eq.0)then
697d620
<           end if
704d626
<           if(rank.eq.0)then
709a632,633
>           R1 = RADIUS(I1)*SU
>           R2 = RADIUS(I2)*SU
715d638
<           end if
722,723c645
<       if(rank.eq.0)
<      &WRITE (6,90)  WHICH1, NSYS, NAME1, NAME2, ZM*SMU, RCOLL, EB,
---
>       WRITE (6,90)  WHICH1, NSYS, NAME1, NAME2, ZM*SMU, RCOLL, EB,
734,738c656
< *     --12/13/13 10:57-lwang-update-------------------------------------*
< ***** Note: From Sverre Sep.4 2013-------------------------------------**
< c$$$          NSUB = NSUB - 1
<          NSUB = MAX(NSUB - 1,0)
< *     --12/13/13 10:57-lwang-end----------------------------------------*
---
>           NSUB = MAX(NSUB - 1,0)
1c1
<       SUBROUTINE COAL(IPAIR,KW1,MASS)
---
>       SUBROUTINE COAL(IPAIR,KW1,KW2,MASS)
16d15
<       call xbpredall
24,26c23,29
<               CALL STEPK(DT,DTN)
<               TIME = TPREV + INT((TIME2 + DT)/DTN)*DTN
<               TIME = MIN(TBLOCK,TIME)
---
>               IF (TIME2.LE.16.0*STEP(I)) THEN
>                   CALL STEPK(DT,DTN)
>                   TIME = TPREV + INT((TIME2 + DT)/DTN)*DTN
>                   TIME = MIN(TBLOCK,TIME)
>               ELSE
>                   TIME = MIN(T0(I) + STEP(I),TBLOCK)
>               END IF
61c64
<           IF (KZ(9).GE.2) THEN
---
>           IF (KZ(8).GT.3) THEN
109d111
<       VIJ = SQRT(VIJ2)
113c115
<       ECC = 1.0 - RCOLL/SEMI
---
>       ECC = MAX(1.0 - RCOLL/SEMI,0.001D0)
147d148
<               call jpred(JJ,TIME,TIME)
191a193
>          RADIUS(I2) = 0.0
197,203c199,202
<       T0(I2) = TADJ + DTADJ
< *     remove from NXTLST
<       call delay_remove_tlist(I2,STEP,DTK)
< C      CALL DTCHCK(TIME,STEP(I2),DTK(40))
<       STEP(I2) = 2*DTK(1)
< *     add into GHOST LIST
<       call add_tlist(I2,STEP,DTK)
---
>       T0(I2) = TADJ + DTADJ 
>       IF (KZ(23).EQ.0.OR.RTIDE.GT.1000.0*RSCALE) T0(I2) = 1.0D+10
> *     CALL DTCHCK(TIME,STEP(I2),DTK(40))
>       STEP(I2) = 1.0D+06
211c210
< *     Set T0 = TIME for any other chain members.
---
> *	Set T0 = TIME for any other chain members.
223d221
<          if(rank.eq.0)then
226d223
<          end if
266a264,272
> *       Check removal of #I1 ghost neighbour if #I2 is first single particle.
>       IF (LIST(2,I1).EQ.I2) THEN
>           DO 21 L = 2,NNB
>               LIST(L,I1) = LIST(L+1,I1)
>    21     CONTINUE
>           NNB = NNB - 1
>           LIST(1,I1) = NNB
>       END IF
> *
297,298d302
< C*       remove from NXTLST (In binary, not needed)
<           call delay_remove_tlist(I1,STEP,DTK)
300,302c304,306
<           CALL DTCHCK(TIME,STEP(I1),DTK(40))
< *       add into NLSTDELAY
<           call delay_store_tlist(I1)
---
>           IF (BODY(I1).GT.0.0D0) THEN
>               CALL DTCHCK(TIME,STEP(I1),DTK(40))
>           END IF
319,320d322
< *     remove from NXTLST
<                       call delay_remove_tlist(J,STEP,DTK)
322d323
< *                      call jpred(j,time,time)
324,325d324
< *     remove from NXTLST
<                       call delay_remove_tlist(J,STEP,DTK)
327,329d325
<                   ELSE
< *     remove from NXTLST
<                       call delay_remove_tlist(J,STEP,DTK)
333d328
<                       X0(K,J) = X(K,J)
337,354c332,348
<                       DO 26 K = 1,3
<                          X0(K,I1) = MIN(1.0d+04 + (X(K,I1)-RDENS(K)),
<      &                             1000.d0*RSCALE*(X(K,I1)-RDENS(K))/RI)
<                           X(K,I1) = X0(K,I1)
<                           X0DOT(K,I1) = SQRT(0.004d0*ZMASS/RSCALE)*
<      &                                               XDOT(K,I1)/VI
<                           XDOT(K,I1) = X0DOT(K,I1)
<                           F(K,I1) = 0.d0
<                           FDOT(K,I1) = 0.d0
<                           D2(K,I1) = 0.d0
<                           D3(K,I1) = 0.d0
<    26                 CONTINUE
<                       T0(I1) = TADJ + DTADJ
< C                      call delay_remove_tlist(I1,STEP,DTK)
<                       STEP(I1) = 2*DTK(1)
<                       call add_tlist(I1,STEP,DTK)
<                       if(rank.eq.0) WRITE (6,28)  NAME(I1), KW1
<    28                 FORMAT (' MASSLESS PRIMARY!    NAM KW ',I8,I4)
---
>                      IF(J.EQ.I1)THEN
>                         DO 26 K = 1,3
>                            X0(K,I1) = MIN(1.0d+04 + (X(K,I1)-RDENS(K)),
>      &                            1000.d0*RSCALE*(X(K,I1)-RDENS(K))/RI)
>                            X(K,I1) = X0(K,I1)
>                            X0DOT(K,I1) = SQRT(0.004d0*ZMASS/RSCALE)*
>      &                                                XDOT(K,I1)/VI
>                            XDOT(K,I1) = X0DOT(K,I1)
>                            F(K,I1) = 0.d0
>                            FDOT(K,I1) = 0.d0
>                            D2(K,I1) = 0.d0
>                            D3(K,I1) = 0.d0
>    26                   CONTINUE
>                         T0(I1) = 1.0D+06
>                         WRITE (6,28)  NAME(I1), KW1
>    28                   FORMAT (' MASSLESS PRIMARY!    NAM KW ',I8,I4)
>                      ENDIF
358d351
<                       call delay_store_tlist(J)
360d352
< *     add into NLSTDELAY
371d362
<                   X0(K,JMIN) = X(K,JMIN)
376d366
<               if(rank.eq.0)then
380d369
<               end if
384,386d372
<               call delay_remove_tlist(I2,STEP,DTK)
<               STEP(I2) = 2*DTK(1)
<               call add_tlist(I2,STEP,DTK)
388,389d373
< *       remove from NXTLST
<               call delay_remove_tlist(ICOMP,STEP,DTK)
393,394d376
< *     add into NLSTDELAY
<               call delay_store_tlist(ICOMP)
406,440c388,402
<       IF (rank.eq.0.and.FIRST) THEN
<          OPEN (UNIT=24,STATUS='UNKNOWN',FORM='FORMATTED',FILE='coal.24'
<      &        ,ACCESS='APPEND')
<          FIRST = .FALSE.
< *     
< *     Print cluster scaling parameters at start of the run.
<          IF (NCOAL.EQ.1) THEN
<             WRITE (24,40)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
<      &           NBIN0, NZERO
<  40         FORMAT (/,6X,'MODEL:    RBAR =',1P,E26.17,'  <M> =',E26.17,
<      &           '  M1 =',E26.17,'  TSCALE =',E26.17,0P,
<      &           '  NB =',I12,'  N0 =',I12,//)
<             WRITE (12,45)
<  45         FORMAT ('          TIME[NB]        ',
<      &           '   NAME(I1) ',
<      &           '   NAME(I2) ',
<      &           '    K*(I1)  ',
<      &           '    K*(I2)  ',
<      &           '     K*1    ',
<      &           '   IQCOLL   ',
<      &           '          M(I1)[M*]       ',
<      &           '          M(I2)[M*]       ',
<      &           '         M(INEW)[M*]      ',
<      &           '          DM[M*]          ',
<      &           '          RS(I1)[R*]      ',
<      &           '          RS(I2)[R*]      ',
<      &           '           RI/RC          ',
<      &           '           R12[R*]        ',
<      &           '           ECC            ',
<      &           '           P[days]        ',
<      &           '           RCOLL[R*]      ',
<      &           '            EB[NB]        ',
<      &           '            DP[NB]        ',
<      &           '            VINF[km/s]    ')
<          END IF
---
>       IF (FIRST) THEN
>           OPEN (UNIT=12,STATUS='NEW',FORM='FORMATTED',FILE='COAL')
>           FIRST = .FALSE.
> *
> *       Print cluster scaling parameters at start of the run.
>           IF (NCOAL.EQ.1) THEN
>               WRITE (12,40)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
>      &                       NBIN0, NZERO
>    40         FORMAT (/,6X,'MODEL:    RBAR =',F5.1,'  <M> =',F6.2,
>      &                     '  M1 =',F6.1,'  TSCALE =',F6.2,
>      &                     '  NB =',I5,'  N0 =',I6,//)
>               WRITE (12,45)
>    45         FORMAT ('    TIME  NAME  NAME  K1  K2  IQ  M1   M2',
>      &                '   DM    R1     R2    r/Rc   R     ECC      P',/)
>           END IF
443,450c405,409
<       if(rank.eq.0)then
<          WRITE (24,*)  TTOT, NAME1, NAME2, KSTAR(I1), KSTAR(I2), 
<      &        KW1, IQCOLL, ZM1, ZM2, ZMNEW*ZMBAR, 
<      &        DM*ZMBAR, RADIUS(I1)*SU, RADIUS(I2)*SU,
<      &        RI/RC, RIJ*SU, ECC, TK, RCOLL*SU, EB, DP, VINF
< C 50      FORMAT (1X,F7.1,2I6,3I4,3F5.1,2F7.2,F6.1,F7.2,F9.5,1P,E9.1)
<          CALL FLUSH(12)
<       end if
---
>       WRITE (12,50)  TTOT, NAME1, NAME2, KSTAR(I1), KSTAR(I2), IQCOLL,
>      &               ZM1, ZM2, DM*ZMBAR, RADIUS(I1)*SU, RADIUS(I2)*SU,
>      &               RI/RC, RIJ*SU, ECC, TK
>    50 FORMAT (1X,F7.1,2I6,3I4,3F5.1,2F7.2,F6.1,F7.2,F9.5,1P,E9.1)
>       CALL FLUSH(12)
452d410
<       if(rank.eq.0)then
454,461c412,416
<      &              KW1, ZMNEW*ZMBAR, RCOLL*SU, EB, DP, DM*ZMBAR, VINF,
<      &              BODY(I1)*ZMBAR,BODY(I2)*ZMBAR,
<      &              RADIUS(I1)*SU,RADIUS(I2)*SU,RIJ,VIJ
<  55   FORMAT (/,A8,'COAL: IQCOLL',I3,' N1,2',2I10,' KW1,2,S',3I4,
<      &     '  M(INEW)[M*]',1P,E9.2,'  RCOLL[R*]',E9.2,'  EB[NB]',E9.2,
<      &     '  DP[NB]',E9.2,'  DM[M*]',E9.2,'  VINF[km/s]',E9.2,
<      &     '  M1,2[*]',2E9.2,' RAD1,2[*]',2E9.2,' RI,VI=',2E9.2)
<       end if
---
>      &              KW1, ZMNEW*ZMBAR, RCOLL, EB, ECC, DM*ZMBAR, VINF
>    55 FORMAT (/,A8,'COAL    IQ =',I3,'  NAME =',2I6,'  K* =',3I3,
>      &             '  M =',F6.2,'  RCOLL =',1P,E8.1,'  EB =',E9.1,
>      &             '  ECC =',0P,F9.5,'  DM =',F6.2,'  VINF =',F5.1)
>       CALL FLUSH(6)
463a419,420
> *       Ensure a BH does not get a smaller type (should not happen).
>       IF (KSTAR(I2).EQ.14) KSTAR(I1) = 14
13c13
<       REAL*8 M02,M2,MC2,AJ2,JSPIN2,R2,L2,MC22
---
>       REAL*8 M02,M2,MC2,AJ2,JSPIN2,R2,L2,MC22,OSPBRU,JSPBRU
20c20
<       REAL*8 RC1,RCC2,Q1,Q2,RL1,RL2
---
>       REAL*8 RC1,RC2,Q1,Q2,RL1,RL2
25,26c25
< ccc      PARAMETER (LAMBDA = 0.0D0,ALPHA1 = 3.0D0)		// changing for Abbas... 
<       PARAMETER (LAMBDA = 0.5D0,ALPHA1 = 3.0D0)
---
>       PARAMETER (LAMBDA = 0.D0,ALPHA1 = 3.D0)
54,56c53
<       IF(KW.NE.KW1.and.rank.eq.0) THEN
<           WRITE(38,*)' COMENV TYPE CHANGE *1'
<       END IF
---
>       IF(KW.NE.KW1) WRITE(38,*)' COMENV TYPE CHANGE *1'
62,66c59,61
<      &            R2,L2,KW2,MC2,RCC2,MENV,RENV,K22)
<       OSPIN2 = JSPIN2/(K22*R2*R2*(M2-MC2)+K3*RCC2*RCC2*MC2)
<       IF(KW.NE.KW2.and.rank.eq.0) THEN
<           WRITE(38,*)' COMENV TYPE CHANGE *2'
<       END IF
---
>      &            R2,L2,KW2,MC2,RC2,MENV,RENV,K22)
>       OSPIN2 = JSPIN2/(K22*R2*R2*(M2-MC2)+K3*RC2*RC2*MC2)
>       IF(KW.NE.KW2) WRITE(38,*)' COMENV TYPE CHANGE *2'
73c68
<       if(rank.eq.0) WRITE(38,66) KW1,M01,M1,MC1,AJ1,SEP
---
>       WRITE(38,66)KW1,M01,M1,MC1,AJ1,SEP
75c70
<       if(rank.eq.0) WRITE(38,67) KW2,M02,M2,MC2,AJ2
---
>       WRITE(38,67)KW2,M02,M2,MC2,AJ2
132c127
<                if(rank.eq.0) WRITE(*,*) ' WARNING: CE DM ',DM,M1,MC1
---
>                WRITE(*,*)' WARNING: CE DM ',DM,M1,MC1
252c247
<          IF(RC1/RL1.GE.RCC2/RL2)THEN
---
>          IF(RC1/RL1.GE.RC2/RL2)THEN
258c253
<             IF(RCC2.GT.RL2*SEPF)THEN
---
>             IF(RC2.GT.RL2*SEPF)THEN
260c255
<                SEPL = RCC2/RL2
---
>                SEPL = RC2/RL2
330c325
<      &                  R2,L2,KW2,MC2,RCC2,MENV,RENV,K22)
---
>      &                  R2,L2,KW2,MC2,RC2,MENV,RENV,K22)
439c434
< *        JSPIN2 = OORB*(K22*R2*R2*(M2-MC2)+K3*RCC2*RCC2*MC2)
---
> *        JSPIN2 = OORB*(K22*R2*R2*(M2-MC2)+K3*RC2*RC2*MC2)
445c440,444
<          JSPIN2 = OSPIN2*(K22*R2*R2*(M2-MC2)+K3*RCC2*RCC2*MC2)
---
>          JSPIN2 = OSPIN2*(K22*R2*R2*(M2-MC2)+K3*RC2*RC2*MC2)
> * Include break-up check for the secondary (Jarrod fix 8/16).
>          OSPBRU = TWOPI*SQRT(M2*AURSUN**3/R2**3)
>          JSPBRU = OSPBRU*(K22*R2*R2*(M2-MC2)+K3*RC2*RC2*MC2)
>          IF(JSPIN2.GT.JSPBRU) JSPIN2 = JSPBRU
453d451
<       if(rank.eq.0)then
458,469d455
<       end if
< *
< * Include collision criterion at the end (note RC1 = 0 for main sequence).
<       IF (RC1.EQ.0.0D0) THEN
<           IF (R1 + RCC2.GE.SEP*(1.0 - ECC)) THEN
<               COEL = .TRUE.
<           END IF
<       ELSE
<           IF (RC1 + RCC2.GE.SEP*(1.0 - ECC)) THEN
<               COEL = .TRUE.
<           END IF
<       END IF
2,7c2,6
< *     
< *     
< *     Rectification of chaotic orbit.
< *     -------------------------------
< *     
<       Include 'kspars.h'
---
> *
> *
> *       Rectification of chaotic orbit.
> *       -------------------------------
> *
9d7
< *     Unsafe!!: modified value: EB0,ZJ0,ecrit,ar,br,edec,tosc,rp,es,iosc,namec!!!
11,13c9,11
<      &     BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
<      &     RP(NTMAX),ES(NTMAX),CM(2,NTMAX),IOSC(NTMAX),
<      &     NAMEC(NTMAX)
---
>      &               BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
>      &               RP(NTMAX),ES(NTMAX),CM(2,NTMAX),IOSC(NTMAX),
>      &               NAMEC(NTMAX)
18,20c16,18
< *     
< *     
< *     Define c.m. & KS indices and search current names for chaos index.
---
> *
> *
> *       Define c.m. & KS indices and search current names for chaos index.
26c24
<          IF (NAMEC(K).EQ.NAME(I)) IC = K
---
>           IF (NAMEC(K).EQ.NAME(I)) IC = K
28,29c26,27
< *     
< *     Include case of chain chaos without identified NAMEC.
---
> *
> *       Include case of chain chaos without identified NAMEC.
31,54c29,51
<          if(rank.eq.0)
<      &        WRITE (6,2)  NCHAOS, IPAIR, KSTAR(I), NAME(I1), NAME(I2),
<      &        LIST(1,I1), STEP(I1), STEP(I)
<  2       FORMAT (' WARNING!    CHRECT    NCH KS K* NAM NP DT1 DTI ',
<      &        3I4,2I6,I4,1P,2E10.2)
< *     See whether wrong component name (+ NZERO) saved as NAMEC in CHAOS2.
<          NAM2 = 0
<          DO 6 L = 1,2
<             NAM1 = KSAVE(2*L) - NAME(I2)
<             IF (KSAVE(2*L-1).LT.0.AND.NAM1.EQ.NAME(I1)) THEN
<                NAM2 = NZERO + NAME(I2)
<             END IF
<  6       CONTINUE
<          IC = NCHAOS
<          NAMC = NAMEC(IC)
< *     Check identification for correct value (two K*=-2 are possible).
<          DO 8 K = 1,NCHAOS
<             IF (NAMEC(K).EQ.NAM2) IC = K
<  8       CONTINUE
<          NAMEC(IC) = NAME(I)
<          IF (rank.eq.0.and.(NAM2.EQ.NAMC.OR.IC.LT.NCHAOS)) THEN
<             WRITE (6,9)  IC, NCHAOS, NAM2, NAMC, NAME(I)
<  9          FORMAT (' CHRECT RESTORE    IC NCH NM2 NMC NMI ',2I4,3I8)
<          END IF
---
>           WRITE (6,2)  NCHAOS, IPAIR, KSTAR(I), NAME(I1), NAME(I2),
>      &                 LIST(1,I1), STEP(I1), STEP(I)
>     2     FORMAT (' WARNING!    CHRECT    NCH KS K* NAM NP DT1 DTI ',
>      &                                    3I4,2I6,I4,1P,2E10.2)
> *       See whether wrong component name (+ NZERO) saved as NAMEC in CHAOS2.
>           NAM2 = 0
>           DO 6 L = 1,2
>               NAM1 = KSAVE(2*L) - NAME(I2)
>               IF (KSAVE(2*L-1).LT.0.AND.NAM1.EQ.NAME(I1)) THEN
>                   NAM2 = NZERO + NAME(I2)
>               END IF
>     6     CONTINUE
>           IC = NCHAOS
>           NAMC = NAMEC(IC)
> *       Check identification for correct value (two K*=-2 are possible).
>           DO 8 K = 1,NCHAOS
>               IF (NAMEC(K).EQ.NAM2) IC = K
>     8     CONTINUE
>           NAMEC(IC) = NAME(I)
>           IF (NAM2.EQ.NAMC.OR.IC.LT.NCHAOS) THEN
>               WRITE (6,9)  IC, NCHAOS, NAM2, NAMC, NAME(I)
>     9         FORMAT (' CHRECT RESTORE    IC NCH NM2 NMC NMI ',2I4,3I8)
>           END IF
56,61c53,58
<          if(rank.eq.0)WRITE (6,3)  NCHAOS, IPAIR, KSTAR(I), NAME(I)
<  3       FORMAT (' CHRECT RESTORE    NCH KS K* NAM ',3I4,I6)
< *     Restore case of former merger with KSTARM < 0 to chaos table.
<          NCHAOS = 1
<          IC = 1
<          NAMEC(NCHAOS) = NAME(I)
---
>           WRITE (6,3)  NCHAOS, IPAIR, KSTAR(I), NAME(I)
>     3     FORMAT (' CHRECT RESTORE    NCH KS K* NAM ',3I4,I6)
> *       Restore case of former merger with KSTARM < 0 to chaos table.
>           NCHAOS = 1
>           IC = 1
>           NAMEC(NCHAOS) = NAME(I)
63,64c60,61
< *     
< *     Save variables for diagnostic output.
---
> *
> *       Save variables for diagnostic output.
69,70c66,67
< *     
< *     Obtain current values of KS variables in case of spiral.
---
> *
> *       Obtain current values of KS variables in case of spiral.
72,112c69,105
< *     Skip on call from RESET/MDOT with arbitrary phase (only updating).
<          IF (ABS(TDOT2(IPAIR)).GT.1.0D-12.AND.DMR.GE.0.0) THEN
< *     Rectify KS variables in order to obtain correct pericentre.
<             CALL KSRECT(IPAIR)
< *     Reduce eccentric anomaly by pi for inward motion.
<             IF (TDOT2(IPAIR).LT.0.0D0) THEN
<                CALL KSAPO(IPAIR)
<             END IF
< *     Transform from outward motion to exact pericentre.
<             CALL KSPERI(IPAIR)
<          END IF
< *     
< *     Form current two-body elements.
<          SEMI = -0.5*BODY(I)/H(IPAIR)
<          ECC2 = (1.0 - R(IPAIR)/SEMI)**2 +
<      &        TDOT2(IPAIR)**2/(BODY(I)*SEMI)
<          ECC = SQRT(ECC2)
< *     
< *     Update periastron and eccentricity (ECC modulation or mass loss).
<          QPERI = SEMI*(1.0D0 - ECC)
<          RP(IC) = QPERI
<          ES(IC) = ECC
< *     
< *     Update orbital parameters after merger, mass loss or radius change.
<          IF (DMR.GE.0.0D0) THEN
<             KSTAR(I) = -KSTAR(I)
< *     ks MPI communication TEV
<             call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<             CALL SPIRAL(IPAIR)
<             IF (IPHASE.LT.0.OR.KSTAR(I).GT.0) GO TO 30
<          END IF
< *     
< *     Check circularization time for spiral after radius/orbit expansion.
<          ICIRC = -1
<          CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
<          TC = MAX(TC,0.01D0)
< *     Restrict lookup time to TC/2 for exit from possible merger.
<          TEV(I1) = MIN(TEV(I1),TIME + 0.5*TC/TSTAR)
< *     ks MPI communication TEV
<          call ksparmpi(K_store,K_real8,K_TEV,I1,0,TEV(I1))
< *     TEV(I2) = TEV(I1)
---
> *       Skip on call from RESET/MDOT with arbitrary phase (only updating).
>           IF (ABS(TDOT2(IPAIR)).GT.1.0D-12.AND.DMR.GE.0.0) THEN
> *       Rectify KS variables in order to obtain correct pericentre.
>               CALL KSRECT(IPAIR)
> *       Reduce eccentric anomaly by pi for inward motion.
>               IF (TDOT2(IPAIR).LT.0.0D0) THEN
>                   CALL KSAPO(IPAIR)
>               END IF
> *       Transform from outward motion to exact pericentre.
>               CALL KSPERI(IPAIR)
>           END IF
> *
> *       Form current two-body elements.
>           SEMI = -0.5*BODY(I)/H(IPAIR)
>           ECC2 = (1.0 - R(IPAIR)/SEMI)**2 +
>      &                                    TDOT2(IPAIR)**2/(BODY(I)*SEMI)
>           ECC = SQRT(ECC2)
> *
> *       Update periastron and eccentricity (ECC modulation or mass loss).
>           QPERI = SEMI*(1.0D0 - ECC)
>           RP(IC) = QPERI
>           ES(IC) = ECC
> *
> *       Update orbital parameters after merger, mass loss or radius change.
>           IF (DMR.GE.0.0D0) THEN
>               KSTAR(I) = -KSTAR(I)
>               CALL SPIRAL(IPAIR)
>               IF (IPHASE.LT.0.OR.KSTAR(I).GT.0) GO TO 30
>           END IF
> *
> *       Check circularization time for spiral after radius/orbit expansion.
>           ICIRC = -1
>           CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
>           TC = MAX(TC,0.01D0)
> *       Restrict lookup time to TC/2 for exit from possible merger.
>           TEV(I1) = MIN(TEV(I1),TIME + 0.5*TC/TSTAR)
> *         TEV(I2) = TEV(I1)
114,115c107,108
< *     
< *     Form (new) semi-major axis, eccentricity & periastron distance.
---
> *
> *       Form (new) semi-major axis, eccentricity & periastron distance.
120,121c113,114
< *     
< *     Set latest values of periastron & eccentricity and update time.
---
> *
> *       Set latest values of periastron & eccentricity and update time.
125,126c118,119
< *     
< *     Include check for SLEEP after recent WD/NS formation.
---
> *
> *       Include check for SLEEP after recent WD/NS formation.
130,141c123,134
< *     Determine index of most recent degenerate object formation.
<          IF (KSTAR(I2).LT.10) THEN
<             J1 = I1
<          ELSE IF (KSTAR(I1).LT.10) THEN
<             J1 = I2
<          ELSE
<             J1 = I1
<             IF (EPOCH(I2).GT.EPOCH(I1)) J1 = I2
<          END IF
<          IF (TIME - TEV0(J1).LT.2.0*STEPX.AND.TC.GT.3000.0) THEN
<             SLEEP = .TRUE.
<          END IF
---
> *       Determine index of most recent degenerate object formation.
>           IF (KSTAR(I2).LT.10) THEN
>               J1 = I1
>           ELSE IF (KSTAR(I1).LT.10) THEN
>               J1 = I2
>           ELSE
>               J1 = I1
>               IF (EPOCH(I2).GT.EPOCH(I1)) J1 = I2
>           END IF
>           IF (TIME - TEV0(J1).LT.2.0*STEPX.AND.TC.GT.3000.0) THEN
>               SLEEP = .TRUE.
>           END IF
143,144c136,137
< *     
< *     Check circularization time after chain regularization.
---
> *
> *       Check circularization time after chain regularization.
146,152c139,145
<          ICIRC = -1
<          CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
<          IF (TC.GT.3000.0) THEN
<             if(rank.eq.0)WRITE (6,4)  NAME(I1), TC
<  4          FORMAT (' CHAIN SLEEP:    NM TC ',I6,1P,E10.2)
<             SLEEP = .TRUE.
<          END IF
---
>           ICIRC = -1
>           CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
>           IF (TC.GT.3000.0) THEN
>               WRITE (6,4)  NAME(I1), TC
>     4         FORMAT (' CHAIN SLEEP:    NM TC ',I6,1P,E10.2)
>               SLEEP = .TRUE.
>           END IF
154,155c147,148
< *     
< *     Re-initialize all chaos parameters after expansion or check SLEEP.
---
> *
> *       Re-initialize all chaos parameters after expansion or check SLEEP.
157,260c150,242
<          IF (rank.eq.0.and.DMR.GT.0.01.AND.TC.GT.100.0.AND.KM.LT.5) THEN
<             WRITE (6,5)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
<      &           KSTAR(I), TPHYS, RADIUS(I1), RADIUS(I2),
<      &           QPERI, SEMI, ECC, ES0, BODY(I)*ZMBAR, TC
<  5          FORMAT (' CHRECT:    NAM K* TP R* QP A E E0 M TC ',
<      &           2I6,3I4,F8.1,1P,4E10.2,0P,3F7.3,F7.1)
<          END IF
< *     
< *     Reset spiral indicator for degenerate component and long t_{circ}.
<          IF (SLEEP) THEN
<             KSTAR(I) = 0
< *     ks MPI communication TEV
<             call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<             NSLP = NSLP + 1
<             TK = SEMI*SQRT(SEMI/BODY(I))
<             TB = YRS*TK
<             XP = (TIME - TIME0)/(TWOPI*TK)
<             QPS = SEMI*(1.0 - ECC)/MAX(RADIUS(I1),RADIUS(I2))
<             if(rank.eq.0)
<      &           WRITE (6,10)  TTOT, NAME(I1), NAME(I2), KSTAR(I1), 
<      &           KSTAR(I2), ECC, ES0, QPS, SEMI, TC, TB, XP
<  10         FORMAT (' SLEEP SPIRAL    T NM K* E E0 QP/S A TC TB DTK ',
<      &           F9.2,2I6,2I4,2F8.4,1P,5E9.1)
< *     Update chaos variables at end of routine SPIRAL (argument < 0).
<             II = -I
<             CALL SPIRAL(II)
<             GO TO 30
<          END IF
< *     
< *     Save eccentricity, binding energy & J0 and initialize EDEC & IOSC.
<          ZMU = BODY(I1)*BODY(I2)/BODY(I)
<          CJ = ZMU*SQRT(BODY(I))
<          EB0(IC) = ZMU*H(IPAIR)
<          ZJ0(IC) = CJ*SQRT(QPERI*(1.0 + ECC))
<          EDEC(IC) = 0.0
<          IOSC(IC) = 1
<          ZN = 0.0
<          DO 12 K = 1,2
<             IK = I1 + K - 1
<             IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
<      &           KSTAR(IK).EQ.6.OR.KSTAR(IK).EQ.9) THEN
<                CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,ZN,QL)
<                W(K) = WG(1)
<             ELSE
<                IP = 3
<                IF (KSTAR(IK).EQ.0) IP = 1
<                W(K) = WW(IP)
<             END IF
<  12      CONTINUE
< *     
< *     Set new chaos boundary parameters (ECRIT, AR & BR).
<          CALL CHAOS0(QPERI,ECC,EB0(IC),ZJ0(IC),BODY(I1),BODY(I2),
<      &        RADIUS(I1),RADIUS(I2),W,ECRIT(IC),AR(IC),BR(IC),IDIS)
< *     
<          RCOLL = RADIUS(I1) + RADIUS(I2)
<          IF (IDIS.EQ.-1.AND.KSTAR(I).EQ.-1) THEN
<             IOSC(IC) = 2
<             if(rank.eq.0)
<      &           WRITE (6,15)  TTOT, IPAIR, NAME(I1), NAME(I2), 
<      &           KSTAR(I1), KSTAR(I2), RADIUS(I1), RADIUS(I2), QPERI,
<      &           SEMI, ES0, ECC
<  15         FORMAT (' CHAOS => SPIRAL    T KS NAM K* R* QP A E0 E ',
<      &           F9.2,I4,2I6,2I4,1P,4E10.2,0P,2F7.3)
< *     Activate spiral indicator and save time, pericentre & eccentricity.
<             KSTAR(I) = -2
< *     ks MPI communication TEV
<             call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<             TOSC(IC) = TIME
<             RP(IC) = QPERI
<             ES(IC) = ECC
<             NSP = NSP + 1
<             IF (KZ(9).GE.2) THEN
<                CALL BINEV(IPAIR)
<             END IF
<             GO TO 30
<          END IF
< *     
< *     Combine the two stars inelastically in case of chaos disruption.
<          IF (IDIS.GT.0.AND.QPERI.LT.RCOLL) THEN
<             R1 = MAX(RADIUS(I1),RADIUS(I2))
<             WHICH1 = ' CHAOS  '
<             IF (KSTAR(I).EQ.-2) WHICH1 = ' SPIRAL '
<             if(rank.eq.0)
<      &           WRITE (6,20)  WHICH1, IPAIR, NAME(I1), NAME(I2),
<      &           KSTAR(I1), KSTAR(I2), R1, R(IPAIR), QPERI,
<      &           SEMI, ECC, ES0, ZN
<  20         FORMAT (' DISRUPTED',A8,'  KS NM K* R* R QP A E E0 n ',
<      &           I4,2I6,2I4,1P,4E10.2,0P,3F7.3)
< *     Update chaos variables at end of routine SPIRAL (argument < 0).
<             IQCOLL = 1
<             IF (KSTAR(I).EQ.-2) IQCOLL = 2
<             II = -I
<             CALL SPIRAL(II)
<             KSTAR(I) = 0
< *     ks MPI communication TEV
<             call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<             call jpred(I,time,time)
<             KSPAIR = IPAIR
< *       Delay collision/coalescence until end of KSINT using IPHASE < 0.
<             IPHASE = -1
< c$$$            CALL CMBODY(2)
<             DMR = -1.0
<             GO TO 30
<          END IF
---
>           IF (DMR.GT.0.01.AND.TC.GT.100.0.AND.KM.LT.5) THEN
>               WRITE (6,5)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
>      &                     KSTAR(I), TPHYS, RADIUS(I1), RADIUS(I2),
>      &                     QPERI, SEMI, ECC, ES0, BODY(I)*ZMBAR, TC
>     5         FORMAT (' CHRECT:    NAM K* TP R* QP A E E0 M TC ',
>      &                             2I6,3I4,F8.1,1P,4E10.2,0P,3F7.3,F7.1)
>           END IF
> *
> *       Reset spiral indicator for degenerate component and long t_{circ}.
>           IF (SLEEP) THEN
>               KSTAR(I) = 0
>               NSLP = NSLP + 1
>               TK = SEMI*SQRT(SEMI/BODY(I))
>               TB = YRS*TK
>               XP = (TIME - TIME0)/(TWOPI*TK)
>               QPS = SEMI*(1.0 - ECC)/MAX(RADIUS(I1),RADIUS(I2))
>               WRITE (6,10)  TTOT, NAME(I1), NAME(I2), KSTAR(I1), 
>      &                      KSTAR(I2), ECC, ES0, QPS, SEMI, TC, TB, XP
>    10         FORMAT (' SLEEP SPIRAL    T NM K* E E0 QP/S A TC TB DTK ',
>      &                                  F9.2,2I6,2I4,2F8.4,1P,5E9.1)
> *       Update chaos variables at end of routine SPIRAL (argument < 0).
>               II = -I
>               CALL SPIRAL(II)
>               GO TO 30
>           END IF
> *
> *       Save eccentricity, binding energy & J0 and initialize EDEC & IOSC.
>           ZMU = BODY(I1)*BODY(I2)/BODY(I)
>           CJ = ZMU*SQRT(BODY(I))
>           EB0(IC) = ZMU*H(IPAIR)
>           ZJ0(IC) = CJ*SQRT(QPERI*(1.0 + ECC))
>           EDEC(IC) = 0.0
>           IOSC(IC) = 1
>           XN = 0.0
>           DO 12 K = 1,2
>               IK = I1 + K - 1
>               IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
>      &            KSTAR(IK).EQ.6.OR.KSTAR(IK).EQ.9) THEN
>                   CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,XN,QL)
>                   W(K) = WG(1)
>               ELSE
>                   IP = 3
>                   IF (KSTAR(IK).EQ.0) IP = 1
>                   W(K) = WW(IP)
>               END IF
>    12     CONTINUE
> *
> *       Set new chaos boundary parameters (ECRIT, AR & BR).
>           CALL CHAOS0(QPERI,ECC,EB0(IC),ZJ0(IC),BODY(I1),BODY(I2),
>      &             RADIUS(I1),RADIUS(I2),W,ECRIT(IC),AR(IC),BR(IC),IDIS)
> *
>           RCOLL = RADIUS(I1) + RADIUS(I2)
> 	  IF (IDIS.EQ.-1.AND.KSTAR(I).EQ.-1) THEN
>               IOSC(IC) = 2
>               WRITE (6,15)  TTOT, IPAIR, NAME(I1), NAME(I2), KSTAR(I1),
>      &                      KSTAR(I2), RADIUS(I1), RADIUS(I2), QPERI,
>      &                      SEMI, ES0, ECC
>    15         FORMAT (' CHAOS => SPIRAL    T KS NAM K* R* QP A E0 E ',
>      &                               F9.2,I4,2I6,2I4,1P,4E10.2,0P,2F7.3)
> *       Activate spiral indicator and save time, pericentre & eccentricity.
> 	      KSTAR(I) = -2
> 	      TOSC(IC) = TIME
> 	      RP(IC) = QPERI
> 	      ES(IC) = ECC
>               NSP = NSP + 1
>               IF (KZ(8).GT.3) THEN
>                   CALL BINEV(IPAIR)
>               END IF
> 	      GO TO 30
> 	  END IF
> *
> *       Combine the two stars inelastically in case of chaos disruption.
>           IF (IDIS.GT.0.AND.QPERI.LT.RCOLL) THEN
>               R1 = MAX(RADIUS(I1),RADIUS(I2))
>               WHICH1 = ' CHAOS  '
>               IF (KSTAR(I).EQ.-2) WHICH1 = ' SPIRAL '
>               WRITE (6,20)  WHICH1, IPAIR, NAME(I1), NAME(I2),
>      &                      KSTAR(I1), KSTAR(I2), R1, R(IPAIR), QPERI,
>      &                      SEMI, ECC, ES0, XN
>    20         FORMAT (' DISRUPTED',A8,'  KS NM K* R* R QP A E E0 n ',
>      &                                   I4,2I6,2I4,1P,4E10.2,0P,3F7.3)
> *       Update chaos variables at end of routine SPIRAL (argument < 0).
>               IQCOLL = 1
>               IF (KSTAR(I).EQ.-2) IQCOLL = 2
>               II = -I
>               CALL SPIRAL(II)
>               KSTAR(I) = 0
>               CALL XVPRED(I,0)
>               KSPAIR = IPAIR
> *             CALL CMBODY(R(IPAIR),2)
>               DMR = -1.0
>               GO TO 30
>           END IF
262,291c244,270
<          I1 = 2*IPAIR - 1
<          I2 = I1 + 1
<          IF (QPERI.LT.2.0*MAX(RADIUS(I1),RADIUS(I2))) THEN
< *     Determine indices for primary & secondary star (donor & accretor).
<             J1 = I1
<             IF (RADIUS(I2).GT.RADIUS(I1)) J1 = I2
< *     Define mass ratio and evaluate Roche radius for the primary.
<             Q0 = BODY(J1)/(BODY(I) - BODY(J1))
<             Q1 = Q0**0.3333
<             Q2 = Q1**2
<             RL1 = 0.49*Q2/(0.6*Q2 + LOG(1.0D0 + Q1))*SEMI
< *     Check Roche radius but skip RESET call (no second EMERGE correction).
<             IF (RADIUS(J1).GT.RL1.AND.IPHASE.NE.7) THEN
<                if(rank.eq.0)
<      &              WRITE (6,25) NAME(I1), NAME(I2), KSTAR(I1),
<      &              KSTAR(I2), ECC, ES0, RCOLL, RL1, QPERI, SEMI, TC
<  25            FORMAT (' DISRUPTED SPIRAL    NM K* E E0 RC RL QP A',
<      &              ' TC ',2I6,2I4,2F7.3,1P,5E10.2)
< *     Obtain KS variables at pericentre and enforce collision or CE.
<                CALL KSPERI(IPAIR)
<                KSTAR(I) = 0
< *     ks MPI communication TEV
<                call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
< c$$$               KSPAIR = IPAIR
< c$$$               IQCOLL = 2
< c$$$               CALL CMBODY(2)
<                DMR = -1.0
< *     Note that same result achieved by TERM SPIRAL in case IPHASE = 7.
<             END IF
<          END IF
---
>           I1 = 2*IPAIR - 1
>           I2 = I1 + 1
>           IF (QPERI.LT.2.0*MAX(RADIUS(I1),RADIUS(I2))) THEN
> *       Determine indices for primary & secondary star (donor & accretor).
>               J1 = I1
>               IF (RADIUS(I2).GT.RADIUS(I1)) J1 = I2
> *       Define mass ratio and evaluate Roche radius for the primary.
>               Q0 = BODY(J1)/(BODY(I) - BODY(J1))
>               Q1 = Q0**0.3333
>               Q2 = Q1**2
>               RL1 = 0.49*Q2/(0.6*Q2 + LOG(1.0D0 + Q1))*SEMI
> *       Check Roche radius but skip RESET call (no second EMERGE correction).
>               IF (RADIUS(J1).GT.RL1.AND.IPHASE.NE.7) THEN
>                   WRITE (6,25) NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2),
>      &                         ECC, ES0, RCOLL, RL1, QPERI, SEMI, TC
>    25             FORMAT (' DISRUPTED SPIRAL    NM K* E E0 RC RL QP A',
>      &                    ' TC ',2I6,2I4,2F7.3,1P,5E10.2)
> *       Obtain KS variables at pericentre and enforce collision or CE.
>                   CALL KSPERI(IPAIR)
>                   KSTAR(I) = 0
>                   KSPAIR = IPAIR
>                   IQCOLL = 2
>                   CALL CMBODY(QPERI,2)
>                   DMR = -1.0
> *       Note that same result achieved by TERM SPIRAL in case IPHASE = 7.
>               END IF
>           END IF
293,295c272,274
< *     
<  30   RETURN
< *     
---
> *
>    30 RETURN
> *
1c1
<       SUBROUTINE CMBODY(NSYS)
---
>       SUBROUTINE CMBODY(ENERGY,NSYS)
20,26d19
<       call xbpredall
< *     --12/29/13 22:37-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$      print*,rank,time,'Call cmbody!!'
< c$$$      call flush(6)
< c$$$      call abort()
< *     --12/29/13 22:37-lwang-end----------------------------------------*
41,44d33
< *          CALL JPRED(I,TIME,TIME)
< *     --12/13/13 10:49-lwang-update-------------------------------------*
< ***** Note: From sverre code Sep.4,2013, More accurate dt
< *          DT = 0.1*STEP(I)
46,56c35,42
< *     --12/13/13 10:49-lwang-end----------------------------------------*
< *         Suppress the TIME determination to fix TIME = TBLOCK
< c$$$          IF (DT.GT.2.4E-11) THEN
< c$$$              TIME2 = TIME - TPREV
< c$$$              CALL STEPK(DT,DTN)
< c$$$              TIME = TPREV + INT((TIME2 + DT)/DTN)*DTN
< c$$$              TIME = MIN(TBLOCK,TIME)
< c$$$          ELSE
< c$$$              TIME = MIN(T0(I) + STEP(I),TBLOCK)
< c$$$          END IF
<           TIME = TBLOCK
---
>           IF (DT.GT.2.4E-11) THEN
>               TIME2 = TIME - TPREV
>               CALL STEPK(DT,DTN)
>               TIME = TPREV + INT((TIME2 + DT)/DTN)*DTN
>               TIME = MIN(TBLOCK,TIME)
>           ELSE
>               TIME = MIN(T0(I) + STEP(I),TBLOCK)
>           END IF
68d53
< *              CALL JPRED(J,TIME,TIME)
106,107c91
<                   if(rank.eq.0)
<      &            WRITE (6,4)  KSPAIR, NAME(J), H(KSPAIR), ECC, SEMI,
---
>                   WRITE (6,4)  KSPAIR, NAME(J), H(KSPAIR), ECC, SEMI,
134c118
<           IF (rank.eq.0.and.RX.LT.20.0*RMIN) THEN
---
>           IF (RX.LT.20.0*RMIN) THEN
147,148c131
<                   if(rank.eq.0)
<      &            WRITE (6,6)  NAM1, NAM2, LISTD(K), K
---
>                   WRITE (6,6)  NAM1, NAM2, LISTD(K), K
176,187c159,167
< *     --12/13/13 10:50-lwang-update-------------------------------------*
< ***** Note: From Sverre Sep.4,2013 (suppressed)------------------------**
< *     PreMS collision scheme: -1, -1 ==> -1; -1, 0 ==> -1; -1, x ==> x.
<               ICASE = KTYPE(K1,K2)
< c$$$             IF (K1.LT.0.OR.K2.LT.0) THEN
< c$$$                 ICASE = -1
< c$$$                 IF (MAX(K1,K2).EQ.0) ICASE = -1
< c$$$                 IF (MAX(K1,K2).GT.0) ICASE = MAX(K1,K2)
< c$$$             ELSE
< c$$$                 ICASE = KTYPE(K1,K2)
< c$$$             END IF
< *     --12/13/13 10:51-lwang-end-update---------------------------------*
---
> *       PreMS collision scheme: -1, -1 ==> -1; -1, 0 ==> -1; -1, x ==> x.
>               IF (K1.LT.0.OR.K2.LT.0) THEN
>                   ICASE = -1
>                   IF (MAX(K1,K2).EQ.0) ICASE = -1
>                   IF (MAX(K1,K2).GT.0) ICASE = MAX(K1,K2)
>               ELSE
>                   ICASE = KTYPE(K1,K2)
>                   IF (MAX(K1,K2).EQ.14) ICASE = 200
>               END IF
201,202d180
< *       Remove from NXTLST
<               call delay_remove_tlist(JCL,STEP,DTK)
204,205d181
< *       Add to NLSTDELAY
<               call delay_store_tlist(JCL)
213c189
<           IF(KZ(9).GE.3.AND.MAX(KSTAR(I1),KSTAR(I2)).GE.10)THEN
---
>           IF(KZ(8).GT.3.AND.MAX(KSTAR(I1),KSTAR(I2)).GE.10)THEN
220c196
<           IF (KZ(9).GE.2) THEN
---
>           IF (KZ(8).GT.3) THEN
237,238d212
< *       Remove from NXTLST
< C          call delay_remove_tlist(I1,STEP,DTK)
240,241d213
< *       Add to NLSTDELAY
< C          call delay_store_tlist(I1)
258c230,233
<           ECC = 1.0 + 2.0*EBS*DMINC/(BODY(I1)*BODY(I2))
---
>           DMINC = MIN(DMINC,RCOLL)
>           SEMI = -0.5*BODY(I1)*BODY(I2)/EBS
> *       Note the QUAD common also used for TRIPLE.
>           ECC = 1.0 - RCOLL4/SEMI
274,280c249
< *     --12/13/13 10:54-lwang-update-------------------------------------*
< ***** Note: From Sverre Sep.4. 2013------------------------------------**
< c$$$              ECC = 1.0 + 2.0*EBS*DMINC/(BODY(I1)*BODY(I2))
< c$$$              ECC = MAX(ECC,0.0D0)
< *     --12/13/13 10:54-lwang-end----------------------------------------*
<               if(rank.eq.0)
<      &        WRITE (86,9)  TPHYS, NAME(I1), NAME(I2), KSTAR(I1),
---
>               WRITE (86,9)  TPHYS, NAME(I1), NAME(I2), KSTAR(I1),
307,308c276
<                           if(rank.eq.0)
<      &                    WRITE (6,10)  KSTAR(I1), KSTAR(I2), DTMAX
---
>                           WRITE (6,10)  KSTAR(I1), KSTAR(I2), DTMAX
344c312
< *     Set T0 = TIME for correct potential energy correction in FCORR.
---
> *       Set T0 = TIME for correct potential energy correction in FCORR.
349,350d316
< *       Remove from NXTLST
<               call delay_remove_tlist(J,STEP,DTK)
352,353d317
< *       Add to NLSTDELAY
<               call delay_store_tlist(J)
357,367d320
< *     --12/13/13 10:55-lwang-update-------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$*     Ensure the heaviest body is new progenitor (only ICOMP is needed).
< c$$$      IF (BODY(I2).GT.BODY(I1)) THEN
< c$$$          I1S = I1
< c$$$          I1 = I2
< c$$$          I2 = I1S
< c$$$          ICOMP = I1
< c$$$          JCOMP = I2
< c$$$      END IF
< c$$$*
370,372c323,325
<          NAM1 = NAME(I1)
<          NAME(I1) = NAME(I2)
<          NAME(I2) = NAM1
---
>           NAM1 = NAME(I1)
>           NAME(I1) = NAME(I2)
>           NAME(I2) = NAM1
374,375c327
<       
< *     --12/13/13 10:56-lwang-end----------------------------------------*
---
> *
396c348
< *       Compensate EGRAV for any chain mass loss.
---
> *       Compensate EGRAV for any chain (or TRIPLE/QUAD) mass loss.
401d352
< *                  CALL JPRED(J,TIME,TIME)
409,412c360,362
<               if(rank.eq.0)
<      &        WRITE (6,19)  NSYS, EGRAV, EGRAV - EG0
<    19         FORMAT (' CMAIN MASS LOSS    NSYS EGRAV DEGR ',
<      &                                     I4,1P,2E10.2)
---
>               WRITE (6,19)  NSYS, EGRAV, EGRAV - EG0
>    19         FORMAT (' CHAIN/TRIPLE MASS LOSS    NSYS EGRAV DEGR ',
>      &                                            I4,1P,2E10.2)
426,431c376
< *     Remove ghost particle and old particle
<       call delay_remove_tlist(I2,STEP,DTK)
< C     STEP(I2) = DTMAX
<       STEP(I2) = 2*DTK(1)
< *     Add ghost particle into NXTLST
<       call add_tlist(I2,STEP,DTK)
---
>       STEP(I2) = DTMAX
483c428
< *       Determine index and set neighbour membership of original chain c.m.
---
> *       Determine index and set neighbour membership of original c.m.
494c439
< *       Update neighbour lists of current chain c.m. and remove ghost I2.
---
> *       Update neighbour lists of current c.m. and remove ghost I2.
503a449,454
> *       Determine new neighbour list for first CHAIN/TRIPLE member #I1.
>       IF (NSYS.GT.2) THEN
>           RSI = RSCALE*(10.0/FLOAT(N - NPAIRS))**0.3333
>           CALL NBLIST(I1,RSI)
>       END IF
> *
507,512d457
< *       Determine neighbour list for chain member.
<           IF (NSYS.GT.2) THEN
<               RSI = RSCALE*(10.0/FLOAT(N - NPAIRS))**0.3333
<               CALL NBLIST(I1,RSI)
<           END IF
< *
538d482
< *              call xbpredall
541d484
< *                  CALL JPRED(J,TIME,TIME)
544d486
<                       X0(K,J) = X(K,J)
546,547d487
< *     Remove J particle first from NXTLST
<                   call delay_remove_tlist(J,STEP,DTK)
550,551d489
< *     Add J particle into NLSTDELAY
<                   call delay_store_tlist(J)
554c492,493
<           TPREV = TIME - STEPX
---
> *       Note danger of multiple collisions on same block-step (early times).
> *         TPREV = TIME - STEPX
560,561d498
< *     Remove I1 particle first from NXTLST
<           call delay_remove_tlist(I1,STEP,DTK)
563,564d499
< *     Add J particle into NLSTDELAY
<           call delay_store_tlist(I1)
591,592c526
<               if(rank.eq.0)
<      &        WRITE (6,38)  NAME(I1)
---
>               WRITE (6,38)  NAME(I1)
622,623d555
< *     Remove ICOMP particle first from NXTLST
<       call delay_remove_tlist(ICOMP,STEP,DTK)
626,628d557
< *     Add new particle into NLSTDELAY
<       call delay_store_tlist(ICOMP)
< 
630d558
<           call delay_remove_tlist(I5,STEP,DTK)
633,636c561
< *     Add new particle into NLSTDELAY
<           call delay_store_tlist(I5)
<           if(rank.eq.0)
<      &    WRITE (6,42)  NAME(I5), STEP(I5)
---
>           WRITE (6,42)  NAME(I5), STEP(I5)
683c608
<           OPEN (UNIT=26,STATUS='UNKNOWN',FORM='FORMATTED',FILE='COAL2')
---
>           OPEN (UNIT=26,STATUS='NEW',FORM='FORMATTED',FILE='COAL2')
687d611
<           if(rank.eq.0)then
697d620
<           end if
704d626
<           if(rank.eq.0)then
709a632,633
>           R1 = RADIUS(I1)*SU
>           R2 = RADIUS(I2)*SU
715d638
<           end if
722,723c645
<       if(rank.eq.0)
<      &WRITE (6,90)  WHICH1, NSYS, NAME1, NAME2, ZM*SMU, RCOLL, EB,
---
>       WRITE (6,90)  WHICH1, NSYS, NAME1, NAME2, ZM*SMU, RCOLL, EB,
734,738c656
< *     --12/13/13 10:57-lwang-update-------------------------------------*
< ***** Note: From Sverre Sep.4 2013-------------------------------------**
< c$$$          NSUB = NSUB - 1
<          NSUB = MAX(NSUB - 1,0)
< *     --12/13/13 10:57-lwang-end----------------------------------------*
---
>           NSUB = MAX(NSUB - 1,0)
30,31c30,31
<       IF (NB.GT.0.AND.FIRST.AND.KSTART.EQ.1) THEN
< *          OPEN (UNIT=4,STATUS='UNKNOWN',FORM='FORMATTED',FILE='DEGEN')
---
>       IF (NB.GT.0.AND.FIRST) THEN
>           OPEN (UNIT=4,STATUS='NEW',FORM='FORMATTED',FILE='DEGEN')
35,49c35,43
<           if(rank.eq.0)then
<              WRITE (4,2)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
<      &            NBIN0, NZERO
<  2           FORMAT (/,6X,1P, 'MODEL:    RBAR =',E26.17,'  <M>[M*] =',
<      &            E26.17,'  M1[M*] =',E26.17,'  TSCALE =',E26.17,0P,
<      &            '  NB0 =',I12,'  N0 =',I12,//)
< *     
<              WRITE (4,3)
<  3           FORMAT ('       ICASE                 Time[Myr]',
<      &         '                  SEMI[AU]                       ECC',
<      &         '                   PERI/RS                   P[days]',
<      &         '                    RI[PC]                 M(I1)[M*]',
<      &         '                 M(I2)[M*]      K*(I1)      K*(I2)',
<      &         '     K*(ICM)    NAME(I1)    NAME(I2)',/)
<           end if
---
>           WRITE (4,2)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
>      &                 NBIN0, NZERO
>     2     FORMAT (/,6X,'MODEL:    RBAR =',F5.1,'  <M> =',F6.2,
>      &                 '  M1 =',F6.1,'  TSCALE =',F6.2,
>      &                 '  NB =',I4,'  N0 =',I6,//)
> *
>           WRITE (4,3)
>     3     FORMAT (' #   TPHYS    A     E     Rp/R*      P    r',
>      &            '     M1   M2    K*         NAME',/)
61d54
<           CALL JPRED(ICM,TIME,TIME)
74c67
< C              EB(JPAIR) = MAX(EB(JPAIR),-9.99999d0)
---
>               EB(JPAIR) = MAX(EB(JPAIR),-9.99999d0)
107c100
< C          TK = MIN(TK,999999.9d0)
---
>           TK = MIN(TK,999999.9d0)
110c103
< C          RATIO = MIN(RATIO,99.9d0)
---
>           RATIO = MIN(RATIO,99.9d0)
114c107
<               if(rank.eq.0) WRITE (4,*)
---
>               WRITE (4,*)
116,122c109,113
<           if(rank.eq.0)then
<           WRITE (4,*)  ICASE, TPHYS, SEMI(JPAIR), ECC(JPAIR), RATIO,
<      &            TK, RCM(JPAIR)*RBAR, BODY(J1)*ZMBAR,
<      &            BODY(J2)*ZMBAR,KSTAR(J1), KSTAR(J2),
<      &            KSTAR(ICM),NAME(J1), NAME(J2)
< C   10     FORMAT (I2,F8.1,F8.2,F7.3,F6.1,F9.1,F6.2,2F5.1,3I4,2I6)
<           end if
---
>           WRITE (4,10)  ICASE, TPHYS, SEMI(JPAIR), ECC(JPAIR), RATIO,
>      &                  TK, RCM(JPAIR), BODY(J1)*ZMBAR, BODY(J2)*ZMBAR,
>      &                  KSTAR(J1), KSTAR(J2), KSTAR(ICM),
>      &                  NAME(J1), NAME(J2)
>    10     FORMAT (I2,F8.1,F8.2,F7.3,F6.1,F9.1,F6.2,2F5.1,3I4,2I6)
131c122
< *       Search for neutron stars at main output. (seem never used)
---
> *       Search for neutron stars at main output.
135,137c126,128
<                   IF (rank.eq.0.and.FIRST2) THEN
<                       OPEN (UNIT=33,STATUS='UNKNOWN',FORM='FORMATTED',
<      &                    FILE='ns.33',ACCESS='APPEND')
---
>                   IF (FIRST2) THEN
>                       OPEN (UNIT=33,STATUS='NEW',FORM='FORMATTED',
>      &                                                 FILE='NS')
143d133
<                       CALL JPRED(I,TIME,TIME)
151d140
<                   if(rank.eq.0)then
154,155c143,144
<    25             FORMAT (1X,A8,'NS','  I NAME IFIRST K* Time[Myr] ',
<      &                 'VI[km/s] ', 3I12,I4,1P,E25.16,E16.7,0P)
---
>    25             FORMAT (1X,A8,'NS','  J NAM I* K* TPH V ',
>      &                                  2I6,I5,I4,2F7.1)
157d145
<                   end if
164,165c152,153
<                       OPEN (UNIT=34,STATUS='UNKNOWN',FORM='FORMATTED',
<      &                    FILE='bh.34',ACCESS='APPEND')
---
>                       OPEN (UNIT=34,STATUS='NEW',FORM='FORMATTED',
>      &                                                 FILE='BH')
174d161
<                      CALL JPRED(J,TIME,TIME)
186d172
<                       if(rank.eq.0)then
188,189c174
<    28                 FORMAT (1X,A8,'I NAME K* Time[Myr] VI[km/s] ',
<      &                     2I12,I4,1P,E25.16,E16.7,0P)
---
>    28                 FORMAT (1X,A8,'J NAM K* TPH V ',2I6,I4,2F7.1)
191d175
<                       end if
203d186
<           if(rank.eq.0)then
205d187
<           end if
216d197
<               if(rank.eq.0)then
220d200
<               end if
8d7
< *     Unsafe for parallel! update variables: tmdis
14d12
< *     Unsafe for parallel!
119c117
<           CALL FLUSH(3)
---
>           CALL FLUSH(6)
131c129
<           CALL FLUSH(3)
---
>           CALL FLUSH(6)
1c1
<       SUBROUTINE ECIRC(RP,ES0,I1,I2,TG,TC,ECC1,EDOT)
---
>       SUBROUTINE ECIRC(RP,ES0,I1,I2,ICIRC,TG,TC,ECC1,EDOT)
41c41
<               CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,ZN,QL)
---
>               CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,XN,QL)
62c62
<           RP1 = RP/RADIUS(I1)
---
> 	  RP1 = RP/RADIUS(I1)
64c64
<           M21 = BODY(I1)/BODY(I2)
---
> 	  M21 = BODY(I1)/BODY(I2)
66c66
<           RP1 = RP/RADIUS(I2)
---
> 	  RP1 = RP/RADIUS(I2)
69c69
< *     Evaluate damping coefficient.
---
> *	Evaluate damping coefficient.
80c80
< *     Form rational function approximation to Hut solution.
---
> *	Form rational function approximation to Hut solution.
88c88
<      &     /(C(5) + C(6)*Z)
---
>      &	                                      /(C(5) + C(6)*Z)
11c11
<       REAL*8  ZETA,COEFF(6),EFAC3,Y
---
>       REAL*8  ZETA,COEFF(6),EFAC3
3,5c3,4
< *
< *       Common envelope stage of interacting stars.
< *       -------------------------------------------
---
> *       Common envelope stage of interacting stars & BH.
> *       ------------------------------------------------
19d17
<       call xbpredall
28a27,33
> *       Switch to #I2 if #I1 is a BH (standard case not affected).
>       IF (KSTAR(I1).EQ.14.AND.KZ(43).GE.2) THEN
>           II = I1
>           I1 = I2
>           I2 = II
>       END IF
> *
57a63,98
>       RP1 = R(IPAIR)
>       ISKIP = 0
> *
> *       Include special disruption treatment for BH + star.
>       IF (MAX(KSTAR(I1),KSTAR(I2)).EQ.14.AND.KZ(43).GE.2) THEN
> *       Enforce coalescence of two black holes (extremely rare)..
>           IF (MIN(KSTAR(I1),KSTAR(I2)).EQ.14) THEN
>               COALS = .TRUE.
>               SEMI = SEMI0
>               GO TO 4
>           END IF
>           DM1 = 0.1*BODY(I1)*ZMBAR
> *       Conserve total mass and specific energy (H = const here).
>           M1 = M1 - DM1
>           M2 = M2 + DM1
>           R1 = RADIUS(I1)*SU
>           R2 = RADIUS(I2)*SU
> *       Skip hyperbolic motion.
>           IF (H(IPAIR).LT.0.0) THEN
>               CALL KSPERI(IPAIR)
>               TIME = TBLOCK
> *       Transform to positive radial velocity and obtain global coordinates.
>               JPAIR = 0
>               CALL KSAPO(JPAIR)   ! note JPAIR = KSPAIR on return.
> *       Note zero argument which advances eccentric anomaly to R = SEMI.
>               T0(I1) = TBLOCK
>               WRITE (6,2)  R(IPAIR), TDOT2(IPAIR)
>     2         FORMAT (' KSAPO TRANSF    R TD2 ',1P,2E10.2)
>           END IF
>           CALL RESOLV(IPAIR,1)
>           COALS = .FALSE.
>           SEMI = SEMI0
>           ISKIP = 1
> *       Skip common envelope part for BH + star interaction.
>           GO TO 4
>       END IF
68c109
<          if(rank.eq.0)WRITE(38,*)' EXPEL TYPE CHANGE1 ',KSTAR(I1),KW1
---
>          WRITE(38,*)' EXPEL TYPE CHANGE1 ',KSTAR(I1),KW1
80c121
<             if(rank.eq.0)WRITE(38,*)' EXPEL TYPE CHANGE2 ',KSTAR(I2),KW2
---
>              WRITE(38,*)' EXPEL TYPE CHANGE2 ',KSTAR(I2),KW2
85d125
< C      PERI = SEP*(1-ECC)
87,91c127,129
<            COALS = .TRUE.
< cnew-abbas-26/07/2017
<            KW1 = KTYPE(KSTAR(I1),KSTAR(I2))
<            IF (KW1.GT.100) KW1 = KW1 - 100
< cnew-abbas-26/07/2017
---
>           COALS = .TRUE.
>           KW1 = KTYPE(KSTAR(I1),KSTAR(I2))
>           IF (KW1.GT.100) KW1 = KW1 - 100
97,98c135,136
< *         if(rank.eq.0)WRITE (77,7)  TIME, ECC, DMS, SEMI0*SU-SEP
< *   7     FORMAT (' FAIL!    T ECC DMS DSEP ',F12.4,F8.4,1P,2E10.2)
---
> *         WRITE (77,3)  TIME, ECC, DMS, SEMI0*SU-SEP
> *   3     FORMAT (' FAIL!    T ECC DMS DSEP ',F12.4,F8.4,1P,2E10.2)
115c153
<       ZMU0 = BODY(I1)*BODY(I2)/BODY(I)
---
>     4 ZMU0 = BODY(I1)*BODY(I2)/BODY(I)
120c158
< *       Add current energy (final state: coalescence or close binary).
---
> *       Add current energy (final state: coalescence, binary or disruption).
133c171
<               if(rank.eq.0)WRITE (6,5)  KW1, M1, M2
---
>               WRITE (6,5)  KW1, M1, M2
136c174
<           CALL COAL(IPAIR,KW1,MI)
---
>           CALL COAL(IPAIR,KW1,KW2,MI)
160c198
<           EGRAV = EGRAV - ZMU*H(IPAIR)
---
> *         EGRAV = EGRAV - ZMU*H(IPAIR)
161a200
>           IF (ISKIP.EQ.0) THEN
163c202
<           RX = R(IPAIR)/(1.0 - ECC)
---
>               RX = R(IPAIR)/(1.0 - ECC)
165,166c204,209
<           CALL EXPAND(IPAIR,RX)
<           CALL RESOLV(IPAIR,1)
---
>               CALL EXPAND(IPAIR,RX)
>               CALL RESOLV(IPAIR,1)
>           ELSE
> *       Fine-tune the variables (especially for hyperbolic pericentre).
>               CALL RESOLV(IPAIR,1)
>           END IF
174,175c217,229
<           if(rank.eq.0)
<      &    WRITE (6,10)  WHICH1, NAME(I1), NAME(I2), KSTAR(I1),KSTAR(I2),
---
>           IF (ISKIP.GT.0)  THEN
>               WHICH1 = 'DISRUPT '
>               NDISR = NDISR + 1
> *       Restore mass of accreted star for diagnostics only (from 23/5/14).
>               M1 = 10.0*DM1
>               WRITE (24,6)  TIME+TOFF, NDISR, NAME(I1), KSTAR(I1),
>      &                      ECC, MIN(M1,M2), MAX(M1,M2), SEMI
>     6         FORMAT (' DISRUPT1    T NDISR NM K* E M1 M2 SEMI ',
>      &                              F8.1,I5,I7,I4,F10.6,2F6.1,1P,E10.2)
>               CALL FLUSH(24)
>           END IF
> *
>           WRITE (6,10)  WHICH1, NAME(I1), NAME(I2), KSTAR(I1),KSTAR(I2),
177,179c231,233
<      &                  SEMI0*SU, SEMI*SU
<    10     FORMAT (A8,'CE    NAM K0* K* M1 M2 DM E0 E R1 R2 A0 A ',
<      &                      2I6,4I3,3F5.1,2F8.4,2F7.1,1P,E9.1,0P,F7.1)
---
>      &                  RP1, SEMI0*SU, SEMI*SU
>    10     FORMAT (A8,'CE    NAM K0* K* M1 M2 DM E0 E R1 R2 RP A0 A ',
>      &                      2I6,4I3,F5.1,F6.1,F5.1,2F10.6,2F7.1,1P3E9.1)
190c244
<                       if(rank.eq.0)WRITE (6,8)  RL1*SEP, RL2*SEP
---
>                       WRITE (6,8)  RL1*SEP, RL2*SEP
194,195d247
< *     --10/29/13 14:30-lwang-bug-fix------------------------------------*
< ***** Note: INITIAL the new seperation for the next loop---------------**
199c251
<                          CALL FICORR(I,DM)
---
>                           CALL FICORR(I,DM)
201c253
<                          CALL FCORR(I,DM,0)
---
>                           CALL FCORR(I,DM,0)
204d255
< *     --10/29/13 14:30-lwang-end----------------------------------------*
215,216c266,267
< *       Obtain neighbour list for force corrections and polynomials.
<           NNB = LIST(1,I)
---
> *       Save perturber list for force corrections and polynomials.
>           NNB = LIST(1,I1)
218c269
<               ILIST(L) = LIST(L,I)
---
>               ILIST(L) = LIST(L,I1)
222c273
<          IF (KW1.EQ.15.OR.KW2.EQ.15) THEN
---
>           IF (KW1.EQ.15.OR.KW2.EQ.15) THEN
228,232c279
< *        remove from NXTLST
<             call delay_remove_tlist(I,STEP,DTK)
<             STEP(I) = 2*DTK(1)
< *        add into ghost list
<             call add_tlist(I,STEP,DTK)
---
>             STEP(I) = 1.0D+06
245c292
<             if(rank.eq.0)WRITE (6,13)  NAME(I), KSTAR(I), BODY(I)*ZMBAR
---
>             WRITE (6,13)  NAME(I), KSTAR(I), BODY(I)*ZMBAR
246a294
> *
248c296
<           ELSE IF (KW1.GE.10) THEN
---
>           ELSE IF (KW1.GE.10.OR.ISKIP.GT.0) THEN
256a305,308
>               IF (ISKIP.GT.0) THEN
> *       Ensure binary velocity kick by setting BH index (not saved).
>                   KW1 = 14
>               END IF
289d340
< *              call xbpredall
294d344
<                       X0(K,J) = X(K,J)
296,297d345
< *     remove J from NXTLST
<                   call delay_remove_tlist(J,STEP,DTK)
300,301d347
< *     Add J into NLSTDELAY
<                   call delay_store_tlist(J)
304a351,352
> *       Check for possible WD/NS/BH kick.
>               IF (KW1.GE.13.OR.KZ(25).GT.0) THEN
306,308c354,357
<               I = I1 + 2*(NPAIRS - IPAIR)
<               CALL KSTERM
<               CALL KICK(I,1,KW1,DM)
---
>                   I = I1 + 2*(NPAIRS - IPAIR)
>                   IF (ISKIP.GT.0) KW1 = KSTAR(I1)
>                   CALL KSTERM
>                   CALL KICK(I,1,KW1,DM)
310,314c359,367
<               ICOMP = IFIRST
<               JCOMP = IFIRST + 1
<               CALL KSREG
<               IPHASE = -1
< *
---
>                   ICOMP = IFIRST
>                   JCOMP = IFIRST + 1
>                   CALL KSREG
>                   IPHASE = -1
> *
> *       Avoid negative radial velocity for same star (TD2 is small).
>                   IF (ISKIP.GT.0.AND.TDOT2(NPAIRS).LT.0.0) THEN
>                       IF (ECC.GT.1.0) TDOT2(NPAIRS) = 0.0
>                   END IF
316c369,371
<               I = NTOT
---
>                   I = NTOT
>                   IPAIR = NPAIRS
>               END IF
320c375
<                  if(rank.eq.0)WRITE (6,35)  KW1, R(IPAIR)/SEMI, SEMI*SU,
---
>                   WRITE (6,35)  KW1, R(IPAIR)/SEMI, SEMI*SU,
347c402
<                           if(rank.eq.0)WRITE (6,38) NAME(I1),NCHAOS,ECC
---
>                           WRITE (6,38)  NAME(I1), NCHAOS, ECC
365,366d419
< *     remove from NXTLST
<                   call delay_remove_tlist(I,STEP,DTK)
368,369d420
< *     add into NLSTDELAY
<                   call delay_store_tlist(I)
402,403d452
< *     remove from NXTLST
<                           call delay_remove_tlist(J,STEP,DTK)
405,406d453
< *     remove from NXTLST
<                           call delay_remove_tlist(J,STEP,DTK)
411d457
<                               X0(K,J) = X(K,J)
416,417d461
< *     add into NLSTDELAY
<                       call delay_store_tlist(J)
449,456d492
< 
< 
< 
< 
< 
< 
< 
< 
84,93d83
< *       Update the stars to previous latest time (only for original KS pair).
< *     ID = 0
< *       Check original identity (NCH=3 may have been reduced from B-B).
< *     DO 2 L = 1,2
< *         IF (NAME(I1) + NAME(I2).EQ.KSAVE(2*L)) THEN
< *             ID = 1
< *         END IF
< *   2 CONTINUE
<       TEV1 = MAX(TEV0(I1),TEV0(I2))
< *
94a85
>       TEV1 = MAX(TEV0(I1),TEV0(I2))
119c110
<       if(rank.eq.0.and.kw1.ne.kstar(i1))then
---
>       if(kw1.ne.kstar(i1))then
132c123
<           if(rank.eq.0.and.kw2.ne.kstar(i2))then
---
>           if(kw2.ne.kstar(i2))then
139,140c130
< *         if(rank.eq.0)
< *    &    WRITE (78,7) TIME, ECC, DMSUN, SEMI0*SU-SEP
---
> *         WRITE (78,7) TIME, ECC, DMSUN, SEMI0*SU-SEP
157,158c147
<                       if(rank.eq.0)
<      &                WRITE (6,8)  RL1*SEP, RL2*SEP
---
>                       WRITE (6,8)  RL1*SEP, RL2*SEP
193,194c182
<               if(rank.eq.0)
<      &        WRITE (6,10)  M1, M2
---
>               WRITE (6,10)  M1, M2
198c186
<           CALL COAL(IPAIR,KW1,MI)
---
>           CALL COAL(IPAIR,KW1,KW2,MI)
258,263d245
<           DO K = 1,3
<              X0(K,I1) = X(K,I1) 
<              X0DOT(K,I1) = XDOT(K,I1)  
<              X0(K,I2) = X(K,I2)        
<              X0DOT(K,I2) = XDOT(K,I2)  
<           END DO 
282d263
<           call xbpredall
305d285
<           if(rank.eq.0)then
307c287
<    55     FORMAT (' EXPEL2!    DM*POTJ RX A00 A0 EBS ',1P,6E10.2)
---
>    55     FORMAT (' EXPEL2    DM*POTJ RX A00 A0 EBS ',1P,6E10.2)
313d292
<           end if
315c294
<           IF (rank.eq.0.and.SEMI0.LT.0.0) THEN
---
>           IF (SEMI0.LT.0.0) THEN
337,340c316
< C*       Initialize neighbour force polynomials on significant mass loss.
< C      IF (DM*SMU.GT.0.1) THEN
<       call xbpredall
< *     Save reference body in temporary variables.
---
> *       Save reference body in temporary variables (original chain masses).
342,347c318,322
<          XREL(K) = X(K,ICH)
<          VREL(K) = XDOT(K,ICH)
<          XCM(K) = 0.0
<          VCM(K) = 0.0
<  70   CONTINUE
< C      SAVEB = BODY(ICH)
---
>           XREL(K) = X(K,ICH)
>           VREL(K) = XDOT(K,ICH)
>           XCM(K) = 0.0
>           VCM(K) = 0.0
>    70 CONTINUE
352,359c327,334
<          J = JLIST(L)
<          IF (J.EQ.0) GO TO 80
<          ZM = ZM + BODY(J)
<          DO 75 K = 1,3
<             XCM(K) = XCM(K) + BODY(J)*X(K,J)
<             VCM(K) = VCM(K) + BODY(J)*XDOT(K,J)
<  75      CONTINUE
<  80   CONTINUE
---
>           J = JLIST(L)
>           IF (J.EQ.0) GO TO 80
>           ZM = ZM + BODY(J)
>           DO 75 K = 1,3
>               XCM(K) = XCM(K) + BODY(J)*X(K,J)
>               VCM(K) = VCM(K) + BODY(J)*XDOT(K,J)
>    75     CONTINUE
>    80 CONTINUE
362,367c337,340
<          X(K,ICH) = XCM(K)/ZM
<          XDOT(K,ICH) = VCM(K)/ZM
<          X0(K,ICH) = X(K,ICH)
<          X0DOT(K,ICH) = XDOT(K,ICH)
<  85   CONTINUE
< 
---
>           X(K,ICH) = XCM(K)/ZM
>           XDOT(K,ICH) = VCM(K)/ZM
>    85 CONTINUE
> *
378a352,361
> *       Restore the ghosts to neighbours of #ICH. (bug 13/5/14)
>       JLIST(1) = I1
>       JLIST(2) = I2
>       JLIST(3) = I3
>       NNB = LIST(1,ICH)
>       DO 86 L = 2,NNB+1
>           JPERT(L-1) = LIST(L,ICH)
>    86 CONTINUE
>       CALL NBREST(ICH,3,NNB)
> *
386,406c369,383
<          IF (DMSUN.LT.0.2) THEN
<             J = LISTC(L)
<          ELSE
<             J = LIST(L,ICH)
<          END IF
< C         IF (J.EQ.I1.OR.J.EQ.I3.OR.J.EQ.I4) GO TO 95
< *     remove from NXTLST
<          call delay_remove_tlist(J,STEP,DTK)
<          CALL DTCHCK(TIME,STEP(J),DTK(40))
<          DO 90 KK = 1,3
<             X0DOT(KK,J) = XDOT(KK,J)
<             X0(KK,J) = X(KK,J)
<  90      CONTINUE
<          SJR = STEPR(J)
<          CALL FPOLY1(J,J,0)
<          CALL FPOLY2(J,J,0)
< *     Replace possible small regular step with current value above 1D-04.
<          IF (SJR.GT.1.0D-04) STEPR(J) = SJR
< *     add into NLSTDELAY
<          call delay_store_tlist(J)
<  95   CONTINUE
---
>           IF (DMSUN.LT.0.2) THEN
>               J = LISTC(L)
>           ELSE
>               J = LIST(L,ICH)
>           END IF
>           CALL DTCHCK(TIME,STEP(J),DTK(40))
>           DO 90 KK = 1,3
>               X0DOT(KK,J) = XDOT(KK,J)
>    90     CONTINUE
>           SJR = STEPR(J)
>           CALL FPOLY1(J,J,0)
>           CALL FPOLY2(J,J,0)
> *       Replace possible small regular step with current value above 1D-04.
>           IF (SJR.GT.1.0D-04) STEPR(J) = SJR
>    95 CONTINUE
414,420c391,393
<          X(K,ICH) = XREL(K)
<          XDOT(K,ICH) = VREL(K)
<          X0(K,ICH) = X(K,ICH)
<          X0DOT(K,ICH) = XDOT(K,ICH)
<  99   CONTINUE
< C          BODY(ICH) = SAVEB
< C      END IF
---
>           X(K,ICH) = XREL(K)
>           XDOT(K,ICH) = VREL(K)
>    99 CONTINUE
8c8,13
<       INTEGER  NTYPE(17)
---
>       PARAMETER  (NMX=10,NMX4=4*NMX)
>       COMMON/CHAINC/  XC(3,NCMAX),UC(3,NCMAX),BODYC(NCMAX),ICH,
>      &                LISTC(LMAX)
>       COMMON/CCOLL2/  QK(NMX4),PK(NMX4),RIK(NMX,NMX),SIZE(NMX),VSTAR1,
>      &                ECOLL1,RCOLL,QPERI,ISTAR(NMX),ICOLL,ISYNC,NDISS1
>       INTEGER  NTYPE(17),IHIST(10)
14,38c19,55
< C      IF (NMDOT.GT.0) THEN
<       DO 5 J = 1,16
<          NTYPE(J) = 0
<  5    CONTINUE
< *     
<       KM = 1
<       DO 10 J = 1,N
<          KW = KSTAR(J) + 1
<          KW = MIN(KW,16)
<          KW = MAX(KW,1)
<          NTYPE(KW) = NTYPE(KW) + 1
<          KM = MAX(KM,KW)
<  10   CONTINUE
< *
<       if(rank.eq.0)then
<          WRITE (6,15)
<  15      FORMAT (/,6X,'  NMDOT NRG  NHE  NRS  NNH  NWD  NSN  NBH  NBS',
<      &        '  ZMRG  ZMHE  ZMRS  ZMNH  ZMWD  ZMSN   ZMDOT',
<      &        '  NTYPE')
<          WRITE (6,20)  NMDOT, NRG, NHE, NRS, NNH, NWD, NSN, NBH, NBS,
<      &        ZMRG, ZMHE, ZMRS, ZMNH, ZMWD, ZMSN, ZMDOT,
<      &        (NTYPE(J),J=1,KM)
<  20      FORMAT (' #4',I9,8I5,6F6.1,F8.1,I7,I6,9I4,I5,3I7)
<       end if
< C      END IF
---
>       NS = 0
>       NB = 0
>       IF (NMDOT.GT.0) THEN
>           DO 5 J = 1,16
>               NTYPE(J) = 0
>     5     CONTINUE
> *
>           KM = 1
>           ZMX = 0.0
>           ZMS = 0.0
>           NSS = 0
>           DO 10 J = 1,N
>               KW = KSTAR(J) + 1
>               KW = MIN(KW,16)
>               KW = MAX(KW,1)
>               NTYPE(KW) = NTYPE(KW) + 1
>               KM = MAX(KM,KW)
>               ZMX = MAX(BODY(J),ZMX)
> *       Determine mean mass of luminous stars.
>               IF (KSTAR(J).LT.13) THEN
>                   ZMS = ZMS + BODY(J)
>                   NSS = NSS + 1
>               END IF
>               IF (KSTAR(J).EQ.13) NS = NS + 1
>               IF (KSTAR(J).EQ.14) NB = NB + 1
>    10     CONTINUE
>           IF (NSS.GT.0) ZMS = ZMS/FLOAT(NSS)
> *
>           WRITE (6,15)
>    15     FORMAT (/,6X,'NMDOT   NRG  NHE  NRS  NNH  NWD  NSN  NBH  NBS',
>      &               '  ZMRG  ZMHE   ZMRS  ZMNH  ZMWD  ZMSN   ZMDOT',
>      &               '  NTYPE')
>           WRITE (6,20)  NMDOT, NRG, NHE, NRS, NNH, NWD, NSN, NBH, NBS,
>      &                  ZMRG, ZMHE, ZMRS, ZMNH, ZMWD, ZMSN, ZMDOT,
>      &                  (NTYPE(J),J=1,KM)
>    20     FORMAT (' #4',I9,8I5,2F6.1,F7.1,3F6.1,F8.1,I7,I6,9I4,I5,4I4)
>       END IF
57c74
< C      IF (NDISS + NCOLL + NCOAL.GT.0.OR.EGRAV.LT.0.0D0) THEN
---
>       IF (NDISS + NCOLL + NCOAL.GT.0.OR.EGRAV.LT.0.0D0) THEN
59,94c76,127
<       DEGRAV = EBIN + ESUB + EBESC + EMESC + EMERGE + EGRAV - EBIN0
<       ZMX = BODY1*SMU
<       if(rank.eq.0)then
<          WRITE (6,30)
<  30      FORMAT (/,5X,' NDISS NTIDE  NSYNC  NCOLL  NCOAL  NDD  NCIRC',
<      &        '  NROCHE  NRO  NCE  NHYP  NHYPC  NKICK  EBIN ',
<      &        '  EMERGE  ECOLL  EMDOT  ECDOT  EKICK  ESESC ',
<      &        '  EBESC  EMESC  DEGRAV   EBIND  MMAX')
<          WRITE (6,35)  NDISS, NTIDE, NSYNC, NCOLL, NCOAL, NDD, NCIRC,
<      &        NROCHE, NRO, NCE, NHYP, NHYPC, NKICK, EBIN, EMERGE,
<      &        ECOLL, EMDOT, ECDOT, EKICK, ESESC, EBESC,
<      &        EMESC, DEGRAV, E(3), ZMX
<  35      FORMAT (' #5',I8,I6,3I7,I5,I7,I8,2I5,I6,2I7,3F8.3,4F7.3,F8.3,
<      &        F7.3,2F8.3,F6.1)
<       end if
< C      END IF
< 
< *     write to event.35 all counters
<       IF(rank.eq.0) THEN
<          if(kstart.eq.1.and.ttot.eq.0.0) then
<             WRITE(35,40) 
<  40         FORMAT('TIME[Myr] NDISS  NTIDE  NSYNC NCOLL NCOAL ',
<      &           'NDD NCIRC NROCHE NRO NCE NHYP NHYPC NKICK ',
<      &           'EBIN EMERGE ECOLL EMDOT ECDOT EKICK ESESC ',
<      &           'EBESC EMESC DEGRAV EBIND MMAX ',
<      &           'NMDOT NRG NHE NRS NNH NWD NSN NBH NBS ',
<      &           'ZMRG ZMHE ZMRS ZMNH ZMWD ZMSN ZMDOT NTYPE(1:16)')
<          end if
<          write(35,41) TTOT*TSTAR, NDISS, NTIDE, NSYNC, NCOLL, NCOAL,
<      &        NDD, NCIRC,NROCHE, NRO, NCE, NHYP, NHYPC, NKICK,
<      &        EBIN, EMERGE,ECOLL, EMDOT, ECDOT, EKICK, ESESC, EBESC,
<      &        EMESC, DEGRAV, E(3), ZMX,
<      &        NMDOT, NRG, NHE, NRS, NNH, NWD, NSN, NBH, NBS,
<      &        ZMRG, ZMHE, ZMRS, ZMNH, ZMWD, ZMSN, ZMDOT,NTYPE(1:16)
<  41      FORMAT(E26.17,13I12,12E26.17,9I12,7E26.17,16I12)
<          call flush(35)
---
>           DEGRAV = EBIN + ESUB + EBESC + EMESC + EMERGE + EGRAV - EBIN0
>           WRITE (6,30)
>    30     FORMAT (/,5X,'NDISS  NTIDE  NSYNC  NCOLL  NCOAL  NDD  NCIRC',
>      &                 '  NROCHE  NRO  NCE  NHYP  NKICK    EBIN ',
>      &                 '  EMERGE  ECOLL  EMDOT  ECDOT  EKICK  ESESC ',
>      &                 '  EBESC  EMESC  DEGRAV   EBIND  MAXM  TURN',
>      &                 '  NS  NB')
>           WRITE (6,35)  NDISS, NTIDE, NSYNC, NCOLL, NCOAL, NDD, NCIRC,
>      &                  NROCHE, NRO, NCE, NHYP, NKICK, EBIN, EMERGE,
>      &                  ECOLL, EMDOT, ECDOT, EKICK, ESESC, EBESC,
>      &                  EMESC, DEGRAV, E(3), ZMX*SMU, TURN, NS, NB
>    35     FORMAT (' #5',I8,I6,3I7,I5,I7,I8,2I5,I6,I7,3F8.3,4F7.3,F8.3,
>      &                  F7.3,2F8.3,F6.1,F6.2,2I4)
>       END IF
> *
> *       Include plotting file on unit #4 for NS & BHs; also BH mass function.
>       IF (KZ(4).GT.0.AND.NS + NB.GT.0) THEN
>           WRITE (4,40)  (TIME+TOFF)*TSTAR, N, NS, NB
>    40     FORMAT (' T N NS NB ',F7.1,I7,I5,I4)
>           CALL FLUSH(4)
>           IF (KZ(4).GT.1.AND.NB.GT.0) THEN
>               DO 45 J = 1,10
>                   IHIST(J) = 0
>    45         CONTINUE
>               KX = 0
>               DO 50 J = 1,N
>                   IF (KSTAR(J).NE.14.OR.BODY(J).EQ.0.0D0) GO TO 50
>                   IF (NCH.GT.0.AND.J.EQ.ICH) GO TO 50
>                   ZM = BODY(J)*SMU
>                   KK = ZM/4.0 + 1
>                   KK = MIN(KK,10)
>                   KX = MAX(KK,KX)
>                   IHIST(KK) = IHIST(KK) + 1
>    50         CONTINUE
> *
> *       Include any members of chain regularization.
>               IF (NCH.GT.0) THEN
>                   DO 60 J = 1,NCH
>                       IF (ISTAR(J).EQ.14) THEN
>                           ZM = BODYC(J)*SMU
>                           KK = ZM/4.0 + 1
>                           KK = MIN(KK,10)
>                           KX = MAX(KK,KX)
>                           IHIST(KK) = IHIST(KK) + 1
>                       END IF
>    60             CONTINUE
>               END IF
> *       Print histogram of BH masses (factor of 2 from 4.0 Msun).
>               WRITE (93,70)  (TIME+TOFF)*TSTAR, (IHIST(K),K=1,KX)
>    70         FORMAT (' T6 IHIST ',F7.1,10I4)
>               CALL FLUSH(93)
>           END IF
1c1
<       SUBROUTINE GIANT(IPAIR,I,W,Q,WSCALE,QSCALE,ZN,QL)
---
>       SUBROUTINE GIANT(IPAIR,I,W,Q,WSCALE,QSCALE,XN,QL)
11d10
< *     Unsafe for parallel! update variables: cm, used variables: namec
44d42
< *     KS mpi coummincation for CM
46d43
<           call ksparmpi(K_store,K_real8,K_CM_M,L,IC,CM(L,IC))
49d45
< *     KS mpi coummincation for CM
51d46
<           call ksparmpi(K_store,K_real8,K_CM_M,L,IC,CM(L,IC))
65d59
< *     KS mpi coummincation for CM
67d60
<           call ksparmpi(K_store,K_real8,K_CM_M,L,IC,CM(L,IC))
72c65
<       ZCMC = CM(L,IC)*ZMBAR
---
>       ZMC = CM(L,IC)*ZMBAR
74c67
<       ZME = ZM - ZCMC
---
>       ZME = ZM - ZMC
76c69
<       ZL = 1.98D+05*ZCMC**6
---
>       ZL = 1.98D+05*ZMC**6
84,85c77,78
<           IF (K.EQ.1) THEN
<              SW(K) = ((C3*SIG + C2)*SIG + C1)*SIG + C0
---
> 	  IF (K.EQ.1) THEN
>               SW(K) = ((C3*SIG + C2)*SIG + C1)*SIG + C0
87,89c80,82
<              SW(K) = ((E3*SIG + E2)*SIG + E1)*SIG + E0
<           END IF
<           W(K) = SW(K)**2
---
>               SW(K) = ((E3*SIG + E2)*SIG + E1)*SIG + E0
> 	  END IF
> 	  W(K) = SW(K)**2
97,98c90,91
<       ZN = (B2*SW(1) + B1)*SW(1) + B0
< *     WRITE (24,20)  IC, IPAIR, KSTAR(J), CM(L,IC)/BODY(I), RSI, ZN, QL
---
>       XN = (B2*SW(1) + B1)*SW(1) + B0
> *     WRITE (24,20)  IC, IPAIR, KSTAR(J), CM(L,IC)/BODY(I), RSI, XN, QL
104c97
< *     IF (ZN.GE.5.0.OR.QSM.LT.0.00011) THEN
---
> *     IF (XN.GE.5.0.OR.QSM.LT.0.00011) THEN
106c99
< *    &                  RADIUS(I)*SU, QSM, ZN, QL
---
> *    &                  RADIUS(I)*SU, QSM, XN, QL
1c1
<       SUBROUTINE GIANT2(L,I,W,Q,WSCALE,QSCALE,ZN,QL)
---
>       SUBROUTINE GIANT2(L,I,W,Q,WSCALE,QSCALE,XN,QL)
42,43c42
<           if(rank.eq.0)
<      &    WRITE (6,5)  IC, ISTAR(I), I, M(I)*ZMBAR, CM(L,IC)*ZMBAR
---
>           WRITE (6,5)  IC, ISTAR(I), I, M(I)*ZMBAR, CM(L,IC)*ZMBAR
51c50
<       ZCMC = CM(L,IC)*ZMBAR
---
>       ZMC = CM(L,IC)*ZMBAR
53c52
<       ZME = ZM - ZCMC
---
>       ZME = ZM - ZMC
55c54
<       ZL3 = 58.3*ZCMC**2
---
>       ZL3 = 58.3*ZMC**2
63c62
<           IF (K.EQ.1) THEN
---
> 	  IF (K.EQ.1) THEN
67,68c66,67
<            END IF
<            W(K) = SW(K)**2
---
> 	  END IF
> 	  W(K) = SW(K)**2
76,78c75,76
<       ZN = (B2*SW(1) + B1)*SW(1) + B0
< *     if(rank.eq.0)
< *    &WRITE (24,20)  IC, IPAIR, ISTAR(J), CM(L,IC)/M(I), ZN
---
>       XN = (B2*SW(1) + B1)*SW(1) + B0
> *     WRITE (24,20)  IC, IPAIR, ISTAR(J), CM(L,IC)/M(I), XN
83c81
< *     IF (rank.eq.0.and.ZN.GE.5.0) THEN
---
> *     IF (XN.GE.5.0) THEN
85c83
< *    &                  SIZE(I)/RIN, ZN
---
> *    &                  SIZE(I)/RIN, XN
1c1
<       SUBROUTINE GIANT3(I,BODYI,W,Q,ZN,QL)
---
>       SUBROUTINE GIANT3(I,BODYI,W,Q,XN,QL)
43,49c43,49
<          IF (K.EQ.1) THEN
<             SW(K) = ((C3*SIG + C2)*SIG + C1)*SIG + C0
<          ELSE
<             SW(K) = ((E3*SIG + E2)*SIG + E1)*SIG + E0
<          END IF
<          W(K) = SW(K)**2
<          Q(K) = ((A3*SW(K) + A2)*SW(K) + A1)*SW(K) + A0
---
> 	  IF (K.EQ.1) THEN
>               SW(K) = ((C3*SIG + C2)*SIG + C1)*SIG + C0
>           ELSE
>               SW(K) = ((E3*SIG + E2)*SIG + E1)*SIG + E0
> 	  END IF
> 	  W(K) = SW(K)**2
>           Q(K) = ((A3*SW(K) + A2)*SW(K) + A1)*SW(K) + A0
53,54c53,54
<       ZN = (B2*SW(1) + B1)*SW(1) + B0
< *     WRITE (24,20)  IC, IPAIR, KSTAR(J), MC/(BODYI*SMU), RSI, ZN, QL
---
>       XN = (B2*SW(1) + B1)*SW(1) + B0
> *     WRITE (24,20)  IC, IPAIR, KSTAR(J), MC/(BODYI*SMU), RSI, XN, QL
59c59
< *     IF (ZN.GE.5.0) THEN
---
> *     IF (XN.GE.5.0) THEN
61c61
< *    &                  RADIUS(I)/RIN, ZN, QL
---
> *    &                  RADIUS(I)/RIN, XN, QL
37,38c37
<               if(rank.eq.0)
<      &        WRITE (6,5) NAME(I), NAME(JJ), (NAMEG(K),K=1,NMERGE)
---
>               WRITE (6,5) NAME(I), NAME(JJ), (NAMEG(K),K=1,NMERGE)
63c62
<       IF (rank.eq.0.and.DH.GT.0.2*ABS(H(IPAIR))) THEN
---
>       IF (DH.GT.0.2*ABS(H(IPAIR))) THEN
19c19
< *          OPEN (UNIT=10,STATUS='UNKNOWN',FORM='FORMATTED',FILE='HIARCH')
---
>           OPEN (UNIT=10,STATUS='NEW',FORM='FORMATTED',FILE='HIARCH')
23,24c23,24
<           IF (rank.eq.0.AND.KSTART.EQ.1) THEN
<               WRITE (12,1)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
---
>           IF (NMERG.EQ.0) THEN
>               WRITE (10,1)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
26,28c26,28
<  1            FORMAT (/,6X,1P, 'MODEL:    RBAR =',E26.17,'  <M>[M*] =',
<      &            E26.17,'  M1[M*] =',E26.17,'  TSCALE =',E26.17,0P,
<      &            '  NB0 =',I12,'  N0 =',I12,//)
---
>     1         FORMAT (/,6X,'MODEL:    RBAR =',F5.1,'  <M> =',F6.2,
>      &                     '  M1 =',F6.1,'  TSCALE =',F6.2,
>      &                     '  NB =',I4,'  N0 =',I6,//)
37,46c37,43
< C          if(rank.eq.0.AND.KSTART.EQ.1)then
< C             WRITE (12,2)
< C 2           FORMAT ('      TIME   A         A1        E1    PMIN',
< C     &            '    P1/P0  Q     PCR   MB    Q1     I      NAME',
< C     &            '        KC',/)
< C             WRITE (12,3)
< C 3           FORMAT ('             r/Rc                           ',
< C     &            '           Rc   GAM   IT        N0   N1   KS  NAME',
< C     &            /)
< C          end if
---
>           WRITE (10,2)
>     2     FORMAT ('      TIME   A         A1        E1    PMIN',
>      &            '    P1/P0  Q     PCR   MB    Q1     I      NAME',
>      &            '        KC',/)
>           WRITE (10,3)
>     3     FORMAT ('             r/Rc                           ',
>      &           '           Rc   GAM   IT        N0   N1   KS  NAME',/)
51d47
<       call jpred(I,TIME,TIME)
115d110
<          call jpred(Jcomp,time,time)
164,167c159,162
<           PMIN = SEMI1*(1.0D0 - ECC1)/RAP
<           TK1 = TWOPI*SEMI1*SQRT(SEMI1/ZMB)/TK
< C          PMIN = MIN(PMIN/RAP,999.0D0)
< C          TK1 = MIN(TK1/TK,99999.0D0)
---
>           PMIN = SEMI1*(1.0D0 - ECC1)
>           TK1 = TWOPI*SEMI1*SQRT(SEMI1/ZMB)
>           PMIN = MIN(PMIN/RAP,999.0D0)
>           TK1 = MIN(TK1/TK,99999.0D0)
172c167
<           DEG = 360.0*FAC/TWOPI
---
>           IDEG = 360.0*FAC/TWOPI
204a200,208
>           WRITE (10,10)  TTOT, SEMI, SEMI1, ECC1, PMIN, TK1, Q,
>      &                   PCRIT/SEMI, BODY(I)/BODYM, Q1, IDEG,
>      &                   NAME(I1), NAME(I2), NAME(JCOMP), KCM
>    10     FORMAT (/,' #1',F8.1,1P,2E10.2,0P,F6.2,F7.2,F8.1,3F6.2,F5.1,
>      &                    I5,2I5,I6,I4)
> *
>           WRITE (30,10)  TTOT, SEMI, SEMI1, ECC1, PMIN, TK1, Q,
>      &                   PCRIT/SEMI, BODY(I)/BODYM, Q1, IDEG,
>      &                   NAME(I1), NAME(I2), NAME(JCOMP), KCM
218,230c222,226
<           if(rank.eq.0) then
<           WRITE (12,10)  TTOT, SEMI, SEMI1, ECC1, PMIN, PMIN2, TK1, Q,
<      &            PCRIT/SEMI, BODY(I)/BODYM, Q1, DEG,
<      &            NAME(I1), NAME(I2), NAME(JCOMP), KCM,
<      &            SQRT(EI2), EM, EMAX, KSTAR(I1), KSTAR(I2), RBIG
<    10     FORMAT (/,'NEW HIAR  Time SEMI0 SMEI1 ECC1 ',
<      &         'PERI0 PERI0M P1/P0 M(INCM)/M(I3) PCR/SEMI0 ',
<      &         'M(INCM)/<M> MR INA NAME(I1) NAME(I2) NAME(I3) ', 
<      &         'K*(INCM) ECC0 ECCMIN ECCMAX K*(I1) K*(I2) RSM ',
<      &         1P,E20.11,2E14.5,0P,F6.2,1P,8E13.4,0P,4I12,3F6.2,2I12,1P,
<      &         E14.5,0P)
<           end if
<           CALL FLUSH(12)
---
>           WRITE (30,11)  SQRT(EI2), EMAX, KSTAR(I1), KSTAR(I2),KSTAR(I),
>      &                   SEMI, A, Z, PMIN2, R1, R2, EM
>    11     FORMAT (' INNER:    E EMAX K* SEMI A Z PM2 R1 R2 EM ',
>      &                        2F8.4,3I3,1P,4E10.2,0P,2F7.1,F7.3)
>           CALL FLUSH(30)
235,236c231,232
<           PMIN = SEMI*(1.0D0 - ECC)/RAP
< C          PMIN = MIN(PMIN/RAP,999.0D0)
---
>           PMIN = SEMI*(1.0D0 - ECC)
>           PMIN = MIN(PMIN/RAP,999.0D0)
238,243c234,238
<           TK1 = TK/TK0(IL)
< C          TK1 = MIN(TK/TK0(IL),99999.0D0)
<           NK = INT((TTOT - TLAST(IL))/TK0(IL))
<           NK1 = INT((TTOT - TLAST(IL))/TK)
< C         NK = MIN(NK,99999999)
< C          NK1 = MIN(NK1,9999)
---
>           TK1 = MIN(TK/TK0(IL),99999.0D0)
>           NK = (TTOT - TLAST(IL))/TK0(IL)
>           NK1 = (TTOT - TLAST(IL))/TK
>           NK = MIN(NK,99999999)
>           NK1 = MIN(NK1,9999)
252,263c247,257
< C          IT = 0
< C          IF (TIME.GT.MIN(TEV(I1),TEV(I2),TEV(I))) IT = 1
< C          IF (KSTAR(I1).NE.0.AND.IT.EQ.0) IT = KSTAR(I1)
< *
<           if(rank.eq.0)then
<           WRITE (12,20)  TTOT, SQRT(RI)/RC, SEMI, ECC, PMIN, TK1,
<      &                   RR, GAMMA(IPAIR), NK, NK1, NPAIRS, NAME(I2)
<    20     FORMAT ('END HIAR  Time RI/RC SEMI0 ECC0 PERI0 P0F/P0I ',
<      &         'RC/RSCALE GAMMA(INCM) NKI NKF NPAIRS NAME(I2)',
<      &         1P,E20.11,2E14.5,0P,F6.2,1P,4E13.4,0P,2I4,2I12)
<           CALL FLUSH(12)
<           end if
---
>           IT = 0
>           IF (TIME.GT.MIN(TEV(I1),TEV(I2),TEV(I))) IT = 1
>           IF (KSTAR(I1).NE.0.AND.IT.EQ.0) IT = KSTAR(I1)
> *
>           WRITE (10,20)  TTOT, SQRT(RI)/RC, SEMI, ECC, PMIN, TK1,
>      &                   RR, GAMMA(IPAIR), IT, NK, NK1, NPAIRS, NAME(I2)
>    20     FORMAT (' #2',F8.1,1P,2E10.2,0P,F6.2,F7.2,F8.1,2F6.2,I4,I10,
>      &                  3I6)
>           CALL FLUSH(10)
>           WRITE (30,20)  TTOT, SQRT(RI)/RC, SEMI, ECC, PMIN, TK1,
>      &                   RR, GAMMA(IPAIR), IT, NK, NK1, NPAIRS, NAME(I2)
46c46
<               CALL GIANT3(IK,BODI,WG,QG,ZN,QL)
---
>               CALL GIANT3(IK,BODI,WG,QG,XN,QL)
68c68
<           RP1 = RP/RADIUS(I1)
---
> 	  RP1 = RP/RADIUS(I1)
70c70
<           M21 = BODYI(1)/BODYI(2)
---
> 	  M21 = BODYI(1)/BODYI(2)
72c72
<           RP1 = RP/RADIUS(I2)
---
> 	  RP1 = RP/RADIUS(I2)
75c75
< *     Evaluate damping coefficient.
---
> *	Evaluate damping coefficient.
81c81
< *     Form rational function approximation to Hut solution.
---
> *	Form rational function approximation to Hut solution.
89c89
<      &     /(C(5) + C(6)*Z)
---
>      &	                                      /(C(5) + C(6)*Z)
13,15c13,15
< *      LOGICAL  FIRST
<       CHARACTER*29 OUTFILE
<       CHARACTER*20 TCHAR
---
>       LOGICAL  FIRST
>       SAVE  FIRST
>       DATA  FIRST /.TRUE./
18,23c18,26
< *       Write formatted data bank on unit 87, Split by time
<       call string_left(TCHAR,TTOT,DELTAT)
<       write(OUTFILE,119) TCHAR
<  119  format('hidat.87_',A20)
<       OPEN (UNIT=87,STATUS='UNKNOWN',FORM='FORMATTED',FILE=OUTFILE)
< *     
---
> *       Write formatted data bank on unit 87.
>       IF (FIRST) THEN
>           OPEN (UNIT=87,STATUS='NEW',FORM='FORMATTED',FILE='HIDAT')
>           FIRST = .FALSE.
>           WRITE (87,1)
>     1     FORMAT (/,'  NAM1  NAM2  NAM3  K*       M1   M2   M3    RI',
>      &            '    EMAX   E0    E1      P0    P1')
>       END IF
> *
30,31c33
<           if(rank.eq.0)
<      &    WRITE (87,3)  NPAIRS, NRUN, N, NC, NMERGE, MULT, NEWHI, TTOT
---
>           WRITE (87,3)  NPAIRS, NRUN, N, NC, NMERGE, MULT, NEWHI, TTOT
34,41d35
< *      
<       WRITE (87,1)
<  1    FORMAT (/,'NAME(I1)    NAME(I2)    NAME(I3)    K*(I1)      ',
<      &     'K*(I2)      K*(INCM)    M(I1)[M*]                 ',
<      &     'M(I2)[M*]                 M(I3)[M*]                 ',
<      &     'RI[NB]                    ECCMAX                    ',
<      &     'ECC0                      ECC1                      ',
<      &     'P0[days]                  P1[days]')
127c121,123
<               PCR = stability(M1,M2,M3,E0,E1,ANGLE)*SEMI
---
> *             PCR = stability(M1,M2,M3,E0,E1,ANGLE)*SEMI
>               QST = QSTAB(E0,E1,ANGLE,M1,M2,M3)
>               PCR = QST*SEMI
133,134c129
<                   if(rank.eq.0)
<      &            WRITE (6,20)  NAME(J1), NAME(J), 180.0*ANGLE/3.14, E1,
---
>                   WRITE (6,20)  NAME(J1), NAME(J), 180.0*ANGLE/3.14, E1,
211c206
< C          P0 = MIN(P0,9999.0D0)
---
>           P0 = MIN(P0,9999.0D0)
218,219c213
<           if(rank.eq.0)
<      &    WRITE (87,*)  NAME(J1), NAM2, NAME(J2), KSTAR(J1), KSTAR(J),
---
>           WRITE (87,28)  NAME(J1), NAM2, NAME(J2), KSTAR(J1), KSTAR(J),
221c215
< C   28     FORMAT (3I6,3I3,3F5.1,F7.2,F7.3,2F6.2,F8.1,1P,E9.1)
---
>    28     FORMAT (3I6,3I3,3F5.1,F7.2,F7.3,2F6.2,F8.1,1P,E9.1)
224d217
<       CLOSE(87)
7d6
<       Include 'kspars.h'
9,10d7
< *     Unsafe for parallel!  Used variables: CM,NAMEM,
< *     Update variables: YREL,ZREL,HM,UM,UMDOT,TMDIS,KSTARM
14d10
< *     Unsafe for parallel! Update variables: ecrit,br,tosc,rp,es
19d14
< *     Safe for parallel
21d15
< *     Unsafe for parallel! Update variables: dedt
23d16
< *     Safe for parallel
27c20
<       REAL*8  BODYI(2),WG(2)
---
>       REAL*8  BODYI(2),QG(2),WG(2)
30d22
< *     Unsafe for parallel
48c40
<       JCL = I + 1
---
>       JCOMP = I + 1
57c49
<       ZM3 = BODY(JCL)
---
>       ZM3 = BODY(JCOMP)
74,75c66,67
<           A2(K) = (X(K1,JCL) - X(K1,I))*(XDOT(K2,JCL) - XDOT(K2,I))
<      &          - (X(K2,JCL) - X(K2,I))*(XDOT(K1,JCL) - XDOT(K1,I))
---
>           A2(K) = (X(K1,JCOMP) - X(K1,I))*(XDOT(K2,JCOMP) - XDOT(K2,I))
>      &          - (X(K2,JCOMP) - X(K2,I))*(XDOT(K1,JCOMP) - XDOT(K1,I))
85c77
<       ZMB = BODY(I) + BODY(JCL)
---
>       ZMB = BODY(I) + BODY(JCOMP)
93c85
<             WRITE (6,9)  IPAIR, I, JCL, ECC1, SEMI1*SU, FAC 
---
>             WRITE (6,9)  IPAIR, I, JCOMP, ECC1, SEMI1*SU, FAC 
148,149c140,141
<       AZ = A**2 + Z - 2.0
<       IF (AZ.GE.0.0) THEN
---
>       AZ2 = A**2 + Z - 2.0
>       IF (AZ2.GE.0.0) THEN
151c143
<           EMIN2 = ONE6*(AZ1 - SQRT(AZ1**2 - 12.0*AZ))
---
>           EMIN2 = ONE6*(AZ1 - SQRT(AZ1**2 - 12.0*AZ2))
161c153
<       TG = TK1**2*ZMB*(1.0 - ECC1**2)**1.5/(BODY(JCL)*TK)
---
>       TG = TK1**2*ZMB*(1.0 - ECC1**2)**1.5/(BODY(JCOMP)*TK)
171c163
<       YFAC = 15.0*BODY(JCL)/(4.0*ZMB)*TWOPI*TK/TK1**2
---
>       YFAC = 15.0*BODY(JCOMP)/(4.0*ZMB)*TWOPI*TK/TK1**2
257c249
<                   CALL GIANT3(IK,BODI,WG,QG,ZN,QL)
---
>                   CALL GIANT3(IK,BODI,WG,QG,XN,QL)
282c274
<            ELSE IF (IDIS.EQ.-1) THEN
---
> 	  ELSE IF (IDIS.EQ.-1) THEN
310,311c302,303
<           XR0(K) = X(K,JCL) - X(K,I)
<           VR0(K) = XDOT(K,JCL) - XDOT(K,I)
---
>           XR0(K) = X(K,JCOMP) - X(K,I)
>           VR0(K) = XDOT(K,JCOMP) - XDOT(K,I)
344,360c336,339
<           NST = NSTAB(SEMI,SEMI1,ECC,ECC1,ZI,BODYI(1),BODYI(2),ZM3)
<           IF (NST.EQ.0) THEN
<               PCRIT = 0.98*QPERI*(1.0 - PERT)
<               PCR = stability(BODYI(1),BODYI(2),ZM3,ECC,ECC1,ZI)
<               PCR = PCR*SEMI
< *       Specify reduced peri if old criterion < PCRIT/2 (avoids switching).
<               IF (PCR.LT.0.5*PCRIT) THEN
<                   PCRIT = 0.75*PCRIT
<               END IF
<               IF (PCRIT.LT.PCR.AND.PERT.LT.0.01.AND.
<      &            ITIME.LT.20) THEN
<                   ALPH = 360.0*ZI/TWOPI
<                   FAIL = QPERI*(1-PERT) - PCR
<                   WRITE (6,42)  TTOT, ALPH, ECC, ECC1, QPERI, FAIL, PERT
<    42             FORMAT (' NEWSTAB    T INC EI EO QP FAIL PERT ',
<      &                                 F7.1,F7.2,2F8.4,1P,3E10.2)
<               END IF
---
>           QST = QSTAB(ECC,ECC1,ZI,BODYI(1),BODYI(2),ZM3)
>           PMIN = SEMI1*(1.0 - ECC1)
>           IF (QST*SEMI.LT.PMIN) THEN
>               PCRIT = 0.99*QPERI*(1.0 - PERT)
364,365c343
<           PMIN1 = SEMI1*(1.0 - ECC1)
<           IF (PMIN1.LT.PCRIT) THEN
---
>           IF (PMIN.LT.PCRIT) THEN
469,472d446
< *     ks MPI communication EMERGE ECOLL EGRAV
< *          call ksparmpi(K_store,K_real8,K_EMERGE,0,0,-DECORR)
<           call ksparmpi(K_store,K_real8,K_ECOLL,0,0,DECORR)
<           call ksparmpi(K_store,K_real8,K_EGRAV,0,0,DECORR)
480,482d453
< *     ks MPI communication TEV
<               call ksparmpi(K_store,K_real8,K_TEV,N+IPAIR,0,
<      &             TEV(N+IPAIR))
110,111c110,111
<       AZ = A**2 + Z - 2.0
<       IF (AZ.GE.0.0) THEN
---
>       AZ2 = A**2 + Z - 2.0
>       IF (AZ2.GE.0.0) THEN
113c113
<           EMIN2 = ONE6*(AZ1 - SQRT(AZ1**2 - 12.0*AZ))
---
>           EMIN2 = ONE6*(AZ1 - SQRT(AZ1**2 - 12.0*AZ2))
2,7c2,7
< *     
< *     
< *     Modification of hierarchical binary.
< *     ------------------------------------
< *     
< *     Author:  Rosemary Mardling (3/98).
---
> *
> *
> *       Modification of hierarchical binary.
> *       ------------------------------------
> *
> *       Author:  Rosemary Mardling (3/98).
10d9
< *     Unsafe for parallel! updata variables: coeff,hohat,e0,a,hh,mb
13,17c12,16
<      &     element(6),r(3),v(3),u(6),udot(6)
< *     
< *     
< *     Given inner Runge-Lenz vector {\bf e}=evec and {\bf h}=hvec.
< *     Calculate eccentricity e, magnitude of hvec and semi-major axis a.
---
>      &        element(6),r(3),v(3),u(6),udot(6)
> *
> *
> *	Given inner Runge-Lenz vector {\bf e}=evec and {\bf h}=hvec.
> *	Calculate eccentricity e, magnitude of hvec and semi-major axis a.
24,25c23,24
< *     Given OUTER {\bf E}=Eout and {\bf H}=Hout.
< *     Calculate outer eccentricity and semi-major axis.
---
> *	Given OUTER {\bf E}=Eout and {\bf H}=Hout.
> *	Calculate outer eccentricity and semi-major axis.
34c33
< *     Calculate the semi-minor axis Bout and the semi-latus rectum SLRout.
---
> *	Calculate the semi-minor axis Bout and the semi-latus rectum SLRout.
46c45
<          CALL DERIV(u,udot,icall)
---
>          CALL DERIV(u,udot,ICALL)
50,51c49,50
<      &        F8.4,1P,2E10.2,0P,F8.4,1P,4E10.2)
<          CALL FLUSH(3)
---
>      &                     F8.4,1P,2E10.2,0P,F8.4,1P,4E10.2)
>          CALL FLUSH(6)
55c54
< *     Initialize integration variables.
---
> *       Initialize integration variables.
57,59c56,58
<  10   do i=1,3
<          u(i)=evec(i)
<          u(i+3)=hvec(i)
---
>    10 do i=1,3
> 	 u(i)=evec(i)
> 	 u(i+3)=hvec(i)
62c61
< *     Perform integration.
---
> *       Perform integration.
69,70c68,69
<          evec(i)=u(i)
<          hvec(i)=u(i+3)
---
> 	 evec(i)=u(i)
> 	 hvec(i)=u(i+3)
74,75c73,74
<       e0=sqrt(dot(evec,evec))
<       hh=sqrt(dot(hvec,hvec))
---
> 	e0=sqrt(dot(evec,evec))
> 	hh=sqrt(dot(hvec,hvec))
77c76
< *     Apply symmetric re-orthogonalization (small eh; Seppo Mikkola 3/98).
---
> *       Apply symmetric re-orthogonalization (small eh; Seppo Mikkola 3/98).
79c78
<       eps=-eh/(e0**2+hh**2) 
---
>         eps=-eh/(e0**2+hh**2) 
81,84c80,83
<       do k=1,3
<          evec(k)=evec(k)+eps*hvec(k)
<          hvec(k)=hvec(k)+eps*evec(k)
<       end do
---
>         do k=1,3
>            evec(k)=evec(k)+eps*hvec(k)
>            hvec(k)=hvec(k)+eps*evec(k)
>         end do
90c89
< *     Calculate new orbital parameters.
---
> *	Calculate new orbital parameters.
97,101c96,100
< *     Calculate updated vectors r and v. 
< *     Note that the vectors evec and hvec give no information about
< *     the orbital phase. Thus there is a kind of degeneracy. Since
< *     we are updating to a later time using an approximation, we can't
< *     expect to know it anyway. Hence the phase of peri is set to zero.
---
> *	Calculate updated vectors r and v. 
> *	Note that the vectors evec and hvec give no information about
> *	the orbital phase. Thus there is a kind of degeneracy. Since
> *	we are updating to a later time using an approximation, we can't
> *	expect to know it anyway. Hence the phase of peri is set to zero.
109,235c108,109
<       
<       subroutine cross(u,v,w)
< 
< *     Vectorial cross product.
< *     ------------------------
<       real*8 u(3),v(3),w(3)
< 
<       w(1) = u(2)*v(3) - u(3)*v(2)
<       w(2) = u(3)*v(1) - u(1)*v(3)
<       w(3) = u(1)*v(2) - u(2)*v(1)
< 
<       end
< 
< 
<       real*8 function dot(u,v)
< 
< *     Scalar dot product.
< *     ------------------
<       real*8 u(3),v(3)
< 
<       dot=u(1)*v(1)+u(2)*v(2)+u(3)*v(3)
< 
<       end
< 
< 
<       subroutine transform2(element,mb,r,v)
< *     
< *     Calculates vectors r and v given 6 orbital elements.
< *     ----------------------------------------------------
< *     
<       IMPLICIT REAL*8 (A-H,O-Z)
<       real*8 r(3),v(3),element(6),mb
<       real*8 tempr(3),tempv(3)
<       real*8 inc,B(3,3)
< 
< 
<       a=element(1)
<       e=element(2)
<       inc=element(3)
<       w=element(4)
<       Om=element(5)
<       phi=element(6)
< 
<       cosp=cos(phi)
<       sinp=sin(phi)
<       cosi=cos(inc)
<       sini=sin(inc)
<       cosw=cos(w)
<       sinw=sin(w)
<       cosOm=cos(Om)
<       sinOm=sin(Om)
< 
<       B(1,1) = cosw*cosOm - sinw*cosi*sinOm
<       B(1,2) = cosw*sinOm + sinw*cosi*cosOm
<       B(1,3) = sinw*sini
<       B(2,1) = -sinw*cosOm - cosw*cosi*sinOm
<       B(2,2) = -sinw*sinOm + cosw*cosi*cosOm
<       B(2,3) = cosw*sini
<       B(3,1) = sini*sinOm
<       B(3,2) = -sini*cosOm
<       B(3,3) = cosi
< 
<       h=sqrt(mb*a*(1-e**2))
<       rr=a*(1-e**2)/(1+e*cosp)
<       rd=e*h*sinp/(a*(1-e**2))
<       phid=h/rr**2
< 
<       r(1)=rr*cosp
<       r(2)=rr*sinp
<       r(3)=0.0
< 
<       v(1)=rd*cosp-rr*phid*sinp
<       v(2)=rd*sinp+rr*phid*cosp
<       v(3)=0.0
< 
<       do i=1,3
<          sum1=0.0
<          sum2=0.0
<          do j=1,3
<             sum1=sum1 + B(j,i)*r(j)
<             sum2=sum2 + B(j,i)*v(j)
<          enddo
<          tempr(i)=sum1
<          tempv(i)=sum2
<       enddo
<       do i=1,3
<          r(i)=tempr(i)
<          v(i)=tempv(i)
<       enddo
< 
<       end
< 
< 
<       subroutine transform4(e,h,mb,element)
< *     
< *     Calculates 5 orbital elements given vectors evec and h and mass mb.
< *     -------------------------------------------------------------------
< *     
<       IMPLICIT REAL*8 (A-H,O-Z)
<       real*8 element(6)
<       real*8 h(3),e(3),n(3),hn(3),he(3)
<       real*8 eh(3)
<       real*8 ii(3),jj(3),kk(3),nn,mb
<       data ii/1.d0,0.d0,0.d0/
<       data jj/0.d0,1.d0,0.d0/
<       data kk/0.d0,0.d0,1.d0/
< 
< 
<       hh=sqrt(dot(h,h))
< 
<       do i=1,3
<          h(i)=h(i)/hh
<       enddo
< 
<       call cross(kk,h,n)
< 
<       nn=sqrt(dot(n,n))
<       ecc=sqrt(dot(e,e))
<       a=hh**2/mb/(1-ecc**2)
< 
<       do i=1,3
<          n(i)=n(i)/nn
<          eh(i)=e(i)/ecc
<       enddo
< 
<       call cross(h,n,hn)
<       call cross(h,eh,he)
---
> 	
> 	subroutine cross(u,v,w)
237,250c111,249
<       cosOm=dot(ii,n)
<       sinOm=dot(jj,n)
<       cosi=dot(kk,h)
<       sini=nn
<       cosw=dot(n,eh)
<       sinw=dot(eh,hn)
< 
<       element(1)=a
<       element(2)=ecc
<       element(3)=atan2(sini,cosi)
<       element(4)=atan2(sinw,cosw)
<       element(5)=atan2(sinOm,cosOm)
<       element(6)=0.0
< *     Pericentre phase (can be specified).
---
> *       Vectorial cross product.
> *       ------------------------
> 	real*8 u(3),v(3),w(3)
> 
> 	w(1) = u(2)*v(3) - u(3)*v(2)
> 	w(2) = u(3)*v(1) - u(1)*v(3)
> 	w(3) = u(1)*v(2) - u(2)*v(1)
> 
> 	end
> 
> 
>         real*8 function dot(u,v)
> 
> *       Scalar dot product.
> *       ------------------
>         real*8 u(3),v(3)
> 
> 	dot=u(1)*v(1)+u(2)*v(2)+u(3)*v(3)
> 
> 	end
> 
> 
> 	subroutine transform2(element,mb,r,v)
> *
> *	Calculates vectors r and v given 6 orbital elements.
> *       ----------------------------------------------------
> *
>         IMPLICIT REAL*8 (A-H,O-Z)
> 	real*8 r(3),v(3),element(6),mb
> 	real*8 tempr(3),tempv(3)
> 	real*8 inc,B(3,3)
> 
> 
>         a=element(1)
> 	e=element(2)
> 	inc=element(3)
> 	w=element(4)
> 	Om=element(5)
> 	phi=element(6)
> 
> 	cosp=cos(phi)
> 	sinp=sin(phi)
> 	cosi=cos(inc)
> 	sini=sin(inc)
> 	cosw=cos(w)
> 	sinw=sin(w)
> 	cosOm=cos(Om)
> 	sinOm=sin(Om)
> 
>         B(1,1) = cosw*cosOm - sinw*cosi*sinOm
>         B(1,2) = cosw*sinOm + sinw*cosi*cosOm
>         B(1,3) = sinw*sini
>         B(2,1) = -sinw*cosOm - cosw*cosi*sinOm
>         B(2,2) = -sinw*sinOm + cosw*cosi*cosOm
>         B(2,3) = cosw*sini
>         B(3,1) = sini*sinOm
>         B(3,2) = -sini*cosOm
>         B(3,3) = cosi
> 
> 	h=sqrt(mb*a*(1-e**2))
> 	rr=a*(1-e**2)/(1+e*cosp)
> 	rd=e*h*sinp/(a*(1-e**2))
> 	phid=h/rr**2
> 
> 	r(1)=rr*cosp
> 	r(2)=rr*sinp
> 	r(3)=0.0
> 
> 	v(1)=rd*cosp-rr*phid*sinp
> 	v(2)=rd*sinp+rr*phid*cosp
> 	v(3)=0.0
> 
> 	do i=1,3
> 	   sum1=0.0
> 	   sum2=0.0
> 	   do j=1,3
> 	      sum1=sum1 + B(j,i)*r(j)
> 	      sum2=sum2 + B(j,i)*v(j)
> 	   enddo
> 	   tempr(i)=sum1
> 	   tempv(i)=sum2
> 	enddo
> 	do i=1,3
> 	   r(i)=tempr(i)
> 	   v(i)=tempv(i)
> 	enddo
> 
> 	end
> 
> 
> 	subroutine transform4(e,h,mb,element)
> *
> *	Calculates 5 orbital elements given vectors evec and h and mass mb.
> *	-------------------------------------------------------------------
> *
>         IMPLICIT REAL*8 (A-H,O-Z)
> 	real*8 element(6)
> 	real*8 h(3),e(3),n(3),hn(3),he(3)
> 	real*8 eh(3)
> 	real*8 ii(3),jj(3),kk(3),nn,mb
> 	data ii/1.d0,0.d0,0.d0/
> 	data jj/0.d0,1.d0,0.d0/
> 	data kk/0.d0,0.d0,1.d0/
> 
> 
> 	hh=sqrt(dot(h,h))
> 
>         do i=1,3
>            h(i)=h(i)/hh
>         enddo
> 
> 	call cross(kk,h,n)
> 
> 	nn=sqrt(dot(n,n))
> 	ecc=sqrt(dot(e,e))
>         a=hh**2/mb/(1-ecc**2)
> 
> 	do i=1,3
> 	   n(i)=n(i)/nn
> 	   eh(i)=e(i)/ecc
> 	enddo
> 
> 	call cross(h,n,hn)
> 	call cross(h,eh,he)
> 
> 	cosOm=dot(ii,n)
> 	sinOm=dot(jj,n)
> 	cosi=dot(kk,h)
> 	sini=nn
> 	cosw=dot(n,eh)
> 	sinw=dot(eh,hn)
> 
> 	element(1)=a
> 	element(2)=ecc
> 	element(3)=atan2(sini,cosi)
> 	element(4)=atan2(sinw,cosw)
> 	element(5)=atan2(sinOm,cosOm)
> 	element(6)=0.0
> *       Pericentre phase (can be specified).
254,255c253,254
< *     5 FORMAT (' TRANSFORM    e i w Om IN ',F8.4,F9.3,3F9.3)
<       end
---
> *   5 FORMAT (' TRANSFORM    e i w Om IN ',F8.4,F9.3,3F9.3)
> 	end
12,22d11
< #ifdef PARALLEL
< #define MPIINIT 1
< #else
< #ifdef ENSEMBLE
< #define MPIINIT 1
< #else
< #define MPIINIT 0
< #endif
< #endif
< * recover random number sequence from COMMON variable IDUM1.
<       KDUM = IDUM1
25,31c14
<       if(rank.eq.0)READ (5,*)  SEMI0, ECC0, RATIO, RANGE
< #if MPIINIT
<       CALL MPI_BCAST(SEMI0,1,MPI_REAL8,0,MPI_COMM_WORLD,ierr)
<       CALL MPI_BCAST(ECC0,1,MPI_REAL8,0,MPI_COMM_WORLD,ierr)
<       CALL MPI_BCAST(RATIO,1,MPI_REAL8,0,MPI_COMM_WORLD,ierr)
<       CALL MPI_BCAST(RANGE,1,MPI_REAL8,0,MPI_COMM_WORLD,ierr)
< #endif
---
>       READ (5,*)  SEMI0, ECC0, RATIO, RANGE, ICIRC
33c16
<       if(rank.eq.0) WRITE (6,1)  NHI, SEMI0, ECC0, RATIO, RANGE
---
>       WRITE (6,1)  NHI, SEMI0, ECC0, RATIO, RANGE, ICIRC
36c19
<      &              /)
---
>      &              '  ICIRC =',I2,/)
48,50c31,33
<           PI = TWOPI*RAN2(KDUM)
<           OMEGA = TWOPI*RAN2(KDUM)
<           ZI = 0.25*TWOPI*RAN2(KDUM)
---
>           PI = TWOPI*RAN2(IDUM1)
>           OMEGA = TWOPI*RAN2(IDUM1)
>           ZI = 0.5*TWOPI*RAN2(IDUM1)
82c65
<           Q0 = 0.5 + 0.4*RAN2(KDUM)
---
>           Q0 = 0.5 + 0.4*RAN2(IDUM1)
91c74
<               ECC2 = RAN2(KDUM)
---
>               ECC2 = RAN2(IDUM1)
101,102c84,85
<                   EXP = RAN2(KDUM)*LOG10(RANGE)
<                   SEMI = SEMI0/10.0**EXP
---
>                   EXP = RAN2(IDUM1)*LOG10(RANGE)
>                   SEMI = SEMI1/10.0**EXP
108c91
<                SEMI = SEMI0
---
>               SEMI = SEMI0
112,113c95,97
<           PCRIT = stability(BODY(I1),BODY(I2),BS(I),ECC,ECC1,ZI)
<           PCRIT = PCRIT*SEMI
---
> *         PCRIT = stability(BODY(I1),BODY(I2),BS(I),ECC,ECC1,ZI)
>           QST = QSTAB(ECC,ECC1,ZI,BODY(I1),BODY(I2),BS(I))
>           PCRIT = QST*SEMI
119,120c103
<       if(rank.eq.0)
<      &    WRITE (6,20)  ITER, ECC, ECC1, PMIN, PCRIT, P0, P1
---
>           WRITE (6,20)  ITER, ECC, ECC1, PMIN, PCRIT, P0, P1
176,178d158
< *       Save random number sequence in COMMON for future use.
<       IDUM1 = KDUM
< *
182d161
< 
8d7
< *     Unsafe for parallel! update variables: UM, UMDOT
35c34
<     3 FORMAT (' HIRECT:   Time[Nb] NAME K* ECC R12/SEMI H DB DH/H ',
---
>     3 FORMAT (' HIRECT:   T NM K* E R/A H DB DH/H ',
11c11
< *       Define KS & c.m. indices.
---
> *       Define KS & c.m. indices and save IPAIR for RETURN.
14a15
>       JPAIR = IPAIR
36,37d36
<       CALL JPRED(I,TIME,TIME)
<       CALL JPRED(J,TIME,TIME)
59,65c58,64
<       Q = BODY(J)/BODY(I)
<       IF (ECC1.LT.1.0) THEN
<           XFAC = (1.0 + Q)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
<       ELSE
<           XFAC = 40.0*(1.0 + Q)
<       END IF
<       PCRIT = 2.8*XFAC**0.4*SEMI
---
> *     Q = BODY(J)/BODY(I)
> *     IF (ECC1.LT.1.0) THEN
> *         XFAC = (1.0 + Q)*(1.0 + ECC1)/SQRT(1.0 - ECC1)
> *     ELSE
> *         XFAC = 40.0*(1.0 + Q)
> *     END IF
> *     PCRIT = 2.8*XFAC**0.4*SEMI
68,71c67,70
<       IF ((PCRIT.GT.1.5*PMIN.OR.PCRIT.LT.0.5*PMIN).AND.J.LE.N) THEN
<           RSTAB = PCRIT
<           GO TO 20
<       END IF
---
> *     IF ((PCRIT.GT.1.5*PMIN.OR.PCRIT.LT.0.5*PMIN).AND.J.LE.N) THEN
> *         RSTAB = PCRIT
> *         GO TO 20
> *     END IF
112,116c111,114
< *       Employ the improved stability criterion for doubtful cases.
<       RSTAB = stability(BODY(I1),BODY(I2),BODY(JJ),ECC,ECC1,ANGLE)*SEMI
< *       Note: the present stability routine includes inclination!
< *     RSTAB = YFAC*RSTAB
<       PCRIT = RSTAB
---
>       QST = QSTAB(ECC,ECC1,ANGLE,BODY(I1),BODY(I2),BODY(JJ))
>       RSTAB = QST*SEMI
>       PCRIT = RSTAB   ! Needed by routine MERGE.
>       IPAIR = JPAIR
78c78
< *       Evaluate the general stability function (Mardling 2008).
---
> *       Evaluate the general stability function (Valtonen 2015).
86c86
<               IF (ECC1.GT.0.9) DE = DE + 0.011
---
>               DE = DE + 0.011
88d87
<               PMIN = SEMI1*(1.0 - EOUT)
90,92c89,93
<           NST = NSTAB(SEMI2,SEMI1,ECC,EOUT,ZI,CM(1,IMERGE),
<      &                                     CM(2,IMERGE),BODY(2*IPAIR))
<           IF (NST.EQ.0) THEN
---
>           QST = QSTAB(ECC,EOUT,ZI,CM(1,IMERGE),CM(2,IMERGE),
>      &                                         BODY(2*IPAIR))
>           RP = SEMI1*(1.0 - EOUT)/SEMI0
>           IF (QST.LT.RP) THEN
>               PMIN = SEMI1*(1.0 - EOUT)
94,97d94
<               PCR = stability(CM(1,IMERGE),CM(2,IMERGE),BODY(2*IPAIR),
<      &                                          ECC,ECC1,ZI)*SEMI2
<           ELSE
<               PCRIT = 1.01*PMIN
100,101c97
<           PCRIT = stability(CM(1,IMERGE),CM(2,IMERGE),BODY(2*IPAIR),
<      &                                          ECC,ECC1,ZI)*SEMI2
---
>           PCRIT = 1.01*PMIN
136,137c132
<           if(rank.eq.0)
<      &    WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), ECC, DMS,
---
>           WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), ECC, DMS,
145,146c140
<               if(rank.eq.0)
<      &        WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), ECC, DMS,
---
>               WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), ECC, DMS,
189c183
<       IF (rank.eq.0.and.DMS.GT.1.0D-03) THEN
---
>       IF (DMS.GT.1.0D-03) THEN
37,38c37
<               if(rank.eq.0)
<      &        WRITE (6,5)  NAME(I1), IGHOST
---
>               WRITE (6,5)  NAME(I1), IGHOST
84c83
< *       Obtain stability parameters for the new configuration.
---
> *       Check general three-body stability.
86,88c85,99
<           NST = NSTAB(SEMI2,SEMI1,ECC,ECC1,ZI,CM(1,IMERGE),
<      &                                     CM(2,IMERGE),BODY(2*IPAIR))
<           IF (NST.EQ.0) THEN
---
>           EOUT = ECC1
> *       Increase tolerance near sensitive stability boundary (RM 10/2008).
>           IF (EOUT.GT.0.9) THEN
>               DE = 0.5*(1.0 - EOUT)
>               DE = MIN(DE,0.01D0)
> *       Add extra amount 0.011 to avoid switching.
>               DE = DE + 0.011
>               EOUT = EOUT - DE
>           END IF
>           ZI = 0.0
>           QST = QSTAB(ECC,EOUT,ZI,CM(1,IMERGE),CM(2,IMERGE),
>      &                                         BODY(2*IPAIR))
>           RP = SEMI1*(1.0 - EOUT)/SEMI
>           IF (QST.LT.RP) THEN
>               PMIN = SEMI1*(1.0 - EOUT)
90,91d100
<           ELSE
<               PCRIT = 1.01*PMIN
94,95c103
<           PCRIT = stability(CM(3,IMERGE),CM(4,IMERGE),BODY(2*IPAIR-1),
<      &                                          ECC,ECC1,0.0D0)*SEMI2
---
>           PCRIT = 1.01*PMIN
121,122c129
<           if(rank.eq.0)
<      &    WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), ECC, DMS,
---
>           WRITE (6,15)  NAME(J), KSTAR(J), KSTARM(IMERGE), ECC, DMS,
166c173
<       IF (rank.eq.0.and.DMS.GT.1.0D-03) THEN
---
>       IF (DMS.GT.1.0D-03) THEN
21a22,26
> *       Revised 21st January 2011 by A. D. Railton
> *       to include pre-mainsequence evolution for 0.1-8.0 Msun
> *       with solar metallicity. Note KW=-1 for preMS evolution.
> *       Use negative aj for preMS.
> *
26,27c31,33
<       parameter(wdflag=1,nsflag=1)
<       common /fall/fallback
---
>       parameter(wdflag=1,nsflag=2)
>       integer ecflag
>       parameter (ecflag=1)
30c36
<       real*8 r,lum,mc,rc,menv,renv,k2,fallback
---
>       real*8 r,lum,mc,rc,menv,renv,k2
34c40
<       parameter(mxns0=1.8d0,mxns1=3.d0)
---
>       parameter(mxns0=1.8d0,mxns1=2.5d0)
44a51,52
>       real*8 tprems,pre1,pre2,pre3,pre4
> *
69c77
< *       KW      Classification type (0 - 15).
---
> *       KW      Classification type (-1 -> 15).
71d78
< *       fallback Belczynski's Prescription for fallback on black holes
74d80
<       fallback = 0.d0
77c83
<       if(nsflag.eq.1) mxns = mxns1
---
>       if(nsflag.ge.1) mxns = mxns1
80c86
< c      if(mass0.gt.100.d0) mass = 100.d0
---
> *     if(mass0.gt.100.d0) mass = 100.d0
82c88
< c      if(mt0.gt.100.d0) mt = 100.d0
---
> *     if(mt0.gt.100.d0) mt = 100.d0
94c100,155
<       if(aj.lt.tscls(1))then
---
>       if(aj.ge.0.d0.and.kw.eq.-1)then
>          if(mass.le.0.7d0)then
>             kw = 0
>          else
>             kw = 1
>          endif
>       endif
> *
>       if(aj.lt.0.d0)then
> *
> *        PreMS evolution (valid for 0.1<=M<=8.0).
> *
>          kw = -1
>          tprems = -1.d0*aj/tscls(15)
> * Note: tprems cannot exceed 1 - if it does, start at top of Hayashi track.
>          if(tprems.gt.1.d0)then
>             tprems = 1.d0
>          endif
> *
>          if(mass.le.1.d0)then
>             pre1 = 0.d0
>             pre2 = 0.d0
>             pre3 = 7.432d-02 - 9.43d-02*mass + 7.439d-02*mass**2
>          endif
>          if(mass.gt.1.d0.and.mass.lt.2.d0)then
>             pre1 = -4.00772d0 + 4.00772d0*mass
>             pre2 = 8.5656d0 - 8.5656d0*mass
>             pre3 = -4.50678d0 + 4.56118d0*mass
>          endif
>          if(mass.ge.2.d0)then
>             pre1 = 1.60324d0 + 2.20401d0*mass - 0.60433d0*mass**2 +
>      &         5.172d-02*mass**3
>             pre2 = -4.56878d0 - 4.05305d0*mass + 1.24575*mass**2 -
>      &         0.10922d0*mass**3
>             pre3 = 3.01153 + 1.85745*mass -0.64290d0*mass**2 +
>      &         5.759d-02*mass**3
>          endif
> *
>          rzams = rzamsf(mass)
>          r = rzams*10.d0**((pre1*tprems**3 + pre2*tprems**4 +
>      &     pre3*tprems**5)/(1.05d0-tprems))
> *
>          pre1 = -2.63181d0 + 3.16607d0*mass - 3.30223d0*mass**2 +
>      &     0.83556d0*mass**3 - 0.06356d0*mass**4
>          pre2 = -11.70230d0 + 16.60510d0*mass - 9.69755d0*mass**2 +
>      &     2.42426d0*mass**3 - 0.27213d0*mass**4 + 0.01134d0*mass**5
>          pre3 = 26.19360d0 - 35.09590d0*mass + 20.64280d0*mass**2 -
>      &     5.18601d0*mass**3 + 0.58360d0*mass**4 - 0.02434d0*mass**5
>          pre4 = -14.64590d0 + 18.55660d0*mass - 10.95070d0*mass**2 +
>      &     2.75979d0*mass**3 - 0.31103d0*mass**4 + 0.01298d0*mass**5
> *
>          lum = lums(1)*10.d0**((exp(pre1*tprems**2) - 1.d0)*
>      &     (pre2*tprems + pre3*tprems**2 + pre4*tprems**3)/
>      &     (1.05d0-tprems))
> *
>       elseif(aj.lt.tscls(1))then
269c330
<          end if
---
>          endif
387c448
<          mcmax = MAX(MAX(mch,0.773d0*mcbagb-0.35d0),1.05d0*mcx)
---
>          mcmax = MAX(MAX(mch,0.773d0*mcbagb-0.35d0),1.02d0*mcx)
419,420c480,482
< * This next is a brute force fix to allow negative epochs to work
< * for SAGB stars (Jarrod, 2014)
---
> * Guard against age going out of range for a slightly negative epoch. 
>             if(aj.ge.tscls(11)-2.d0*tiny) aj = tscls(14) +
>      &                                    0.95d0*(tscls(11)-tscls(14))
422,423d483
<             if(aj.ge.tscls(11)-2.d0*tiny) aj = tscls(14) + 
<      &           0.95d0*(tscls(11)-tscls(14))
426c486
< *            
---
> *
472c532,533
<                   if(nsflag.eq.0)then
---
>                   if(nsflag.le.0)then
> * Use the original SSE NS/BH mass.
474,477c535,536
<                   elseif(nsflag.ge.1)then
< *
< * Use NS/BH mass given by Belczynski et al. 2002, ApJ, 572, 407.
< *
---
>                   elseif(nsflag.eq.1)then
> * Use FeNi core mass given by Belczynski et al. 2002, ApJ, 572, 407.
482a542,564
>                   elseif(nsflag.eq.2)then
> * Use FeNi mass given by Belczynski et al. 2008, ApJSS, 174, 223. 
>                      if(mc.lt.4.82d0)then
>                         mcx = 1.5d0
>                      elseif(mc.lt.6.31d0)then
>                         mcx = 2.11d0
>                      elseif(mc.lt.6.75d0)then
>                         mcx = 0.69255d0*mc - 2.26d0
>                      else
>                         mcx = 0.37d0*mc - 0.0828d0
>                      endif
>                   elseif(nsflag.ge.3)then
> * Use remnant masses based on Eldridge & Tout 2004, MNRAS, 353, 87.
>                      if(mc.lt.6.d0)then
>                         mcx = 1.44d0
>                      else
>                         mcx = 1.4512017d0*mc - 6.5913737d-03*mc*mc
>      &                        - 6.1073371d0
>                      endif
>                      mt = mcx
>                   endif
>                   if(nsflag.eq.1.or.nsflag.eq.2)then
> * For Belczynski methods calculate the remnant mass from the FeNi core. 
485d566
<                         fallback = 0.d0
488d568
<                         fallback = (mc - 5.d0)/2.6d0
490c570,581
<                      if(mc.gt.7.60) fallback = 1.d0
---
>                   endif
>                   if(nsflag.ge.2)then
> * Reduce the mass to the gravitational mass for the relevant cases. 
>                      mcx = (-1.d0 + SQRT(1.d0 + 0.3d0*mt))/0.15d0
>                      if(mcx.le.mxns)then
>                         mt = mcx
>                      elseif(mcx.le.mxns+1.0d0)then
>                         mc = 1.d0/(0.075d0*mxns + 1.d0)
>                         mt = (0.9d0 - (mxns+1.d0-mcx)*(0.9d0-mc))*mt
>                      else
>                         mt = 0.9d0*mt
>                      endif
492a584
> *
503d594
< *       print*,' HRDIAG BH mc, mt, mxns, fallback ',mc,mt,mxns,fallback
504a596,605
> *
>                endif
>             endif
>          else
> * Check for an electron-capture collapse of an ONe core. 
>             if(mcbagb.ge.1.6d0.and.mcbagb.le.2.25d0)then
>                if(ecflag.gt.0.and.mcx.ge.1.372d0)then
>                   mt = 1.26d0
>                   mc = mt
>                   kw = 13
580c681
<                      if(nsflag.eq.0)then
---
>                      if(nsflag.le.0)then
582c683
<                      elseif(nsflag.ge.1)then
---
>                      elseif(nsflag.eq.1)then
587a689,708
>                      elseif(nsflag.eq.2)then
>                         if(mc.lt.4.82d0)then
>                            mcx = 1.5d0
>                         elseif(mc.lt.6.31d0)then
>                            mcx = 2.11d0
>                         elseif(mc.lt.6.75d0)then
>                            mcx = 0.69255d0*mc - 2.26d0
>                         else
>                            mcx = 0.37d0*mc - 0.0828d0
>                         endif
>                      elseif(nsflag.ge.3)then
>                         if(mc.lt.6.d0)then
>                            mcx = 1.44d0
>                         else
>                            mcx = 1.4512017d0*mc - 6.5913737d-03*mc*mc
>      &                           - 6.1073371d0
>                         endif
>                         mt = mcx
>                      endif
>                      if(nsflag.eq.1.or.nsflag.eq.2)then
590d710
<                            fallback = 0.d0
593d712
<                            fallback = (mc - 5.d0)/2.6d0
595c714,724
<                         if(mc.gt.7.60) fallback = 1.d0
---
>                      endif
>                      if(nsflag.ge.2)then
>                         mcx = (-1.d0 + SQRT(1.d0 + 0.3d0*mt))/0.15d0
>                         if(mcx.le.mxns)then
>                            mt = mcx
>                         elseif(mcx.le.mxns+1.0d0)then
>                            mc = 1.d0/(0.075d0*mxns + 1.d0)
>                            mt = (0.9d0 - (mxns+1.d0-mcx)*(0.9d0-mc))*mt
>                         else
>                            mt = 0.9d0*mt
>                         endif
608d736
< *                     print*,' HRDIAG BH T ',mc,mt,mxns,fallback
624c752,753
< * unless WD is ONe.
---
> * unless WD is ONe in which case we assume a NS 
> * of minimum mass is the remnant.
627,628c756,757
<             mt = 1.3d0
< *           mt = 1.17d0 + 0.09d0*mc
---
>             aj = 0.d0
>             mt = 1.26d0
780c909
<       if(kw.lt.10)then
---
>       if(kw.ge.0.and.kw.lt.10)then
785,790c914,919
<       if(mass.gt.99.99d0)then
<          mass = mass0
<       endif
<       if(mt.gt.99.99d0)then
<          mt = mt0
<       endif
---
> *     if(mass.gt.99.99d0)then
> *        mass = mass0
> *     endif
> *     if(mt.gt.99.99d0)then
> *        mt = mt0
> *     endif
13,14d12
<       CHARACTER*27 FILE(2)
<       CHARACTER*20 TCHAR
16,29c14,20
< *     Save SSE and BSE data in separate files splited by time
<       if(rank.eq.0) then
<          call string_left(TCHAR,TTOT,DTPLOT)
<          write(FILE(1),118) TCHAR
<  118     format('sev.83_',A20)
<          write(FILE(2),119) TCHAR
<  119     format('bev.82_',A20)
<          OPEN (UNIT=83,STATUS='UNKNOWN',FORM='FORMATTED',FILE=FILE(1))
<          OPEN (UNIT=82,STATUS='UNKNOWN',FORM='FORMATTED',FILE=FILE(2))
<       end if
< *      
<       if(rank.eq.0) WRITE (82,1)  NPAIRS, TPHYS
<     1 FORMAT (I8,F9.1)
<       NS = N - 2*NPAIRS
---
> *
>       WRITE (82,1)  NPAIRS, TPHYS
>     1 FORMAT (' ## BEGIN',I8,F9.1)
> *       Define the number of objects (rather than single stars).
>       NS = N - NPAIRS - NMERGE - (NCH - 1)
> *       Choose the number of singles (alternative definition, triples only).
> *     NS = N - 2*NPAIRS - NMERGE - NCH
31,32c22,24
<       if(rank.eq.0) WRITE (83,1)  NS, TPHYS
< 
---
>       NB = 0
>       NSTAR = 0
>       WRITE (83,1)  NS, TPHYS
48,49c40
<                   if(rank.eq.0)
<      &            WRITE (6,3)  I, NCH
---
>                   WRITE (6,3)  I, NCH
103,105c94,97
<                   RDOT = XREL(1,IMERGE)*VREL(1,IMERGE) + 
<      &                 XREL(2,IMERGE)*VREL(2,IMERGE) +
<      &                 XREL(3,IMERGE)*VREL(3,IMERGE)
---
>                   RDOT = 0.0
>                   DO K = 1,4
>                       RDOT = RDOT + UM(K,IMERGE)*UMDOT(K,IMERGE)
>                   END DO        
119c111
<      &                    RM2,LUM2,KW,MC,RCC,ME,RE,K2)
---
>      &                    RM2,LUM2,KW2,MC,RCC,ME,RE,K2)
130a123
>               PB = MIN(PB,99999.9D0)
137,141c130,132
<               TE1 = 0.25*(ZL1 - 2.0*R1) + 3.7
<               TE2 = 0.25*(ZL2 - 2.0*R2) + 3.7
<               if(rank.eq.0)
<      &        WRITE (82,5)  TTOT, J1, J2, NAME(J1), NAME(J2), KW, KW2, 
<      &            KSTAR(ICM),
---
>               TE1 = 0.25*(ZL1 - 2.0*R1) + 3.76
>               TE2 = 0.25*(ZL2 - 2.0*R2) + 3.76
>               WRITE (82,5)  NAME(J1), NAME(J2), KW, KW2, KSTAR(ICM),
143c134,135
<     5         FORMAT (1X,1P,E13.5,4I8,2I3,I4,6E13.5,6E13.5)
---
>     5         FORMAT (2I6,2I3,I4,F6.1,F6.3,10F7.3)
>               NB = NB + 1
149a142
>               RI = MIN(RI,99.0D0)
153,156c146,149
<               TE = 0.25*(ZL1 - 2.0*R1) + 3.7
<               if(rank.eq.0)
<      &        WRITE (83,10)  TTOT, I, NAME(I), KW, RI, M1, ZL1, R1, TE
<    10         FORMAT (1X,1P,E12.5,2I8,I3,5E13.5)
---
>               TE = 0.25*(ZL1 - 2.0*R1) + 3.76
>               WRITE (83,10)  NAME(I), KW, RI, M1, ZL1, R1, TE
>    10         FORMAT (I10,I4,5F10.3)
>               NSTAR = NSTAR + 1
158a152,154
>       WRITE (82,30)  NB
>       WRITE (83,30)  NSTAR
>    30 FORMAT (' ## END',I8)
160,165c156,159
<       if(rank.eq.0) then
<          CALL FLUSH(82)
<          CALL FLUSH(83)
<          CLOSE(82)
<          CLOSE(83)
<       end if
---
> *       Update next plotting time.
>       TPLOT = TPLOT + DTPLOT
>       CALL FLUSH(82)
>       CALL FLUSH(83)
1c1
<       subroutine hut(es0,spin10,spin20,ecc,spin1,spin2,nsteps,dtau)
---
> 	subroutine hut(es0,spin10,spin20,ecc,spin1,spin2,nsteps,dtau)
3,4c3,4
<       implicit real*8 (A-H,O-Z)
<       real*8 u(3),udot(3)
---
>         implicit real*8 (A-H,O-Z)
> 	real*8 u(3),udot(3)
6,57c6,61
<       u(1)=es0
<       u(2)=spin10
<       u(3)=spin20
< 
<       call deriv2(u,udot)
< 
< *     Include step reduction for large de/dt or primary spin rate.
<       IT = 0
<  1    IF (ABS(udot(1))*dtau.GT.0.01*MAX(es0,0.01d0)) THEN
<          dtau = 0.5D0*dtau
<          nsteps = 2*nsteps
<          IT = IT + 1
<          IF (IT.LT.10) GO TO 1
<       END IF
< 
<     2 IF (ABS(udot(2))*dtau.GT.0.01*u(2).AND.u(2).GT.0.1) THEN
<          dtau = 0.5D0*dtau
<          nsteps = 2*nsteps
<          IT = IT + 1
<          IF (IT.LT.10) GO TO 2
<       END IF
< 
< *     Treat large eccentricity carefully for rapid spin change.
<       IF (es0.GT.0.9995.and.ABS(udot(2))*dtau.GT.
<      &     0.01*u(2).AND.u(2).GT.0.1) THEN
<          dtau = 0.5D0*dtau
<          nsteps = 2*nsteps
<          IT = IT + 1
<       END IF
< 
<       IF (IT.GT.0) THEN
<          WRITE (96,3)  nsteps, IT, u, udot, dtau
<  3       FORMAT ('HUT REDUCE  NSTEPS IT U UD DTAU ',I6,I3,F8.4,1P,7E9.1)
<          CALL FLUSH(96)
<       END IF
< 
<       do i=1,nsteps
< *     Save spins in case eccentricity goes negative.
<          usave2 = u(2)
<          usave3 = u(3)
<          call rk4b(dtau,u)
< *     Note there are 4 calls to deriv2 when u(1) may go negative.
<          IF (u(1).lt.0.002.or.u(1).gt.0.99999) then
< *     Enforce circularization by adopting e=0.00199 and copying spins.
<             IF (u(1).LT.0.0) WRITE (6,4) I, nsteps, u(1)
<  4          FORMAT (' HUT SAFETY EXIT!   I nsteps u1 ',2I5,F8.4)
<             u(1) = 0.00199
<             u(2) = usave2
<             u(3) = usave3
<             GO TO 5
<          END IF
<       enddo
---
> 	u(1)=es0
> 	u(2)=spin10
> 	u(3)=spin20
> 
>         call deriv2(u,udot)
> 
> *       Include step reduction for large de/dt or primary spin rate.
>         IT = 0
>     1   IF (ABS(udot(1))*dtau.GT.0.01*MAX(es0,0.01d0)) THEN
>             dtau = 0.5D0*dtau
>             nsteps = 2*nsteps
>             IT = IT + 1
>             IF (IT.LT.10) GO TO 1
>         END IF
> 
>     2   IF (ABS(udot(2))*dtau.GT.0.01*u(2).AND.u(2).GT.0.1) THEN
>             dtau = 0.5D0*dtau
>             nsteps = 2*nsteps
>             IT = IT + 1
>             IF (IT.LT.10) GO TO 2
>         END IF
> 
> *       Treat large eccentricity carefully for rapid spin change.
>         IF (es0.GT.0.9995.and.
>      &      ABS(udot(2))*dtau.GT.0.01*u(2).AND.u(2).GT.0.1) THEN
>             dtau = 0.5D0*dtau
>             nsteps = 2*nsteps
>             IT = IT + 1
>         END IF
> 
>         IF (IT.GT.0) THEN
>             WRITE (96,3)  nsteps, IT, u, udot, dtau
>     3       FORMAT (' HUT REDUCE    # IT u ud dt ',I6,I3,F8.4,1P,7E9.1)
>             CALL FLUSH(96)
>         END IF
> 
> 	do i=1,nsteps
> *       Save spins in case eccentricity goes negative.
>            usave2 = u(2)
>            usave3 = u(3)
> 	   call rk4b(dtau,u)
> *       Note there are 4 calls to deriv2 when u(1) may go negative.
>            IF (u(1).lt.0.002.or.u(1).gt.0.99999) then
> *       Enforce circularization by adopting e=0.00199 and copying spins.
>               IF (u(1).LT.0.0) WRITE (6,4) I, nsteps, u(1)
>     4         FORMAT (' HUT SAFETY EXIT!   I nsteps u1 ',2I5,F8.4)
>               u(1) = 0.00199
>               u(2) = usave2
>               u(3) = usave3
>               GO TO 5
>             END IF
> 	enddo
> 
>     5   ecc=u(1)
> 	spin1=u(2)
> 	spin2=u(3)
59,63c63
<  5    ecc=u(1)
<       spin1=u(2)
<       spin2=u(3)
< 
<       end
---
> 	end
67,68c67,68
< *     Runge-Kutta integrator.
< *     -----------------------
---
> *	Runge-Kutta integrator.
> *       -----------------------
70c70
< *     Author:  Rosemary Mardling (3/98).
---
> *       Author:  Rosemary Mardling (3/98).
106,107c106,107
<       
<       subroutine deriv2(u,udot)
---
> 	
> 	subroutine deriv2(u,udot)
109,151c109,151
<       implicit real*8 (A-H,M,O-Z)
<       real*8 u(3),udot(3)
<       common/spins/angmom0,rg2(2),m21,r21,semi0,C1,C2,C3,C4,semi
< *     SAVE IC
< *     DATA IC /0/
< 
<       e=u(1)
<       spin1=u(2)
<       spin2=u(3)
<       semi1=semi
< 
<       e2=e**2
<       e4=e2**2
<       e6=e4*e2
<       fac=1-e2
< 
<       f2=1+7.5*e2+5.625*e4+0.3125*e6
<       f3=1+3.75*e2+1.875*e4+0.078125*e6
<       f4=1+1.5*e2+0.125*e4
<       f5=1+3*e2+0.375*e4
< 
<       semi=angmom0-rg2(1)*spin1-m21*r21**2*rg2(2)*spin2
<       semi=(semi*(1+m21)/m21/semi0**2)**2/fac
<       oa = 1.0/semi
< 
<       if(e.le.0.0.or.e.ge.1.0.or.oa.lt.0.0)then
<          udot(1) = 0.0
<          udot(2) = 0.0
<          udot(3) = 0.0
<       else
<          udot(1)=-oa**8*(e/fac**6.5)*
<      &        (C1*(f3-(11./18.)*fac**1.5*f4*spin1/oa**1.5)+
<      &        C2*(f3-(11./18.)*fac**1.5*f4*spin2/oa**1.5))
<          udot(2)=(oa/fac)**6*C3*(oa**1.5*f2-fac**1.5*f5*spin1)
<          udot(3)=(oa/fac)**6*C4*(oa**1.5*f2-fac**1.5*f5*spin2)
<       endif
<       if (e.lt.0.002.and.semi.lt.0.0d0) semi=semi1
< 
< *     IC = IC + 1
< *     IF (IC.EQ.1.OR.MOD(IC,10000).EQ.0) THEN
< *     WRITE (6,1)  IC, e, spin1, spin2, udot
< *     1       FORMAT (' HUT DERIV    # e s1 s2 udot ',I10,F8.4,1P,5E9.1)
< *     END IF
---
>         implicit real*8 (A-H,M,O-Z)
> 	real*8 u(3),udot(3)
> 	common/spins/angmom0,rg2(2),m21,r21,semi0,C1,C2,C3,C4,C5,semi
> *       SAVE IC
> *       DATA IC /0/
> 
>         e=u(1)
>         spin1=u(2)
>         spin2=u(3)
>         semi1=semi
> 
>         e2=e**2
>         e4=e2**2
>         e6=e4*e2
>         fac=1-e2
> 
>         f2=1+7.5*e2+5.625*e4+0.3125*e6
>         f3=1+3.75*e2+1.875*e4+0.078125*e6
>         f4=1+1.5*e2+0.125*e4
>         f5=1+3*e2+0.375*e4
> 
>         semi=angmom0-rg2(1)*spin1-m21*r21**2*rg2(2)*spin2
>         semi=(semi*(1+m21)/m21/semi0**2)**2/fac
>         oa = 1.0/semi
> 
>         if(e.le.0.0.or.e.ge.1.0.or.oa.lt.0.0)then
>            udot(1) = 0.0
>            udot(2) = 0.0
>            udot(3) = 0.0
>         else	
>            udot(1)=-oa**8*(e/fac**6.5)*(
>      &             C1*(f3-(11./18.)*fac**1.5*f4*spin1/oa**1.5)+
>      &             C2*(f3-(11./18.)*fac**1.5*f4*spin2/oa**1.5))
>            udot(2)=(oa/fac)**6*C3*(oa**1.5*f2-fac**1.5*f5*spin1)
>            udot(3)=(oa/fac)**6*C4*(oa**1.5*f2-fac**1.5*f5*spin2)
>         endif
>         if (e.lt.0.002.and.semi.lt.0.0d0) semi=semi1
> 
> *       IC = IC + 1
> *       IF (IC.EQ.1.OR.MOD(IC,10000).EQ.0) THEN
> *           WRITE (6,1)  IC, e, spin1, spin2, udot
> *   1       FORMAT (' HUT DERIV    # e s1 s2 udot ',I10,F8.4,1P,5E9.1)
> *       END IF
153c153
<       end
---
> 	end
1,4c1,41
<       subroutine hut2(spin10,spin20,spin1,spin2,nsteps,dtau)
< *     
< *     Spin evolution of circular binary.
< *     ----------------------------------
---
> 	subroutine hut2(spin10,spin20,spin1,spin2,nsteps,dtau)
> *
> *       Spin evolution of circular binary.
> *       ----------------------------------
> 
>         implicit real*8 (A-H,O-Z)
> 	real*8 u(2),udot(2)
>         COMMON/CFLAG/ IFLAG,IQ
> 
> 	u(1)=spin10
> 	u(2)=spin20
>         IFLAG = 0
>         IQ = 0
> 
>         call deriv3(u,udot)
> 
> *       Include step reduction for large derivatives.
>         IT = 0
>     1   IF (ABS(udot(1))*dtau.GT.0.01*spin10) THEN
>             dtau = 0.5D0*dtau
>             nsteps = 2*nsteps
>             IT = IT + 1
>             IF (IT.LT.5) GO TO 1
>         END IF
> 
>     5   IF (ABS(udot(2))*dtau.GT.0.01*spin20) THEN
>             dtau = 0.5D0*dtau
>             nsteps = 2*nsteps
>             IT = IT + 1
>             IF (IT.LT.5) GO TO 5
>         END IF
> 
> *       do i=1,nsteps
> *       call rk4c(dtau,u)
> *       IF (IFLAG.GT.0) GO TO 10
> *       enddo
> 
>         ITER = 0
>     6   call rk4c(dtau,u)
>         ITER = ITER + 1
>         IF (IFLAG.EQ.0.AND.ITER.LT.NSTEPS) GO TO 6
6,41c43,44
<       implicit real*8 (A-H,O-Z)
<       real*8 u(2),udot(2)
<       COMMON/CFLAG/ IFLAG,IQ
< 
<       u(1)=spin10
<       u(2)=spin20
<       IFLAG = 0
<       IQ = 0
< 
<       call deriv3(u,udot)
< 
< *     Include step reduction for large derivatives.
<       IT = 0
<  1    IF (ABS(udot(1))*dtau.GT.0.01*spin10) THEN
<          dtau = 0.5D0*dtau
<          nsteps = 2*nsteps
<          IT = IT + 1
<          IF (IT.LT.5) GO TO 1
<       END IF
< 
<  5    IF (ABS(udot(2))*dtau.GT.0.01*spin20) THEN
<          dtau = 0.5D0*dtau
<          nsteps = 2*nsteps
<          IT = IT + 1
<          IF (IT.LT.5) GO TO 5
<       END IF
< 
< *     do i=1,nsteps
< *     call rk4c(dtau,u)
< *     IF (IFLAG.GT.0) GO TO 10
< *     enddo
< 
<       ITER = 0
<  6    call rk4c(dtau,u)
<       ITER = ITER + 1
<       IF (IFLAG.EQ.0.AND.ITER.LT.NSTEPS) GO TO 6
---
>         spin1=u(1)
> 	spin2=u(2)
43,45c46
<       spin1=u(1)
<       spin2=u(2)
<       end
---
> 	end
49,50c50,51
< *     Runge-Kutta integrator.
< *     -----------------------
---
> *	Runge-Kutta integrator.
> *       -----------------------
52c53
< *     Author:  Rosemary Mardling (3/98).
---
> *       Author:  Rosemary Mardling (3/98).
88,89c89,90
<       
<       subroutine deriv3(u,udot)
---
> 	
> 	subroutine deriv3(u,udot)
91,120c92,121
<       implicit real*8 (A-H,M,O-Z)
<       real*8 u(2),udot(2)
<       common/spins/angmom0,rg2(2),m21,r21,semi0,C1,C2,C30,C40,C5,semi
<       common/radii/  R1,R2
<       COMMON/CFLAG/ IFLAG,IQ
<       SAVE IC,ID
<       DATA IC,ID /0,0/
< 
< *     Assume e=0.
<       spin1=u(1)
<       spin2=u(2)
< 
<       C3=C30*R1**6
<       C4=C40*R2**6
< 
< *     e2=e**2
< *     e4=e2**2
< *     e6=e4*e2
< *     fac=1-e2
< 
< *     f2=1+7.5*e2+5.625*e4+0.3125*e6
< *     f3=1+3.75*e2+1.875*e4+0.078125*e6
< *     f4=1+1.5*e2+0.125*e4
< *     f5=1+3*e2+0.375*e4
<       
< 
<       semi=angmom0-rg2(1)*spin1-m21*r21**2*rg2(2)*spin2
< *     semi=(semi*(1+m21)/m21/semi0**2)**2/fac
<       semi=(semi*(1+m21)/m21/semi0**2)**2
<       oa = 1.0/semi
---
>         implicit real*8 (A-H,M,O-Z)
> 	real*8 u(2),udot(2)
> 	common/spins/angmom0,rg2(2),m21,r21,semi0,C1,C2,C30,C40,C5,semi
>         common/radii/  R1,R2
>         COMMON/CFLAG/ IFLAG,IQ
>         SAVE IC,ID
>         DATA IC,ID /0,0/
> 
> *       Assume e=0.
> 	spin1=u(1)
> 	spin2=u(2)
> 
> 	C3=C30*R1**6
> 	C4=C40*R2**6
> 
> *       e2=e**2
> *       e4=e2**2
> *       e6=e4*e2
> *       fac=1-e2
> 
> *       f2=1+7.5*e2+5.625*e4+0.3125*e6
> *       f3=1+3.75*e2+1.875*e4+0.078125*e6
> *       f4=1+1.5*e2+0.125*e4
> *       f5=1+3*e2+0.375*e4
>         
> 
> 	semi=angmom0-rg2(1)*spin1-m21*r21**2*rg2(2)*spin2
> *       semi=(semi*(1+m21)/m21/semi0**2)**2/fac
>         semi=(semi*(1+m21)/m21/semi0**2)**2
>         oa = 1.0/semi
122,123c123,124
<          oa0 = oa
<          IQ = 1
---
>       oa0 = oa
>       IQ = 1
125,129c126,130
<       
< *     udot(1)=(oa/fac)**6*C3*(oa**1.5*f2-fac**1.5*f5*spin1)
< *     udot(2)=(oa/fac)**6*C4*(oa**1.5*f2-fac**1.5*f5*spin2)
<       udot(1)=oa**6*C3*(oa**1.5-spin1) - C5*spin1
<       udot(2)=oa**6*C4*(oa**1.5-spin2)
---
> 	
> *       udot(1)=(oa/fac)**6*C3*(oa**1.5*f2-fac**1.5*f5*spin1)
> *       udot(2)=(oa/fac)**6*C4*(oa**1.5*f2-fac**1.5*f5*spin2)
>         udot(1)=oa**6*C3*(oa**1.5-spin1) - C5*spin1
>         udot(2)=oa**6*C4*(oa**1.5-spin2)
132c133
<       IF (ABS(oa - oa0).GT.0.02*oa0) IFLAG = 1
---
>         IF (ABS(oa - oa0).GT.0.02*oa0) IFLAG = 1
134,139c135,140
< *     IC = IC + 1
< *     IC = IC + 1
< *     IF (IC.LT.10) THEN
< *     WRITE (6,1)  IC, spin1, spin2, udot, C5
< *     1       FORMAT (' HUT DERIV    # s1 s2 udot C5 ',I5,1P,6E9.1)
< *     END IF
---
> *       IC = IC + 1
> *       IC = IC + 1
> *       IF (IC.LT.10) THEN
> *           WRITE (6,1)  IC, spin1, spin2, udot, C5
> *   1       FORMAT (' HUT DERIV    # s1 s2 udot C5 ',I5,1P,6E9.1)
> *       END IF
141c142
<       end
---
> 	end
7c7,43
<       Include 'kspars.h'
---
> * There are various choices that can be made for kicks. 
> * Make sure you are comfortable with the choices set (see below) 
> * as this will critically affect retention statistics. 
> *
> * For regular NSs the kick choice is controlled by the value of 
> * DISP (sigma in BSE). Choices are: 
> *    DISP < 0.0 - kick drawn randomly between 0 - ABS(DISP) km/s
> *    DISP = 0.0 - no kick
> *    DISP > 0.0 - kick drawn from a Maxwellian with dispersion DISP. 
> * You may also choose to have the kick velocity distribution scaled 
> * by VSTAR (i.e. scaled by the initial escape velocity). 
> * To do this set VFAC to a non-zero value and VFAC*VSTAR will be 
> * either the maximum of the flat distribution (DISP < 0) or 
> * the dispersion of the Maxwellian (DISP > 0). 
> *
> * Then for an electron capture supernova or an accretion-induced 
> * collapse the choice is determined by the value of ECSIG set 
> * internally here. Choices are: 
> *    ECSIG = 0.0 - no kick
> *    ECSIG > 0.0 - kick drawn from a Maxwellian, dispersion ECSIG 
> *    ECSIG < 0.0 - same as for the regular NSs but scaled by ABS(ECSIG).
> * These supernova are identified by their mass of 1.26 Msun. 
> *
> * For BHs the kick choice is controlled by the value of BHFLAG.  
> * Choices are: 
> *    BHFLAG = 0 - no kick
> *    BHFLAG = 1 - same as for the regular NSs
> *    BHFLAG = 2 - same as for the regular NSs but scaled by fallback. 
> *
> * Small kicks for WDs can also be set if KZ(25) > 0 in the input file. 
> * In this case you can distinguish: 
> *   WDSIG1 - He and COWDs
> *   WDSIG2 - ONeWDs 
> * as the dispersion in a Maxwellian for the different WD types. 
> * A limit of WDKMAX is set. 
> * See Fellhauer et al. 2003, ApJ, 595, L53 for more on WD kicks. 
> *
9,10c45,46
<       REAL*8  RAN2,VK(4)
< *     Unsafe for parallel
---
>       INTEGER BHFLAG
>       REAL*8  RAN2, VK(4)
13,32c49,79
< *       Reinstall the traditional kicks (March 2012)
<       PARAMETER (VFAC=-1.0D0)
< *       Get fallback from hrdiag.f
< *     Safe for parallel
<       common /fall/fallback
< *
< *     --03/07/14 11:30-lwang-ks-parallel--------------------------------*
< ***** Note: Here when icase eq. -147 means for ks communication
< *****       I will be the processer id to share data
<       IF (ICASE.EQ.-147) THEN
< #ifdef PARALLEL         
<          CALL MPI_BCAST(IPAIR,1,MPI_INTEGER,I,MPI_COMM_WORLD,ierr)
<          CALL MPI_BCAST(KC,1,MPI_INTEGER,I,MPI_COMM_WORLD,ierr)
<          CALL MPI_BCAST(VDIS,1,MPI_REAL8,I,MPI_COMM_WORLD,ierr)
<          CALL MPI_BCAST(RI,1,MPI_REAL8,I,MPI_COMM_WORLD,ierr)
< #endif         
<          RETURN
<       END IF
< *     --03/07/14 11:30-lwang-end-ks-parallel----------------------------*
<       
---
>       REAL*8 DISP, VFAC, ECSIG, WDSIG1, WDSIG2, WDKMAX
>       REAL*8 DISP0, VK2
>       LOGICAL IFLAT
> *
> *       Choose the kick settings. 
> *       Some suggested combinations are included: 
> *
> *       Adopt the Maxwellian of Hansen & Phinney (MN 291, 569, 1997) 
> *       for regular NSs, with EC kicks from a Maxwellian with a lower 
> *       peak and BH kicks scaled by fallback. WD kicks depend on #25. 
> *     DISP = 190.D0
> *     VFAC = 0.D0
> *     ECSIG = 20.D0
> *     WDSIG1 = 2.D0
> *     WDSIG2 = 2.D0
> *     WDKMAX = 6.D0
> *     BHFLAG = 2
> *
> *       Take a flat distribution between 0-100 km/s for regular NSs, 
> *       scale EC kicks down by a factor of 4 and do not give kicks 
> *       to BHs. WD kicks depend on #25. 
>       DISP = -100.D0
>       VFAC = 0.D0
>       ECSIG = -0.25D0
>       WDSIG1 = 2.D0
>       WDSIG2 = 2.D0
>       WDKMAX = 6.D0
>       BHFLAG = 0
>       BHFLAG = 2
>       DISP = 20.0
> *
37c84
< *       Identify the correct component (KSTAR reversed in MDOT).
---
> *       Identify the correct component (KSTAR reversed in MDOT or EXPEL).
39c86
<           IF (KSTAR(I1).LT.0) THEN
---
>           IF (KSTAR(I1).LE.0) THEN
41c88
<           ELSE IF (KSTAR(I1+1).LT.0) THEN
---
>           ELSE IF (KSTAR(I1+1).LE.0) THEN
45,46d91
< *     ks MPI communication KSTAR
<           call ksparmpi(K_store,K_int,K_KSTAR,IN,0,KSTAR(IN))
48,55c93,98
< *     When call expel in cmbody and WD/NS binary form after Binary CE, 
< *     There is big energy error when DM is large. It seems here the DM 
< *     will be set to zero and then cause the issue. Thus suppress now.
< C      Determine mass loss and actual disruption velocity.
< C          DM = BODY(IN) - 1.4/ZMBAR
< C          IF (KW.LT.13) DM = 0.0
< C          VD2 = 2.0*(BODY(N+IPAIR) - DM)/R(IPAIR)
<           VD2 = 2.0*(BODY(N+IPAIR))/R(IPAIR)
---
> *       Determine mass loss and actual disruption velocity.
> *         DM = BODY(IN) - 1.4/ZMBAR
> *         IF (KW.LT.13) DM = 0.0
> *         VD2 = 2.0*(BODY(N+IPAIR) - DM)/R(IPAIR)
> *       Determine disruption velocity after mass-loss.
>           VD2 = 2.0*BODY(N+IPAIR)/R(IPAIR)
58d100
< C          VP2 = 2.0*BODY(N+IPAIR)/R(IPAIR)
63c105,110
<           EB = BODY(I1)*BODY(I1+1)/BODY(N+IPAIR)*H(IPAIR)
---
> *       Skip case of massless binary.
>           IF (BODY(N+IPAIR).GT.0.0D0) THEN
>               EB = BODY(I1)*BODY(I1+1)/BODY(N+IPAIR)*H(IPAIR)
>           ELSE
>               EB = 0.0
>           END IF
66,67c113
<           IF ((KW.LT.13.AND.KZ(25).EQ.0).OR.
<      &        (KW.EQ.12.AND.KZ(25).NE.2)) GO TO 30
---
>           IF (KW.LT.13.AND.KZ(25).EQ.0) GO TO 30
71,73d116
< *     ks MPI communicaton EKICK EGRAV
<           call ksparmpi(K_store,K_real8,K_EGRAV,0,0,EB)
<           call ksparmpi(K_store,K_real8,K_EKICK,0,0,EB)
75,76c118
<           if(rank.eq.0)
<      &    WRITE (6,1)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2), ZM1,
---
>           WRITE (6,1)  NAME(I1), NAME(I2), KSTAR(I1), KSTAR(I2), ZM1,
78,80c120,121
<     1     FORMAT (' BINARY KICK:    NAME(I1) NAME(I2) K*(I1) K*(I2) ',
<      &         'M(I1)[M*] M(I2)[M*] VESC[km/s] VDIS[km/s] R12/SEMI ',
<      &         'EB R12[NB] ',2I10,2I4,4F7.1,F6.2,F9.4,1P,E10.2)
---
>     1     FORMAT (' BINARY KICK:    NAM K* M1 M2 VESC VDIS R/A EB R ',
>      &                              2I6,2I4,4F7.1,F6.2,F9.4,1P,E10.2)
87,89d127
< *     ks MPI communication KSTAR
<               call ksparmpi(K_store,K_int,K_KSTAR,N+IPAIR,0,
<      &             KSTAR(N+IPAIR))
105,109c143,144
< C*       Adopt the Maxwellian of Hansen & Phinney (MNRAS 291, 569, 1997).
< C      DISP = 190.0
< *
< *       Adopt the Maxwellian of Hobbs (MNRAS 360, 974, 2005)
<       DISP = 265.0
---
>       ZM = BODY(I)*ZMBAR
>       VKICK = 0.D0
111,125c146,184
< *       Include velocity dispersion in terms of VSTAR (Parameter statement!).
<       IF (VFAC.GT.0.0D0) THEN
<           DISP = VFAC*VSTAR
<       END IF
< *
< *       Allow for optional type-dependent WD kick.
<       IF (KW.LT.13) THEN
<           IF (KZ(25).EQ.1.AND.(KW.EQ.10.OR.KW.EQ.11)) THEN
<               DISP = 5.0
<           ELSE IF (KZ(25).GT.1.AND.KW.EQ.12) THEN
<               DISP = 5.0
<           ELSE
<               DISP = 0.0
<           END IF
<       END IF
---
>       IFLAT = .FALSE.
>       IF(DISP.LT.-0.01)THEN
>          IF(KW.EQ.13.AND.ZM.GE.1.28) IFLAT = .TRUE.
>          IF(KW.EQ.13.AND.ZM.LT.1.28.AND.ECSIG.LT.-0.01) IFLAT = .TRUE.
>          IF(KW.EQ.14.AND.BHFLAG.GT.0) IFLAT = .TRUE.
>       ENDIF
> *
>       IF(IFLAT)THEN
> *
> *       Generate the kick velocity from a flat distribution. 
>          DISP0 = ABS(DISP)
>          IF(VFAC.GT.0.001D0) DISP0 = VFAC*VSTAR
>          IF(KW.EQ.13.AND.ZM.LT.1.28) DISP0 = DISP0*ABS(ECSIG)
> *
>          VKICK = RAN2(IDUM1)*DISP0
>          THETA = RAN2(IDUM1)*TWOPI
>          SPHI = RAN2(IDUM1)
>          X1 = ASIN(SPHI)
>          CPHI = COS(X1)
>          VK(1) = COS(THETA)*CPHI*VKICK
>          VK(2) = SIN(THETA)*CPHI*VKICK
>          VK(3) = SPHI*VKICK
>          VK2 = VKICK*VKICK
> *
>       ELSE
> *
> *       Generate the kick velocity using a Maxwellian distribution. 
>          DISP0 = MAX(DISP,0.D0)
>          IF(VFAC.GT.0.001D0) DISP0 = VFAC*VSTAR
>          IF(KW.EQ.10.OR.KW.EQ.11) DISP0 = MAX(WDSIG1,0.D0)
>          IF(KW.EQ.12) DISP0 = MAX(WDSIG2,0.D0)
>          IF(KW.EQ.13.AND.ZM.LT.1.28)THEN
>             IF(ECSIG.LT.-0.01)THEN
>                DISP0 = DISP0*ABS(ECSIG)
>             ELSE
>                DISP0 = MAX(ECSIG,0.D0)
>             ENDIF
>          ENDIF
>          IF(KW.EQ.14.AND.BHFLAG.EQ.0) DISP0 = 0.D0
128,130c187,189
<       DO 2 K = 1,2
<           X1 = RAN2(IDUM1)
<           X2 = RAN2(IDUM1)
---
>          DO 2 K = 1,2
>              X1 = RAN2(IDUM1)
>              X2 = RAN2(IDUM1)
132,137c191,206
<           S = DISP*SQRT(-2.0*LOG(1.0 - X1))
<           THETA = TWOPI*X2
<           VK(2*K-1) = S*COS(THETA)
<           VK(2*K) = S*SIN(THETA)
<     2 CONTINUE
<       VKICK = SQRT(VK(1)**2 + VK(2)**2 + VK(3)**2)
---
>              S = DISP0*SQRT(-2.0*LOG(1.0 - X1))
>              THETA = TWOPI*X2
>              VK(2*K-1) = S*COS(THETA)
>              VK(2*K) = S*SIN(THETA)
>     2    CONTINUE
> *
>          IF(DISP0.GT.0.001D0)THEN
>             VK2 = VK(1)**2 + VK(2)**2 + VK(3)**2
>             VKICK = SQRT(VK2)
>          ELSE
>             VK2 = 0.D0
>             VKICK = 0.D0
>          ENDIF
> *
>       ENDIF
> *
139d207
<       IF(KW.EQ.14) VKICK = VKICK*(1.D0-fallback)
141,146c209,232
< *       Limit kick velocity to VDIS+10*VSTAR/10*VST for binary/single stars.
< C      IF (IPAIR.GT.0) THEN
< C          VBF = SQRT(VDIS**2 + 100.0*VSTAR**2)
< C          VKICK = MIN(VKICK,VBF)
< C      ELSE
< C          VKICK = MIN(VKICK,10.0D0*VSTAR)
---
> * Impose the maximum WD kick velocity. 
> *
>       IF(KW.GE.10.AND.KW.LE.12.AND.VKICK.GT.WDKMAX)THEN
>          VKICK = WDKMAX
>       ENDIF
> *
> * Restrict the BH kick velocity by fallback. 
> * This could be done better but in the N-body code we only have 
> * limited information. 
> *
>       IF(KW.EQ.14.AND.BHFLAG.GT.1)THEN
>          VKICK = VK(4)*DM/(BODY(I)+DM)
>       ENDIF
> *
> *       Limit kick velocity to VDIS+10*VSTAR/10*VST.
> *       (disabled)
>       IF (IPAIR.GT.0) THEN
>           VBF = SQRT(VDIS**2 + 100.0*VSTAR**2)
> *       Include large kick velocity to ensure escape of disrupted star.
>           IF (KW.LT.10.OR.(KW.LT.13.AND.KZ(25).EQ.0)) VKICK = 1.0*VBF
> *         VKICK = MIN(VKICK,VBF)
> *         VKICK = MAX(VKICK,VDIS+3.0*VSTAR)
>       ELSE
> *         VKICK = MIN(VKICK,10.0D0*VSTAR)
148,150c234,235
<       IF (IPAIR.LE.0.AND.BODY(I).EQ.0.0D0) VKICK = 10.0*VSTAR
< C      END IF
<       VKICK = VKICK/VSTAR
---
>           IF (BODY(I).EQ.0.0D0) VKICK = 10.0*VSTAR
>       END IF
152c237,243
<       IF (VKICK.EQ.0.0) GO TO 30
---
>       IF (VKICK.NE.VK(4)) THEN
>          DO K = 1,3
>             VK(K) = VK(K)*VKICK/VK(4)
>          ENDDO
>          VK2 = VKICK*VKICK
>          VK(4) = VKICK
>       END IF
154,159c245,246
< *       Randomize the velocity components.
< *     A(4) = 0.0
< *     DO 5 K = 1,3
< *         A(K) = 2.0*RAN2(IDUM1) - 1.0
< *         A(4) = A(4) + A(K)**2
< *   5 CONTINUE
---
> *       Skip case of zero kick velocity.
>       IF (VKICK.EQ.0.0D0.OR.DISP0.EQ.0.0D0) GO TO 30
161a249
>       VKICK = VKICK/VSTAR
164d251
<       CALL JPRED(I,TIME,TIME)
167,168c254
< *         XDOT(K,I) = XDOT(K,I) + VKICK*A(K)/SQRT(A(4))
<           XDOT(K,I) = XDOT(K,I) + VKICK*VK(K)/VK(4)
---
>           XDOT(K,I) = XDOT(K,I) + VK(K)/VSTAR
170,171d255
< *     ks MPI communication
<           call ksparmpi(K_store,K_real8,K_X0DOT,k,i,x0dot(k,i))
176,179c260
<       DETMP = - 0.5*BODY(I)*(VF2 - VI2)
<       ECDOT = ECDOT + DETMP
< *     ks MPI communication
<       call ksparmpi(K_store,K_real8,K_ECDOT,0,0,DETMP)
---
>       ECDOT = ECDOT - 0.5*BODY(I)*(VF2 - VI2)
182c263,264
< *       Replace final velocity by relative velocity for binary kick.
---
> *       Evaluate binary kick energy from relative velocity (for
> *       diagnostics).
188d269
<           CALL JPRED(J,TIME,TIME)
193c274,279
<           EB1 = BODY(I)*BODY(J)/(BODY(I) + BODY(J))*HNEW
---
> *       Exclude colliding WDs.
>           IF (BODY(I) + BODY(J).EQ.0.0D0) THEN
>               EB1 = 0.0
>           ELSE
>               EB1 = BODY(I)*BODY(J)/(BODY(I) + BODY(J))*HNEW
>           END IF
197,199d282
< *     ks MPI communicaton EKICK EGRAV
<               call ksparmpi(K_store,K_real8,K_EGRAV,0,0,-EB1)
<               call ksparmpi(K_store,K_real8,K_EKICK,0,0,-EB1)
204,215c287,292
< *     IF (NKICK.LT.50.OR.NAME(I).LE.2*NBIN0.OR.
< *    &    (KW.GE.13.AND.TTOT*TSTAR.GT.100.0)) THEN
<           ZM = BODY(I)*ZMBAR
<           if(rank.eq.0)
<      &    WRITE (6,20)  I, NAME(I), (TIME+TOFF)*TSTAR, KSTAR(I), KW, KC,
<      &         BODY0(I)*ZMBAR,ZM,SQRT(VI2)*VSTAR, VKICK*VSTAR, 
<      &         SQRT(VF2)*VSTAR, VK(4),fallback
<    20     FORMAT (' VELOCITY KICK: I',I10'  NAME',I10,
<      &         '  Time[Myr]',E12.5,'  K*0',I4,
<      &         '  K*',I4,'  K*(ICM)',I4'  M0[M*]',F9.4,'  MN[M*]',F9.4,
<      &         '  VI[km/s]',F9.4,'  VK[km/s]',F9.4'  VF[km/s]',F9.4,
<      &         '  VK0[km/s]',F9.4,'  FB',F9.4)
---
>       IF (NKICK.LT.50.OR.NAME(I).LE.2*NBIN0.OR.
>      &    (KW.GE.13.AND.TTOT*TSTAR.GT.100.0)) THEN
>           WRITE (6,20)  I, NAME(I), KSTAR(I), KC, BODY0(I)*ZMBAR, ZM,
>      &                  SQRT(VI2)*VSTAR, VKICK*VSTAR, SQRT(VF2)*VSTAR
>    20     FORMAT (' VELOCITY KICK:    I NAM K* KC* M0 M VI VK VF ',
>      &                                2I6,2I4,2F7.2,3F7.1)
217c294
< *     END IF
---
>       END IF
220,224c297,299
<       IF (VKICK.LT.4.0*SQRT(0.5).AND.KW.GE.13) THEN
<           if(rank.eq.0)
<      &    WRITE (6,25)  I, NAME(I), KW, VKICK*VSTAR, SQRT(VF2)*VSTAR
<    25     FORMAT (' LOW KICK:    I',I10,'  NAME',I10,'  K*',I4,
<      &         '  VK[km/s]',F7.2,'  VF[km/s]',F7.2)
---
>       IF (VKICK.LT.4.0*SQRT(0.5).AND.KW.GE.13.AND.VKICK.GT.0.05) THEN
>           WRITE (6,25)  I, NAME(I), KW, VKICK*VSTAR, SQRT(VF2)*VSTAR
>    25     FORMAT (' LOW KICK:    I NAM K* VK VF ',2I7,I4,2F7.2)
4,5c4,5
< *       Velocity kick for Roche NS & BH stars.
< *       --------------------------------------
---
> *       Velocity kick for Roche WD, NS & BH stars.
> *       ------------------------------------------
27c27,30
<       CALL KICK(I,1,KW,DM)
---
>       CALL KICK(I,1,KW,0.0D0)
> *
> *       Copy block-step time to prevent SMALL STEP problem (19/3/12).
>       TIME = TBLOCK
40,41d42
< *     shift particle one step deeper
<               call delay_remove_tlist(J,STEP,DTK)
43,44c44
<               call delay_store_tlist(J)
<               TIMENW(J) = T0(J) + STEP(J)
---
>               TNEW(J) = T0(J) + STEP(J)
9d8
<       INCLUDE 'timing.h'
16,17c15,16
<      &               NAMEC(NTMAX)
<       INTEGER JX(2),KACC,MLIST(NMAX),ML,ML0
---
>      &               NAMEC(NTMAX),MLIST(NMAX)
>       INTEGER JX(2),KACC
40,49d38
< *      INTEGER NDMLIST(NMAX),NPNUM
< *      REAL*8 DMLIST(NMAX)
< *      LOGICAL IGPUDM,IGPUSWITCH
< *     --11/10/13 15:34-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$      INTEGER MDOT_C
< c$$$      DATA MDOT_C /0/
< c$$$      SAVE MDOT_C
< c$$$      MDOT_C = MDOT_C + 1
< *     --11/10/13 15:34-lwang-end----------------------------------------*
57d45
<       NPNUM = 0
59,77c47,58
< c$$$      IGPUDM = .false.
< c$$$      IGPUSWITCH = .false.
< c$$$#ifdef GPU
< c$$$      IGPUDM = .true.
< c$$$      call gpupot_send(rank,NTOT-IFIRST+1,BODY(IFIRST),X(1,IFIRST))
< c$$$#endif                  
< c$$$      NCNUM = 0
< *
< *       Form list of look-up times.
<  1    ML0 = 0
<       ML = 0
<       DO J = 1,NTOT
<          IF (TEV(J).LE.TIME) THEN
<             ML0 = ML0 + 1
<             MLIST(ML0) = J
<          ELSE
<             TMDOT = MIN(TMDOT,TEV(J))
<          END IF
<       END DO
---
> *
> *       Form list of look-up times and determine next TMDOT.
>     1 ML = 0
>       ML0 = 0
>       DO 2 J = 1,NTOT
>           IF (TEV(J).LE.TIME) THEN
>               ML0 = ML0 + 1
>               MLIST(ML0) = J
>           ELSE
>               TMDOT = MIN(TMDOT,TEV(J))
>           END IF
>     2 CONTINUE
79,81c60,67
< 
< *     Find global index of next star to be checked (NB! reset KS & IKS).
<  4    ML = ML + 1
---
>       IF (ML0.GE.NMAX) THEN
>           WRITE (6,3)  ML0, TIME
>     3     FORMAT (' DANGER!    MDOT LIMIT   ML T',I5,F8.2)
>           STOP
>       END IF
> *
> *       Treat list members sequentially until GO TO 5 at end.
>     4 ML = ML + 1
83,89c69,78
< *     Avoid the same binary or merger do the loop again
<       IF(TEV(I).GT.TIME) THEN
<          IF(ML.LT.ML0) THEN
<             GO TO 4
<          ELSE
<             GO TO 103
<          END IF
---
> *       Beware reduction of NTOT by KSTERM since last update!! (bug 2/17).
>       IF (I.GT.NTOT) GO TO 100
> *
> *       Avoid the same binary or merger
>       IF (TEV(I).GT.TIME) THEN
>           IF (ML.LT.ML0) THEN
>               GO TO 4
>            ELSE
>               GO TO 100
>           END IF
91c80,82
<  5    KS = 0
---
> *
> *       Consider global index of next star (NB! reset KS & IKS).
>     5 KS = 0
103,116d93
<       
< *
< c$$$*       Determine smallest look-up time (< TIME!).
< c$$$      DO 5 J = 1,NTOT
< c$$$          IF (TEV(J).LE.TIME) THEN
< c$$$              I = J
< c$$$              GO TO 10
< c$$$          END IF
< c$$$    5 CONTINUE
< c$$$*
< *       Determine new evolution time (current TMDOT may be escaped star).
< c$$$      KW = 0
< c$$$      I = 1
< c$$$      GO TO 70
121c98,102
<           CALL BRAKE2(KSPAIR,ITERM)
---
> *       Check spin synchronization of inner binary for small eccentricity.
>           CALL SPINUP(KSPAIR,ITERM)
>           IF (ITERM.EQ.0) THEN
>               CALL BRAKE2(KSPAIR,ITERM)
>           END IF
123,129c104,110
< C             NWARN = NWARN + 1
< C             IF (rank.eq.0.and.NWARN.LT.1000) THEN
< C                 WRITE(14,900) KSPAIR, NAME(I), TTOT, R(KSPAIR)
< C 900             FORMAT('BRAKE2 MERGER TERM:    K* NAME(ICM) Time[NB] ',
< C     &                'R12[NB] ',I4,I12,1P,E26.17,E15.6)
< C                 CALL FLUSH(14)
< C             END IF
---
>              NWARN = NWARN + 1
>              IF (NWARN.LT.1000) THEN
>                  WRITE(14,900) KSPAIR, NAME(I), TTOT, R(KSPAIR)
>  900             FORMAT(' MDOT MERGER TERM:    KS NAM T R ',
>      &                                         I4,I6,F10.4,1P,E10.2)
>                  CALL FLUSH(14)
>              END IF
132,134d112
<              IPOLY = -1
< *     Do enery correction before particle index change
< *             call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,IGPUSWITCH)
136,140d113
< *     If reset, send new jparticle to gpu and use gpupot_dm
< c#ifdef GPU             
< c             IGPUDM = .true.
< c             IGPUSWITCH = .true.
< c#endif             
162d134
<                   IPOLY = -1
164,166d135
< *     Do enery correction before particle index change
< *                  call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< *     &                 IGPUSWITCH)
168,172d136
< *     If reset, send new jparticle to gpu and use gpupot_dm
< *#ifdef GPU             
< *                  IGPUDM = .true.
< *                  IGPUSWITCH = .true.
< *#endif             
178c142
< *     Check possible Roche overflow condition (skip any ghost c.m.).
---
> *       Check possible Roche overflow condition (skip any ghost c.m.).
184,192c148
< *     Do enery correction before particle index change
< *             call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< *     &            IGPUSWITCH)
<              CALL ROCHE(IPAIR)
< *     If reset, send new jparticle to gpu and use gpupot_dm
< *#ifdef GPU             
< *                  IGPUDM = .true.
< *                  IGPUSWITCH = .true.
< *#endif             
---
>               CALL ROCHE(IPAIR)
199,200c155
<                  if(rank.eq.0)
<      &           WRITE(6,902)I,NAME(I),IPAIR,KSTAR(I),TEV(I),TTOT
---
>                  WRITE(6,902)I,NAME(I),IPAIR,KSTAR(I),TEV(I),TTOT
208,210d162
< *     Do enery correction before particle index change
< *                  call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< *     &                 IGPUSWITCH)
212,216d163
< *     If reset, send new jparticle to gpu and use gpupot_dm
< *#ifdef GPU             
< *                  IGPUDM = .true.
< *                  IGPUSWITCH = .true.
< *#endif             
246,249d192
<                       IPOLY = -1
< *     Do enery correction before particle index change
< *                      call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< *     &                     IGPUSWITCH)
251,255d193
< *     If reset, send new jparticle to gpu and use gpupot_dm
< *#ifdef GPU             
< *                      IGPUDM = .true.
< *                      IGPUSWITCH = .true.
< *#endif             
269c207
<               IF (rank.eq.0.and.MOD(IWARN,100).EQ.0) THEN
---
>               IF (MOD(IWARN,100).EQ.0) THEN
290c228
<           IF(rank.eq.0.and.IGHOST.LT.0)THEN
---
>           IF(IGHOST.LT.0)THEN
298,299c236,237
<               IF (rank.eq.0.and.I.EQ.IGHOST) WRITE(6,906) I, NAME(I),
<      &                                       KSTAR(I), TEV(I), BODY(I)
---
>               IF (I.EQ.IGHOST) WRITE(6,906) I, NAME(I), KSTAR(I),
>      &                                      TEV(I), BODY(I)
314,315c252
<                   if(rank.eq.0)
<      &            WRITE(6,908) IGHOST, I0, I, NAME(I), KSTAR(I), TEV(I)
---
>                   WRITE(6,908) IGHOST, I0, I, NAME(I), KSTAR(I), TEV(I)
318,321d254
< *     Do enery correction before particle index change
< *                     call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< *     &                    IGPUSWITCH)
< *     If reset, send new jparticle to gpu and use gpupot_dm
323,327c256
< *#ifdef GPU             
< *                     IGPUDM = .true.
< *                     IGPUSWITCH = .true.
< *#endif             
<                      GO TO 1
---
>                      GOTO 1
352,355d280
<                   IPOLY = -1
< *     Do enery correction before particle index change
< *                  call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< *     &                 IGPUSWITCH)
357,361d281
< *     If reset, send new jparticle to gpu and use gpupot_dm
< *#ifdef GPU             
< *                  IGPUDM = .true.
< *                  IGPUSWITCH = .true.
< *#endif             
395c315
< *            IF (rank.eq.0.and.MOD(IWARN,100).EQ.0) THEN
---
> *            IF (MOD(IWARN,100).EQ.0) THEN
410,411d329
< *                  call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< *     &                 IGPUSWITCH)
413,416d330
< *#ifdef GPU             
< *                  IGPUDM = .true.
< *                  IGPUSWITCH = .true.
< *#endif             
473,475d386
<              IPOLY = -1
< *     Do enery correction before particle index change
< *             call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,IGPUSWITCH)
477,480d387
< *#ifdef GPU             
< *             IGPUDM = .true.
< *             IGPUSWITCH = .true.
< *#endif             
530,531c437
<             if(rank.eq.0)
<      &      WRITE(6,912)JX,NAME(N+KSPAIR),SQRT(ECC2),TTOT
---
>             WRITE(6,912)JX,NAME(N+KSPAIR),SQRT(ECC2),TTOT
569,570d474
<          RI = SQRT(X(1,I)**2 + X(2,I)**2 + X(3,I)**2)
<          VI = SQRT(XDOT(1,I)**2 + XDOT(2,I)**2 + XDOT(3,I)**2)
573,578c477,480
<          IF(KW.NE.KSTAR(I).OR.DABS(M1-M0)/M0.GT.0.05D0)THEN
<             IF (rank.eq.0.and.KW.GE.13) THEN
<                 WRITE (6,190)  I, NAME(I), KSTAR(I), KW, MASS(K), M0,
<      &              RADIUS(I)*SU, VI, RI, RCC, MC
<   190           FORMAT (' NS/BH FORMATION  ',2I10,2I4,' M new/old[*]',
<      &     1P,2E9.1,' RAD[*]',E9.1,' R,V=',2E9.1,' RCC,MC=',2E9.1)
---
>          IF(KW.NE.KSTAR(I))THEN
>             IF (KW.GE.13) THEN
>                 WRITE (6,190)  I, NAME(I), KSTAR(I), KW, MASS(K)
>   190           FORMAT (' NS/BH FORMATION    ',2I7,2I4,F7.2)
580d481
<             KWOLD = KW
583,592d483
<            
< c$$$*        Start new full sev output
< c$$$            if(rank.eq.0)then
< c$$$            RI = SQRT(X(1,I)**2 + X(2,I)**2 + X(3,I)**2)
< c$$$            VI = SQRT(XDOT(1,I)**2 + XDOT(2,I)**2 + XDOT(3,I)**2)
< c$$$            write(111,191) 0,0,name(i),ttot,m0,radius(i),
< c$$$     *          kw,kwold,ri,vi,age0(k),mass(k),massc(k),menv(k),
< c$$$     *          rad(k),radc(k),renv(k),lumin(k),tm0(k)
< c$$$ 191        format(1x,2i5,i8,1p,3e12.5,2i4,11e12.5)
< c$$$            end if
648,649c539,540
<                IF(rank.eq.0.and.DMA(K).GE.3.16E-9.AND.KW.GE.10)THEN
<                   WRITE(20,913) NAME(I),NAME(JX(3-K)),KSTAR(I),
---
>                IF(DMA(K).GE.3.16E-9.AND.KW.GE.10)THEN
>                   WRITE(20,913)NAME(I),NAME(JX(3-K)),KSTAR(I),
651,653c542,543
<  913              FORMAT(' WINDAC    NAME NAME(JC) K* K*(JC) Time[Myr]',
<      &                 'M[M*] SEMI[R*] DMX(JC) DMA',
<      &                 2I12,2I4,1P,E25.16,4E12.5,0P)
---
>  913              FORMAT(' WINDAC    NAM K* T M A MLOSS MACC ',
>      &                               2I6,2I4,F9.2,2F6.2,F8.1,1P,2E9.1)
727,728c617
< *        if(rank.eq.0)
< *    &   write(*,*)' grrad ',sep,ecc,djgr,delet,dtxmin
---
> *        write(*,*)' grrad ',sep,ecc,djgr,delet,dtxmin
815,816c704
<                if(rank.eq.0)
<      &         WRITE(6,914)NAME(I),M1,TM,TPHYS2,EPCH0(K)+TOFF*TSTAR,
---
>                WRITE(6,914)NAME(I),M1,TM,TPHYS2,EPCH0(K)+TOFF*TSTAR,
837,838c725
<                if(rank.eq.0)
<      &         WRITE(6,994)NAME(I), KW, DMS(K), AGE, TN
---
>                WRITE(6,994)NAME(I), KW, DMS(K), AGE, TN
854,856d740
<          IF(rank.eq.0.and.KW.EQ.14)PRINT*,' MDOT: T,M0,MC,AGE=',
<      &                TTOT,M0,MC,AGE
< *
866,867c750
<                if(rank.eq.0)
<      &         WRITE(6,915)I,NAME(I),M0,KSTAR(I),TEVK*TSTAR-EPCH0(K)
---
>                WRITE(6,915)I,NAME(I),M0,KSTAR(I),TEVK*TSTAR-EPCH0(K)
872,875d754
<                   IPOLY = -1
< *     Do enery correction before particle index change
< *                  call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< *     &                 IGPUSWITCH)
877,881d755
< *     If reset, send new jparticle to gpu and use gpupot_dm
< *#ifdef GPU             
< *                  IGPUDM = .true.
< *                  IGPUSWITCH = .true.
< *#endif             
920,922d793
<                IPOLY = -1
< *     Do enery correction before particle index change
< *               call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,IGPUSWITCH)
924,928d794
< *     If reset, send new jparticle to gpu and use gpupot_dm
< *#ifdef GPU             
< *               IGPUDM = .true.
< *               IGPUSWITCH = .true.
< *#endif             
970c836
< *    &            (KW.NE.KSTAR(I).AND.KW.GE.13)) THEN
---
>      &            (GAMMA(KSPAIR).GT.0.001.AND.
972,974c838
<      &            (KW.GE.13.OR.(KW.GE.11.AND.KZ(25).GE.1).OR.
<      &            (KW.EQ.10.AND.KZ(25).GT.1)))) THEN
< *               IF (KSTAR(I).LT.10.AND.KW.GE.10) THEN
---
>      &            (KW.GE.13.OR.(KW.GE.10.AND.KZ(25).GT.0))))) THEN
983c847
<                   IF(IPOLY.GE.0) IPOLY = 2
---
>                   IPOLY = -1
985,987d848
< *     Do enery correction before particle index change
< *                  call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< *     &                 IGPUSWITCH)
989,993d849
< *     If ksterm, send new jparticle to gpu and use gpupot_dm
< *#ifdef GPU
< *                  IGPUDM = .true.
< *                  IGPUSWITCH = .true.
< *#endif                  
1006,1007c862
<      &             (KW.LT.10.OR.(KW.LT.11.AND.KZ(25).LT.2).OR.
<      &             (KW.LT.13.AND.KZ(25).LT.1))) THEN
---
>      &             (KW.LT.10.OR.(KW.LT.13.AND.KZ(25).LT.1))) THEN
1011,1014d865
<                   IPOLY = -1
< *     Do enery correction before particle index change
< *                  call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< *     &                 IGPUSWITCH)
1016,1020d866
< *     If reset, send new jparticle to gpu and use gpupot_dm
< *#ifdef GPU             
< *                  IGPUDM = .true.
< *                  IGPUSWITCH = .true.
< *#endif             
1028,1029c874
<             if(rank.eq.0)
<      &      WRITE(6,920) I, NAME(I), KW, TPHYS, AGE, M1, M0
---
>             WRITE(6,920) I, NAME(I), KW, TPHYS, AGE, M1, M0
1034c879
< *       Perform neighbour force corrections on significant mass loss (no WD).
---
> *       Perform neighbour force corrections on significant mass loss.
1056,1062c901,906
<             BODY1 = MAX(BODY1,MASS(K)/ZMBAR)
< c$$$            IF(MASS(K)/ZMBAR.GE.0.99*BODY1.AND.NSUB.EQ.0)THEN
< c$$$               BODY1 = 0.d0
< c$$$               DO 35 J = 1,N
< c$$$                  BODY1 = MAX(BODY1,BODY(J))
< c$$$  35           CONTINUE
< c$$$            ENDIF
---
>             IF(MASS(K)/ZMBAR.GE.0.99*BODY1.AND.NSUB.EQ.0)THEN
>                BODY1 = 0.d0
>                DO 35 J = 1,N
>                   BODY1 = MAX(BODY1,BODY(J))
>   35           CONTINUE
>             ENDIF
1082,1088c926,931
< C            IF (rank.eq.0.and.KZ(19).GT.4) THEN
< C               WRITE(6,36) TTOT, I, NAME(I), KSTAR(I), KW, DMSUN,
< C     &              BODY(I)*ZMBAR, ZMDOT
< C  36           FORMAT(' MDOT:      Time[NB]',1P,E15.6,0P,' I',I8,
< C     &              ' NAME',I8,' K*0',I3,' K*N',I3,' DM[M*]',F7.2,
< C     &              ' M1[M*]',F7.1,' DMTOT[M*]',F12.2)
< C            END IF
---
>             IF (KZ(19).GT.3) THEN
>                WRITE(6,36) I, NAME(I), KW, KSTAR(I), BODY(I)*ZMBAR,
>      &                     DMSUN, ZMDOT, TPHYS
>   36           FORMAT(' MDOT:    I NM KW K* MS DMS ZMDOT T6 ',
>      &                           4I5,F6.1,F7.2,F7.1,F8.1)
>             END IF
1124,1143c967,972
< *            DO 40 L = 2,NNB2
< *               J = ILIST(L)
< *               IF (T0(J).LT.TIME) THEN
< *                  CALL XVPRED(J,-2)
< *               END IF
< *     --09/27/13 10:39-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$      if(time.ge.3.5373535156250000) then
< c$$$      write(112+rank,*),j,name(j),'x',(x(kk,j),kk=1,3),
< c$$$     *        'xdot',(xdot(kk,j),kk=1,3),'x0',(x0(kk,j),kk=1,3),
< c$$$     *        'x0dot',(x0dot(kk,j),kk=1,3),'t0',t0(j),'step',step(j),
< c$$$     *        'f',(f(kk,j),kk=1,3),'fdot',(fdot(kk,j),kk=1,3),
< c$$$     *        'd0',(d0(kk,j),kk=1,3),'d1',(d1(kk,j),kk=1,3),
< c$$$     *        'd2',(d2(kk,j),kk=1,3),'d3',(d3(kk,j),kk=1,3),
< c$$$     *        'd0r',(d0r(kk,j),kk=1,3),'d1r',(d1r(kk,j),kk=1,3),
< c$$$     *        'd2r',(d2r(kk,j),kk=1,3),'d3r',(d3r(kk,j),kk=1,3),
< c$$$     *        'body',body(j),'dt',time-t0(j),'time',time
< c$$$      end if
< *     --09/27/13 10:39-lwang-end----------------------------------------*
< *   40       CONTINUE
---
>             DO 40 L = 2,NNB2
>                J = ILIST(L)
>                IF (T0(J).LT.TIME) THEN
>                   CALL XVPRED(J,-2)
>                END IF
>    40       CONTINUE
1147,1148c976
<             IF (KZ(25).EQ.1.AND.(KW.EQ.10.OR.KW.EQ.11)) IKICK = .TRUE.
<             IF (KZ(25).EQ.2.AND.KW.EQ.12) IKICK = .TRUE.
---
>             IF (KZ(25).GT.0.AND.KW.GE.10.AND.KW.LE.12) IKICK = .TRUE.
1152,1167d979
< c$$$       IF(rank.eq.0.and.KW.GE.13.AND.KW.LE.15) then
< c$$$          write(6,*), 'MDOT K*',KW,' K*0',KSTAR(I),' NAME',NAME(I),
< c$$$     &         ' IKICK',IKICK,' M0',M0,' MC',MC,' AGE',AGE,' TN',TN,
< c$$$     &         ' DM',DM,' DMSUN',DMSUN,' TIME',TIME
< c$$$       end if
< 
< *     --09/27/13 10:39-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$      if(time.ge.3.5373535156250000) then
< c$$$      il=3173
< c$$$      print*,rank,'m3',il,name(il),d3(1,il),d2r(1,il),d3r(1,il),time
< c$$$      print*,rank,'ff',i,dmsun,kw,ikick,iphase
< c$$$      call flush(6)
< c$$$      end if
< *     --09/27/13 10:39-lwang-end----------------------------------------*
<        
1169,1194c981,982
<             IF (DMSUN.LE.0.05.AND.(KW.LT.10.OR..NOT.IKICK)) THEN
< c$$$          IF(NPNUM.GT.0) THEN
< c$$$             IF(NDMLIST(NPNUM).EQ.I) THEN
< c$$$                DMLIST(NPNUM) = DMLIST(NPNUM) + DM
< c$$$             ELSE
< c$$$                NPNUM = NPNUM + 1
< c$$$                NDMLIST(NPNUM) = I
< c$$$                DMLIST(NPNUM) = DM
< c$$$             END IF
< c$$$          ELSE
< c$$$             NPNUM = NPNUM + 1
< c$$$             NDMLIST(NPNUM) = I
< c$$$             DMLIST(NPNUM) = DM
< c$$$          END IF
<                call cputim(tttfia)
<                CALL FICORR(I,DM)
<                call cputim(tttfib)
<                ttfic = ttfic + (tttfib-tttfia)*60
< *          call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,IGPUSWITCH)
< *     --11/10/13 15:36-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$  if(rank.eq.0) THEN
< c$$$  write(130,*) 1,MDOT_C,NAME(I),DMSUN,KW,TIME,
< c$$$  &                (tttfib-tttfia)*60
< c$$$  END if
< *     --11/10/13 15:36-lwang-end----------------------------------------*
---
>             IF (DMSUN.LT.0.05.AND.(KW.LT.10.OR..NOT.IKICK)) THEN
>                 CALL FICORR(I,DM)
1196,1217c984
< c$$$          IF (KW.GE.10.AND.KW.LE.15) THEN
< c$$$             call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,IGPUSWITCH)
< c$$$  NCNUM = 0
< c$$$          END IF
<                call cputim(tttfia)
<                CALL FCORR(I,DM,KW)
<                call cputim(tttfib)
< c$$$  if(NCNUM.GT.0.AND.DCLIST(NCNUM).EQ.I) THEN
< c$$$  DCLIST(NCNUM) = DCLIST(NCNUM) + DM
< c$$$  else
< c$$$  NCNUM = NCNUM + 1
< c$$$  NDCLIST(NCNUM) = I
< c$$$  DCLIST(NCNUM) = DM
< c$$$  end if
<                ttfc = ttfc + (tttfib-tttfia)*60
< *     --11/10/13 15:36-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$  if(rank.eq.0) THEN
< c$$$  write(130,*) 0,MDOT_C,NAME(I),DMSUN,KW,TIME,
< c$$$  &                (tttfib-tttfia)*60
< c$$$  end if
< *     --11/10/13 15:36-lwang-end----------------------------------------*
---
>                 CALL FCORR(I,DM,KW)
1224,1306c991,1019
< *     --11/16/13 10:40-lwang-check--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$       IF (KW.GE.10.AND.KW.LE.15.OR.IKICK) THEN
< c$$$          X0DOT(1:3,I) = XDOT(1:3,I)
< c$$$          X0(1:3,I) = X(1:3,I)
< c$$$          call fpoly1(I,I,0)
< c$$$          call fpoly2(I,I,0)
< c$$$          call steps(I,I)
< *     Reduce the steps to make safe
< c$$$          IF(T0(I)+0.5D0*STEP(I).GE.TBLOCK) THEN
< c$$$             STEP(I) = 0.5D0*STEP(I)
< c$$$             IF(T0(I)+0.5D0*STEP(I).GE.TBLOCK) STEP(I) = 0.5D0*STEP(I)
< c$$$          END IF
< c$$$          DO JK = 2, LIST(1,I)+1
< c$$$             JJ = LIST(JK,I)
< c$$$             IF(T0(JJ)+0.5D0*STEP(JJ).GE.TBLOCK) THEN
< c$$$                STEP(JJ) = 0.5D0*STEP(JJ)
< c$$$                IF(T0(JJ)+0.5D0*STEP(JJ).GE.TBLOCK) THEN
< c$$$                   STEP(JJ) = 0.5D0*STEP(JJ)
< c$$$                END IF
< c$$$             END IF
< c$$$          END DO
< 
< *     Make iphase eq -1 thus the nxtlst will determined by full N loop
< c$$$          IPOLY = -1
< *     --03/20/14 13:41-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$          print*,'I KICK',I,'N',NAME(I),'T0',T0(I),'STEP',STEP(I)
< c$$$          call flush(6)
< c$$$          print*,rank,'KICK I',I,'N',NAME(I),'STEP',STEP(I),'T0',T0(I),
< c$$$     &         'STEPR',STEPR(I),'T0R',T0R(I),'T',TIME
< c$$$          call flush(6)
< *     --03/20/14 13:41-lwang-end----------------------------------------*
< c$$$       end if
< *     --11/16/13 10:40-lwang-end----------------------------------------*
< c$$$            IF (ABS(DMSUN).GT.0.1.OR.KW.GE.13.OR.IKICK) THEN
< c$$$*
< c$$$*     --09/06/13 16:21-lwang-template-----------------------------------*
< c$$$***** Note: Do full prediction before fpoly1----------------------------*
< c$$$*               call xbpredall
< c$$$*     --09/06/13 16:21-lwang-end----------------------------------------*
< c$$$*       Obtain new F & FDOT and time-steps (no gain skipping WDs).
< c$$$               DO 50 L = 2,NNB2
< c$$$                  J = ILIST(L)
< c$$$                  IF (L.EQ.NNB2) THEN
< c$$$                     J = I
< c$$$                  ELSE
< c$$$                     NNBJ=LIST(1,J)
< c$$$                     call xvpred(J,nnbj)
< c$$$                  end if
< c$$$*     --09/27/13 10:39-lwang-debug--------------------------------------*
< c$$$***** Note:------------------------------------------------------------**
< c$$$c$$$      if(time.ge.3.5373535156250000) then
< c$$$c$$$         do jk=2,list(1,j)+1
< c$$$c$$$            jj=list(jk,j)
< c$$$c$$$      write(117+rank,*),jj,name(jj),'x',(x(kk,jj),kk=1,3),
< c$$$c$$$     *        'xdot',(xdot(kk,jj),kk=1,3),'x0',(x0(kk,jj),kk=1,3),
< c$$$c$$$     *        'x0dot',(x0dot(kk,jj),kk=1,3),'t0',t0(jj),'step',step(jj),
< c$$$c$$$     *        'f',(f(kk,jj),kk=1,3),'fdot',(fdot(kk,jj),kk=1,3),
< c$$$c$$$     *        'd0',(d0(kk,jj),kk=1,3),'d1',(d1(kk,jj),kk=1,3),
< c$$$c$$$     *        'd2',(d2(kk,jj),kk=1,3),'d3',(d3(kk,jj),kk=1,3),
< c$$$c$$$     *        'd0r',(d0r(kk,jj),kk=1,3),'d1r',(d1r(kk,jj),kk=1,3),
< c$$$c$$$     *        'd2r',(d2r(kk,jj),kk=1,3),'d3r',(d3r(kk,jj),kk=1,3),
< c$$$c$$$     *        'body',body(jj),'dt',time-t0(jj),'time',time
< c$$$c$$$      end do
< c$$$c$$$      end if
< c$$$*     --09/27/13 10:39-lwang-end----------------------------------------*
< c$$$*                 CALL DTCHCK(TIME,STEP(J),DTK(MAXBLK)) ! no effect (08/10).
< c$$$                  DO 45 KK = 1,3
< c$$$                     X0DOT(KK,J) = XDOT(KK,J)
< c$$$   45             CONTINUE
< c$$$                  CALL FPOLY1_KS(J,J,0)
< c$$$                  CALL FPOLY2_KS(J,J,0)
< c$$$                  IPOLY = -1
< c$$$   50          CONTINUE
< c$$$*       Check optional c.m. correction.
< c$$$               IF (KZ(14).GE.3.AND.KZ(31).GT.0) THEN
< c$$$                  CALL XVPRED(IFIRST,NTOT)
< c$$$                  CALL CMCORR
< c$$$               END IF
< c$$$            END IF
<             
< C            TPREV = TIME - STEPX
---
>             IF (ABS(DMSUN).GT.0.1.OR.KW.GE.13.OR.IKICK) THEN
> *
> *       Obtain new F & FDOT and time-steps (no gain skipping WDs).
>                DO 50 L = 2,NNB2
>                   J = ILIST(L)
>                   IF (L.EQ.NNB2) J = I
>                   IF (KW.EQ.15.AND.LIST(1,J).EQ.1) THEN
>                      JJ = LIST(2,J)
>                      IF (BODY(JJ).EQ.0.D0) THEN
>                         LIST(1,J) = 2
>                         LIST(3,J) = N
>                         IF (J.EQ.N.OR.JJ.EQ.N) LIST(3,J) = N - 1
>                      END IF
>                   END IF
> *                 CALL DTCHCK(TIME,STEP(J),DTK(MAXBLK)) ! no effect (08/10).
>                   DO 45 KK = 1,3
>                      X0DOT(KK,J) = XDOT(KK,J)
>    45             CONTINUE
>                   CALL FPOLY1(J,J,0)
>                   CALL FPOLY2(J,J,0)
>                   IPOLY = -1
>    50          CONTINUE
> *       Check optional c.m. correction.
>                IF (KZ(14).GE.3.AND.KZ(31).GT.0) THEN
>                   CALL XVPRED(IFIRST,NTOT)
>                   CALL CMCORR
>                END IF
>             END IF
>             TPREV = TIME - STEPX
1312,1322d1024
< *     --09/27/13 10:39-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$      if(time.ge.3.5373535156250000) then  
< c$$$      il=3173
< c$$$      print*,rank,'m4',il,name(il),d3(1,il),d2r(1,il),d3r(1,il),time
< c$$$      call flush(6)
< c$$$      call mpi_barrier(MPI_COMM_WORLD,ierr)      
< c$$$      stop
< c$$$      end if
< *     --09/27/13 10:39-lwang-end----------------------------------------*
<          
1326,1331c1028
< *       Remove I in NXTLST
<             call delay_remove_tlist(I,STEP,DTK)
<             call shrink_tlist
<             STEP(I) = 2*DTK(1)
< *       Add I to ghost
<             call add_tlist(I,STEP,DTK)
---
>             STEP(I) = 1.0D+06
1387,1388c1084
<             if(rank.eq.0)
<      &      WRITE(43,924) I, NAME(I), TPHYS, DT/1.0d+06,
---
>             WRITE(43,924) I, NAME(I), TPHYS, DT/1.0d+06,
1390,1392c1086,1087
<  924        FORMAT(' EXPAND!    I NAME Time[Myr] DT[Myr] K*0 K*N ',
<      &           'M0[M*] MN[M*] RS0[R*] RSN[R*] ',
<      &           2I12,1P,E26.17,E14.5,0P,2I4,2F12.6,2F12.6)
---
>  924        FORMAT(' EXPAND!    I NM TP DTP K* KW M0 M R RN ',
>      &                          2I6,F7.1,F7.3,2I4,2F7.1,2F7.1)
1413c1108
<             IF(rank.eq.0.and.KW.LT.0)THEN
---
>             IF(KW.LT.0)THEN
1418c1113
<             IF (I.LT.IFIRST.AND.KZ(9).GE.2) THEN
---
>             IF (I.LT.IFIRST.AND.KZ(8).GT.3) THEN
1424c1119
<          IF (KZ(19).GT.4.AND.(KW0.NE.KW.OR.ICORR)) THEN
---
>          IF (KZ(19).GT.3.AND.(KW0.NE.KW.OR.ICORR)) THEN
1430,1437c1125,1128
<             if(rank.eq.0)
<      &      WRITE(6,926)WHICH1, TTOT, TPHYS, I, NAME(I), KW0, KW, DMSUN,
<      &            DMR, ZMDOT, M0, M1, RADIUS(I)*SU, EMDOT
<  926        FORMAT('MDOT NEW',A8,'Time[NB]',1P,E16.7,0P,' Time[Myr]',
<      &           F12.3,' I',I8,' NAME',I8,' K*0',I3,' K*N',I3,
<      &           ' DM[M*]',1P,E10.2,' DM/M',E10.2,0P,' DMTOT[M*]',F12.2,
<      &           ' M0[M*]',F7.2,' MN[M*]',F7.2,' RS[R*]',F7.1,
<      &           ' EMDOT',F10.5)
---
>             WRITE(6,926)WHICH1, TPHYS, I, NAME(I), DMR, KW0, KW, M0, M1,
>      &                  RADIUS(I)*SU, EMDOT
>  926        FORMAT(' NEW',A8,' TPHYS I NAM DM/M KW0 KW M0 M R EMD ',
>      &                         F7.1,2I5,F6.2,2I3,2F6.1,F7.1,F10.5)
1465d1155
<                IF(IPOLY.GE.0) IPOLY = 1
1477,1478c1167
<                   if(rank.eq.0)
<      &            WRITE(6,928) KW, SQRT(ECC2), RA, SEMI*SU, TK, STEP(J),
---
>                   WRITE(6,928) KW, SQRT(ECC2), RA, SEMI*SU, TK, STEP(J),
1484c1173
<                   IF(KZ(9).GE.3)THEN
---
>                   IF(KZ(8).GT.3)THEN
1504,1505c1193
<             if(rank.eq.0)
<      &      WRITE(6,930) I, NAME(I), KW0, KW, KSTAR(I), M0, M1, DMR
---
>             WRITE(6,930) I, NAME(I), KW0, KW, KSTAR(I), M0, M1, DMR
1513c1201
<                IF(rank.eq.0.and.BODY(I)*ZMBAR.GT.MCH)THEN
---
>                IF(BODY(I)*ZMBAR.GT.MCH)THEN
1525,1526c1213
<          if(rank.eq.0)
<      &   WRITE(6,936) I, KSTAR(I), M1, RADIUS(I)
---
>          WRITE(6,936) I, KSTAR(I), M1, RADIUS(I)
1538,1539c1225
<                   if(rank.eq.0)
<      &            WRITE(6,940) NAME(II), KSTAR(II), KW, DMR
---
>                   WRITE(6,940) NAME(II), KSTAR(II), KW, DMR
1547c1233
<                IF(KZ(9).GE.3)THEN
---
>                IF(KZ(8).GT.3)THEN
1580,1584c1266,1269
<             IF (KSX.GE.13.AND.KZ(28).GT.2) THEN
<               if(rank.eq.0)
<      &         WRITE (6,944)  TTOT, NAME(2*IPAIR-1),KSTAR(2*IPAIR),
<      &                        DTGR/TSTAR
<   944          FORMAT (' GR CHECK   T NAM K* DTGR ',F8.2,I6,I4,1P,E9.1)
---
> *           IF (KSX.GE.13.AND.KZ(28).GT.2) THEN
> *              WRITE (6,944)  TTOT, NAME(2*IPAIR-1),KSTAR(2*IPAIR),
> *    &                        DTGR/TSTAR
> * 944          FORMAT (' GR CHECK   T NAM K* DTGR ',F8.2,I6,I4,1P,E9.1)
1592c1277
< *              IF (rank.eq.0.and.KZ(28).GT.2) THEN
---
> *              IF (KZ(28).GT.2) THEN
1601c1286
<             END IF
---
> *           END IF
1612,1614d1296
<                IF (KZ(34).EQ.1.AND.KSTAR(I).GT.0.AND.
<      &            MOD(KSTAR(I),2).EQ.0)THEN
<                END IF
1616,1618d1297
< *     Do enery correction before particle index change
< c$$$                  call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< c$$$     &            IGPUSWITCH)
1620,1623d1298
< c$$$#ifdef GPU             
< c$$$                  IGPUDM = .true.
< c$$$                  IGPUSWITCH = .true.
< c$$$#endif             
1639,1644c1314,1319
< c$$$ 70   TMDOT = 1.0d+10
< c$$$      DO 80 J = 1,NTOT
< c$$$         IF(TEV(J).LE.TMDOT)THEN
< c$$$            TMDOT = TEV(J)
< c$$$         ENDIF
< c$$$   80 CONTINUE
---
> *  70 TMDOT = 1.0d+10
> *     DO 80 J = 1,NTOT
> *        IF(TEV(J).LE.TMDOT)THEN
> *           TMDOT = TEV(J)
> *        ENDIF
> *  80 CONTINUE
1647,1649c1322,1323
< c$$$      IF (TMDOT.LT.TIME) GO TO 1
<       IF (TEV(I).GT.TIME) THEN
<          TMDOT = MIN(TMDOT,TEV(I))
---
>       IF (TEV(I).GT.TIME)  THEN
>           TMDOT = MIN(TMDOT,TEV(I))
1651c1325
<          GO TO 5
---
>           GO TO 5
1652a1327
> *       Check next member.
1656c1331
<  103  IMERGE = 1
---
>   100 IMERGE = 1
1674,1675c1349
<                   if(rank.eq.0)
<      &            WRITE (6,108) NAMEG(IMERGE), NAME(N+KSPAIR),KSTAR(I1),
---
>                   WRITE (6,108) NAMEG(IMERGE), NAME(N+KSPAIR),KSTAR(I1),
1681,1683d1354
< *     Do enery correction before particle index change
< c$$$                  call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,
< c$$$     &                 IGPUSWITCH)
1685,1689d1355
< c$$$*     If ksterm, send new jparticle to gpu and use gpupot_dm
< c$$$#ifdef GPU             
< c$$$                  IGPUDM = .true.
< c$$$                  IGPUSWITCH = .true.
< c$$$#endif             
1698,1714c1364,1379
< c$$$*       Update the maximum single body mass but skip compact subsystems.
< c$$$      IF(NSUB.EQ.0)THEN
< c$$$         BODY1 = 0.d0
< c$$$         DO 110 J = 1,N
< c$$$            BODY1 = MAX(BODY1,BODY(J))
< c$$$  110    CONTINUE
< c$$$      ENDIF
< *
< c$$$      DO 122 J = N+1,NTOT
< c$$$         IF(KSTAR(J).EQ.0.AND.NAME(J).GT.0.AND.TEV(J).LT.9.9E+09.AND.
< c$$$     &      BODY(J).GT.0.0.AND.KZ(28).EQ.0)THEN
< c$$$            if(rank.eq.0)
< c$$$     &      WRITE(6,556)J,NAME(J),TEV(J)
< c$$$            TEV(J) = 1.0d+10
< c$$$ 556        FORMAT(' MDOT TEV SMALL ',2I8,1P,E10.2)
< c$$$         ENDIF
< c$$$ 122  CONTINUE
---
> *       Update the maximum single body mass but skip compact subsystems.
>       IF(NSUB.EQ.0)THEN
>          BODY1 = 0.d0
>          DO 110 J = 1,N
>             BODY1 = MAX(BODY1,BODY(J))
>   110    CONTINUE
>       ENDIF
> *
>       DO 122 J = N+1,NTOT
>          IF(KSTAR(J).EQ.0.AND.NAME(J).GT.0.AND.TEV(J).LT.9.9E+09.AND.
>      &      BODY(J).GT.0.0.AND.KZ(28).EQ.0)THEN
>             WRITE(6,556)J,NAME(J),TEV(J)
>             TEV(J) = 1.0d+10
>   556       FORMAT(' MDOT TEV SMALL ',2I8,1P,E10.2)
>          ENDIF
>   122  CONTINUE
1717c1382
<  810  IF (IPOLY.LT.0) THEN
---
>   810 IF (IPOLY.LT.0) THEN
1720,1721c1385,1386
<       ELSE IF(IPOLY.GT.0) THEN
<          IPHASE = IPOLY
---
>       ELSE IF (IPOLY.GT.0) THEN
>           IPHASE = IPOLY
1724,1725d1388
< *     Do energy correction due to mass loss, only for small mass loss by ficorr
< c$$$      call encorr_mdot(NPNUM,NDMLIST,DMLIST,IGPUDM,IGPUSWITCH)
33c33
<       IF (NMERGE.GE.MMAX.and.rank.eq.0) THEN
---
>       IF (NMERGE.GE.MMAX) THEN
86,92c86,89
< *       Replace index of outer pair by inner one if JPAIR is last pair, 
< *       since outer pair is exchanged with inner pair during inner pair termination.
<           IF (JPAIR.EQ.NPAIRS) THEN
< C              JPAIR = JPAIR - 1
< C              JCOMP1 = JCOMP1 - 1
<              JPAIR = IPAIR
<              JCOMP1 = I
---
> *       Reduce index of outer component if JPAIR moved up at termination.
>           IF (IPAIR.LT.JPAIR) THEN
>               JPAIR = JPAIR - 1
>               JCOMP1 = JCOMP1 - 1
149d145
<           X0(K,ICOMP) = X(K,ICOMP)
153d148
<           XDOT(K,ICOMP) = X0DOT(K,ICOMP)
157d151
<       T0(JCOMP1) = TIME
232,237d225
< *     --03/05/14 16:25-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$         print*,rank,'NBLIST! CMSEP2',CMSEP2,'RMAX',RMAX,'RS',RS(ICOMP),
< c$$$     &        'NNB',NNB
< c$$$         call flush(6)
< *     --03/05/14 16:25-lwang-end----------------------------------------*
243,246d230
< *     --06/19/14 23:11-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< C          print*,'RSI',RSI,'RS',RS(ICOMP),'FAC',FAC
< *     --06/19/14 23:11-lwang-end----------------------------------------*
252d235
< 
257,261d239
< *     Remove ghost from NXTLST and add into ghost list
<       IF(TIME+TOFF.NE.0.D0) call delay_remove_tlist(JCOMP1,STEP,DTK)
<       STEP(JCOMP1) = 2*DTK(1)
<       IF(TIME+TOFF.NE.0.D0) call add_tlist(JCOMP1,STEP,DTK)
< 
264,270d241
< *     --03/04/14 13:25-lwang-debug--------------------------------------*
< ***** Note:------------------------------------------------------------**
< c$$$      print*,rank,'MERGER NTOT',NTOT,'NAME',NAME(NTOT),'S',step(ntot),
< c$$$     &     't',time,'t0',t0(ntot),'stepr',stepr(ntot),
< c$$$     &     'f',f(1,ntot),'fdot',fdot(1,ntot),'nb',list(1,ntot)
< c$$$      call flush(6)
< *     --03/04/14 13:25-lwang-end----------------------------------------*
69c69
< C          EB = MIN(EB,999.9D0)
---
>           EB = MIN(EB,999.9D0)
83,84c83
<           if(rank.eq.0)
<      &    WRITE (6,5)  WHICH1, TIME+TOFF, ZM, NAME(I1), NAME(I2),
---
>           WRITE (6,5)  WHICH1, TIME+TOFF, ZM, NAME(I1), NAME(I2),
87c86
<      &                             F10.2,F6.2,3I6,2F6.2,1P,4E10.2)
---
>      &                             F10.2,F6.2,3I6,2F6.2,F6.1,1P,3E10.2)
101c100
<           IF (rank.eq.0.and.JG.LE.N.AND.JCOMP.LE.N) THEN
---
>           IF (JG.LE.N.AND.JCOMP.LE.N) THEN
107,108c106
<               if(rank.eq.0)
<      &        WRITE (6,8)  TIME+TOFF, ZM, NAME(I1), NAME(I2),
---
>               WRITE (6,8)  TIME+TOFF, ZM, NAME(I1), NAME(I2),
134,135c132
<           if(rank.eq.0)
<      &    WRITE (6,10)  TIME+TOFF, ZM, NAME(I1), NAME(I2), NAME(J1),
---
>           WRITE (6,10)  TIME+TOFF, ZM, NAME(I1), NAME(I2), NAME(J1),
282d278
< *
288,292d283
< *     Remove ghost from NXTLST and add it into ghost list
<       IF(TIME+TOFF.NE.0.D0) call delay_remove_tlist(JCOMP1,STEP,DTK)
<       STEP(JCOMP1) = 2*DTK(1)
<       IF(TIME+TOFF.NE.0.D0) call add_tlist(JCOMP1,STEP,DTK)
< 
1d0
< ***
5a5,6
> *     
> *     Updated by A. D. Railton 23th Feb 2011 to include preMS evolution.
13a15
>       REAL*8 RR,MF,RZAMS,TPREMS,LEFT,RIGHT,ERR,XX
16c18,19
<       PARAMETER(MCH=1.44D0,MXNS = 3.0d0)
---
>       PARAMETER(MCH=1.44D0,MXNS=3.0d0,ERR=1D-5)
>       EXTERNAL RZAMSF,PREMSF
39,40c42,53
<       ICASE = KTYPE(K1,K2)
<       IF(rank.eq.0.and.ICASE.GT.100)THEN
---
> *       PreMS collision scheme: -1, -1 ==> -1; -1, 0 ==> -1; -1, x ==> x.
>       IF (K1.LT.0.OR.K2.LT.0) THEN
>           ICASE = -1
>           IF (MAX(K1,K2).GT.0) THEN
>              ICASE = MAX(K1,K2)
>              IF (K1 .EQ. -1) EPOCH(I1) = TIME*TSTAR
>              IF (K2 .EQ. -1) EPOCH(I2) = TIME*TSTAR
>           END IF
>       ELSE
>           ICASE = KTYPE(K1,K2)
>       END IF
>       IF(ICASE.GT.100)THEN
61,64c74
< *     TEV1 = MAX(TIME,TEV0(I1))
< *       Update the stars to the latest previous time.
<       TEV1 = MAX(TEV0(I1),TEV0(I2))
< *
---
>       TEV1 = MAX(TIME,TEV0(I1))
95c105
<       if(rank.eq.0)WRITE(38,67)K1,M01,M1
---
>       WRITE(38,67)K1,M01,M1
97c107
<       if(rank.eq.0)WRITE(38,68)K2,M02,M2
---
>       WRITE(38,68)K2,M02,M2
119c129
< *      Form binding energy of secondary and orbital kinetic energy.
---
> *       Form binding energy of secondary and orbital kinetic energy.
127c137
<        if(rank.eq.0)WRITE (6,55)  FAC, RIJ*SU, SQRT(VIJ2)*VSTAR, EB, ZKE
---
>           WRITE (6,55)  FAC, RIJ*SU, SQRT(VIJ2)*VSTAR, EB, ZKE
139c149,209
<       IF(ICASE.EQ.1)THEN
---
>       IF (ICASE.EQ.-1) THEN
> *       Collisions between -1 and -1/0 stars.
>          MF = 0.1 
>          M3 = (1.0 - MF)*(M1 + M2)
>          DM = M1 + M2 - M3
> *       Treat case that collided star is greater than 8 solar masses.
> *        -> start on ZAMS.   
>          IF(M3.GT.8.D0)THEN
>             AGE3 = 0.0D0
>          ELSE
> *       From internal energy arguments, treating both stars as
> *       n = 3/2 polytropes, get new radius:
>          RR = M03**2*(1.0-MF)*2.33333
>          RR = RR/(M1*M1/RS1 + M2*M2/RS2)*(3.0 - 4.0*MF)
> *       Define the preMS variables.
>          TPREMS = 10d0**(43.628d0-(35.835d0*M3**1.5029d-2)
>      &            *exp(M3*3.9608d-3))
>          RZAMS = RZAMSF(M3)
> *
> *       Do bisection on the function PREMSR to find the time at
> *       which the preMS star is at this radius.
> *
>          IC = 0
>          LEFT = 0
>          RIGHT = 1
> *       Make sure new radius is in right range.
>          IF(RR.LE.RZAMS)THEN
>             XX=0
>             IF(M3.LT.1.25) KW = 0
>             IF(M3.GE.1.25) KW = 1
>             GOTO 103
>          ENDIF
>          XX = 1D0
>          IF(PREMSF(M3,XX,RR).LE.0D0)THEN
>             XX=1D0
>             GOTO 103
>          ENDIF      
> *
>  101     XX=0.5*(LEFT + RIGHT)
>          IC = IC + 1
>          IF (IC.GT.100) THEN
>              WRITE(6,98)K1,K2
>  98          FORMAT('MIX PRE-MS IC STOP ',2I4)
>              STOP
>          ENDIF
>          IF(ABS(PREMSF(M3,XX,RR)).LE.ERR)GOTO 103
>          IF(ABS(PREMSF(M3,XX,RR)).GT.ERR)GOTO 102
> *
>  102     IF(SIGN(1.D0,PREMSF(M3,XX,RR)).EQ.
>      &        SIGN(1.D0,PREMSF(M3,LEFT,RR)))LEFT=XX
>          IF(SIGN(1.D0,PREMSF(M3,XX,RR)).EQ.
>      &        SIGN(1.D0,PREMSF(M3,RIGHT,RR)))RIGHT=XX
>          GOTO 101
> *     
>  103     AGE3 = -TPREMS*XX            
>          END IF
>       IF (M3.GT.2.0) WRITE (6,720)  M3, RZAMS, XX, TPREMS, AGE3
>   720 FORMAT (' WATCH!   M3 RZAMS XX TP AGE3 ',F7.2,1P,4E10.2)
>          CALL star(KW,M3,M3,TMS3,TN,TSCLS,LUMS,GB,ZPARS)
> *     
>       ELSE IF(ICASE.EQ.1)THEN
151,154c221,222
<             if(rank.eq.0)then
<               WRITE(6,*)' WARNING! MIX AGE WRONG FOR KW=4 ',age1,tms1
<               WRITE(6,*)K1,M01,M1,TEV1,EPOCH(I1)
<             end if
---
>             WRITE(6,*)' WARNING! MIX AGE WRONG FOR KW=4 ',age1,tms1
>             WRITE(6,*)K1,M01,M1,TEV1,EPOCH(I1)
173c241
<             if(rank.eq.0)WRITE (6,2)  K1, K2, NAME(I1), NAME(I2)
---
>             WRITE (6,2)  K1, K2, NAME(I1), NAME(I2)
192,193c260,261
<         if(rank.eq.0)WRITE(6,*)' ERROR MIX: ICASE NOT CAUGHT!!!'
<         if(rank.eq.0)WRITE(6,*)' K1 K2 -> K3 ',K2,K2,KW
---
>         WRITE(6,*)' ERROR MIX: ICASE NOT CAUGHT!!!'
>         WRITE(6,*)' K1 K2 -> K3 ',K2,K2,KW
197c265
<       if(rank.eq.0)WRITE(38,69)KW,M03,M3
---
>       WRITE(38,69)KW,M03,M3
208c276
<             if(rank.eq.0)WRITE (6,5)  NAME(I1), NAME(I2), KW0, KW, DM
---
>             WRITE (6,5)  NAME(I1), NAME(I2), KW0, KW, DM
227c295
<           if(rank.eq.0)WRITE (6,8)  NAME(I1), M3, TMS3, TPHYS, AGE3
---
>           WRITE (6,8)  NAME(I1), M3, TMS3, TPHYS, AGE3
241,242c309
<           if(rank.eq.0)
<      &        WRITE (91,9)  TIME+TOFF, NAME(I1), NAME(I2), M3, ECC, PD,
---
>           WRITE (91,9)  TIME+TTOT, NAME(I1), NAME(I2), M3, ECC, PD,
244,246c311,312
<     9     FORMAT (' NEW BS    Time[NB] NAME(I1) NAME(I2) M(INEW)[M*] ',
<      &         'ECC P[days] ROT(I1) ROT(I2)',
<      &         1P,E25.16,0P,2I12,F12.6,F10.6,1P,3E15.6,0P)
---
>     9     FORMAT (' NEW BS    T NAM M3 ECC P ROT ',
>      &                        F8.1,2I7,F6.2,F8.4,1P,3E9.1)
250,251c316
<       if(rank.eq.0)
<      &WRITE (6,10)  IQCOLL, K1, K2, KSTAR(I1), M1, M2, M3, RS1, RS2,
---
>       WRITE (6,10)  IQCOLL, K1, K2, KSTAR(I1), M1, M2, M3, RS1, RS2,
253,256c318,319
<    10 FORMAT (' NEW STAR:    IQCOLL',I3,' K*(I1)',I3,' K*(I2)',I3,
<      &     ' K*(INEW)',I3,' M(I1)[M*]',F9.3,' M(I2)[M*]',F9.3,
<      &     ' M(INEW)[M*]',F9.3,' RS(I1)[R*]',F9.3,' RS(I2)[R*]',F9.3,
<      &     ' RS(INEW)[R*]',F9.3,' DM[M*]',F9.3)
---
>    10 FORMAT (' NEW STAR:    IQ K1 K2 K* M1 M2 M3 R1 R2 R* DM ',
>      &                       4I3,3F6.1,3F7.1,F5.1)
259,260c322,323
<       IF(rank.eq.0.and.FIRST.AND.IQCOLL.NE.3.AND.KSTART.EQ.1)THEN
< C          OPEN (UNIT=13,STATUS='UNKNOWN',FORM='FORMATTED',FILE='COLL')
---
>       IF(FIRST.AND.IQCOLL.NE.3)THEN
>           OPEN (UNIT=13,STATUS='NEW',FORM='FORMATTED',FILE='COLL')
264,277c327,336
< C          IF(NCOLL.EQ.0)THEN
<           WRITE (13,20)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
<      &         NBIN0, NZERO
<  20       FORMAT (/,6X,1P, 'MODEL:    RBAR =',E26.17,'  <M>[M*] =',
<      &         E26.17,'  M1[M*] =',E26.17,'  TSCALE =',E26.17,0P,
<      &         '  NB0 =',I12,'  N0 =',I12,//)
<           WRITE (13,25)
<  25       FORMAT ('                  TIME[NB]    NAME(I1)    NAME(I2)',
<      &         '      K*(I1)      K*(I2)    K*(INEW)',
<      &         '                 M(I1)[M*]                 M(I2)[M*]',
<      &         '               M(INEW)[M*]                    DM[M*]',
<      &         '                RS(I1)[R*]                RS(I2)[R*]',
<      &         '                    RI[RC]                   R12[R*]',
<      &         '                       ECC                   P[days]',/)
---
>           IF(NCOLL.EQ.0)THEN
>               WRITE (13,20)  RBAR, BODYM*ZMBAR, BODY1*ZMBAR, TSCALE,
>      &                       NBIN0, NZERO
>    20         FORMAT (/,6X,'MODEL:    RBAR =',F5.1,'  <M> =',F6.2,
>      &                     '  M1 =',F6.1,'  TSCALE =',F6.2,
>      &                     '  NB =',I4,'  N0 =',I6,//)
>               WRITE (13,25)
>    25         FORMAT ('    TIME  NAME  NAME  K1  K2  KC  M1   M2   MC',
>      &                '   DM    R1     R2    r/Rc   R     ECC      P',/)
>           ENDIF
297,298c356,357
<       IF (rank.eq.0.and.IQCOLL.NE.3) THEN
<           WRITE (13,*)  TTOT, (ITYPE(K),K=1,5), M1, M2, M3,
---
>       IF (IQCOLL.NE.3) THEN
>           WRITE (13,35)  TTOT, (ITYPE(K),K=1,5), M1, M2, M3,
300c359
< C   35     FORMAT (1X,F7.1,2I6,3I4,4F5.1,2F7.2,F6.2,F7.2,F9.5,1P,E9.1)
---
>    35     FORMAT (1X,F7.1,2I6,3I4,4F5.1,2F7.2,F6.2,F7.2,F9.5,1P,E9.1)
308c367
<       IF(rank.eq.0.and.KSTAR(I1).GT.12)THEN
---
>       IF(KSTAR(I1).GT.12)THEN
311,312c370
<    40     FORMAT (' MIX NS/BH:   K*(I1) K*(I2) K*(INEW) M(I1)[M*] ',
<      &         'M(I2)[M*] M(INEW)[M*] ',3I4,3F12.6)
---
>    40     FORMAT (' MIX:    K1 K2 K* M1 M2 M3 ',3I4,3F7.2)
151,152c151
<       if(rank.eq.0)
<      &WRITE (6,30)  NAME(IMAX), BMAX, BMAX*ZMBAR, ZMDOT, DE, BE(3),
---
>       WRITE (6,30)  NAME(IMAX), BMAX, BMAX*ZMBAR, ZMDOT, DE, BE(3),
165,166c164
<       if(rank.eq.0)
<      &WRITE (6,45)  IMAX, DE, TEV1, A0, SQRT(VI2), BE(3)
---
>       WRITE (6,45)  IMAX, DE, TEV1, A0, SQRT(VI2), BE(3)
4c4
<       integer kw
---
>       integer kw,mdflag
6c6,7
<       real*8 dml,dms,dmt,p0,x,mew,lum0,kap,neta,bwind
---
>       real*8 teff,teff1,dml,dms,dmt,p0,x,mew,vw,t40
>       real*8 lum0,kap,flbv
7a9,10
>       parameter(flbv=1.5d0)
>       real*8 neta,bwind
13,15c16,34
< * Apply mass loss of Nieuwenhuijzen & de Jager, A&A, 1990, 231, 134,
< * for massive stars over the entire HRD.
<       if(lum.gt.4000.d0)then
---
> * Set mdflag to determine the mass-loss you want: 
> *  = 1 - Hurley, Pols & Tout (2000) SSE basic rates; 
> *  = 2 - SSE + LBV added; 
> *  = 3 - Belczynski et al. (2010, ApJ, 714, 1217) updates. 
> *  = 4 - Belczynski without bi-stability jump. 
> * [Currently mdflag = 1 is recommended]
>       mdflag = 1
> *
>       dms = 0.d0
> *
>       teff = 3.762d0 + 0.25d0*log10(lum) - 0.5d0*log10(r)
>       teff = 10.d0**teff
>       teff = MIN(teff,50000.d0)
> *
>       if(lum.gt.4000.d0.and.(mdflag.le.2.or.
>      &                      (mdflag.ge.3.and.kw.le.6)))then
> * Apply mass loss of Nieuwenhuijzen & de Jager (1990, A&A, 231, 134)
> * for massive stars over the entire HRD with a metallicity factor 
> * from Kudritzki et al. (1989, A&A, 219, 205). 
19,20d37
<       else
<          dms = 0.d0
21a39,64
> *
>       if(mdflag.ge.3.and.kw.le.6)then
> * Apply mass loss for hot, massive H-rich O/B stars following 
> * Vink et al. (2001, A&A, 369,574). 
>          if(teff.ge.12500.0.and.teff.le.25000.0.and.mdflag.eq.3)then
>             teff1 = MIN(teff,22500.d0)
>             vw = 1.3d0/2.d0
>             dml = -6.688d0 + 2.21d0*log10(lum/1.0d+05) -  
>      &             1.339d0*log10(mt/30.d0) - 1.601d0*log10(vw) + 
>      &             0.85d0*log10(z/0.02d0) + 1.07d0*log10(teff1/20000.d0)
>             dml = 10.d0**dml
>             dms = MAX(dms,dml)
>          elseif(teff.gt.12500.0.and.teff.le.50000.1)then
>             teff1 = teff
>             if(mdflag.eq.3) teff1 = MAX(teff,27500.d0)
>             vw = 2.6d0/2.d0
>             t40 = log10(teff1/40000.d0)
>             dml = -6.697d0 + 2.194d0*log10(lum/1.0d+05) -  
>      &             1.313d0*log10(mt/30.d0) - 1.226d0*log10(vw) + 
>      &             0.85d0*log10(z/0.02d0) + 
>      &             0.933d0*t40*(1.d0 - 11.704d0*t40)
>             dml = 10.d0**dml
>             dms = MAX(dms,dml)
>          endif
>       endif
> *
23c66,68
< * 'Reimers' mass loss
---
> *
> * Standard 'Reimers' mass loss for giants from Kudritzki & Reimers 
> * (1978, A&A, 70, 227). 
26c71
< * see Tout & Eggleton, MNRAS, 1988, 231, 823.  
---
> * see Tout & Eggleton (1988, MNRAS, 231, 823).  
28,29c73
< * Apply mass loss of Vassiliadis & Wood, ApJ, 1993, 413, 641, 
< * for high pulsation periods on AGB.
---
> *
30a75,76
> * Apply mass loss of Vassiliadis & Wood (1993, ApJ, 413, 641) 
> * for high pulsation periods on AGB.
38a85,86
> *
>          dms = MAX(dml,dms)
40,41c88,94
<             dms = MAX(dml,1.0d-13*lum**(3.d0/2.d0))
<          else
---
> * Apply mass loss of Hamann & Koesterke (1998, A&A, 335, 1003) 
> * for WR (naked helium) stars. 
>             dml = 1.0d-13*lum**(3.d0/2.d0)
>             if(mdflag.eq.3)then
> * Add metallicity factor from Vink & de Koter (2005, A&A, 442, 587). 
>                dml = dml*(z/0.02d0)**0.86d0
>             endif
42a96
>          else
44c98,99
< * reduced WR-like mass loss for small H-envelope mass
---
> * Apply the reduced WR-like mass loss for small H-envelope mass 
> * as described in the Hurley, Pols & Tout (200) SSE paper. 
48,53c103,114
<             end if
< * LBV-like mass loss beyond the Humphreys-Davidson limit.
<             x = 1.0d-5*r*sqrt(lum)
<             if(lum.gt.6.0d+05.and.x.gt.1.d0)then
<                dml = 0.1d0*(x-1.d0)**3*(lum/6.0d+05-1.d0)
<                dms = dms + dml
---
>             endif
> * LBV-like mass loss beyond the Humphreys-Davidson limit
> * (see Humphreys & Davidson 1994 and Belczynski et al. 2010). 
>             x = 1.0d-5*r*SQRT(lum)
>             if(mdflag.gt.1.and.lum.gt.6.0d+05.and.x.gt.1.d0)then
>                if(mdflag.eq.2)then
>                   dml = 0.1d0*(x-1.d0)**3*(lum/6.0d+05-1.d0)
>                   dms = dms + dml
>                else
>                   dml = 1.0d-04*flbv
>                   dms = MAX(dml,dms)
>                endif
55a117
> *
1,69c1,69
< c     general three-body stability algorithm
< c     
< c     system is unstable if nstab=1 is returned
< c     system is stable if nstab=0 is returned
< c     
< c     Rosemary Mardling
< c     School of Mathematical Sciences, Monash University
< c     
< c     version as of 16-11-07
< c     email mardling@sci.monash.edu.au to be added to updates email list
< c     preprint on astro-ph by New Year :-)
< c     
< c     sigma=period ratio (outer/inner) **should be > 1**
< c     ai=inner semi-major axis
< c     a0=outer semi-major axis
< c     ei0=initial inner eccentricity
< c     eo=outer eccentricity
< c     relinc=relative inclination (radians)
< c     m1, m2, m3=masses (any units; m3=outer body)
< c     
< c     valid for all inclinations
< c     
< c     MASS RATIO CONDITIONS
< c     valid for systems with at least one of  m_2/m_1>0.05  OR  m_3/m_1>0.05
< c     (so that one could have, for example,  m_2/m_1=0  and  m_3/m_1=0.1) 
< c     OR BOTH m2/m1>0.01  AND  m3/m1>0.01
< c     **future version will include other resonances to cover smaller mass ratios
< c     
< c     assumes resonance angle phi=0 because resonance overlap criterion doesn't recognize
< c     instability outside separatrix.
< c     
< c     system is unstable if nstab=1 is returned
< c     system is stable if nstab=0 is returned
< 
<       integer function nstab(ai,a0,ei0,eo,relinc,m1,m2,m3)
< 
<       implicit real*8 (a-h,m,o-z)
<       common/params2/mm1,mm2,mm3
<       common/savepi/pi
<       save itime
<       data itime/0/
< 
< c     reject outer pericentre inside inner apocentre
<       if(a0*(1.-eo).lt.ai*(1.+ei0))then
<          nstab=1
<          return
<       endif
< 
<       if(itime.eq.0)then
<          pi=4.d0*datan(1.0d0)
<          itime=1
<       endif
< 
<       mm1=m1
<       mm2=m2
<       mm3=m3
<       
<       m12=m1+m2
<       m123=m12+m3
< 
< c     set period ratio (outer/inner)
<       a0ai=a0/ai
<       sigma=sqrt(a0ai**3*m12/m123)
< c     do not allow period ratio < 1
<       if(sigma.lt.1.0)then
<          nstab=1
<          return
<       endif
<       
---
> c	general three-body stability algorithm
> c
> c	system is unstable if nstab=1 is returned
> c	system is stable if nstab=0 is returned
> c
> c	Rosemary Mardling
> c	School of Mathematical Sciences, Monash University
> c
> c	version as of 16-11-07
> c	email mardling@sci.monash.edu.au to be added to updates email list
> c	preprint on astro-ph by New Year :-)
> c
> c	sigma=period ratio (outer/inner) **should be > 1**
> c       ai=inner semi-major axis
> c       a0=outer semi-major axis
> c	ei0=initial inner eccentricity
> c	eo=outer eccentricity
> c	relinc=relative inclination (radians)
> c	m1, m2, m3=masses (any units; m3=outer body)
> c
> c       valid for all inclinations
> c
> c	MASS RATIO CONDITIONS
> c	valid for systems with at least one of  m_2/m_1>0.05  OR  m_3/m_1>0.05
> c	(so that one could have, for example,  m_2/m_1=0  and  m_3/m_1=0.1) 
> c	OR BOTH m2/m1>0.01  AND  m3/m1>0.01
> c	**future version will include other resonances to cover smaller mass ratios
> c
> c	assumes resonance angle phi=0 because resonance overlap criterion doesn't recognize
> c	instability outside separatrix.
> c
> c       system is unstable if nstab=1 is returned
> c       system is stable if nstab=0 is returned
> 
>         integer function nstab(ai,a0,ei0,eo,relinc,m1,m2,m3)
> 
>         implicit real*8 (a-h,m,o-z)
>         common/params2/mm1,mm2,mm3
>         common/savepi/pi
>         save itime
>         data itime/0/
> 
> c       reject outer pericentre inside inner apocentre
>         if(a0*(1.-eo).lt.ai*(1.+ei0))then
>             nstab=1
>             return
>         endif
> 
>         if(itime.eq.0)then
>            pi=4.d0*datan(1.0d0)
>            itime=1
>         endif
> 
> 	mm1=m1
> 	mm2=m2
> 	mm3=m3
> 	
> 	m12=m1+m2
> 	m123=m12+m3
> 
> c       set period ratio (outer/inner)
>         a0ai=a0/ai
>         sigma=sqrt(a0ai**3*m12/m123)
> c       do not allow period ratio < 1
>         if(sigma.lt.1.0)then
>             nstab=1
>             return
>         endif
> 	
71,187c71,190
<       Mo2=(m1*m2/m12**2)*(m12/m123)**(2./3.)
<       Mi3=(m3/m12)*(m12/m123)**(4./3.)*(m1-m2)/m12
<       Mo3=(m1*m2/m12**2)*(m12/m123)*(m1-m2)/m12
<       
<       c22=3./8.
<       c20=0.25
<       c31=sqrt(3.)/4.
<       c33=-sqrt(5.)/4.
<       
<       e=eo
<       
< c     inclination coefficients
< 
<       win=0
<       
<       A=sqrt(1-ei0**2)*cos(relinc)
<       Z=(1-ei0**2)*(1+sin(relinc)**2)+5*ei0**2*
<      &     (sin(win)*sin(relinc))**2
<       Del=z**2+25+16*A**4-10*Z-20*A**2-8*A**2*Z
<       
<       eK=sqrt(abs((Z+1-4*A**2+sqrt(Del))/6.))
<       cosIK=A/sqrt(1-eK**2)
<       sinIK=sqrt(1-cosIK**2)
<       
<       gam222=0.25*(1+cosIK)**2
<       gam22m2=0.25*(1-cosIK)**2
<       gam220=0.5*sqrt(1.5)*sinIK**2
<       gam200=0.5*(3*cosIK**2-1)
<            
< c     induced inner eccentricity
<            ei=ein_induced(sigma,ei0,e,relinc)
<            
< c     octopole emax	   	   
<            if(m1.ne.m2)then
<               eoctmax=eoct(sigma,ei0,e)
<               ei=max(eoctmax,ei)
<            endif
<            
<            ei=max(eK,ei)
<            ei=min(ei,1.0d0)
<            
<            n=sigma
<            nstab=0
<            
< c     [n:1](222) resonance
<            s221=-3*ei+(13./8.)*ei**3+(5./192.)*ei**5         
< 
<            f22n=flmn(2,2,n,e)/(1-e)**3
< 
<            An=abs(6*c22*s221*f22n*(Mi2+Mo2*sigma**0.666)*gam222)
<            phi=0
<            En=0.5*(sigma-n)**2-An*(1+cos(phi))
< 
< c     [n+1:1](222) resonance	   
<            f22n=flmn(2,2,n+1,e)/(1-e)**3
< 
<            An=abs(6*c22*s221*f22n*(Mi2+Mo2*sigma**0.666)*gam222)
<            
<            Enp1=0.5*(sigma-(n+1))**2-An*(1+cos(phi))
<            if(En.lt.0.and.Enp1.lt.0)nstab=1
<            
< c     [n:1](22-2) resonance
<            s22m1=-(ei**3*(4480 + 1880*ei**2 + 1091*ei**4))/15360.
<            f22n=flmn(2,2,n,e)/(1-e)**3
< 
<            An=abs(6*c22*s22m1*f22n*(Mi2+Mo2*sigma**0.666)*gam22m2)
<            phi=0
<            En=0.5*(sigma-n)**2-An*(1+cos(phi))
< 
< c     [n+1:1](22-2) resonance	   
<            f22n=flmn(2,2,n+1,e)/(1-e)**3
< 
<            An=abs(6*c22*s22m1*f22n*(Mi2+Mo2*sigma**0.666)*gam22m2)
<            
<            Enp1=0.5*(sigma-(n+1))**2-An*(1+cos(phi))
<            if(En.lt.0.and.Enp1.lt.0)nstab=1
< 
< c     [n:1](202) resonance
<            s201=(ei*(-9216 + 1152*ei**2 - 48*ei**4 + ei**6))/9216.
<            f22n=flmn(2,2,n,e)/(1-e)**3
< 
<            An=abs(6*sqrt(c20*c22)*s201*f22n*
<      &          (Mi2+Mo2*sigma**0.666)*gam220)
<            
<            phi=0
<            En=0.5*(sigma-n)**2-An*(1+cos(phi))
< 
< c     [n+1:1](202) resonance	   
<            f22n=flmn(2,2,n+1,e)/(1-e)**3
< 
<            An=abs(6*sqrt(c20*c22)*s201*f22n
<      &          *(Mi2+Mo2*sigma**0.666)*gam220)
<            Enp1=0.5*(sigma-(n+1))**2-An*(1+cos(phi))
<            if(En.lt.0.and.Enp1.lt.0)nstab=1
< 
< c     [n:1](002) resonance
<            s201=(ei*(-9216 + 1152*ei**2 - 48*ei**4 + ei**6))/9216.
<            f20n=flmn(2,0,n,e)/(1-e)**3
< 
<            An=abs(3*c20*s201*f20n*(Mi2+Mo2*sigma**0.666)*gam200)
<            
<            phi=0
<            En=0.5*(sigma-n)**2-An*(1+cos(phi))
< 
< c     [n+1:1](002) resonance	   
<            f20n=flmn(2,0,n+1,e)/(1-e)**3
< 
<            An=abs(3*c20*s201*f20n*(Mi2+Mo2*sigma**0.666)*gam200)
<            
<            Enp1=0.5*(sigma-(n+1))**2-An*(1+cos(phi))
<            if(En.lt.0.and.Enp1.lt.0)nstab=1
<            
<            end
< 
< c     -----------------------------------------
< c     Asymptotic expression for f^(lm)_n(e) for all e<1 and n.
< c     
---
> 	Mo2=(m1*m2/m12**2)*(m12/m123)**(2./3.)
> 	Mi3=(m3/m12)*(m12/m123)**(4./3.)*(m1-m2)/m12
> 	Mo3=(m1*m2/m12**2)*(m12/m123)*(m1-m2)/m12
> 	
> 	c22=3./8.
> 	c20=0.25
> 	c31=sqrt(3.)/4.
> 	c33=-sqrt(5.)/4.
> 	
> 	e=eo
> 	
> c	inclination coefficients
> 
> 	win=0
> 	   
> 	A=sqrt(1-ei0**2)*cos(relinc)
> 	Z=(1-ei0**2)*(1+sin(relinc)**2)+5*ei0**2*
>      &                                 (sin(win)*sin(relinc))**2
> 	Del=z**2+25+16*A**4-10*Z-20*A**2-8*A**2*Z
> 	   
> 	eK=sqrt(abs((Z+1-4*A**2+sqrt(Del))/6.))
> 	cosIK=A/sqrt(1-eK**2)
> 	sinIK=sqrt(1-cosIK**2)
> 	
> 	gam222=0.25*(1+cosIK)**2	   
> 	gam22m2=0.25*(1-cosIK)**2	   
>       gam220=0.5*sqrt(1.5)*sinIK**2 
>      	gam200=0.5*(3*cosIK**2-1)
> 	
> c	induced inner eccentricity
> 	ei=ein_induced(sigma,ei0,e,relinc)
> 	
> c	octopole emax	   	   
> 	if(m1.ne.m2)then
> 	   eoctmax=eoct(sigma,ei0,e)
> 	   ei=max(eoctmax,ei)	   
> 	endif
> 		   
> 	ei=max(eK,ei)
> 	ei=min(ei,1.0d0)
> 	
> 	n=sigma
> 	nstab=0
> 		
> c	[n:1](222) resonance
> 	s221=-3*ei+(13./8.)*ei**3+(5./192.)*ei**5         
> 
> 	f22n=flmn(2,2,n,e)/(1-e)**3
> 
>       An=abs(6*c22*s221*f22n*(Mi2+Mo2*sigma**0.666)*gam222)
> 	phi=0
> 	En=0.5*(sigma-n)**2-An*(1+cos(phi))
> 	   
> c	[n+1:1](222) resonance	   
> 	f22n=flmn(2,2,n+1,e)/(1-e)**3
> 
>       An=abs(6*c22*s221*f22n*(Mi2+Mo2*sigma**0.666)*gam222)
> 	
> 	Enp1=0.5*(sigma-(n+1))**2-An*(1+cos(phi))
> 	if(En.lt.0.and.Enp1.lt.0)nstab=1
> 	
> c	[n:1](22-2) resonance
> 	s22m1=-(ei**3*(4480 + 1880*ei**2 + 1091*ei**4))/15360.        
> 
> 	f22n=flmn(2,2,n,e)/(1-e)**3
> 
>       An=abs(6*c22*s22m1*f22n*(Mi2+Mo2*sigma**0.666)*gam22m2)
> 
> 	phi=0
> 	En=0.5*(sigma-n)**2-An*(1+cos(phi))
> 	   
> c	[n+1:1](22-2) resonance	   
> 	f22n=flmn(2,2,n+1,e)/(1-e)**3
> 
>       An=abs(6*c22*s22m1*f22n*(Mi2+Mo2*sigma**0.666)*gam22m2)
> 	
> 	Enp1=0.5*(sigma-(n+1))**2-An*(1+cos(phi))
> 	if(En.lt.0.and.Enp1.lt.0)nstab=1
> 
> c	[n:1](202) resonance
> 	s201=(ei*(-9216 + 1152*ei**2 - 48*ei**4 + ei**6))/9216.	  
> 
> 	f22n=flmn(2,2,n,e)/(1-e)**3
> 
>       An=abs(6*sqrt(c20*c22)*s201*f22n*(Mi2+Mo2*sigma**0.666)*gam220)
> 		
> 	phi=0
> 	En=0.5*(sigma-n)**2-An*(1+cos(phi))
> 	   
> c	[n+1:1](202) resonance	   
> 	f22n=flmn(2,2,n+1,e)/(1-e)**3
> 
>       An=abs(6*sqrt(c20*c22)*s201*f22n*(Mi2+Mo2*sigma**0.666)*gam220)
> 	
> 	Enp1=0.5*(sigma-(n+1))**2-An*(1+cos(phi))
> 	if(En.lt.0.and.Enp1.lt.0)nstab=1
> 
> c	[n:1](002) resonance
> 	s201=(ei*(-9216 + 1152*ei**2 - 48*ei**4 + ei**6))/9216.	  
> 
> 	f20n=flmn(2,0,n,e)/(1-e)**3
> 
>       An=abs(3*c20*s201*f20n*(Mi2+Mo2*sigma**0.666)*gam200)
> 		
> 	phi=0
> 	En=0.5*(sigma-n)**2-An*(1+cos(phi))
> 	   
> c	[n+1:1](002) resonance	   
> 	f20n=flmn(2,0,n+1,e)/(1-e)**3
> 
>       An=abs(3*c20*s201*f20n*(Mi2+Mo2*sigma**0.666)*gam200)
> 	
> 	Enp1=0.5*(sigma-(n+1))**2-An*(1+cos(phi))
> 	if(En.lt.0.and.Enp1.lt.0)nstab=1
> 	
> 	end
> 
> c	---------------------------------------------------------------------------	
> c	Asymptotic expression for f^(lm)_n(e) for all e<1 and n.
> c
193,201c196,204
<       if(e.lt.5.e-3)then
<          if(m.eq.n)then
<             flmn=1
<          else
<             flmn=0
<          endif
<          return
<       endif
<       
---
> 	if(e.lt.5.e-3)then
> 	   if(m.eq.n)then
> 	      flmn=1
> 	      else
> 	      flmn=0
> 	   endif
> 	   return
> 	endif
> 	
203,204c206,207
<       
<       xi=(a_cosh(1/e)-sqrt(1-e**2))/(1-e)**1.5         
---
> 		
>       xi=(acosh(1/e)-sqrt(1-e**2))/(1-e)**1.5         
207,209c210,212
<      .     ((1+e)**(real(3*m-l-1)/4.)/e**m)*
<      .     (rho**(real(l+m+1)/2.))*
<      .     exp(-rho*xi)
---
>      .        ((1+e)**(real(3*m-l-1)/4.)/e**m)*
>      .        (rho**(real(l+m+1)/2.))*
>      .        exp(-rho*xi)
214,215c217,218
< c     -----------------------------------------
<       real*8 function ein_induced(sigma,ei0,e,relinc)
---
> c	---------------------------------------------------------------------------
> 	real*8 function ein_induced(sigma,ei0,e,relinc)
217,274c220,290
<       implicit real*8 (a-h,m,o-z)
<       common/params2/m1,m2,m3
<       common/savepi/pi
< 
<       m123=m1+m2+m3
<       n=sigma
< 
<            gam222=0.25*(1+cos(relinc))**2
<            gam220=0.5*sqrt(1.5)*sin(relinc)**2
<                 gam200=0.5*(3*cos(relinc)**2-1)
<                 
<                 f22n=flmn(2,2,n,e)/(1-e)**3
<                      f20n=flmn(2,0,n,e)/(1-e)**3
<                 
<                      prod222=f22n*gam222
<                           prod220=f22n*gam220
<                           prod200=f20n*gam200
<                           
<                                prod=max(prod222,prod220,prod200)
<                                
<                                a=4.5*(m3/m123)*(2*pi*n)*prod/sigma**2
<                                
<                                     ein_induced=sqrt(ei0**2+a**2)
<                                
<                                     end
< c     -----------------------------------------
< c     eoct.f
< c     
< c     calculates maximum eccentricity for arbitrary coplanar system
< c     using Mardling (2007) MNRAS in press
< c     
<       real*8 function eoct(sigma,ei0,eo)
<       implicit real*8 (a-h,m,o-z)
<       common/params2/m1,m2,m3
<       common/savepi/pi
< 
<       m12=m1+m2
<       m123=m12+m3
<       aoai=((m123/m12)*sigma**2)**0.3333
<       al=1/aoai
<       
<       epso=sqrt(1-eo**2)
<       
<       eeq=1.25*al*eo/epso**2/abs(1-sqrt(al)*(m2/m3)/epso)
< 
<       AA=abs(1-ei0/eeq)  
<       
<       if(AA.lt.1)then
<          eoct=(1+AA)*eeq
<       else
<          eoct=ei0+2*eeq
<       endif
<       
<       end
< 
< c     -----------------------------------------
<       real*8 function a_cosh(x)
<       real*8 x
---
> 	implicit real*8 (a-h,m,o-z)	
> 	common/params2/m1,m2,m3
>         common/savepi/pi
> 
> 	m123=m1+m2+m3	
> 	n=sigma
> 
>      	gam222=0.25*(1+cos(relinc))**2
>      	gam220=0.5*sqrt(1.5)*sin(relinc)**2
>      	gam200=0.5*(3*cos(relinc)**2-1)
> 	
>      	f22n=flmn(2,2,n,e)/(1-e)**3
>      	f20n=flmn(2,0,n,e)/(1-e)**3
>      	
>      	prod222=f22n*gam222
>      	prod220=f22n*gam220
>      	prod200=f20n*gam200
>      	
>      	prod=max(prod222,prod220,prod200)
> 		    	
>      	a=4.5*(m3/m123)*(2*pi*n)*prod/sigma**2
>      	
>      	ein_induced=sqrt(ei0**2+a**2)
>      	     	
>      	end
> c	------------------------------------------------------------------------------
> c	eoct.f
> c	
> c	calculates maximum eccentricity for arbitrary coplanar system
> c	using Mardling (2007) MNRAS in press
> c
> 	real*8 function eoct(sigma,ei0,eo)
> 	implicit real*8 (a-h,m,o-z)
> 	common/params2/m1,m2,m3
>         common/savepi/pi
> 
> 	m12=m1+m2
> 	m123=m12+m3
> 	aoai=((m123/m12)*sigma**2)**0.3333
> 	al=1/aoai
> 	
> 	epso=sqrt(1-eo**2)
> 	
> 	eeq=1.25*al*eo/epso**2/abs(1-sqrt(al)*(m2/m3)/epso)
> 
> 	AA=abs(1-ei0/eeq)  
> 		
> 	if(AA.lt.1)then
> 	   eoct=(1+AA)*eeq
> 	else
> 	   eoct=ei0+2*eeq
> 	endif
> 		
> 	end
> 
> c	---------------------------------------------------------------------------	
> 	real*8 function acosh(x)
> 	real*8 x
> 
> 	acosh=dlog(x+dsqrt(x**2-1.d0))
> 
> 	end	
> c	---------------------------------------------------------------------------
>         real*8 function sgn(x)
>         real*8 x
> 
>         if(x.lt.0)then
>            sgn=-1
>         else
>            sgn=1
>         endif
276,290c292,293
<       a_cosh=dlog(x+dsqrt(x**2-1.d0))
< 
<       end
< c     -----------------------------------------
<       real*8 function sgn(x)
<       real*8 x
< 
<       if(x.lt.0)then
<          sgn=-1
<       else
<          sgn=1
<       endif
< 
<       end
< c     -----------------------------------------
---
>         end       	
> c	---------------------------------------------------------------------------	
12d11
<       INCLUDE 'mpi_base.h'
19c18
< * partial circularisation and "feeding". Do this if option KZ(41)=1:
---
> * partial circularisation and "feeding". Do this if option BK(1)=1:
74d72
<         if(rank.eq.0)then
78d75
<         end if
81,82c78
<         if(rank.eq.0)
<      +  write(6,'(a,2F8.3)')' new masses [Msun]:', 
---
>         write(6,'(a,2F8.3)')' new masses [Msun]:', 
11d10
< *     Safe for parallel
15d13
< *     Unsafe for parallel! update varaibles: cq,ct,cgr
25d22
< *     Unsafe for parallel!
53c50
<               CALL GIANT3(IK,BODI,WG,QG,ZN,QL)
---
>               CALL GIANT3(IK,BODI,WG,QG,XN,QL)
75c72
<           RP1 = RP/RADIUS(I1)
---
> 	  RP1 = RP/RADIUS(I1)
77c74
<          M21 = CM(1,IM)/CM(2,IM)
---
> 	  M21 = CM(1,IM)/CM(2,IM)
79c76
<           RP1 = RP/RADIUS(I2)
---
> 	  RP1 = RP/RADIUS(I2)
82c79
< *     Evaluate damping coefficient.
---
> *	Evaluate damping coefficient.
88c85
< *     Form rational function approximation to Hut solution.
---
> *	Form rational function approximation to Hut solution.
33d32
<       LOGICAL FIRST
34a34
>       LOGICAL FIRST
95d94
<           IXXX = 0
97,98c96
< *         if(rank.eq.0)
< *    &    write(6,*)' start roche ',name(j1),name(j2),kw1,kw2,
---
> *         write(6,*)' start roche ',name(j1),name(j2),kw1,kw2,
229,230c227
<               if(rank.eq.0)
<      &        WRITE (6,8)  NAME(J1), NAME(J2), TPHYS, KW1, KW2,
---
>               WRITE (6,8)  NAME(J1), NAME(J2), TPHYS, KW1, KW2,
234c231
<               IF(rank.eq.0.and.KSTAR(I).EQ.50)THEN
---
>               IF(KSTAR(I).EQ.50)THEN
240c237
<               IF (KZ(9).GE.2) THEN
---
>               IF (KZ(8).GT.3) THEN
244,246c241,243
<               IF(rank.eq.0.and.FIRST.and.KSTART.eq.1)THEN
< C                 OPEN(UNIT=85,STATUS='UNKNOWN',FORM='FORMATTED',
< C     &                FILE='ROCHE')
---
>               IF(FIRST)THEN
>                  OPEN(UNIT=85,STATUS='NEW',FORM='FORMATTED',
>      &                FILE='ROCHE')
254d250
<               if(rank.eq.0)then
261d256
<               end if
263,272d257
<           
<           if(rank.eq.0)then
<           WRITE (6,5555)  NAME(J1), NAME(J2), KW1, KW2,
<      &              BODY(J1)*ZMBAR, BODY(J2)*ZMBAR,
<      &              RADIUS(J1)*SU,RADIUS(J2)*SU
<  5555       FORMAT (' BEGIN ROCHE.F:  NAME1,2 ',2I10,
<      &     '  KW1,2 ',2I3,' M1,2 [M*] ',1P,2E10.3,
<      &     '  RAD1,2[*]',1P,2E10.3)  
<           end if
< 
341,350d325
< 
<       if(rank.eq.0)then
<           WRITE (6,5556)  NAME(J1), NAME(J2), KW1, KW2,
<      &              BODY(J1)*ZMBAR, BODY(J2)*ZMBAR,
<      &              RADIUS(J1)*SU,RADIUS(J2)*SU
<  5556       FORMAT (' 2 ROCHE.F:  NAME1,2 ',2I10,
<      &     '  KW1,2 ',2I3,' M1,2 [M*] ',1P,2E10.3,
<      &     '  RAD1,2[*]',1P,2E10.3)  
<       end if
< 
393c368,369
<             IF(rank.eq.0.and.TM.LT.TPHYS)THEN
---
>             IF(TM.LT.TPHYS)THEN
>                NBS = NBS + 1
414c390
< * Form a new giant envelope.
---
> * Form a new giant envelope (skip matrix test for preMS evolution).
417,418d392
< *     --02/28/13 9:51-lwang-debug--------------------------------------*
< ***** Note:modife kst--------------------------------------------------**
424d397
< *     --02/28/13 9:52-lwang-end-debug----------------------------------*
452d424
<          IXXX = 1 
466,467c438
<          if(rank.eq.0)
<      &   WRITE (6,20)  MASS, KSTAR(J1), KSTAR(J2), RAD, ROL, SEP
---
>          WRITE (6,20)  MASS, KSTAR(J1), KSTAR(J2), RAD, ROL, SEP
474,476c445,446
<          if(rank.eq.0)
<      &   WRITE (6,25)  MASS, KW1, KW2, SEP, MASSC(1), MASSC(2)
<    25    FORMAT (' END CE    M K A MC',2F7.3,2I3,3F9.3)
---
>          WRITE (6,25)  MASS, KW1, KW2, SEP
>    25    FORMAT (' END CE    M K A ',2F7.3,2I3,F9.3)
558,559c528
<             if(rank.eq.0)
<      &      WRITE (6,27)  NAME(J1), NAME(J2), KSTAR(J2), MASS(2)
---
>             WRITE (6,27)  NAME(J1), NAME(J2), KSTAR(J2), MASS(2)
565d533
<          IXXX = 2
578d545
<          IXXX = 3
591d557
<          IXXX = 4
619,620c585
<             if(rank.eq.0)
<      &      WRITE (6,28)  SEP, DM1, RAD(1), ROL(1)
---
>             WRITE (6,28)  SEP, DM1, RAD(1), ROL(1)
761d725
<                IXXX = 5
779d742
<                      IXXX = 6
802d764
<                IXXX = 7
857,858c819
<             IF (rank.eq.0.and.MOD(IGR,10).EQ.0) 
<      &      WRITE (6,45)  MASS, SEP, DJGR, DTM
---
>             IF (MOD(IGR,10).EQ.0) WRITE (6,45)  MASS, SEP, DJGR, DTM
880,881c841
<                   if(rank.eq.0)
<      &            WRITE (6,40)  MASS, SEP, DJMB, DTM
---
>                   WRITE (6,40)  MASS, SEP, DJMB, DTM
893,894c853
<                   if(rank.eq.0)
<      &            WRITE (6,40)  MASS, SEP, DJMB, DTM
---
>                   WRITE (6,40)  MASS, SEP, DJMB, DTM
1013,1014c972
< *        if(rank.eq.0)
< *    &   WRITE (19,38)  NAME(J1), NAME(J2), KSTAR(J1), KSTAR(J2),
---
> *        WRITE (19,38)  NAME(J1), NAME(J2), KSTAR(J1), KSTAR(J2),
1057,1058c1015
<                if(rank.eq.0)
<      &         WRITE(6,48)NAME(J2),MASS(2),DM2,SEMI*SU,TM,TPHYS,
---
>                WRITE(6,48)NAME(J2),MASS(2),DM2,SEMI*SU,TM,TPHYS,
1144,1145c1101
<           if(rank.eq.0)
<      &    WRITE(85,95)NAME(J1),NAME(J2),KW1,KW2,KSTAR(I),
---
>           WRITE(85,95)NAME(J1),NAME(J2),KW1,KW2,KSTAR(I),
1149,1161c1105
<           if(rank.eq.0)then
<           WRITE (6,5557)  NAME(J1), NAME(J2), KW1, KW2,
<      &              KSTAR(J1),KSTAR(J2),
<      &              BODY(J1)*ZMBAR, BODY(J2)*ZMBAR,
<      &              RADIUS(J1)*SU,RADIUS(J2)*SU,RAD(1),RAD(2),IXXX
<  5557       FORMAT (' END ROCHE.F:  NAME1,2 ',2I10,
<      &     '  KW1,2 ',2I3,' KSTAR 1,2 ', 2I3,' M1,2 [M*] ',1P,2E10.3,
<      &     '  RADIUS1,2[*]',1P,2E10.3,' RAD1,2 ',1P,2E10.3,
<      &     ' IXXX= ',I3)  
<           end if
<                                                  
< 
<           CALL coal(IPAIR,KW1,MASS)
---
>           CALL coal(IPAIR,KW1,KW2,MASS)
1185,1186c1129
< *        if(rank.eq.0)
< *    &   write(6,*)' roche star ',j,name(j),kstar(j),kw,log10(lum)
---
> *        write(6,*)' roche star ',j,name(j),kstar(j),kw,log10(lum)
1242,1243c1185
<          if(rank.eq.0)
<      &   WRITE(85,95)NAME(J1),NAME(J2),KSTAR(J1),KSTAR(J2),KSTAR(I),
---
>          WRITE(85,95)NAME(J1),NAME(J2),KSTAR(J1),KSTAR(J2),KSTAR(I),
1255,1256c1197
<          if(rank.eq.0)
<      &   WRITE(85,95)NAME(J1),NAME(J2),KSTAR(J1),KSTAR(J2),KSTAR(I),
---
>          WRITE(85,95)NAME(J1),NAME(J2),KSTAR(J1),KSTAR(J2),KSTAR(I),
1347,1348c1288
<                if(rank.eq.0)
<      &         WRITE(6,710)NAME(J1),KSTAR(J1),KSTAR(J2),ECC0,FAC0,
---
>                WRITE(6,710)NAME(J1),KSTAR(J1),KSTAR(J2),ECC0,FAC0,
1356,1357d1295
< *     --02/28/13 9:54-lwang-debug--------------------------------------*
< ***** Note:debug-------------------------------------------------------**
1361,1362c1299
<  81            DJORB = DJGR*DTM0
< *     --02/28/13 9:54-lwang-end-debug----------------------------------*
---
>    81          DJORB = DJGR*DTM0
1396,1398c1333
< *     --02/28/13 9:58-lwang-add----------------------------------------*
< ***** Note:add --------------------------------------------------------**
< *     Impose 2.5 % limit on change of JORB (Chris Tout 1/2013).
---
> * Impose 2.5 % limit on change of JORB (Chris Tout 1/2013).
1407d1341
< *     --02/28/13 9:58-lwang-end-add------------------------------------*
1415,1416d1348
< *     --02/28/13 9:58-lwang-add----------------------------------------*
< ***** Note:add---------------------------------------------------------**
1419d1350
<                   IXXX = 8
1423,1424d1353
<                   WRITE(6,*) ' IXXX=8 K(1),K(2) ', KSTAR(J1),KSTAR(J2),
<      &            ' KW1,KW2 ',KW1,KW2,' J1, J2 ', NAME(J1), NAME(J2)     
1427d1355
< *     --02/28/13 9:59-lwang-end-add------------------------------------*
1440c1368
<                IF(rank.eq.0.and.ECC.GT.0.02D0)THEN
---
>                IF(ECC.GT.0.02D0)THEN
1444,1445c1372
<                   if(rank.eq.0)
<      &            WRITE(6,*)' WARNING: will not synchronize'
---
>                   WRITE(6,*)' WARNING: will not synchronize'
1451,1452c1378
<             if(rank.eq.0)
<      &      WRITE(6,711)ECC,OSPIN(1)/OORB,SEP,TK,RAD(1),ROL(1)
---
>             WRITE(6,711)ECC,OSPIN(1)/OORB,SEP,TK,RAD(1),ROL(1)
1489c1415
<                IF (rank.eq.0.and.IWARN.LT.20) THEN
---
>                IF (IWARN.LT.20) THEN
1521,1522c1447
<             if(rank.eq.0)
<      &      WRITE (6,72)  MASS(1), MASS(2), KSTAR(J1), KSTAR(J2), SEP
---
>             WRITE (6,72)  MASS(1), MASS(2), KSTAR(J1), KSTAR(J2), SEP
1533,1534c1458
<             if(rank.eq.0)
<      &      WRITE (6,73)  KSTAR(J1), KSTAR(J2), MASS(1), MASS(2),
---
>             WRITE (6,73)  KSTAR(J1), KSTAR(J2), MASS(1), MASS(2),
1544,1545c1468
<                   if(rank.eq.0)
<      &            WRITE (22,58)  NAME(J1), NAME(J2),
---
>                   WRITE (22,58)  NAME(J1), NAME(J2),
1549,1552c1472,1473
<    58             FORMAT (' DEGEN ROCHE   NAME(I1) NAME(I2) K*(I1) ',
<      &                 'K*(I2) M(I1)[M*] M(I2)[M*] Time[Myr] SEMI[R*] ',
<      &                 'P[days] MD(I1)[M*/Myr] MD(I2)[M*/Myr] ',
<      &                 2I6,2I4,2F6.2,F8.1,2F7.1,1P,2E9.1)
---
>    58             FORMAT (' DEGEN ROCHE    NAM K* M TP A P M1D M2D ',
>      &                             2I6,2I4,2F6.2,F8.1,2F7.1,1P,2E9.1)
1561,1562c1482
<           if(rank.eq.0)
<      &    WRITE (6,76)  KSTAR(J1), KSTAR(J2), MASS(1),
---
>           WRITE (6,76)  KSTAR(J1), KSTAR(J2), MASS(1),
1568c1488
<              IF(KZ(9).GE.3)THEN
---
>              IF(KZ(8).GT.3)THEN
1579c1499
<           IF (KZ(9).GE.2) THEN
---
>           IF (KZ(8).GT.3) THEN
1583,1584c1503
<           if(rank.eq.0)
<      &    WRITE(85,95)NAME(J1),NAME(J2),KSTAR(J1),KSTAR(J2),KSTAR(I),
---
>           WRITE(85,95)NAME(J1),NAME(J2),KSTAR(J1),KSTAR(J2),KSTAR(I),
1615,1616c1534
<               if(rank.eq.0)
<      &        WRITE (6,142)  TIME+TOFF, NAME(J1), KSTAR(J1), KSTAR(J2),
---
>               WRITE (6,142)  TIME+TOFF, NAME(J1), KSTAR(J1), KSTAR(J2),
1644,1645c1562
<           if(rank.eq.0)
<      &    WRITE (6,145)  TIME+TOFF, BODY(J1), BODY(J2), BODY(I)
---
>           WRITE (6,145)  TIME+TOFF, BODY(J1), BODY(J2), BODY(I)
1658,1659c1575
<           if(rank.eq.0)
<      &    WRITE(85,95)NAME(J1),NAME(J2),KSTAR(J1),KSTAR(J2),KSTAR(I),
---
>           WRITE(85,95)NAME(J1),NAME(J2),KSTAR(J1),KSTAR(J2),KSTAR(I),
1663c1579
<               CALL Jpred(I,TIME,TIME)
---
>               CALL xvpred(I,0)
1666c1582
<           CALL cmbody(2)
---
>           CALL cmbody(R(IPAIR),2)
22c22
<           KS(2) = KS2
---
> 	  KS(2) = KS2
24,27c24,27
<          M21 = M1/M2
<          R21 = R1/R2
<          KS(1) = KS2
<          KS(2) = KS1
---
> 	  M21 = M1/M2
> 	  R21 = R1/R2
> 	  KS(1) = KS2
> 	  KS(2) = KS1
2,11c2,10
< *     
< *     
< *     Tidal circularization of binary orbit.
< *     --------------------------------------
< *     
< *     Rational function approximations of solution to the Hut
< *     evolution equation with spin. Ref: A & A 99, 126, eqn (A15).
< *     Developed by Rosemary Mardling (31/1/97 & 25/5/00). See 12/red/36.
< *     
<       Include 'kspars.h'
---
> *
> *
> *       Tidal circularization of binary orbit.
> *       --------------------------------------
> *
> *       Rational function approximations of solution to the Hut
> *       evolution equation with spin. Ref: A & A 99, 126, eqn (A15).
> *       Developed by Rosemary Mardling (31/1/97 & 25/5/00). See 12/red/36.
> *
13d11
< *     Unsafe for parallel!, modified values
15,20c13,17
<      &     BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
<      &     RP(NTMAX),ES(NTMAX),CM(2,NTMAX),IOSC(NTMAX),
<      &     NAMEC(NTMAX)
< *      COMMON/SLOW0/  RANGE,ISLOW(10)
< *     Unsafe for parallel!, modified value angmom0...
<       common/spins/angmom0,rg2(2),m21,r21,semi0,C1,C2,C3,C4,semi
---
>      &               BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
>      &               RP(NTMAX),ES(NTMAX),CM(2,NTMAX),IOSC(NTMAX),
>      &               NAMEC(NTMAX)
>       COMMON/SLOW0/  RANGE,ISLOW(10)
>       common/spins/angmom0,rg2(2),m21,r21,semi0,C1,C2,C3,C4,C5,semi
22c19
<      &     QSCALE(2),A(2),B(2),C(6),meanmotion,RJ(2),ROL(2)
---
>      &        QSCALE(2),A(2),B(2),C(6),meanmotion,RJ(2),ROL(2)
30c27
<      &     -2.314374,-4.127795/
---
>      &                            -2.314374,-4.127795/
32d28
< *     Unsafe for parallel!
35,37c31,33
< *     
< *     
< *     Check for just table updating at KS termination.
---
> *
> *
> *       Check for just table updating at KS termination.
40,51c36,47
<          I = -IPAIR
<          DO 1 K = 1,NCHAOS
<             IF (NAMEC(K).EQ.NAME(I)) IREM = K
<  1       CONTINUE
<          IONE = 0
<          IF (IREM.GT.0) GO TO 30
< *     Include case of removing a specified chaos index (I <= NCHAOS).
<          IF (I.LE.NCHAOS) THEN
<             IREM = I
<             GO TO 30
<          END IF
<          GO TO 100
---
>           I = -IPAIR
>           DO 1 K = 1,NCHAOS
>               IF (NAMEC(K).EQ.NAME(I)) IREM = K
>     1     CONTINUE
>           IONE = 0
>           IF (IREM.GT.0) GO TO 30
> *       Include case of removing a specified chaos index (I <= NCHAOS).
>           IF (I.LE.NCHAOS) THEN
>               IREM = I
>               GO TO 30
>           END IF
>           GO TO 100
53,54c49,50
< *     
< *     Define c.m. & KS indices and search current names for chaos index.
---
> *
> *       Define c.m. & KS indices and search current names for chaos index.
61c57
<          IF (NAMEC(K).EQ.NAME(I)) IC = K
---
>           IF (NAMEC(K).EQ.NAME(I)) IC = K
63,64c59,76
< *     
< *     Set non-zero index on call from CHRECT (KSTAR = -KSTAR) for CE skip.
---
> *
> *       Try repair procedure if NCHAOS reduced to zero or NAMEC missing.
>       IF (NCHAOS.EQ.0.OR.IC.EQ.0) THEN
>           IC = 1
>           NCHAOS = NCHAOS + 1
>           SEMI = -0.5*BODY(I)/H(IPAIR)
>           ECC2 = (1.0-R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
>           ECC = SQRT(ECC2)
> *       Re-initialize basic elements and NAMEC.
>           ES(IC) = ECC
>           RP(IC) = SEMI*(1.0 - ECC)
>           NAMEC(IC) = NAME(I)
>           WRITE (6,4)  NAME(I1), NAME(I), LIST(1,I1), ECC, R(IPAIR)
>     4     FORMAT (' SPIRAL REPAIR    NM NMI NP E RP ',
>      &                               2I7,I4,F8.4,1P,E10.2)
>       END IF
> *
> *       Set non-zero index on call from CHRECT (KSTAR = -KSTAR) for CE skip.
67,70c79,80
<          KSTAR(I) = -KSTAR(I)
< *     ks MPI communication KSTAR
<          call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<          ISTAR = 1
---
>           KSTAR(I) = -KSTAR(I)
>           ISTAR = 1
72,73c82,83
< *     
< *     Include case of chain chaos without identified NAMEC.
---
> *
> *       Include case of chain chaos without identified NAMEC.
75,91c85,100
<          if(rank.eq.0)
<      &        WRITE (6,3)  NCHAOS, KSTAR(I), IPAIR, NAME(I1), NAME(I2),
<      &        STEP(2*IPAIR-1), STEP(I)
<  3       FORMAT (' WARNING!    SPIRAL    NCH K* KS NAME STEP1 STEPI',
<      &        3I4,2I6,1P,2E10.2)
< *     Search for component names (set in CHAOS2).
<          DO 5 K = 1,NCHAOS
<             IF (NAMEC(K).EQ.NAME(I1).OR.NAMEC(K).EQ.NAME(I2)) IC = K
<  5       CONTINUE
< *     
< *     Include safety check just in case.
<          IF (rank.eq.0.and.IC.EQ.0) THEN
<             WRITE (6,6)  NAME(I), KSTAR(I), (NAMEC(K),K=1,NCHAOS)
<  6          FORMAT (' DANGER!    SPIRAL    NAMI K* NAMEC ',15I6)
<             STOP
<          END IF
<          NAMEC(IC) = NAME(I)
---
>           WRITE (6,3)  NCHAOS, KSTAR(I), IPAIR, NAME(I1), NAME(I2),
>      &                 STEP(2*IPAIR-1), STEP(I)
>     3     FORMAT (' WARNING!    SPIRAL    NCH K* KS NAME STEP1 STEPI',
>      &                                    3I4,2I6,1P,2E10.2)
> *       Search for component names (set in CHAOS2).
>           DO 5 K = 1,NCHAOS
>               IF (NAMEC(K).EQ.NAME(I1).OR.NAMEC(K).EQ.NAME(I2)) IC = K
>     5     CONTINUE
> *
> *       Include safety check just in case.
>           IF (IC.EQ.0) THEN
>               WRITE (6,6)  NAME(I), KSTAR(I), (NAMEC(K),K=1,NCHAOS)
>     6         FORMAT (' DANGER!    SPIRAL    NAMI K* NAMEC ',15I6)
>               STOP
>           END IF
>           NAMEC(IC) = NAME(I)
93,94c102,103
< *     
< *     Copy spiral parameters and set semi-major axis & period.
---
> *
> *       Copy spiral parameters and set semi-major axis & period.
101,102c110,111
< *     
< *     Use actual elements for perturbed binary.
---
> *
> *       Use actual elements for perturbed binary.
104,109c113,118
<          ECC2 = (1.0 - R(IPAIR)/SEMI0)**2 +
<      &        TDOT2(IPAIR)**2/(BODY(I)*SEMI0)
<          ECC0 = SQRT(ECC2)
<          ES0 = ECC0
<          RP0 = SEMI0*(1.0 - ECC0)
<          RP(IC) = RP0
---
>           ECC2 = (1.0 - R(IPAIR)/SEMI0)**2 +
>      &                                   TDOT2(IPAIR)**2/(BODY(I)*SEMI0)
>           ECC0 = SQRT(ECC2)
>           ES0 = ECC0
>           RP0 = SEMI0*(1.0 - ECC0)
>           RP(IC) = RP0
111,112c120,121
< *     
< *     Specify index J1 as biggest radius to be used with AT0(1).
---
> *
> *       Specify index J1 as biggest radius to be used with AT0(1).
114,115c123,124
<          J1 = I1
<          J2 = I2
---
>           J1 = I1
>           J2 = I2
117,118c126,127
<          J1 = I2
<          J2 = I1
---
>           J1 = I2
>           J2 = I1
120,122c129,131
< *     
< *     Define oscillation period (dimensionless time) and damping constants.
<       ZN = 0.0
---
> *
> *       Define oscillation period (dimensionless time) and damping constants.
>       XN = 0.0
124,131c133,140
<          IK = I1 + K - 1
<          IF (K.EQ.1) THEN
<             IK = J1
<          ELSE
<             IK = J2
<          END IF
< *     Specify polytropic index for each star (n = 3, 2 or 3/2).
<          IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
---
>           IK = I1 + K - 1
>           IF (K.EQ.1) THEN
>               IK = J1
>           ELSE
>               IK = J2
>           END IF
> *       Specify polytropic index for each star (n = 3, 2 or 3/2).
>           IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
133,155c142,164
<             CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,ZN,QL)
<             W(K) = WG(1)
<             Q(K) = QG(1)
< *     Note: rg2 should really be given by k2 in HRDIAG. 
<             rg2(k)= 0.1*(1.0 - CM(K,IC)/BODY(IK))
<          ELSE
<             QL = 1.0E+04
<             IP = 3
<             IF (KSTAR(IK).GE.3) IP = 2
<             IF (KSTAR(IK).EQ.4.OR.KSTAR(IK).EQ.7) IP = 3
<             IF (KSTAR(IK).EQ.8) IP = 3
<             IF (KSTAR(IK).EQ.0) IP = 1
<             W(K) = WW(IP)
<             Q(K) = QQ(IP)
<             rg2(k)= 0.21
<             IF (KSTAR(IK).LE.2.OR.KSTAR(IK).EQ.7) rg2(k) = 0.1
<             IF (KSTAR(IK).EQ.4) rg2(k)= 0.1*(1.0 - CM(K,IC)/BODY(IK))
<          END IF
<          TL = TWOPI*RADIUS(IK)*SQRT(RADIUS(IK)/BODY(IK)/W(K))
<          AT0(K) = 1.0/(QL*TL)
<  10   CONTINUE
< *     
< *     Form mass, radius & pericentre ratio.
---
>               CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,XN,QL)
>               W(K) = WG(1)
>               Q(K) = QG(1)
> *       Note: rg2 should really be given by k2 in HRDIAG. 
>               rg2(k)= 0.1*(1.0 - CM(K,IC)/BODY(IK))
>           ELSE
>               QL = 1.0E+04
>               IP = 3
>               IF (KSTAR(IK).GE.3) IP = 2
>               IF (KSTAR(IK).EQ.4.OR.KSTAR(IK).EQ.7) IP = 3
>               IF (KSTAR(IK).EQ.8) IP = 3
>               IF (KSTAR(IK).EQ.0) IP = 1
>               W(K) = WW(IP)
>               Q(K) = QQ(IP)
>               rg2(k)= 0.21
>               IF (KSTAR(IK).LE.2.OR.KSTAR(IK).EQ.7) rg2(k) = 0.1
>               IF (KSTAR(IK).EQ.4) rg2(k)= 0.1*(1.0 - CM(K,IC)/BODY(IK))
>           END IF
>           TL = TWOPI*RADIUS(IK)*SQRT(RADIUS(IK)/BODY(IK)/W(K))
>           AT0(K) = 1.0/(QL*TL)
>    10 CONTINUE
> *
> *       Form mass, radius & pericentre ratio.
157,160c166,169
<          M21 = BODY(I2)/BODY(I1)
<          R21 = RADIUS(I2)/RADIUS(I1)
<          RP1 = RP(IC)/RADIUS(I1)
<          rad = radius(i1)
---
>           M21 = BODY(I2)/BODY(I1)
>           R21 = RADIUS(I2)/RADIUS(I1)
>           RP1 = RP(IC)/RADIUS(I1)
>           rad = radius(i1)
162,165c171,174
<          M21 = BODY(I1)/BODY(I2)
<          R21 = RADIUS(I1)/RADIUS(I2)
<          RP1 = RP(IC)/RADIUS(I2)
<          rad = radius(i2)
---
>           M21 = BODY(I1)/BODY(I2)
>           R21 = RADIUS(I1)/RADIUS(I2)
>           RP1 = RP(IC)/RADIUS(I2)
>           rad = radius(i2)
167,168c176,177
< *     
< *     Define initial angular momentum from the scaled semi-major axis.
---
> *
> *       Define initial angular momentum from the scaled semi-major axis.
170,171c179,180
< *     
< *     Form the initial mean motion in N-body units.
---
> *
> *       Form the initial mean motion in N-body units.
173,174c182,183
< *     
< *     Convert from angular momentum to omega (denoted spin1 & spin2).
---
> *
> *       Convert from angular momentum to omega (denoted spin1 & spin2).
176c185
<          SPIN1 = SPIN(J1)/(rg2(1)*BODY(J1)*RADIUS(J1)**2)
---
>           SPIN1 = SPIN(J1)/(rg2(1)*BODY(J1)*RADIUS(J1)**2)
178,189c187,198
<          KW = KSTAR(J1)
<          M0 = BODY0(J1)*SMU
<          MC1 = CM(1,IC)*SMU
<          IF (MC1.LE.0.0D0.OR.MC1.GT.M0) THEN
<             MC1 = 0.3 + 0.1*FLOAT(KW - 3)
<             IF(KW.EQ.9) MC1 = MIN(0.3D0,0.95*M0)
<             CM(1,IC) = MC1/ZMBAR
<          END IF
<          ZDUM = 2.0D0
<          RC1 = CORERD(KW,MC1,M0,ZDUM)/SU
<          SPIN1 = SPIN(J1)/(rg2(1)*BODY(J1)*RADIUS(J1)**2 +
<      &        0.21*MC1/SMU*RC1**2)
---
>           KW = KSTAR(J1)
>           M0 = BODY0(J1)*SMU
>           MC1 = CM(1,IC)*SMU
>           IF (MC1.LE.0.0D0.OR.MC1.GT.M0) THEN
>               MC1 = 0.3 + 0.1*FLOAT(KW - 3)
>               IF(KW.EQ.9) MC1 = MIN(0.3D0,0.95*M0)
>               CM(1,IC) = MC1/ZMBAR
>           END IF
>           ZDUM = 2.0D0
>           RC1 = CORERD(KW,MC1,M0,ZDUM)/SU
>           SPIN1 = SPIN(J1)/(rg2(1)*BODY(J1)*RADIUS(J1)**2 +
>      &                      0.21*MC1/SMU*RC1**2)
192,194c201,203
<          spin2 = SPIN(J2)/(rg2(2)*BODY(J2)*RADIUS(J2)**2)
< *     Produce diagnostic information for recent WD.
<          IF (rank.eq.0.and.KSTAR(J2).GE.10.AND.KSTAR(J2).LE.12.AND.
---
>           spin2 = SPIN(J2)/(rg2(2)*BODY(J2)*RADIUS(J2)**2)
> *       Produce diagnostic information for recent WD.
>           IF (KSTAR(J2).GE.10.AND.KSTAR(J2).LE.12.AND.
196,202c205,210
<             WRITE (95,780)  TTOT, NAME(J2), NAME(J1), KSTAR(J1),
<      &           spin1, spin2, meanmotion, SPIN(J2)
<  780        FORMAT (' WD SPIN    Time[NB] NAME(I2) NAME(I1) K*(I1) ',
<      &           'ROT(I1)[NB] ROT(I2)[NB] <motion> SPIN(I2)[NB] ',
<      &           1P,E20.11,0P,2I12,I4,1P,4E14.5)
<             CALL FLUSH(95)
<          END IF
---
>               WRITE (95,780)  TTOT, NAME(J2), NAME(J1), KSTAR(J1),
>      &                        spin1, spin2, meanmotion, SPIN(J2)
>   780         FORMAT (' WD SPIN    T NM K*1 ROT1 ROT2 <n> S2 ',
>      &                             F8.1,2I6,I4,1P,4E10.2)
>               CALL FLUSH(95)
>           END IF
204,215c212,223
<          KW = KSTAR(J2)
<          M0 = BODY0(J2)*SMU
<          MC2 = CM(2,IC)*SMU
<          IF (MC2.LE.1.0D-10.OR.MC2.GT.M0) THEN
<             MC2 = 0.3 + 0.1*FLOAT(KW - 3)
<             IF(KW.EQ.9) MC2 = MIN(0.3D0,0.95*M0)
<             CM(2,IC) = MC2/ZMBAR
<          END IF
<          ZDUM = 2.0D0
<          RCS2 = CORERD(KW,MC2,M0,ZDUM)/SU
<          spin2 = SPIN(J2)/(rg2(2)*BODY(J2)*RADIUS(J2)**2 +
<      &        0.21*MC2/SMU*RCS2**2)
---
>           KW = KSTAR(J2)
>           M0 = BODY0(J2)*SMU
>           MC2 = CM(2,IC)*SMU
>           IF (MC2.LE.1.0D-10.OR.MC2.GT.M0) THEN
>               MC2 = 0.3 + 0.1*FLOAT(KW - 3)
>               IF(KW.EQ.9) MC2 = MIN(0.3D0,0.95*M0)
>               CM(2,IC) = MC2/ZMBAR
>           END IF
>           ZDUM = 2.0D0
>           RC2 = CORERD(KW,MC2,M0,ZDUM)/SU
>           spin2 = SPIN(J2)/(rg2(2)*BODY(J2)*RADIUS(J2)**2 +
>      &                      0.21*MC2/SMU*RC2**2)
217c225
< *     
---
> *
219,226c227,233
<          IONE = IONE + 1
<          IF (ABS(SPIN1).GT.0.D0.AND.ABS(SPIN2).GT.0.D0) THEN
<             TS = 1.0D+06*365.0*TWOPI*TSTAR
<             if(rank.eq.0)
<      &           WRITE (6,790)  TS/spin1, TS/spin2, TS/meanmotion,
<      &           DAYS*TK, RADIUS(J1)*SU, RADIUS(J2)*SU
<  790        FORMAT (' BEGIN    TROT P TK R* ',1P,2E9.1,0P,4F9.2)
<          END IF
---
>           IONE = IONE + 1
>           IF (ABS(SPIN1).GT.0.D0.AND.ABS(SPIN2).GT.0.D0) THEN
>               TS = 1.0D+06*365.0*TWOPI*TSTAR
>               WRITE (6,790)  TS/spin1, TS/spin2, TS/meanmotion,
>      &                       DAYS*TK, RADIUS(J1)*SU, RADIUS(J2)*SU
>   790         FORMAT (' BEGIN    TROT P TK R* ',1P,2E9.1,0P,4F9.2)
>           END IF
228,229c235,236
< *     
< *     Scale the spins by mean motion and define angular momentum.
---
> *
> *       Scale the spins by mean motion and define angular momentum.
233,235c240,242
<      &     m21*r21**2*rg2(2)*spin20
< *     
< *     Evaluate damping coefficients (Mardling & SJA, M.N. 321, 398, 2001).
---
>      &         m21*r21**2*rg2(2)*spin20
> *
> *       Evaluate damping coefficients (Mardling & SJA, M.N. 321, 398, 2001).
243,244c250,251
< *     
< *     Adopt WD scaling for any NS or BH to avoid numerical problem.
---
> *
> *       Adopt WD scaling for any NS or BH to avoid numerical problem.
246c253
<          C1 = 1.0D-04*C1
---
>           C1 = 1.0D-04*C1
249c256
<          C2 = 1.0D-04*C2
---
>           C2 = 1.0D-04*C2
251c258
< *     
---
> *
253,254c260,261
< *     
< *     Obtain dominant terms of the derivatives (cf. routine HUT/DERIV2).
---
> *
> *       Obtain dominant terms of the derivatives (cf. routine HUT/DERIV2).
259,260c266,267
< *     
< *     Choose the step from smallest time-scale (! time0 < time possible).
---
> *
> *       Choose the step from smallest time-scale (! time0 < time possible).
264c271
< *     Include extra steps for long intervals and/or AGB type 5 or 6.
---
> *       Include extra steps for long intervals and/or AGB type 5 or 6.
267c274
< *     Evaluate the equilibrium angular velocity.
---
> *       Evaluate the equilibrium angular velocity.
272c279
< *     Increase number of steps on slow primary rotation.
---
> *       Increase number of steps on slow primary rotation.
275,276c282,283
< *     
< *     Check circularization time after merger or large interval.
---
> *
> *       Check circularization time after merger or large interval.
278,293c285,298
<          ICIRC = -1
<          A0 = -0.5*BODY(I)/H(IPAIR)
<          QPERI = A0*(1.0 - es0)
<          CALL TCIRC(QPERI,es0,I1,I2,ICIRC,TC)
<          DT = MIN(0.1D0*TC,1.0D0)
< *     Ensure careful integration with DT=0.1*TC for rapid evolution.
<          IF (TC.LT.10.0.AND.(KSTAR(J1).GT.1.OR.ECC.GT.0.1)) THEN
<             nstep = 500*(1.0 + 100.0/TC)
<             nstep = MIN(nstep,5000)
<             if(rank.eq.0)
<      &           WRITE (6,12)  NAME(J1), nstep, ES0, QPERI,
<      &           TIME-TIME0, TC
<  12         FORMAT (' SPIRAL RESET    NM # E QP T-T0 TC ',
<      &           2I6,F7.3,1P,3E10.2)
<          END IF
<          dtau1 = ABS(DT)/float(nstep)
---
>           ICIRC = -1
>           A0 = -0.5*BODY(I)/H(IPAIR)
>           QPERI = A0*(1.0 - es0)
>           CALL TCIRC(QPERI,es0,I1,I2,ICIRC,TC)
>           DT = MIN(0.1D0*TC,1.0D0)
> *       Ensure careful integration with DT=0.1*TC for rapid evolution.
>           IF (TC.LT.10.0.AND.(KSTAR(J1).GT.1.OR.ECC.GT.0.1)) THEN
>               nstep = 500*(1.0 + 100.0/TC)
>               nstep = MIN(nstep,5000)
>               WRITE (6,12)  NAME(J1), nstep, ES0, QPERI, TIME-TIME0, TC
>    12         FORMAT (' SPIRAL RESET    NM # E QP T-T0 TC ',
>      &                                  2I6,F7.3,1P,3E10.2)
>           END IF
>           dtau1 = ABS(DT)/float(nstep)
295c300
< *     
---
> *
297,301c302,306
<       IF (rank.eq.0.and.IONE.LE.2.OR.MOD(IONE,10000).EQ.0) THEN
<          WRITE (6,13) LIST(1,I1), NAME(I1),es0, omeq, meanmotion,
<      &        spin1, spin2
<  13      FORMAT (' SPIRAL    NP NM es0 omeq <n> spin ',
<      &        I4,I6,F9.5,1P,4E10.2)
---
>       IF (IONE.LE.2.OR.MOD(IONE,10000).EQ.0) THEN
>           WRITE (6,13) LIST(1,I1), NAME(I1),es0, omeq, meanmotion,
>      &                 spin1, spin2
>    13     FORMAT (' SPIRAL    NP NM es0 omeq <n> spin ',
>      &                        I4,I6,F9.5,1P,4E10.2)
303,304c308,309
< *     
< *     Integrate equations for eccentricity and angular velocities.
---
> *
> *       Integrate equations for eccentricity and angular velocities.
306,307c311,312
< *     
< *     Ensure that no overshooting takes place.
---
> *
> *       Ensure that no overshooting takes place.
309,317c314,322
<          IF (rank.eq.0.and.MOD(IWARN,100).EQ.0) THEN
<             WRITE (66,14) TTOT, NAME(J1), KSTAR(J1), nstep, ecc,
<      &           RP0*SU/(1.0-es0), spin1-1.0
<  14         FORMAT (' SPIN WARNING   T NM K* # E A S-1 ',
<      &           F8.1,I7,I4,I6,F7.3,1P,2E10.1)
<             CALL FLUSH(66)
<          END IF
<          spin1 = 1.0
<          IWARN = IWARN + 1
---
>           IF (MOD(IWARN,100).EQ.0) THEN
>               WRITE (66,14) TTOT, NAME(J1), KSTAR(J1), nstep, ecc,
>      &                      RP0*SU/(1.0-es0), spin1-1.0
>    14         FORMAT (' SPIN WARNING   T NM K* # E A S-1 ',
>      &                                 F8.1,I7,I4,I6,F7.3,1P,2E10.1)
>               CALL FLUSH(66)
>           END IF
>           spin1 = 1.0
>           IWARN = IWARN + 1
320,326c325,331
<          IF (rank.eq.0.and.MOD(IWARN,100).EQ.0) THEN
<             WRITE (66,14) TTOT, NAME(J2), KSTAR(J2), nstep, ecc,
<      &           RP0*SU/(1.0-es0), spin2-1.0
<             CALL FLUSH(66)
<          END IF
<          spin2 = 1.0
<          IWARN = IWARN + 1
---
>           IF (MOD(IWARN,100).EQ.0) THEN
>               WRITE (66,14) TTOT, NAME(J2), KSTAR(J2), nstep, ecc,
>      &                       RP0*SU/(1.0-es0), spin2-1.0
>               CALL FLUSH(66)
>           END IF
>           spin2 = 1.0
>           IWARN = IWARN + 1
328,329c333,334
< *     
< *     Re-scale the semi-major axis and angular velocities to N-body units.
---
> *
> *       Re-scale the semi-major axis and angular velocities to N-body units.
335,336c340,341
< *     
< *     Convert back to angular momenta.
---
> *
> *       Convert back to angular momenta.
338c343
<          SPIN(J1) = rg2(1)*BODY(J1)*RADIUS(J1)**2*spin1
---
>           SPIN(J1) = rg2(1)*BODY(J1)*RADIUS(J1)**2*spin1
340,341c345,346
<          SPIN(J1) = (rg2(1)*BODY(J1)*RADIUS(J1)**2 +
<      &        0.21*MC1/SMU*RC1**2)*spin1
---
>           SPIN(J1) = (rg2(1)*BODY(J1)*RADIUS(J1)**2 +
>      &                0.21*MC1/SMU*RC1**2)*spin1
344c349
<          SPIN(J2) = rg2(2)*BODY(J2)*RADIUS(J2)**2*spin2
---
>           SPIN(J2) = rg2(2)*BODY(J2)*RADIUS(J2)**2*spin2
346,347c351,352
<          SPIN(J2) = (rg2(2)*BODY(J2)*RADIUS(J2)**2 +
<      &        0.21*MC2/SMU*RCS2**2)*spin2
---
>           SPIN(J2) = (rg2(2)*BODY(J2)*RADIUS(J2)**2 +
>      &                0.21*MC2/SMU*RC2**2)*spin2
349,353c354,355
< *     ks MPI communication SPIN
<       call ksparmpi(K_store,K_real8,K_SPIN,J1,0,SPIN(J1))
<       call ksparmpi(K_store,K_real8,K_SPIN,J2,0,SPIN(J2))
< *     
< *     Obtain the tidal contributions from integration.
---
> *
> *       Obtain the tidal contributions from integration.
356,357c358,359
< *     
< *     Update energy and semi-major axis.
---
> *
> *       Update energy and semi-major axis.
360,361c362,363
< *     
< *     Set new pericentre from final elements and update reference values.
---
> *
> *       Set new pericentre from final elements and update reference values.
363c365
<          QPERI = semi*(1.0 - ecc)
---
>           QPERI = semi*(1.0 - ecc)
365c367
<          QPERI = RP0*(1.0 + ES0)/(1.0 + ECC)
---
>           QPERI = RP0*(1.0 + ES0)/(1.0 + ECC)
370,371c372,373
< *     
< *     Define synchronous state at the end and adopt ECC = ECCM.
---
> *
> *       Define synchronous state at the end and adopt ECC = ECCM.
373,394c375,391
<          IONE = 0
<          KSTAR(I) = 10
< *     ks MPI communication KSTAR
<          call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<          NCIRC = NCIRC + 1
<          TB = DAYS*SEMI*SQRT(SEMI/BODY(I))
< *     Ensure the dominant star has synchronous rotation.
<          IF(KSTAR(J1).LE.2.OR.(KSTAR(J1).GE.7.AND.KSTAR(J1).NE.9))THEN
<             SPIN(J1) = rg2(1)*BODY(J1)*RADIUS(J1)**2*meanmotion
<          ELSE
<             SPIN(J1) = (rg2(1)*BODY(J1)*RADIUS(J1)**2 +
<      &           0.21*MC1/SMU*RC1**2)*meanmotion
<          END IF
< *     ks MPI communication SPIN
<          call ksparmpi(K_store,K_real8,K_SPIN,J1,0,SPIN(J1))
<          DOM = (spin1 - meanmotion)/meanmotion
<          if(rank.eq.0)
<      &        WRITE (6,15)  TTOT, IPAIR, ES0, ECC, 
<      &        RP0, R(IPAIR), H(IPAIR), TB, ZN, DOM
<  15      FORMAT (' END SPIRAL    T KS E0 E RP0 R H P n DOM/OM ',
<      &        F9.2,I4,2F8.4,1P,4E10.2,0P,F5.1,F7.3)
<          ECC = ECCM
---
>           IONE = 0
>           KSTAR(I) = 10
>           NCIRC = NCIRC + 1
>           TB = DAYS*SEMI*SQRT(SEMI/BODY(I))
> *       Ensure the dominant star has synchronous rotation.
>           IF(KSTAR(J1).LE.2.OR.(KSTAR(J1).GE.7.AND.KSTAR(J1).NE.9))THEN
>               SPIN(J1) = rg2(1)*BODY(J1)*RADIUS(J1)**2*meanmotion
>           ELSE
>               SPIN(J1) = (rg2(1)*BODY(J1)*RADIUS(J1)**2 +
>      &                    0.21*MC1/SMU*RC1**2)*meanmotion
>           END IF
>           DOM = (spin1 - meanmotion)/meanmotion
>           WRITE (6,15)  TTOT, IPAIR, ES0, ECC, RP0, R(IPAIR), H(IPAIR),
>      &                  TB, XN, DOM
>    15     FORMAT (' END SPIRAL    T KS E0 E RP0 R H P n DOM/OM ',
>      &                            F9.2,I4,2F8.4,1P,4E10.2,0P,F5.1,F7.3)
>           ECC = ECCM
396,397c393,394
< *     
< *     Ensure apocentre or arbitrary phase is replaced by pericentre.
---
> *
> *       Ensure apocentre or arbitrary phase is replaced by pericentre.
400,411c397,408
< *     Reduce eccentric anomaly by pi for inward motion.
<          IF (TDOT2(IPAIR).LT.0.0D0) THEN
<             CALL KSAPO(IPAIR)
<          END IF
< *     Transform from outward motion (anomaly < pi) to exact pericentre.
<          IF (GAMMA(IPAIR).LT.1.0D-04) THEN
< *     Note consistency problem for large GAMMA (HDOT effect not included).
<             TT0 = TIME
<             CALL KSPERI(IPAIR)
< *     Restore TIME just in case (possible bug in scheduling of #I1).
<             TIME = TT0
<          END IF
---
> *       Reduce eccentric anomaly by pi for inward motion.
>           IF (TDOT2(IPAIR).LT.0.0D0) THEN
>               CALL KSAPO(IPAIR)
>           END IF
> *       Transform from outward motion (anomaly < pi) to exact pericentre.
>           IF (GAMMA(IPAIR).LT.1.0D-04) THEN
> *       Note consistency problem for large GAMMA (HDOT effect not included).
>               TT0 = TIME
>               CALL KSPERI(IPAIR)
> *       Restore TIME just in case (possible bug in scheduling of #I1).
>               TIME = TT0
>           END IF
413,414c410,411
< *     
< *     Form KS coordinate scaling factor from pericentre ratio.
---
> *
> *       Form KS coordinate scaling factor from pericentre ratio.
416,417c413,414
< *     
< *     Set KS velocity scaling from energy relation with RP0 instead of R.
---
> *
> *       Set KS velocity scaling from energy relation with RP0 instead of R.
419,420c416,417
< *     
< *     Scale KS variables to yield the prescribed elements (set TDOT2 >= 0).
---
> *
> *       Scale KS variables to yield the prescribed elements (set TDOT2 >= 0).
424,429c421,426
<          U(K,IPAIR) = C1*U(K,IPAIR)
<          UDOT(K,IPAIR) = C2*UDOT(K,IPAIR)
<          U0(K,IPAIR) = U(K,IPAIR)
<          R(IPAIR) = R(IPAIR) + U(K,IPAIR)**2
<          TDOT2(IPAIR) = TDOT2(IPAIR) + 2.0*U(K,IPAIR)*UDOT(K,IPAIR)
<  18   CONTINUE
---
>           U(K,IPAIR) = C1*U(K,IPAIR)
>           UDOT(K,IPAIR) = C2*UDOT(K,IPAIR)
>           U0(K,IPAIR) = U(K,IPAIR)
>           R(IPAIR) = R(IPAIR) + U(K,IPAIR)**2
>           TDOT2(IPAIR) = TDOT2(IPAIR) + 2.0*U(K,IPAIR)*UDOT(K,IPAIR)
>    18 CONTINUE
431,432c428,429
< *     
< *     Perform energy correction to maintain conservation.
---
> *
> *       Perform energy correction to maintain conservation.
434,441c431,434
<       DETMP = ZMU*(HI - H(IPAIR))
<       ECOLL = ECOLL + DETMP
<       EGRAV = EGRAV + DETMP
< *     ks MPI communication ECOLL EGRAV
<       call ksparmpi(K_store,K_real8,K_ECOLL,0,0,DETMP)
<       call ksparmpi(K_store,K_real8,K_EGRAV,0,0,DETMP)
< *     
< *     Rectify large eccentricity deviation from integrated value.
---
>       ECOLL = ECOLL + ZMU*(HI - H(IPAIR))
>       EGRAV = EGRAV + ZMU*(HI - H(IPAIR))
> *
> *       Rectify large eccentricity deviation from integrated value.
445c438
<          CALL KSRECT(IPAIR)
---
>           CALL KSRECT(IPAIR)
447,448c440,441
< *     
< *     Check Roche time and update RADIUS of primary frequently.
---
> *
> *       Check Roche time and update RADIUS of primary frequently.
450c443
< *     Specify semi-major axis and binding energy for evaluating Roche time.
---
> *       Specify semi-major axis and binding energy for evaluating Roche time.
455,456c448,449
< *     
< *     Obtain Roche radius and stellar radius for each component.
---
> *
> *       Obtain Roche radius and stellar radius for each component.
459,465c452,458
<          Q1 = BODY(J)/(BODY(I) - BODY(J))
<          ROL(K) = RL(Q1)
<          RJ(K) = RADIUS(J)
<          J = I2
<  20   CONTINUE
< *     
< *     Determine indices for primary & secondary star (donor & accretor).
---
>           Q1 = BODY(J)/(BODY(I) - BODY(J))
>           ROL(K) = RL(Q1)
>           RJ(K) = RADIUS(J)
>           J = I2
>    20 CONTINUE
> *
> *       Determine indices for primary & secondary star (donor & accretor).
467,468c460,461
<          J1 = I1
<          J2 = I2
---
>           J1 = I1
>           J2 = I2
470,471c463,464
<          J1 = I2
<          J2 = I1
---
>           J1 = I2
>           J2 = I1
473,474c466,467
< *     
< *     Form critical mass ratio using approximate core mass.
---
> *
> *       Form critical mass ratio using approximate core mass.
479,484c472,477
<          ZCMC = CM(1,IC)
<          IF (J1.EQ.I2) ZCMC = CM(2,IC)
<          QC = (1.67D0-ZPARS7+2.D0*(ZCMC/BODY(J1))**5)/2.13D0
< *     
< *     Consider using condition of Hjellming & Webbink, 1987, ApJ, 318, 794.
< *     QC = 0.362D0 + 1.D0/(3.D0*(1.D0 - MASSC(1)/MASS(1)))
---
>          ZMC = CM(1,IC)
>          IF (J1.EQ.I2) ZMC = CM(2,IC)
>          QC = (1.67D0-ZPARS7+2.D0*(ZMC/BODY(J1))**5)/2.13D0
> *
> *       Consider using condition of Hjellming & Webbink, 1987, ApJ, 318, 794.
> *        QC = 0.362D0 + 1.D0/(3.D0*(1.D0 - MASSC(1)/MASS(1)))
490,491c483,484
< *     
< *     Adopt common envelope evolution for eccentric binaries with Q1 > QC.
---
> *
> *       Adopt common envelope evolution for eccentric binaries with Q1 > QC.
493,538c486,525
< *     --12/28/13 22:35-lwang-modify-------------------------------------*
< ***** Note: Avoid call expel in parallel KS----------------------------**
< c$$$      IF (DTR.LT.0.1/TSTAR.AND.Q1.GT.QC.AND.ISTAR.EQ.0) THEN
< c$$$         KSPAIR = IPAIR
< c$$$         TIME = TBLOCK
< c$$$         IQCOLL = 1
< c$$$         CALL EXPEL(J1,J2,ICASE)
< c$$$*     Exit before updating TEV in the unlikely case of coalescence.
< c$$$         IF (IPHASE.EQ.-1) GO TO 100
< c$$$         TEV(I1) = TEV(I) + 2.0*STEPX
< c$$$         TEV(I2) = TEV(I1)
< c$$$         GO TO 100
< c$$$      END IF
< *     --12/28/13 22:35-lwang-end-modify---------------------------------*
< *     
< *     Enforce termination at constant angular momentum on Roche condition.
<       IF (DTR.LE.0.1/TSTAR) THEN
<          AF = SEMI*(1.0 - ECC**2)/(1.0 - ECCM**2)
<          H(IPAIR) = -0.5*BODY(I)/AF
<          DETMP = ZMU*(HI - H(IPAIR))
<          ECOLL = ECOLL + DETMP
<          EGRAV = EGRAV + DETMP
<          KSTAR(I) = 10
< *     ks MPI communication ECOLL EGRAV KSTAR
<          call ksparmpi(K_store,K_real8,K_ECOLL,0,0,DETMP)
<          call ksparmpi(K_store,K_real8,K_EGRAV,0,0,DETMP)
<          call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<          if(rank.eq.0)WRITE (6,21)  ES0, ECC, AF/SEMI, DTR, SEMI, AF
<  21      FORMAT (' WARNING!    SPIRAL TERM    E0 E A/A0 DTR A AF ',
<      &        2F8.4,F6.2,1P,3E10.2)
< *     Ensure the dominant star has synchronous rotation.
<          meanmotion = SQRT(BODY(I)/AF**3)
<          IF(KSTAR(J1).LE.2.OR.(KSTAR(J1).GE.7.AND.KSTAR(J1).NE.9))THEN
<             SPIN(J1) = rg2(1)*BODY(J1)*RADIUS(J1)**2*meanmotion
<          ELSE
<             SPIN(J1) = (rg2(1)*BODY(J1)*RADIUS(J1)**2 +
<      &           0.21*MC1/SMU*RC1**2)*meanmotion
<          END IF
< *     ks MPI communication SPIN
<          call ksparmpi(K_store,K_real8,K_SPIN,J1,0,SPIN(J1))
<          DOM = (spin1 - meanmotion)/meanmotion
<          if(rank.eq.0)WRITE (6,26)  NAME(J1), Q1, QC, DOM
<  26      FORMAT (' ENFORCED ROCHE   NM(J1) Q1 QC DOM/OM',I8,2F8.2,F7.3)
< *     Modify KS variables to yield circular velocity with energy H.
<          CALL EXPAND(IPAIR,R(IPAIR))
<          CALL RESOLV(IPAIR,1)
---
>       IF (N.GT.0) GO TO 99  ! Fudge 10/12 to avoid COAL without ISTAT(KCASE).
>       IF (DTR.LT.0.1/TSTAR.AND.Q1.GT.QC.AND.ISTAR.EQ.0) THEN
>           KSPAIR = IPAIR
>           TIME = TBLOCK
>           IQCOLL = 1
>           CALL EXPEL(J1,J2,ICASE)
> *       Exit before updating TEV in the unlikely case of coalescence.
>           IF (IPHASE.EQ.-1) GO TO 100
>           TEV(I1) = TEV(I) + 2.0*STEPX
>           TEV(I2) = TEV(I1)
>           GO TO 100
>       END IF
>    99 CONTINUE   ! Fudge leads to SPIRAL TERM and ENFORCED ROCHE.
> *
> *       Enforce termination at constant angular momentum on Roche condition.
>       IF (DTR.LE.0.1/TSTAR.OR.
>      &   (STEP(I1).GT.100.0*TK.AND.KSTAR(J1).GE.5)) THEN
> *       Include also enforcement for AGB stars in unperturbed state.
>           AF = SEMI*(1.0 - ECC**2)/(1.0 - ECCM**2)
>           H(IPAIR) = -0.5*BODY(I)/AF
>           ECOLL = ECOLL + ZMU*(HI - H(IPAIR))
>           EGRAV = EGRAV + ZMU*(HI - H(IPAIR))
>           KSTAR(I) = 10
>           WRITE (6,21)  ES0, ECC, AF/SEMI, DTR, SEMI, AF
>    21     FORMAT (' WARNING!    SPIRAL TERM    E0 E A/A0 DTR A AF ',
>      &                                         2F8.4,F6.2,1P,3E10.2)
> *       Ensure the dominant star has synchronous rotation.
>           meanmotion = SQRT(BODY(I)/AF**3)
>           IF(KSTAR(J1).LE.2.OR.(KSTAR(J1).GE.7.AND.KSTAR(J1).NE.9))THEN
>               SPIN(J1) = rg2(1)*BODY(J1)*RADIUS(J1)**2*meanmotion
>           ELSE
>               SPIN(J1) = (rg2(1)*BODY(J1)*RADIUS(J1)**2 +
>      &                    0.21*MC1/SMU*RC1**2)*meanmotion
>           END IF
>           DOM = (spin1 - meanmotion)/meanmotion
>           WRITE (6,26)  NAME(J1), Q1, QC, DOM
>    26     FORMAT (' ENFORCED ROCHE   NM(J1) Q1 QC DOM/OM',I8,2F8.2,F7.3)
> *       Modify KS variables to yield circular velocity with energy H.
>           CALL EXPAND(IPAIR,R(IPAIR))
>           CALL RESOLV(IPAIR,1)
540,541c527,528
< *     
< *     Initialize KS for perturbed motion (cf. backwards step in KSPERI).
---
> *
> *       Initialize KS for perturbed motion (cf. backwards step in KSPERI).
543,552c530,539
< *     Ensure unperturbed motion for small GAMMA.
<          IF (GAMMA(IPAIR).LT.1.0D-10.AND.ES0.LT.0.95) THEN
<             LIST(1,I1) = 0
<          END IF
<          IF (GAMMA(IPAIR).LT.5.0D-07.AND.ES0.LT.0.3) THEN
<             LIST(1,I1) = 0
<          END IF
<          CALL RESOLV(IPAIR,1)
<          IMOD = KSLOW(IPAIR)
<          CALL KSPOLY(IPAIR,IMOD)
---
> *       Ensure unperturbed motion for small GAMMA.
>           IF (GAMMA(IPAIR).LT.1.0D-10.AND.ES0.LT.0.95) THEN
>               LIST(1,I1) = 0
>           END IF
>           IF (GAMMA(IPAIR).LT.5.0D-07.AND.ES0.LT.0.3) THEN
>               LIST(1,I1) = 0
>           END IF
>           CALL RESOLV(IPAIR,1)
>           IMOD = KSLOW(IPAIR)
>           CALL KSPOLY(IPAIR,IMOD)
554,555c541,542
< *     
< *     Rectify the orbit to yield consistent variables (only at end).
---
> *
> *       Rectify the orbit to yield consistent variables (only at end).
557,619c544,602
<          CALL KSRECT(IPAIR)
< *     
< *     Re-evaluate eccentricity after rectification.
<          SEMI = -0.5*BODY(I)/H(IPAIR)
<          ECC2 = (1.0-R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
<          ECC = SQRT(ECC2)
< *     
< *     Deform the orbit to small eccentricity (H = const).
<          IF (ECC.GT.ECCM) THEN
<             CALL DEFORM(IPAIR,ECC,ECCM)
< *     
<             if(rank.eq.0)WRITE (6,22)  ECC, ECCM, TIME-TIME0, SEMI,
<      &           BODY(I1)*ZMBAR, BODY(I2)*ZMBAR
<  22         FORMAT (' DEFORM SPIRAL    E EF T-TOSC SEMI M1 M2 ',
<      &           2F8.4,F9.4,1P,E10.2,0P,2F6.2)
<          END IF
< *     
< *     Determine indices for primary & secondary star (donor & accretor).
<          IF (BODY(I1)/RADIUS(I1)**3.LT.BODY(I2)/RADIUS(I2)**3) THEN
<             J1 = I1
<             J2 = I2
<          ELSE
<             J2 = I1
<             J1 = I2
<          END IF
< *     
< *     Define mass ratio and evaluate Roche radius for the primary.
<          Q0 = BODY(J1)/BODY(J2)
<          Q1 = Q0**0.3333
<          Q2 = Q1**2
<          RL1 = 0.49*Q2/(0.6*Q2 + LOG(1.0D0 + Q1))*SEMI
< *     
< *     Update Roche look-up time (does not depend on choice of primary).
<          CALL TRFLOW(IPAIR,DTR)
<          TEV(I) = TIME + DTR
< *     ks MPI communication
<          call ksparmpi(K_store,K_real8,K_TEV,I,0,TEV(I))
<          TK = DAYS*SEMI*SQRT(SEMI/BODY(I))
< *     
<          if(rank.eq.0)
<      &        WRITE (6,24)  IC, NAME(J1), NAME(J2), KSTAR(J1), 
<      &        KSTAR(J2), SEMI*SU, RL1*SU, RADIUS(J1)*SU, RADIUS(J2)*SU,
<      &        TPHYS, TK, DTR
<  24      FORMAT (' ROCHE CHECK    IC NAM K* A RL R* TP TK DTR ',
<      &        I4,2I6,2I4,4F7.1,F9.2,1P,2E9.1)
<          ZM1 = BODY(J1)*SMU
<          CALL TRDOT(J1,DTM,ZM1)
<          TEV(J1) = TIME + DTM
< *     ks MPI communication
<          call ksparmpi(K_store,K_real8,K_TEV,J1,0,TEV(J1))
< *     IF (DTR.LT.0.1/TSTAR) THEN
< *     TEV(I1) = TEV(I) + 2.0*STEPX
< *     TEV(I2) = TEV(I1)
< *     END IF
< c$$$*     Include enforcement of Roche coalescence to prevent shrinkage stop.
< c$$$         IF (DTR.EQ.0.0D0.AND.SEMI.LT.0.5*RADIUS(J1)) THEN
< c$$$            KSPAIR = IPAIR
< c$$$            IQCOLL = 1
< c$$$            if(rank.eq.0)WRITE (6,23)
< c$$$ 23         FORMAT (' ENFORCED COAL')
< c$$$            CALL CMBODY(2)
< c$$$            IF (IPHASE.LT.0) GO TO 100
< c$$$         END IF
---
>           CALL KSRECT(IPAIR)
> *
> *       Re-evaluate eccentricity after rectification.
>           SEMI = -0.5*BODY(I)/H(IPAIR)
>           ECC2 = (1.0-R(IPAIR)/SEMI)**2 + TDOT2(IPAIR)**2/(BODY(I)*SEMI)
>           ECC = SQRT(ECC2)
> *
> *       Deform the orbit to small eccentricity (H = const).
>           IF (ECC.GT.ECCM) THEN
>               CALL DEFORM(IPAIR,ECC,ECCM)
> *
>               WRITE (6,22)  ECC, ECCM, TIME-TIME0, SEMI,
>      &                      BODY(I1)*ZMBAR, BODY(I2)*ZMBAR
>    22         FORMAT (' DEFORM SPIRAL    E EF T-TOSC SEMI M1 M2 ',
>      &                                   2F8.4,F9.4,1P,E10.2,0P,2F6.2)
>           END IF
> *
> *       Determine indices for primary & secondary star (donor & accretor).
>           IF (BODY(I1)/RADIUS(I1)**3.LT.BODY(I2)/RADIUS(I2)**3) THEN
>               J1 = I1
>               J2 = I2
>           ELSE
>               J2 = I1
>               J1 = I2
>           END IF
> *
> *       Define mass ratio and evaluate Roche radius for the primary.
>           Q0 = BODY(J1)/BODY(J2)
>           Q1 = Q0**0.3333
>           Q2 = Q1**2
>           RL1 = 0.49*Q2/(0.6*Q2 + LOG(1.0D0 + Q1))*SEMI
> *
> *       Update Roche look-up time (does not depend on choice of primary).
>           CALL TRFLOW(IPAIR,DTR)
>           TEV(I) = TIME + DTR
>           TK = DAYS*SEMI*SQRT(SEMI/BODY(I))
> *
>           WRITE (6,24)  IC, NAME(J1), NAME(J2), KSTAR(J1), KSTAR(J2),
>      &                  SEMI*SU, RL1*SU, RADIUS(J1)*SU, RADIUS(J2)*SU,
>      &                  TPHYS, TK, DTR
>    24     FORMAT (' ROCHE CHECK    IC NAM K* A RL R* TP TK DTR ',
>      &                             I4,2I6,2I4,4F7.1,F9.2,1P,2E9.1)
>           ZM1 = BODY(J1)*SMU
>           CALL TRDOT(J1,DTM,ZM1)
>           TEV(J1) = TIME + DTM
> *         IF (DTR.LT.0.1/TSTAR) THEN
> *             TEV(I1) = TEV(I) + 2.0*STEPX
> *             TEV(I2) = TEV(I1)
> *         END IF
> *       Include enforcement of Roche coalescence to prevent shrinkage stop.
>           IF (DTR.EQ.0.0D0.AND.SEMI.LT.0.5*RADIUS(J1)) THEN
>               KSPAIR = IPAIR
>               IQCOLL = 1
>               WRITE (6,23)  IPAIR
>    23         FORMAT (' ENFORCED COAL    KS = ',I4)
> *        Delay coalescence until detected by ROCHE or UNPERT.
> *             CALL CMBODY(R(IPAIR),2)
> *             IF (IPHASE.LT.0) GO TO 100
>           END IF
621,622c604,605
< *     
< *     Include occasional diagnostics of spiral evolution (every output).
---
> *
> *       Include occasional diagnostics of spiral evolution (every output).
624,632c607,614
<          IF (RP1.LT.3.0.AND.(ECC.LT.0.1.OR.KSTAR(J1).GE.3)) THEN
<             NP = LIST(1,I1)
<             TK = DAYS*SEMI*SQRT(SEMI/BODY(I))
<             if(rank.eq.0)
<      &           WRITE (6,25)  NAME(I1), NAME(I2), IPAIR, NCHAOS,
<      &           KSTAR(I1), KSTAR(I2), NP, ECC, RP1, TK
<  25         FORMAT (' SPIRAL    NAM KS NCH K* NP E RP P ',
<      &           2I6,I5,4I4,F8.4,F6.2,F8.2)
<          END IF
---
>           IF (RP1.LT.3.0.AND.(ECC.LT.0.1.OR.KSTAR(J1).GE.3)) THEN
>               NP = LIST(1,I1)
>               TK = DAYS*SEMI*SQRT(SEMI/BODY(I))
>               WRITE (6,25)  NAME(I1), NAME(I2), IPAIR, NCHAOS,
>      &                      KSTAR(I1), KSTAR(I2), NP, ECC, RP1, TK
>    25         FORMAT (' SPIRAL    NAM KS NCH K* NP E RP P ',
>      &                            2I6,I5,4I4,F8.4,F6.2,F8.2)
>           END IF
634,635c616,617
< *     
< *     Include enforced circularization for difficult cases.
---
> *
> *       Include enforced circularization for difficult cases.
637,657c619,635
<      &     (ECC.LT.0.8.AND.GAMMA(IPAIR).LT.1.0D-08).OR.
<      &     (ECC.LT.0.95.AND.GAMMA(IPAIR).LT.1.0D-09)) THEN
<          ICIRC = 0
<          CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC) 
<          IF (TC.GT.200.0.OR.(TC.GT.10.AND.ECC.LT.0.7)) THEN
<             CALL KSPERI(IPAIR)
<             CALL KSAPO(IPAIR)
<             CALL DEFORM(IPAIR,ECC,ECCM)
<             KSTAR(I) = 10
< *     ks MPI communication KSTAR
<             call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<             NCIRC = NCIRC + 1
<             CALL RESOLV(IPAIR,1)
<             CALL KSPOLY(IPAIR,1)
<             NP = LIST(1,I1)
<             if(rank.eq.0)
<      &           WRITE (6,28)  IPAIR, NP, NAME(I1),
<      &           ECC, TC, GAMMA(IPAIR)
<  28         FORMAT (' ENFORCED CIRC   KS NP NM E TC G  ',
<      &           2I4,I6,F7.3,1P,2E9.1)
<          END IF
---
>      &    (ECC.LT.0.8.AND.GAMMA(IPAIR).LT.1.0D-08).OR.
>      &    (ECC.LT.0.95.AND.GAMMA(IPAIR).LT.1.0D-09)) THEN
>           ICIRC = 0
>           CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC) 
>           IF (TC.GT.200.0.OR.(TC.GT.10.AND.ECC.LT.0.7)) THEN
>               CALL KSPERI(IPAIR)
>               CALL KSAPO(IPAIR)
>               CALL DEFORM(IPAIR,ECC,ECCM)
>               KSTAR(I) = 10
>               NCIRC = NCIRC + 1
>               CALL RESOLV(IPAIR,1)
>               CALL KSPOLY(IPAIR,1)
>               NP = LIST(1,I1)
>               WRITE (6,28)  IPAIR, NP, NAME(I1), ECC, TC, GAMMA(IPAIR)
>    28         FORMAT (' ENFORCED CIRC   KS NP NM E TC G  ',
>      &                                  2I4,I6,F7.3,1P,2E9.1)
>           END IF
659,660c637,638
< *     
< *     Set standard binary on large ECC and TC if small GAMMA (large omeq).
---
> *
> *       Set standard binary on large ECC and TC if small GAMMA (large omeq).
662,710c640,662
<          ICIRC = 0
<          CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC) 
<          IF (TC.GT.1.0D+04) THEN
<             KSTAR(I) = 0
< *     ks MPI communication KSTAR
<             call ksparmpi(K_store,K_int,K_KSTAR,I,0,KSTAR(I))
<             IREM = IC
<             if(rank.eq.0)WRITE (6,29)  NAME(I1), LIST(1,I1), ECC, TC
<  29         FORMAT (' FROZEN CIRC    NM NP E TC ',I7,I4,F9.5,1P,E9.1)
<             GO TO 30
<          END IF
<       END IF
< *     
< *     Check for terminated or escaped chaotic binaries at end of spiral.
<  30   IF (KSTAR(I).EQ.10.OR.IREM.GT.0) THEN
<          IF (IREM.GT.0) GO TO 50
<          J = 1
< *     See whether case #J indicates current or escaped/disrupted KS binary.
<  40      DO 45 JPAIR = 1,NPAIRS
<             IF (NAMEC(J).EQ.NAME(N+JPAIR)) THEN
< *     Update #J if KSTAR > 0, otherwise consider next member.
<                IF (KSTAR(N+JPAIR).GT.0) THEN
<                   GO TO 50
<                ELSE
<                   GO TO 70
<                END IF
<             END IF
<  45      CONTINUE
< *     
< *     Skip during multiple regularizations (KSTAR not visible).
<          IF (NSUB.GT.0) THEN
<             GO TO 70
<          END IF
< *     
< *     Skip removal if chaos binary is member of single/double merger.
<          IF (NMERGE.GT.0) THEN
<             DO 48 JPAIR = 1,NPAIRS
<                IF (NAME(N+JPAIR).LT.0) THEN
<                   IF (NAMEC(J).EQ.NZERO + NAME(2*JPAIR-1).OR.
<      &                 NAMEC(J).EQ.NZERO + NAME(2*JPAIR).OR.
<      &                 NAMEC(J).LT.-2*NZERO.OR.
<      &                 NAMEC(J).EQ.NAME(2*JPAIR)) THEN
<                      if(rank.eq.0)
<      &                    WRITE (71,46)  NCHAOS, NAMEC(J), 
<      &                    NAME(N+JPAIR), NAME(2*JPAIR)
<  46                  FORMAT (' MERGED SPIRAL  NCHAOS NAMEC NAME(ICM)',
<      &                    I4,3I7)
<                      CALL FLUSH(71)
<                      GO TO 70
---
>           ICIRC = 0
>           CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC) 
>           IF (TC.GT.1.0D+04) THEN
>               KSTAR(I) = 0
>               IREM = IC
>               WRITE (6,29)  NAME(I1), LIST(1,I1), ECC, TC
>    29         FORMAT (' FROZEN CIRC    NM NP E TC ',I7,I4,F9.5,1P,E9.1)
>               GO TO 30
>           END IF
>       END IF
> *
> *       Check for terminated or escaped chaotic binaries at end of spiral.
>    30 IF (KSTAR(I).EQ.10.OR.IREM.GT.0) THEN
>           IF (IREM.GT.0) GO TO 50
>           J = 1
> *       See whether case #J indicates current or escaped/disrupted KS binary.
>    40     DO 45 JPAIR = 1,NPAIRS
>               IF (NAMEC(J).EQ.NAME(N+JPAIR)) THEN
> *       Update #J if KSTAR > 0, otherwise consider next member.
>                   IF (KSTAR(N+JPAIR).GT.0) THEN
>                       GO TO 50
>                   ELSE
>                       GO TO 70
712,755c664,729
<                END IF 
<  48         CONTINUE
<          END IF
< *     
< *     Update chaos variables for #IC and any disrupted or escaped binaries.
<  50      NCHAOS = NCHAOS - 1
< *     Copy chaos index in case of KS termination.
<          IF (IREM.GT.0) THEN
<             J = IREM
<          END IF
< *     
<          DO 60 L = J,NCHAOS
<             L1 = L + 1
<             DO 55 K = 1,4
<                EOSC(K,L) = EOSC(K,L1)
<  55         CONTINUE
<             EB0(L) = EB0(L1)
<             ZJ0(L) = ZJ0(L1)
<             ECRIT(L) = ECRIT(L1)
<             AR(L) = AR(L1)
<             BR(L) = BR(L1)
<             EDEC(L) = EDEC(L1)
<             TOSC(L) = TOSC(L1)
<             RP(L) = RP(L1)
<             ES(L) = ES(L1)
<             CM(1,L) = CM(1,L1)
<             CM(2,L) = CM(2,L1)
<             IOSC(L) = IOSC(L1)
<             NAMEC(L) = NAMEC(L1)
<  60      CONTINUE
< *     Ensure next chaos location contains zero core masses.
<          CM(1,NCHAOS+1) = 0.0
<          CM(2,NCHAOS+1) = 0.0
< *     Consider the same location again after each removal (J <= NCHAOS).
<          J = J - 1
<  70      J = J + 1
<          IF (J.LE.NCHAOS.AND.IREM.EQ.0) GO TO 40
<       END IF
< *     
< *     Check optional diagnostics on transition to ECC = 0 or SLEEP.
<       IF (KZ(9).GE.2.AND.KSTAR(I).NE.-2) THEN
< *     Note case IPAIR < 0 from CHRECT with I denoting c.m.
<          IF (IPAIR.LT.0) IPAIR = I - N
<          CALL BINEV(IPAIR)
---
>               END IF
>    45     CONTINUE
> *
> *       Skip during multiple regularizations (KSTAR not visible).
>           IF (NSUB.GT.0) THEN
>               GO TO 70
>           END IF
> *
> *       Skip removal if chaos binary is member of single/double merger.
>           IF (NMERGE.GT.0) THEN
>               DO 48 JPAIR = 1,NPAIRS
>                  IF (NAME(N+JPAIR).LT.0) THEN
>                      IF (NAMEC(J).EQ.NZERO + NAME(2*JPAIR-1).OR.
>      &                   NAMEC(J).EQ.NZERO + NAME(2*JPAIR).OR.
>      &                   NAMEC(J).LT.-2*NZERO.OR.
>      &                   NAMEC(J).EQ.NAME(2*JPAIR)) THEN
>                          WRITE (71,46)  NCHAOS, NAMEC(J), NAME(N+JPAIR),
>      &                                  NAME(2*JPAIR)
>    46                    FORMAT (' MERGED SPIRAL    NCH NAM ',I4,3I7)
>                          CALL FLUSH(71)
>                          GO TO 70
>                      END IF
>                  END IF 
>    48         CONTINUE
>           END IF
> *
> *       Update chaos variables for #IC and any disrupted or escaped binaries.
>    50     NCHAOS = NCHAOS - 1
> *       Copy chaos index in case of KS termination.
>           IF (IREM.GT.0) THEN
>               J = IREM
>           END IF
> *
>           DO 60 L = J,NCHAOS
>               L1 = L + 1
>               DO 55 K = 1,4
>                   EOSC(K,L) = EOSC(K,L1)
>    55         CONTINUE
>               EB0(L) = EB0(L1)
>               ZJ0(L) = ZJ0(L1)
>               ECRIT(L) = ECRIT(L1)
>               AR(L) = AR(L1)
>               BR(L) = BR(L1)
>               EDEC(L) = EDEC(L1)
>               TOSC(L) = TOSC(L1)
>               RP(L) = RP(L1)
>               ES(L) = ES(L1)
>               CM(1,L) = CM(1,L1)
>               CM(2,L) = CM(2,L1)
>               IOSC(L) = IOSC(L1)
>               NAMEC(L) = NAMEC(L1)
>    60     CONTINUE
> *       Ensure next chaos location contains zero core masses.
>           CM(1,NCHAOS+1) = 0.0
>           CM(2,NCHAOS+1) = 0.0
> *       Consider the same location again after each removal (J <= NCHAOS).
>           J = J - 1
>    70     J = J + 1
>           IF (J.LE.NCHAOS.AND.IREM.EQ.0) GO TO 40
>       END IF
> *
> *       Check optional diagnostics on transition to ECC = 0 or SLEEP.
>       IF (KZ(8).GT.3.AND.KSTAR(I).NE.-2) THEN
> *       Note case IPAIR < 0 from CHRECT with I denoting c.m.
>           IF (IPAIR.LT.0) IPAIR = I - N
>           CALL BINEV(IPAIR)
757c731
< *     
---
> *
759,760c733,734
<  100  RETURN
< *     
---
>   100 RETURN
> *
1c1
<       real*8 function stability(mm1,mm2,mm3,ein,eout,inc)
---
> 	real*8 function stability(mm1,mm2,mm3,ein,eout,inc)
4,7c4,7
< *       
<       implicit real*8 (a-h,m,o-z)
<       REAL*8 inc
< 
---
> *
>         implicit real*8 (a-h,m,o-z)
>         REAL*8 inc
> 	
11c11
<          XFAC = (1.0 + Q)*(1.0 + EOUT)/SQRT(1.0 - EOUT)
---
>           XFAC = (1.0 + Q)*(1.0 + EOUT)/SQRT(1.0 - EOUT)
13c13
<          XFAC = 40.0*(1.0 + Q)
---
>           XFAC = 40.0*(1.0 + Q)
16c16
< *       
---
> *
20,23c20,23
< *       
<       stability=PCRIT
<       
<       end
---
> *
>         stability=PCRIT
> 
> 	end
36a37,41
> *       Revised 21st January 2011 by A. D. Railton
> *       to include the pre-mainsequence evolution for 0.1-8 solar masses 
> *       with solar metallicity. New timescale (15) added.
> *       KW=-1 for preMS evolution.
> *
42c47
< *             13; TP              14; t(Mcmax)     
---
> *             13; TP              14; t(Mcmax)     15; PreMS  
56c61
< c      if(mass0.gt.100.d0) mass = 100.d0
---
> *     if(mass0.gt.100.d0) mass = 100.d0
60a66,74
> * Mass should be in the range [0.1,8] (Extrapolate at your own risk!)
> * PreMS timescale
> *
>       if(mass.gt.0.01.and.mass.lt.8.0)then 
>          tscls(15)=43.628d0-(35.835d0*mass**1.5029d-2)*
>      &                             exp(mass*3.9608d-3)
>          tscls(15)=10.d0**tscls(15)/1.0D+06
>       endif
> *
206c220,223
<       mcmax = MAX(MAX(mch,0.773d0*mcbagb - 0.35d0),1.05d0*mc2)
---
>       mcmax = MAX(MAX(mch,0.773d0*mcbagb - 0.35d0),1.02d0*mc2)
>       if(mcbagb.ge.1.6d0.and.mcbagb.le.2.25d0)then
>          mcmax = MAX(MAX(1.372d0,0.773d0*mcbagb - 0.35d0),1.02d0*mc2)
>       endif
230,233c247,250
<       if(mass.ge.100.d0)then
<          tn = tscls(2)
<          goto 100
<       endif
---
> *     if(mass.ge.100.d0)then
> *        tn = tscls(2)
> *        goto 100
> *     endif
354a372
>       tscls(1) = tm
2,9c2,9
< *     
< *     
< *     Spin synchronization of circularized orbit.
< *     -------------------------------------------
< *     
< *     Rational function approximations of solution to the Hut
< *     evolution equation with spin. Ref: A & A 99, 126, eqn (A15).
< *     
---
> *
> *
> *       Spin synchronization of circularized orbit.
> *       -------------------------------------------
> *
> *       Rational function approximations of solution to the Hut
> *       evolution equation with spin. Ref: A & A 99, 126, eqn (A15).
> *
12,14c12,14
<      &     BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
<      &     RP(NTMAX),ES(NTMAX),CM(2,NTMAX),IOSC(NTMAX),
<      &     NAMEC(NTMAX)
---
>      &               BR(NTMAX),EOSC(4,NTMAX),EDEC(NTMAX),TOSC(NTMAX),
>      &               RP(NTMAX),ES(NTMAX),CM(2,NTMAX),IOSC(NTMAX),
>      &               NAMEC(NTMAX)
18c18
<      &     QSCALE(2),A(2),B(2),C(6)
---
>      &        QSCALE(2),A(2),B(2),C(6)
27c27
<      &     -2.314374,-4.127795/
---
>      &                            -2.314374,-4.127795/
31,33c31,33
< *     
< *     
< *     Define c.m. & KS indices and search current names for chaos index.
---
> *
> *
> *       Define c.m. & KS indices and search current names for chaos index.
39c39
<          IF (NAMEC(K).EQ.NAME(I)) IC = K
---
>           IF (NAMEC(K).EQ.NAME(I)) IC = K
41,42c41,42
< *     
< *     Count new cases ignoring rare multiple simultaneous events.
---
> *
> *       Count new cases ignoring rare multiple simultaneous events.
44,45c44,45
<          INAME = NAME(I)
<          NSYNC = NSYNC + 1
---
>           INAME = NAME(I)
>           NSYNC = NSYNC + 1
47,48c47,48
< *     
< *     Exit if binary is not identified but include updating of small ECC.
---
> *
> *       Exit if binary is not identified but include updating of small ECC.
50,98c50,95
<          JPAIR = -IPAIR
<          CALL TRFLOW(JPAIR,DTR)
<          M1 = BODY(I1)*SMU
<          CALL TRDOT(I1,DTM,M1)
<          M1 = BODY(I2)*SMU
<          CALL TRDOT(I2,DTM2,M1)
<          DTM = MIN(DTM,DTM2)
<          DTM = MAX(DTM,0.1D0)
<          TEV(I) = TIME + 0.1*MIN(DTM,DTR)
<          A0 = -0.5*BODY(I)/H(IPAIR)
<          ECC2 = (1.0 - R(IPAIR)/A0)**2 + TDOT2(IPAIR)**2/(A0*BODY(I))
<          ECC = SQRT(ECC2)
<          ITIME = ITIME + 1
<          IF (ITIME.GT.10) THEN
<             if(rank.eq.0)
<      &           WRITE (6,3) NAME(I1), KSTAR(I), NCHAOS,
<      &           ECC, A0, DTM, DTR       
<  3          FORMAT (' MISSING!   SYNCH    NM K* NCH ECC A DTM DTR ',
<      &           I6,2I4,F8.4,1P,3E10.2)
<          END IF
< *     
< *     Check enforcement of circularization for small TCIRC.
<          IF (ECC.LT.0.10.AND.LIST(1,I1).EQ.0) THEN
<             ICIRC = -1
<             QPERI = A0*(1.0 - ECC)
<             CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
<             IF (TC.LT.100.0) THEN
<                CALL DEFORM(IPAIR,ECC,ECCM)
<                ECC = ECCM
<             END IF
<          END IF
< *     
< *     Initialize chaos elements after possible common envelope or E < 0.1.
<          IF (ECC.LE.0.003.OR.IC.EQ.0) THEN
<             NCHAOS = NCHAOS + 1
<             IC = NCHAOS
<             NAMEC(IC) = NAME(I)
<             RP(IC) = A0*(1.0 - ECC)
<             ES(IC) = ECC
<             TOSC(IC) = TIME
<             IF (NCHAOS.GT.NTMAX) THEN
<                if(rank.eq.0)
<      &              WRITE (6,4)  NAME(I1), NCHAOS, ECC, A0*(1.0 - ECC)
<  4             FORMAT (' FATAL ERROR!    SYNCH    NM NCH E QP ',
<      &              I6,I4,F8.4,1P,E9.1)
<                STOP
<             END IF
<          END IF
<          GO TO 100
---
>           JPAIR = -IPAIR
>           CALL TRFLOW(JPAIR,DTR)
>           M1 = BODY(I1)*SMU
>           CALL TRDOT(I1,DTM,M1)
>           M1 = BODY(I2)*SMU
>           CALL TRDOT(I2,DTM2,M1)
>           DTM = MIN(DTM,DTM2)
>           DTM = MAX(DTM,0.1D0)
>           TEV(I) = TIME + 0.1*MIN(DTM,DTR)
>           A0 = -0.5*BODY(I)/H(IPAIR)
>           ECC2 = (1.0 - R(IPAIR)/A0)**2 + TDOT2(IPAIR)**2/(A0*BODY(I))
>           ECC = SQRT(ECC2)
>           ITIME = ITIME + 1
>           IF (ITIME.GT.10) THEN
>           WRITE (6,3) NAME(I1), KSTAR(I), NCHAOS, ECC, A0, DTM, DTR
>     3     FORMAT (' MISSING!   SYNCH    NM K* NCH ECC A DTM DTR ',
>      &                                  I6,2I4,F8.4,1P,3E10.2)
>           END IF
> *
> *       Check enforcement of circularization for small TCIRC.
>           IF (ECC.LT.0.10.AND.LIST(1,I1).EQ.0) THEN
>               ICIRC = -1
>               QPERI = A0*(1.0 - ECC)
>               CALL TCIRC(QPERI,ECC,I1,I2,ICIRC,TC)
>               IF (TC.LT.100.0) THEN
>                   CALL DEFORM(IPAIR,ECC,ECCM)
>                   ECC = ECCM
>               END IF
>           END IF
> *
> *       Initialize chaos elements after possible common envelope or E < 0.1.
>           IF (ECC.LE.0.003.OR.IC.EQ.0) THEN
>               NCHAOS = NCHAOS + 1
>               IC = NCHAOS
>               NAMEC(IC) = NAME(I)
>               RP(IC) = A0*(1.0 - ECC)
>               ES(IC) = ECC
>               TOSC(IC) = TIME
>               IF (NCHAOS.GT.NTMAX) THEN
>                   WRITE (6,4)  NAME(I1), NCHAOS, ECC, A0*(1.0 - ECC)
>     4             FORMAT (' FATAL ERROR!    SYNCH    NM NCH E QP ',
>      &                                               I6,I4,F8.4,1P,E9.1)
>                   STOP
>               END IF
>           END IF
>           GO TO 100
100,101c97,98
< *     
< *     Check Roche overflow time during small intervals.
---
> *
> *       Check Roche overflow time during small intervals.
103,107c100,104
<          JPAIR = -IPAIR
<          CALL TRFLOW(JPAIR,DTR)
<          IF (DTR.LT.STEP(I)) THEN
<             TEV(I) = TIME + DTR
<          END IF
---
>           JPAIR = -IPAIR
>           CALL TRFLOW(JPAIR,DTR)
>           IF (DTR.LT.STEP(I)) THEN
>               TEV(I) = TIME + DTR
>           END IF
109,110c106,107
< *     
< *     Copy spiral parameters and set semi-major axis & eccentricity.
---
> *
> *       Copy spiral parameters and set semi-major axis & eccentricity.
119,120c116,117
< *     
< *     Rectify elements after possible common envelope, Roche or GR process.
---
> *
> *       Rectify elements after possible common envelope, Roche or GR process.
123,134c120,130
<          DT = TIME - TOSC(IC)
<          IF (ITIME.LT.50) THEN
<             if(rank.eq.0)
<      &           WRITE (6,5)  NAME(I1), KSTAR(I1),KSTAR(I2),
<      &           KSTAR(I), ES0, ECC, RP0, QPERI, DT
<  5          FORMAT (' RP RECTIFY SYNCH    NM K* ES0 E RP0 QP DT  ',
<      &           I6,3I4,2F8.4,1P,3E10.2)
<          END IF
< *     Note: new RP(IC) needed for scaling RADIUS (original bug Oct 2008).
<          RP(IC) = QPERI
<          RP0 = QPERI
<          ES0 = ECC
---
>           DT = TIME - TOSC(IC)
>           IF (ITIME.LT.50) THEN
>               WRITE (6,5)  NAME(I1), KSTAR(I1),KSTAR(I2),KSTAR(I), ES0,
>      &                     ECC, RP0, QPERI, DT
>     5         FORMAT (' RP RECTIFY SYNCH    NM K* ES0 E RP0 QP DT  ',
>      &                                      I6,3I4,2F8.4,1P,3E10.2)
>           END IF
> *       Note: new RP(IC) needed for scaling RADIUS (original bug Oct 2008).
>           RP(IC) = QPERI
>           RP0 = QPERI
>           ES0 = ECC
136,137c132,133
< *     
< *     Set standard binary or current elements on significant departure.
---
> *
> *       Set standard binary or current elements on significant departure.
139,152c135,147
<          ECC = SQRT(ECC2)
<          IF (ECC.GT.0.01) THEN
<             KSTAR(I) = 0
<             if(rank.eq.0)
<      &           WRITE (6,8)  NAME(I1), LIST(1,I1), ES0, ECC, A0*SU
<  8          FORMAT (' NON-CIRCULAR    SYNCH    NM NP ES0 ECC A ',
<      &           I6,I4,2F8.4,1P,E10.2)
<             NAMI = -I
<             CALL SPIRAL(NAMI)
<             GO TO 100
<          ELSE
<             ES0 = ECC
<             RP0 = A0*(1.0 - ECC)
<          END IF
---
>           ECC = SQRT(ECC2)
>           IF (ECC.GT.0.01) THEN
>               KSTAR(I) = 0
>               WRITE (6,8)  NAME(I1), LIST(1,I1), ES0, ECC, A0*SU
>     8         FORMAT (' NON-CIRCULAR    SYNCH    NM NP ES0 ECC A ',
>      &                                           I6,I4,2F8.4,1P,E10.2)
>               NAMI = -I
>               CALL SPIRAL(NAMI)
>               GO TO 100
>           ELSE
>               ES0 = ECC
>               RP0 = A0*(1.0 - ECC)
>           END IF
154,155c149,150
< *     
< *     Specify index J1 as biggest radius to be used with AT0(1).
---
> *
> *       Specify index J1 as biggest radius to be used with AT0(1).
157,158c152,153
<          J1 = I1
<          J2 = I2
---
>           J1 = I1
>           J2 = I2
160,161c155,156
<          J1 = I2
<          J2 = I1
---
>           J1 = I2
>           J2 = I1
163,164c158,159
< *     
< *     Obtain stellar parameters for evolving stars at current epoch.
---
> *
> *       Obtain stellar parameters for evolving stars at current epoch.
166,175c161,170
<          KW = KSTAR(J1)
<          M1 = BODY(J1)*SMU
<          M0 = BODY0(J1)*ZMBAR
<          MC = 0.D0
<          AGE = TIME*TSTAR - EPOCH(J1)
<          CALL star(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
<          CALL hrdiag(M0,AGE,M1,TM,TN,TSCLS,LUMS,GB,ZPARS,
<      &        RM,LUM,KW,MC,RCC,MENV,RENV,K2)
<          CM(1,IC) = MC/SMU
<          KW1 = KW
---
>           KW = KSTAR(J1)
>           M1 = BODY(J1)*SMU
>           M0 = BODY0(J1)*ZMBAR
>           MC = 0.D0
>           AGE = TIME*TSTAR - EPOCH(J1)
>           CALL star(KW,M0,M1,TM,TN,TSCLS,LUMS,GB,ZPARS)
>           CALL hrdiag(M0,AGE,M1,TM,TN,TSCLS,LUMS,GB,ZPARS,
>      &                RM,LUM,KW,MC,RCC,MENV,RENV,K2)
>           CM(1,IC) = MC/SMU
>           KW1 = KW
177c172
<          KW1 = KSTAR(J1)
---
>           KW1 = KSTAR(J1)
179,181c174,176
< *     
< *     Define oscillation period (dimensionless time) and damping constants.
<       ZN = 0.0
---
> *
> *       Define oscillation period (dimensionless time) and damping constants.
>       XN = 0.0
184,191c179,186
<          IK = I1 + K - 1
<          IF (K.EQ.1) THEN
<             IK = J1
<          ELSE
<             IK = J2
<          END IF
< *     Specify polytropic index for each star (n = 3, 2 or 3/2).
<          IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
---
>           IK = I1 + K - 1
>           IF (K.EQ.1) THEN
>               IK = J1
>           ELSE
>               IK = J2
>           END IF
> *       Specify polytropic index for each star (n = 3, 2 or 3/2).
>           IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
193,225c188,216
<             CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,ZN,QL)
<             W(K) = WG(1)
<             Q(K) = QG(1)
< *     --09/20/13 19:55-lwang-bug-fix------------------------------------*
< ***** Note: K2 is not defined for J1.----------------------------------**
<             rg2(k)= 0.1*(1.0 - CM(K,IC)/BODY(IK))
< *            rg2(k) = K2*(1.0 - CM(K,IC)/BODY(IK))
< *     --09/20/13 19:55-lwang-end----------------------------------------*
<             QD = QL
<          ELSE
<             QL = 1.0E+04
<             IP = 3
<             IF (KSTAR(IK).GE.3) IP = 2
<             IF (KSTAR(IK).EQ.4.OR.KSTAR(IK).EQ.7) IP = 3
<             IF (KSTAR(IK).EQ.8) IP = 3
<             IF (KSTAR(IK).EQ.0) IP = 1
<             W(K) = WW(IP)
<             Q(K) = QQ(IP)
<             IF (KSTAR(IK).LE.2.OR.KSTAR(IK).EQ.7) THEN
<                rg2(k) = 0.1
<             ELSE IF (KSTAR(IK).EQ.4) THEN
<                CM(K,IC) = MIN(0.89D0*BODY(IK),CM(K,IC))
<                rg2(k)= 0.1*(1.0 - CM(K,IC)/BODY(IK))
<             ELSE
<                rg2(k)= 0.21
<             END IF
<          END IF
<          TL = TWOPI*RADIUS(IK)*SQRT(RADIUS(IK)/BODY(IK)/W(K))
<          IF (KSTAR(IK).GE.11) QL = 1.0D+10
<          AT0(K) = 1.0/(QL*TL)
<  10   CONTINUE
< *     
< *     Form mass, radius & pericentre ratio.
---
>               CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,XN,QL)
>               W(K) = WG(1)
>               Q(K) = QG(1)
>               rg2(k)= 0.1*(1.0 - CM(K,IC)/BODY(IK))
>               QD = QL
>           ELSE
>               QL = 1.0E+04
>               IP = 3
>               IF (KSTAR(IK).GE.3) IP = 2
>               IF (KSTAR(IK).EQ.4.OR.KSTAR(IK).EQ.7) IP = 3
>               IF (KSTAR(IK).EQ.8) IP = 3
>               IF (KSTAR(IK).EQ.0) IP = 1
>               W(K) = WW(IP)
>               Q(K) = QQ(IP)
>               IF (KSTAR(IK).LE.2.OR.KSTAR(IK).EQ.7) THEN
>                   rg2(k) = 0.1
> 	      ELSE IF (KSTAR(IK).EQ.4) THEN
>                   CM(K,IC) = MIN(0.89D0*BODY(IK),CM(K,IC))
>                   rg2(k)= 0.1*(1.0 - CM(K,IC)/BODY(IK))
>               ELSE
> 	          rg2(k)= 0.21
>               END IF
>           END IF
>           TL = TWOPI*RADIUS(IK)*SQRT(RADIUS(IK)/BODY(IK)/W(K))
>           IF (KSTAR(IK).GE.11) QL = 1.0D+10
>           AT0(K) = 1.0/(QL*TL)
>    10 CONTINUE
> *
> *       Form mass, radius & pericentre ratio.
227,230c218,221
<          M21 = BODY(I2)/BODY(I1)
<          R21 = RADIUS(I2)/RADIUS(I1)
<          RP1 = RP(IC)/RADIUS(I1)
<          rad = radius(i1)
---
>           M21 = BODY(I2)/BODY(I1)
>           R21 = RADIUS(I2)/RADIUS(I1)
>           RP1 = RP(IC)/RADIUS(I1)
>           rad = radius(i1)
232,235c223,226
<          M21 = BODY(I1)/BODY(I2)
<          R21 = RADIUS(I1)/RADIUS(I2)
<          RP1 = RP(IC)/RADIUS(I2)
<          rad = radius(i2)
---
> 	  M21 = BODY(I1)/BODY(I2)
>           R21 = RADIUS(I1)/RADIUS(I2)
> 	  RP1 = RP(IC)/RADIUS(I2)
> 	  rad = radius(i2)
237,238c228,229
< *     
< *     Define initial angular momentum from the scaled semi-major axis.
---
> *
> *       Define initial angular momentum from the scaled semi-major axis.
240,241c231,232
< *     
< *     Form the initial mean motion in N-body units.
---
> *
> *       Form the initial mean motion in N-body units.
243,244c234,235
< *     
< *     Convert from angular momentum to omega (denoted spin1 & spin2).
---
> *
> *       Convert from angular momentum to omega (denoted spin1 & spin2).
246c237
<          SPIN1 = SPIN(J1)/(rg2(1)*BODY(J1)*RADIUS(J1)**2)
---
>           SPIN1 = SPIN(J1)/(rg2(1)*BODY(J1)*RADIUS(J1)**2)
248,259c239,250
<          KW = KSTAR(J1)
<          M0 = BODY0(J1)*SMU
<          MC1 = CM(1,IC)*SMU
<          IF (MC1.LE.0.0D0.OR.MC1.GT.M0) THEN
<             MC1 = 0.3 + 0.1*(KSTAR(J1) - 3)
<             IF(KW.EQ.9) MC1 = MIN(0.3D0,0.95*M0)
<             CM(1,IC) = MC1/ZMBAR
<          END IF
<          ZDUM = 2.0D0
<          RC1 = CORERD(KW,MC1,M0,ZDUM)/SU
<          SPIN1 = SPIN(J1)/(rg2(1)*BODY(J1)*RADIUS(J1)**2 +
<      &        0.21*MC1/SMU*RC1**2)
---
>           KW = KSTAR(J1)
>           M0 = BODY0(J1)*SMU
>           MC1 = CM(1,IC)*SMU
>           IF (MC1.LE.0.0D0.OR.MC1.GT.M0) THEN
>               MC1 = 0.3 + 0.1*(KSTAR(J1) - 3)
>               IF(KW.EQ.9) MC1 = MIN(0.3D0,0.95*M0)
>               CM(1,IC) = MC1/ZMBAR
>           END IF
>           ZDUM = 2.0D0
>           RC1 = CORERD(KW,MC1,M0,ZDUM)/SU
>           SPIN1 = SPIN(J1)/(rg2(1)*BODY(J1)*RADIUS(J1)**2 +
>      &                      0.21*MC1/SMU*RC1**2)
262c253
<          spin2 = SPIN(J2)/(rg2(2)*BODY(J2)*RADIUS(J2)**2)
---
>           spin2 = SPIN(J2)/(rg2(2)*BODY(J2)*RADIUS(J2)**2)
264,279c255,266
<          KW = KSTAR(J2)
<          M0 = BODY0(J2)*SMU
<          MC2 = CM(2,IC)*SMU
<          IF (MC2.LE.0.0D0.OR.MC2.GT.M0) THEN
< *     --09/20/13 19:53-lwang-bug-fix------------------------------------*
< ***** Note: May cause NAN in rochea.f when MC2=0.0---------------------**
< *            MC2 = 0.3 + 0.1*(KSTAR(J1) - 3)
<             MC2 = 0.3 + 0.1*(KSTAR(J2) - 3)            
< *     --09/20/13 19:54-lwang-end----------------------------------------*
<             IF(KW.EQ.9) MC2 = MIN(0.3D0,0.95*M0)
<             CM(2,IC) = MC2/ZMBAR
<          END IF
<          ZDUM = 2.0D0
<          RCC2 = CORERD(KW,MC2,M0,ZDUM)/SU
<          spin2 = SPIN(J2)/(rg2(2)*BODY(J2)*RADIUS(J2)**2 +
<      &        0.21*MC2/SMU*RCC2**2)
---
>           KW = KSTAR(J2)
>           M0 = BODY0(J2)*SMU
>           MC2 = CM(2,IC)*SMU
>           IF (MC2.LE.0.0D0.OR.MC2.GT.M0) THEN
>               MC2 = 0.3 + 0.1*(KSTAR(J2) - 3)
>               IF(KW.EQ.9) MC2 = MIN(0.3D0,0.95*M0)
>               CM(2,IC) = MC2/ZMBAR
>           END IF
>           ZDUM = 2.0D0
>           RC2 = CORERD(KW,MC2,M0,ZDUM)/SU
>           spin2 = SPIN(J2)/(rg2(2)*BODY(J2)*RADIUS(J2)**2 +
>      &                      0.21*MC2/SMU*RC2**2)
281,282c268,269
< *     
< *     Set synchronous spin for degenerate stars.
---
> *
> *       Set synchronous spin for degenerate stars.
289,290c276,277
< *     
< *     Skip integration if both spins are synchronous.
---
> *
> *       Skip integration if both spins are synchronous.
292,301c279,287
<          KX = MAX(KSTAR(J1),KSTAR(J2))
<          IF (ABS(DS20).GT.0.01.AND.KX.LT.10) THEN
<             if(rank.eq.0)
<      &           WRITE (6,20)  NAME(I1), KSTAR(I1), KSTAR(I2), 
<      &           A0*SU, DS1, DS20, OMEQ
<  20         FORMAT (' ENFORCED SYNCH    NM K* A DS1 DS2 omeq ',
<      &           I6,2I4,F9.3,1P,3E10.2)
<          END IF
<          ISYNCH = 1
<          GO TO 50
---
>           KX = MAX(KSTAR(J1),KSTAR(J2))
>           IF (ABS(DS20).GT.0.01.AND.KX.LT.10) THEN
>               WRITE (6,20)  NAME(I1), KSTAR(I1), KSTAR(I2), A0*SU, DS1,
>      &                      DS20, OMEQ
>    20         FORMAT (' ENFORCED SYNCH    NM K* A DS1 DS2 omeq ',
>      &                                    I6,2I4,F9.3,1P,3E10.2)
>           END IF
>           ISYNCH = 1
>           GO TO 50
303c289
< *     
---
> *
305c291
< *     Scale the spins by mean motion and define angular momentum.
---
> *       Scale the spins by mean motion and define angular momentum.
309,325c295,309
<      &     m21*r21**2*rg2(2)*spin20
< *     
< C      IF (ICOUNT.LE.-1000) THEN
< C         ICOUNT = ICOUNT + 1
< C         SUM1=(m21/(1+m21))*semi0**2*sqrt(1-es0**2)
< C         SUM2 = rg2(1)*spin10
< C         SUM3 =       m21*r21**2*rg2(2)*spin20
< C         SUM4 = SUM1 + SUM2 + SUM3
< C         ZM = BODY(J1)*SMU
< C         if(rank.eq.0)
< C     &        WRITE (92,21)KSTAR(J1),KSTAR(J2),ZM,a0,SUM1,
< C     &        SUM2,SUM3,SUM4,DS
< C 21      FORMAT ('K*(I1) K*(I2) M1 A S1 S2 S3 S4 DS ',
< C     &        2I4,F8.4,1P,E12.4,4E10.2,0P,F6.1)
< C         CALL FLUSH(92)
< C      END IF
< *     Evaluate damping coefficients (Mardling & SJA, M.N. 321, 398, 2001).
---
>      &         m21*r21**2*rg2(2)*spin20
> *
>       IF (ICOUNT.LE.-1000) THEN
>       ICOUNT = ICOUNT + 1
>       SUM1=(m21/(1+m21))*semi0**2*sqrt(1-es0**2)
>       SUM2 = rg2(1)*spin10
>       SUM3 =       m21*r21**2*rg2(2)*spin20
>       SUM4 = SUM1 + SUM2 + SUM3
>       ZM = BODY(J1)*SMU
>       WRITE (92,21)KSTAR(J1),KSTAR(J2),ZM,a0,SUM1,SUM2,SUM3,SUM4,DS
>    21 FORMAT (' K*  M1 A S1 S2 S3 S4 DS ',2I4,F8.4,1P,E12.4,4E10.2,
>      &                                 0P,F6.1)
>       CALL FLUSH(92)
>       END IF
> *	Evaluate damping coefficients (Mardling & SJA, M.N. 321, 398, 2001).
329,331c313,315
<      &     semi0**6
< *     
< *     Include change in moment of inertia for rapid evolution of primary.
---
>      &      semi0**6
> *
> *       Include change in moment of inertia for rapid evolution of primary.
333,343c317,327
< *     Obtain mass loss due to stellar wind for single star (Msun/yr).
<          RLPERI = 0.D0
<          DMX = MLWIND(KW1,LUM,RM,M1,MC,RLPERI,ZMET)
<          DT = TIME - TEV0(J1)
< *     Include safety check on small time interval (SJA 4/09).
<          IF (DT.LE.1.0D-10) DT = ABS(TEV(J1) - TIME)
<          RDOT = (RM/SU - RADIUS(J1))/DT
< *     Form combined moment of inertia factor for primary (RM 11/08).
<          C5 = -1.0D+06*DMX*TSTAR/M1 + 2.0*RDOT/RADIUS(J1)
<          R1 = RM/(SU*RADIUS(J1))
<          R2 = 1.0
---
> *       Obtain mass loss due to stellar wind for single star (Msun/yr).
>           RLPERI = 0.D0
>           DMX = MLWIND(KW1,LUM,RM,M1,MC,RLPERI,ZMET)
>           DT = TIME - TEV0(J1)
> *       Include safety check on small time interval (SJA 4/09).
>           IF (DT.LE.1.0D-10) DT = ABS(TEV(J1) - TIME)
>           RDOT = (RM/SU - RADIUS(J1))/DT
> *       Form combined moment of inertia factor for primary (RM 11/08).
>           C5 = -1.0D+06*DMX*TSTAR/M1 + 2.0*RDOT/RADIUS(J1)
>           R1 = RM/(SU*RADIUS(J1))
>           R2 = 1.0
345,347c329,331
<          R1 = 1.0
<          R2 = 1.0
<          C5 = 0.0
---
>           R1 = 1.0
>           R2 = 1.0
>           C5 = 0.0
349,350c333,334
< *     
< *     Skip on zero or negative interval.
---
> *
> *       Skip on zero or negative interval.
352,353c336,337
< *     
< *     Obtain dominant terms of the derivatives (cf. routine HUT/DERIV2).
---
> *
> *       Obtain dominant terms of the derivatives (cf. routine HUT/DERIV2).
356,357c340,341
< *     
< *     Choose the step from smallest time-scale (! time0 < time possible).
---
> *
> *       Choose the step from smallest time-scale (! time0 < time possible).
361c345
< *     Increase number of steps on slow primary rotation.
---
> *       Increase number of steps on slow primary rotation.
366,367c350,351
< *     
< *     Reduce integration interval for slow evolution or after merger.
---
> *
> *       Reduce integration interval for slow evolution or after merger.
369,385c353,368
<          JPAIR = -IPAIR
<          CALL TRFLOW(JPAIR,DTR)
<          M1 = BODY(J1)*SMU
<          CALL TRDOT(J1,DTM,M1)
<          DTM = MAX(DTM,0.1D0)
<          DT = 0.1*MIN(DTR,DTM,10.0D0)
<          IF (ABS(DS2).GT.0.05.OR.DS10.LT.-0.99) THEN
<             DT = 0.1*DT
<             nstep = nstep + 50
<          END IF
<          TK = DAYS*A0*SQRT(A0/BODY(I))
<          IF (ICOUNT.LT.50) THEN
<             if(rank.eq.0)
<      &           WRITE (6,30)  NAME(J1), DS1, DS2, DT, TK
<  30         FORMAT (' REDUCE    SYNCH    NM DS1 DS2 DT P ',
<      &           I6,1P,4E10.2)
<          END IF
---
>           JPAIR = -IPAIR
>           CALL TRFLOW(JPAIR,DTR)
>           M1 = BODY(J1)*SMU
>           CALL TRDOT(J1,DTM,M1)
>           DTM = MAX(DTM,0.1D0)
>           DT = 0.1*MIN(DTR,DTM,10.0D0)
>           IF (ABS(DS2).GT.0.05.OR.DS10.LT.-0.99) THEN
>               DT = 0.1*DT
>               nstep = nstep + 50
>           END IF
>           TK = DAYS*A0*SQRT(A0/BODY(I))
>           IF (ICOUNT.LT.50) THEN
>               WRITE (6,30)  NAME(J1), DS1, DS2, DT, TK
>    30         FORMAT (' REDUCE    SYNCH    NM DS1 DS2 DT P ',
>      &                                     I6,1P,4E10.2)
>           END IF
387c370
< *     
---
> *
390,392c373,375
<  40   dtau1 = ABS(DT)/float(nstep)
< *     
< *     Integrate equations for angular velocities only.
---
>    40 dtau1 = ABS(DT)/float(nstep)
> *
> *       Integrate equations for angular velocities only.
394c377
< *     
---
> *
397c380
< *     Re-scale the semi-major axis and angular velocities to N-body units.
---
> *       Re-scale the semi-major axis and angular velocities to N-body units.
406c389
< *     
---
> *
410,417c393,399
<          if(rank.eq.0)
<      &        WRITE (6,42)  ITRY, nstep, DT, spin1, spin2, omeq
<  42      FORMAT (' REPEAT    SYNCH    IT # DT S1 S2 omeq ',
<      &        2I5,1P,4E10.2)
<          ITRY = ITRY + 1
<          nstep = nstep + 50
<          IF (ITRY.LT.2) GO TO 40
< *     STOP
---
>           WRITE (6,42)  ITRY, nstep, DT, spin1, spin2, omeq
>    42     FORMAT (' REPEAT    SYNCH    IT # DT S1 S2 omeq ',
>      &                                 2I5,1P,4E10.2)
>           ITRY = ITRY + 1
>           nstep = nstep + 50
>           IF (ITRY.LT.2) GO TO 40
> *         STOP
420c402
< *     
---
> *
422,430c404,411
<      &     (DS20.LT.0.0.AND.DS2.GT.0.01)) THEN
<          ITER = ITER + 1
<          nstep = nstep + 50
<          IF (ITER.GT.1) DT = 0.5*DT
<          IF (ITER.LT.4) GO TO 40
<          if(rank.eq.0)
<      &        WRITE (6,45)  nstep, DS10, DS1, DS20, DS2, DT
<  45      FORMAT (' LIMIT    SYNCH    # DS10, DS1, DS20, DS2, DT ',
<      &        I4,1P,5E10.2)
---
>      &    (DS20.LT.0.0.AND.DS2.GT.0.01)) THEN
>           ITER = ITER + 1
>           nstep = nstep + 50
>           IF (ITER.GT.1) DT = 0.5*DT
>           IF (ITER.LT.4) GO TO 40
>           WRITE (6,45)  nstep, DS10, DS1, DS20, DS2, DT
>    45     FORMAT (' LIMIT    SYNCH    # DS10, DS1, DS20, DS2, DT ',
>      &                                I4,1P,5E10.2)
432c413
< *     
---
> *
434,440c415,420
<      &     (DS2.GT.0.0.AND.DS20.LT.-0.01)) THEN
<          ITER = ITER + 1
<          nstep = nstep + 50
<          IF (ITER.GT.1) DT = 0.5*DT
<          IF (ITER.LT.4) GO TO 40
<          if(rank.eq.0)
<      &        WRITE (6,45)  nstep, DS10, DS1, DS20, DS2, DT
---
>      &    (DS2.GT.0.0.AND.DS20.LT.-0.01)) THEN
>           ITER = ITER + 1
>           nstep = nstep + 50
>           IF (ITER.GT.1) DT = 0.5*DT
>           IF (ITER.LT.4) GO TO 40
>           WRITE (6,45)  nstep, DS10, DS1, DS20, DS2, DT
443,446c423,426
< *     
< *     Convert back to angular momenta.
<  50   IF (KSTAR(J1).LE.2.OR.(KSTAR(J1).GE.7.AND.KSTAR(J1).NE.9)) THEN
<          SPIN(J1) = rg2(1)*BODY(J1)*RADIUS(J1)**2*spin1
---
> *
> *       Convert back to angular momenta.
>    50 IF (KSTAR(J1).LE.2.OR.(KSTAR(J1).GE.7.AND.KSTAR(J1).NE.9)) THEN
>           SPIN(J1) = rg2(1)*BODY(J1)*RADIUS(J1)**2*spin1
448,449c428,429
<          SPIN(J1) = (rg2(1)*BODY(J1)*RADIUS(J1)**2 +
<      &        0.21*MC1/SMU*RC1**2)*spin1
---
>           SPIN(J1) = (rg2(1)*BODY(J1)*RADIUS(J1)**2 +
>      &                0.21*MC1/SMU*RC1**2)*spin1
452c432
<          SPIN(J2) = rg2(2)*BODY(J2)*RADIUS(J2)**2*spin2
---
>           SPIN(J2) = rg2(2)*BODY(J2)*RADIUS(J2)**2*spin2
454,455c434,435
<          SPIN(J2) = (rg2(2)*BODY(J2)*RADIUS(J2)**2 +
<      &        0.21*MC2/SMU*RCC2**2)*spin2
---
>           SPIN(J2) = (rg2(2)*BODY(J2)*RADIUS(J2)**2 +
>      &                0.21*MC2/SMU*RC2**2)*spin2
458,459c438,439
<          ISYNCH = 0
<          GO TO 70
---
>           ISYNCH = 0
>           GO TO 70
461c441
< *     
---
> *
463c443
< *     Obtain the tidal contributions from integration.
---
> *       Obtain the tidal contributions from integration.
466c446
< *     Prevent new SEMI < R.
---
> *       Prevent new SEMI < R.
468c448
<          DH = -0.5*BODY(I)/R(IPAIR) - H(IPAIR)
---
>           DH = -0.5*BODY(I)/R(IPAIR) - H(IPAIR)
470,471c450,451
< *     
< *     Update energy and semi-major axis.
---
> *
> *       Update energy and semi-major axis.
474,475c454,455
< *     
< *     Set new pericentre from final elements (delay updating).
---
> *
> *       Set new pericentre from final elements (delay updating).
477c457
<          QPERI = semi*(1.0 - ecc)
---
>           QPERI = semi*(1.0 - ecc)
479c459
<          QPERI = RP0*(1.0 + ES0)/(1.0 + ECC)
---
>           QPERI = RP0*(1.0 + ES0)/(1.0 + ECC)
481,482c461,462
< *     
< *     Form KS coordinate scaling factor from pericentre ratio.
---
> *
> *       Form KS coordinate scaling factor from pericentre ratio.
484,485c464,465
< *     
< *     Set KS velocity scaling from energy relation with RP0 instead of R.
---
> *
> *       Set KS velocity scaling from energy relation with RP0 instead of R.
487,488c467,468
< *     
< *     Scale KS variables to yield the prescribed elements (set TDOT2 >= 0).
---
> *
> *       Scale KS variables to yield the prescribed elements (set TDOT2 >= 0).
492,497c472,477
<          U(K,IPAIR) = C1*U(K,IPAIR)
<          UDOT(K,IPAIR) = C2*UDOT(K,IPAIR)
<          U0(K,IPAIR) = U(K,IPAIR)
<          R(IPAIR) = R(IPAIR) + U(K,IPAIR)**2
<          TDOT2(IPAIR) = TDOT2(IPAIR) + 2.0*U(K,IPAIR)*UDOT(K,IPAIR)
<  60   CONTINUE
---
>           U(K,IPAIR) = C1*U(K,IPAIR)
>           UDOT(K,IPAIR) = C2*UDOT(K,IPAIR)
>           U0(K,IPAIR) = U(K,IPAIR)
>           R(IPAIR) = R(IPAIR) + U(K,IPAIR)**2
>           TDOT2(IPAIR) = TDOT2(IPAIR) + 2.0*U(K,IPAIR)*UDOT(K,IPAIR)
>    60 CONTINUE
499,500c479,480
< *     
< *     Perform energy correction to maintain conservation.
---
> *
> *       Perform energy correction to maintain conservation.
504,505c484,485
< *     
< *     Initialize KS for perturbed motion.
---
> *
> *       Initialize KS for perturbed motion.
507,511c487,491
< *     Rectify orbit to prevent eccentricity growth.
<          CALL KSRECT(IPAIR)
<          CALL RESOLV(IPAIR,1)
<          IMOD = KSLOW(IPAIR)
<          CALL KSPOLY(IPAIR,IMOD)
---
> *       Rectify orbit to prevent eccentricity growth.
>           CALL KSRECT(IPAIR)
>           CALL RESOLV(IPAIR,1)
>           IMOD = KSLOW(IPAIR)
>           CALL KSPOLY(IPAIR,IMOD)
513c493
< *     
---
> *
518,523c498,502
<       if(rank.eq.0)
<      &     WRITE (6,65) nstep,time-time0,udot1,udot2,DS1,DS2,DA,TS1
<  65   FORMAT (' HUT2    # t-t0 ud DS DA/A TM ',
<      &     I5,F9.3,1P,5E9.1,0P,F10.2)
< *     
< *     Include magnetic or gravitational braking for small separations.
---
>       WRITE (7,65) nstep,time-time0,udot1,udot2,DS1,DS2,DA,TS1
>    65 FORMAT (' HUT2    # t-t0 ud DS DA/A TM ',
>      &                  I5,F9.3,1P,5E9.1,0P,F10.2)
> *
> *       Include magnetic or gravitational braking for small separations.
525,527c504,506
< *     DT = TIME - TIME0
< *     CALL BRAKE(IPAIR,DT)
< *     IF (IPHASE.LT.0) GO TO 100
---
> *         DT = TIME - TIME0
> *         CALL BRAKE(IPAIR,DT)
> *         IF (IPHASE.LT.0) GO TO 100
529,531c508,510
< *     
< *     Update look-up time from radial expansion or Roche interval.
<  70   JPAIR = -IPAIR
---
> *
> *       Update look-up time from radial expansion or Roche interval.
>    70 JPAIR = -IPAIR
539c518
< *     
---
> *
543c522
< *     Correct for small eccentricity drift.
---
> *       Correct for small eccentricity drift.
545,547c524,526
<          CALL DEFORM(IPAIR,ECC,ES0)
<          ECC = ES0
<          QPERI = SEMI*(1.0 - ES0)
---
>           CALL DEFORM(IPAIR,ECC,ES0)
>           ECC = ES0
>           QPERI = SEMI*(1.0 - ES0)
549c528
< *     Save final reference values.
---
> *       Save final reference values.
553c532
< *     
---
> *
555,560c534,537
<          if(rank.eq.0)
<      &        WRITE (6,80)  NAME(I1), ECC, nstep, dtau1, 
<      &        ERR, C1-1.0, C2-1.0
<  80      FORMAT (' DANGER!    NAM E # dtau DA/A DC1 DC2 ',
<      &        I6,F8.4,I5,1P,5E10.2)
<          STOP
---
>           WRITE (6,80)  NAME(I1), ECC, nstep, dtau1, ERR, C1-1.0, C2-1.0
>    80     FORMAT (' DANGER!    NAM E # dtau DA/A DC1 DC2 ',
>      &                         I6,F8.4,I5,1P,5E10.2)
>           STOP
562c539
< *     
---
> *
564,571c541,547
<          ICOUNT = ICOUNT + 1
<          DT = TEV(I) - TIME
<          if(rank.eq.0)
<      &        WRITE (6,85)  NAME(J1), KSTAR(J1), KSTAR(J2),
<      &        SEMI*SU, DA, omeq, spin1, spin2, DT
<  85      FORMAT (' SYNCH    NM K* A DA/A om s1 s2 DT ',
<      &        I8,2I4,F8.2,1P,5E10.2)
<          CALL FLUSH(7)
---
>           ICOUNT = ICOUNT + 1
>           DT = TEV(I) - TIME
>           WRITE (7,85)  NAME(J1), KSTAR(J1), KSTAR(J2),
>      &                  SEMI*SU, DA, omeq, spin1, spin2, DT
>    85     FORMAT (' SYNCH    NM K* A DA/A om s1 s2 DT ',
>      &                       I8,2I4,F8.2,1P,5E10.2)
>           CALL FLUSH(7)
573c549
< *     
---
> *
575,587c551,562
<          if(rank.eq.0)
<      &        WRITE (6,90)  NAME(J1), KSTAR(J1), spin1, TIME-TIME0
<  90      FORMAT (' DANGER!    NEGATIVE SPIN    NM K* s1 T-T0 ',
<      &        I6,I4,1P,2E10.2)
<          IF (SPIN1.LT.0.0) SPIN1 = 0.1*omeq
<          IF (SPIN2.LT.0.0) SPIN2 = 0.1*omeq
<          ITRY = ITRY + 1
<          IF (ITRY.LE.2) GO TO 50
< *     STOP
<       END IF
< *     
<  100  RETURN
< *     
---
>           WRITE (6,90)  NAME(J1), KSTAR(J1), spin1, TIME-TIME0
>    90     FORMAT (' DANGER!    NEGATIVE SPIN    NM K* s1 T-T0 ',
>      &                         I6,I4,1P,2E10.2)
>           IF (SPIN1.LT.0.0) SPIN1 = 0.1*omeq
>           IF (SPIN2.LT.0.0) SPIN2 = 0.1*omeq
>           ITRY = ITRY + 1
>           IF (ITRY.LE.2) GO TO 50
> *         STOP
>       END IF
> *
>   100 RETURN
> *
2,11c2,10
< *     
< *     
< *     Circularization time.
< *     ---------------------
< *     
< *     Theory of Piet Hut, A & A 99, 126 (1981).
< *     Developed by Rosemary Mardling (31/1/97).
< *     @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
< *     
<       Include 'kspars.h'
---
> *
> *
> *       Circularization time.
> *       ---------------------
> *
> *       Theory of Piet Hut, A & A 99, 126 (1981).
> *       Developed by Rosemary Mardling (31/1/97).
> *       @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
> *
14c13
<      &     WSCALE(2),QSCALE(2),A(2),B(2),C(6)
---
>      &        WSCALE(2),QSCALE(2),A(2),B(2),C(6)
20c19
<      &     -2.314374,-4.127795/
---
>      &                            -2.314374,-4.127795/
22d20
< *     for diagnostics, safe for parallel
25,30c23,29
< *     
< *     
< *     Set large circularization time for merged binary.
<       IF (RADIUS(I1).EQ.0.0D0.OR.RADIUS(I2).EQ.0.0D0) THEN
<          TC = 1.0D+10
<          GO TO 30
---
> *
> *
> *       Set large circularization time for merged binary or BHs.
>       IF (RADIUS(I1).EQ.0.0D0.OR.RADIUS(I2).EQ.0.0D0.OR.
>      &   (KSTAR(I1).EQ.14.AND.KSTAR(I2).EQ.14)) THEN
>           TC = 1.0D+10
>           GO TO 30
32,33c31,32
< *     
< *     Specify index J1 as biggest radius to be used with AT0(1).
---
> *
> *       Specify index J1 as biggest radius to be used with AT0(1).
35,36c34,35
<          J1 = I1
<          J2 = I2
---
>           J1 = I1
>           J2 = I2
38,39c37,38
<          J1 = I2
<          J2 = I1
---
>           J1 = I2
>           J2 = I1
41,42c40,41
< *     
< *     Include an appropriate numerical factor (Chris Tout 07/08).
---
> *
> *       Include an appropriate numerical factor (Chris Tout 07/08).
46c45
<          FF = 100.0
---
>           FF = 100.0
48c47
<          FF = 100.0
---
>           FF = 100.0
50c49
<          FF = 1.0D+17/AR**2
---
>           FF = 1.0D+17/AR**2
54c53
< *     Exit on TC > 1.0D+08 yr (Chris Tout, Cambody Book 2008).
---
> *       Exit on TC > 1.0D+08 yr (Chris Tout, Cambody Book 2008).
56,57c55,56
<          TC = 1.0D+10
<          GO TO 30
---
>           TC = 1.0D+10
>           GO TO 30
59,61c58,60
< *     
< *     Define oscillation period (dimensionless time) and damping constants.
<       ZN = 0.0
---
> *
> *       Define oscillation period (dimensionless time) and damping constants.
>       XN = 0.0
63,69c62,68
<          IF (K.EQ.1) THEN
<             IK = J1
<          ELSE
<             IK = J2
<          END IF
< *     Specify polytropic index for each star (n = 3, 2 or 3/2).
<          IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
---
>           IF (K.EQ.1) THEN
>               IK = J1
>           ELSE
>               IK = J2
>           END IF
> *       Specify polytropic index for each star (n = 3, 2 or 3/2).
>           IF (KSTAR(IK).EQ.3.OR.KSTAR(IK).EQ.5.OR.
71,86c70,85
<             IPAIR = KVEC(I1)
<             CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,ZN,QL)
<             W(K) = WG(1)
<             Q(K) = QG(1)
<          ELSE
<             QL = 1.0D+04
<             IP = 3
<             IF (KSTAR(IK).GE.3) IP = 2
<             IF (KSTAR(IK).EQ.4.OR.KSTAR(IK).EQ.7) IP = 3
<             IF (KSTAR(IK).EQ.8) IP = 3
<             IF (KSTAR(IK).EQ.0) IP = 1
<             W(K) = WW(IP)
<             Q(K) = QQ(IP)
<          END IF
<          TL = TWOPI*RADIUS(IK)*SQRT(RADIUS(IK)/BODY(IK)/W(K))
<          AT0(K) = 1.0/(QL*TL)
---
>               IPAIR = KVEC(I1)
>               CALL GIANT(IPAIR,IK,WG,QG,WSCALE,QSCALE,XN,QL)
>               W(K) = WG(1)
>               Q(K) = QG(1)
>           ELSE
>               QL = 1.0D+04
>               IP = 3
>               IF (KSTAR(IK).GE.3) IP = 2
>               IF (KSTAR(IK).EQ.4.OR.KSTAR(IK).EQ.7) IP = 3
>               IF (KSTAR(IK).EQ.8) IP = 3
>               IF (KSTAR(IK).EQ.0) IP = 1
>               W(K) = WW(IP)
>               Q(K) = QQ(IP)
>           END IF
>           TL = TWOPI*RADIUS(IK)*SQRT(RADIUS(IK)/BODY(IK)/W(K))
>           AT0(K) = 1.0/(QL*TL)
88,89c87,88
< *     
< *     Form mass, radius & pericentre ratio.
---
> *
> *       Form mass, radius & pericentre ratio.
91,93c90,92
<          M21 = BODY(I2)/BODY(I1)
<          R21 = RADIUS(I2)/RADIUS(I1)
<          RP1 = RP/RADIUS(I1)
---
>           M21 = BODY(I2)/BODY(I1)
>           R21 = RADIUS(I2)/RADIUS(I1)
> 	  RP1 = RP/RADIUS(I1)
95,97c94,96
<          M21 = BODY(I1)/BODY(I2)
<          R21 = RADIUS(I1)/RADIUS(I2)
<          RP1 = RP/RADIUS(I2)
---
> 	  M21 = BODY(I1)/BODY(I2)
>           R21 = RADIUS(I1)/RADIUS(I2)
> 	  RP1 = RP/RADIUS(I2)
99,100c98,99
< *     
< *     Evaluate damping coefficient.
---
> *
> *	Evaluate damping coefficient.
103,108c102,107
<      &     AT0(2)*(Q(2)/W(2))**2*((1.0 + M21)/M21**2)*R21**8)/
<      &     RR**8
< *     
< *     Adopt WD scaling for any NS to avoid numerical problem.
<       IF (KSTAR(I1).EQ.13.OR.KSTAR(I2).EQ.13) THEN
<          CONST = 1.0D-04*CONST
---
>      &             AT0(2)*(Q(2)/W(2))**2*((1.0 + M21)/M21**2)*R21**8)/
>      &                                                         RR**8
> *
> *       Adopt WD scaling for any NS/BH to avoid numerical problem.
>       IF (KSTAR(I1).GE.13.OR.KSTAR(I2).GE.13) THEN
>           CONST = 1.0D-04*CONST
110,111c109,110
< *     
< *     Form rational function approximation to Hut solution.
---
> *
> *	Form rational function approximation to Hut solution.
115,116c114,115
< *     
< *     See whether we only want the modified eccentricity (routine BINPOP).
---
> *
> *       See whether we only want the modified eccentricity (routine BINPOP).
118c117
< *     
---
> *
120c119
< *     Obtain the new eccentricity.
---
> *       Obtain the new eccentricity.
123,124c122,123
<      &     /(C(5) + C(6)*Z)
< *     
---
>      &		                             /(C(5) + C(6)*Z)
> *
129,133c128,132
< *     
< *     Evaluate circularization time (in units of 10**6 yrs).
<  10   TC = TSTAR*(1.0 - FF)/CONST
< *     
< *     Activate tidal indicator if TC < 2x10**9 yrs or hyperbolic orbit.
---
> *
> *       Evaluate circularization time (in units of 10**6 yrs).
>    10 TC = TSTAR*(1.0 - FF)/CONST
> *
> *       Activate tidal indicator if TC < 2x10**9 yrs or hyperbolic orbit.
135,153c134,148
<          IP = KVEC(I1)
<          ITIME = ITIME + 1
< *     Note possibility of counter exceeding the limit.
<          IF (ITIME.GT.2000000000) ITIME = 0
<          IF (ICIRC.EQ.0.AND.KZ(27).EQ.2.AND.ITIME.LT.100) THEN
<             SEMI = -0.5*BODY(N+IP)/H(IP)
<             if(rank.eq.0)then
<                WRITE (6,20)  I1, NCHAOS, ES0, RP1, M21, TC, SEMI, ZN
<  20            FORMAT (' TCIRC:    I1 NCH E RP M21 TC A n ',
<      &              2I5,F8.4,F8.1,F6.2,1P,2E10.2,0P,F5.1)
<             end if
<          END IF
<          ICIRC = 1
< *     Define Roche search indicator for circularized orbit (ECCM1 > 0.002).
<          IF (ES0.LE.ECCM1.AND.KSTAR(N+IP).EQ.0) THEN
<             KSTAR(N+IP) = 10
< *     ks MPI communication
<             call ksparmpi(K_store,K_int,K_KSTAR,N+IP,0,KSTAR(N+IP))
<          END IF
---
>           IP = KVEC(I1)
>           ITIME = ITIME + 1
> *       Note possibility of counter exceeding the limit.
>           IF (ITIME.GT.2000000000) ITIME = 0
>           IF (ICIRC.EQ.0.AND.KZ(27).EQ.2.AND.ITIME.LT.100) THEN
>               SEMI = -0.5*BODY(N+IP)/H(IP)
>               WRITE (6,20)  I1, NCHAOS, ES0, RP1, M21, TC, SEMI, XN
>    20         FORMAT (' TCIRC:    I1 NCH E RP M21 TC A n ',
>      &                            2I5,F8.4,F8.1,F6.2,1P,2E10.2,0P,F5.1)
>           END IF
>           ICIRC = 1
> *       Define Roche search indicator for circularized orbit (ECCM1 > 0.002).
>           IF (ES0.LE.ECCM1.AND.KSTAR(N+IP).EQ.0) THEN
>               KSTAR(N+IP) = 10
>           END IF
155,156c150,151
< *     Note ICIRC = -1 for some calls.
<          ICIRC = 0
---
> *       Note ICIRC = -1 for some calls.
>           ICIRC = 0
158,160c153,155
< *     
<  30   RETURN
< *     
---
> *
>    30 RETURN
> *
8d7
<       Include 'mpi_base.h'
33c32
<       IF (rank.eq.0.and.HI.GT.0.0.AND.DH.GT.HI) THEN
---
>       IF (HI.GT.0.0.AND.DH.GT.HI) THEN
7d6
<       Include 'kspars.h'
19,21d17
< *     ks MPI communication RADIUS
<           call ksparmpi(K_store,K_real8,K_RADIUS,I1,0,RADIUS(I1))
<           call ksparmpi(K_store,K_real8,K_RADIUS,I2,0,RADIUS(I2))
7a8
>       REAL*8  XREL(3)
10c11
< *       Set c.m. index and initialize scalars.
---
> *       See whether irregular time-step can replace full loop.
11a13,21
>       JCLOSE = 0
>       SEMI = -0.5*BODY(I)/H(IPAIR)
>       TK = TWOPI*SEMI*SQRT(SEMI/BODY(I))
>       IF (STEP(I).GT.TK) THEN
>           DT = STEP(I)
>           GO TO 20
>       END IF
> *
> *       Initialize scalars.
13,15c23,24
< C      DTIN = 1.0E+20
< C      JCL = 0
< C      NNB1 = LIST(1,I) + 1
---
>       DTIN = 1.0E+20
>       NNB1 = LIST(1,I) + 1
18,19c27
<       IF (LIST(1,I).EQ.0) THEN
< C      IF (NNB1.LE.1) THEN
---
>       IF (NNB1.LE.1) THEN
24,56c32,66
< C*       Find the most likely perturbers (first approach & maximum force).
< C      DO 10 L = 2,NNB1
< C          J = LIST(L,I)
< C          call jpred(J,TIME,TIME)
< C          RIJ2 = 0.0
< C          RDOT = 0.0
< C*
< C          DO 6 K = 1,3
< C              XREL = X(K,J) - X(K,I)
< C              VREL = XDOT(K,J) - XDOT(K,I)
< C              RIJ2 = RIJ2 + XREL**2
< C              RDOT = RDOT + XREL*VREL
< C    6     CONTINUE
< C*
< C          VR = RDOT/RIJ2
< C          IF (VR.LT.DTIN) THEN
< C              DTIN = VR
< C*       Note DTIN is inverse travel time to include case of no RDOT < 0.
< C              RCRIT2 = RIJ2
< C              JCRIT = J
< C          END IF
< C          FIJ = (BODY(I) + BODY(J))/RIJ2
< C          IF (FIJ.GT.FMAX) THEN
< C              FMAX = FIJ
< C              RJMIN2 = RIJ2
< C              JCL = J
< C          END IF
< C   10 CONTINUE
< *
<       JCRIT = IMINR(I)
<       IF(JCRIT.LE.0) THEN
<          DT = STEP(I)
<          GO TO 20
---
> *       Find the most likely perturbers (first approach & maximum force).
>       DO 10 L = 2,NNB1
>           J = LIST(L,I)
>           DO 4 K = 1,3
>               XREL(K) = X(K,J) - X(K,I)
>     4     CONTINUE
>           RIJ2 = XREL(1)**2 + XREL(2)**2 + XREL(3)**2
> *       Skip distant neighbours outside 50*SEMI.
>           IF (RIJ2.GT.2.5D+05*SEMI**2) GO TO 10
>           RDOT = 0.0
> *
>           DO 6 K = 1,3
>               VREL = XDOT(K,J) - XDOT(K,I)
>               RDOT = RDOT + XREL(K)*VREL
>     6     CONTINUE
> *
>           VR = RDOT/RIJ2
>           IF (VR.LT.DTIN) THEN
>               DTIN = VR
> *       Note DTIN is inverse travel time to include case of no RDOT < 0.
>               RCRIT2 = RIJ2
>               JCRIT = J
>           END IF
>           FIJ = (BODY(I) + BODY(J))/RIJ2
>           IF (FIJ.GT.FMAX) THEN
>               FMAX = FIJ
>               RJMIN2 = RIJ2
>               JCLOSE = J
>           END IF
>    10 CONTINUE
> *
> *       Specify safe interval if no candidates selected.
>       IF (JCLOSE.EQ.0) THEN
>           DT = 2.0*STEP(I)
>           GO TO 20
58,66d67
<       CALL JPRED(JCRIT,TIME,TIME)
<       DO K = 1,3
<          XREL = X(K,JCRIT) - X(K,I)
<          VREL = XDOT(K,JCRIT) - XDOT(K,I)
<          RIJ2 = RIJ2 + XREL**2
<          RDOT = RDOT + XREL*VREL
<       END DO
<       DTIN = RDOT/RIJ2
<       RCRIT2 = RIJ2
72d72
<       SEMI = -0.5*BODY(I)/H(IPAIR)
86,91c86,91
< C      IF (JCRIT.NE.JCL) THEN
< C*       Form the return time of the dominant body and choose the minimum.
< C          DR = SQRT(RJMIN2) - RI*(BODY(JCL)*A1)**0.3333
< C          DTMAX = SQRT(2.0D0*ABS(DR)/FMAX)
< C          DT = MIN(DT,DTMAX)
< C      END IF
---
>       IF (JCRIT.NE.JCLOSE) THEN
> *       Form the return time of the dominant body and choose the minimum.
>           DR = SQRT(RJMIN2) - RI*(BODY(JCLOSE)*A1)**0.3333
>           DTMAX = SQRT(2.0D0*ABS(DR)/FMAX)
>           DT = MIN(DT,DTMAX)
>       END IF
94c94
<       DT = MIN(DT,4.0D0*STEP(I))
---
>       DT = MIN(DT,2.0D0*STEP(I))
16a17
>       kw0 = kw              ! Bug fix for undefined value (SJA 04/16).
36c37,40
<       if(kw.le.1)then
---
>       if(kw.lt.0)then
>          dtm = pts1*tscls(15)
>          dtr = ABS(age)
>       elseif(kw.le.1)then
40,41c44
< C         dtm = 1.0d+02
<          dtm = sqrt(0.1/lum)
---
>          dtm = sqrt(10.0/lum)
69,72c72
< *     --09/27/13 23:37-lwang-improvements-------------------------------*
< ***** Note: dtm did not necessary become small-------------------------**
<          dtm = MIN(dtm,0.005d0)
< *     --09/27/13 23:37-lwang-end----------------------------------------*
---
> *        dtm = MIN(dtm,0.005d0)
105c105
<          if(ABS(dr).gt.0.1*rm0)then
---
>          if(ABS(dr).gt.0.1*rm0.and.kw.lt.10)then
126a127
>       if(kw.ne.kw0.and.kw.ge.13) goto 30
128,129c129,130
<          if(rank.eq.0) WRITE (6,22) IT, KSTAR(I), M0, DR, RM0
<    22    FORMAT (' DANGER!    TRDOT: IT K* M0 DR RM0 ',2I4,1P,3E10.2)
---
>          WRITE (6,22) IT, KSTAR(I), M0, DR, RM
>    22    FORMAT (' DANGER!    TRDOT: IT K* M0 DR RM ',2I4,1P,3E10.2)
139a141,151
> *
> * Ensure that change of type has not occurred during radius check. 
> * This is rare but may occur for HG stars of ZAMS mass > 50 Msun 
> * or some cases at the upper end of the mass range for EC SNe. 
> *
>          if(kw.ne.kw0)then
>             kw = kw0
>             m0 = body0(i)*zmbar
>             m1 = m10
>             CALL star(kw,m0,m1,tm,tn,tscls,lums,GB,zpars)
>          endif
45c45
<          dtm = MIN(dtm,0.005d0)
---
> *        dtm = MIN(dtm,0.005d0)
110c110
<                      if(rank.eq.0)WRITE(38,*)' TRFLOW KW1: ',rr,rls,t,tm
---
>                      WRITE(38,*)' TRFLOW KW1: ',rr,rls,t,tm
153d152
<                if(rank.eq.0)then
155d153
<                end if
216c214
<                IF(rank.eq.0.and.ABS(RR-RLS).GT.0.1)THEN
---
>                IF(ABS(RR-RLS).GT.0.1)THEN
251c249
<             if(rank.eq.0) WRITE(38,*)' TRFLOW KW6: ',rr,rls,lum,lums(7)
---
>             WRITE(38,*)' TRFLOW KW6: ',rr,rls,lum,lums(7)
313c311
<                      if(rank.eq.0)WRITE(38,*)' TRFLOW KW9: ',rr,rls,t,tm
---
>                      WRITE(38,*)' TRFLOW KW9: ',rr,rls,t,tm
339,341d336
< *     MPI communication for TEV
<             call ksparmpi(K_store,K_real8,K_TEV,J1,0,TEV(J1))
<             call ksparmpi(K_store,K_real8,K_TEV,J2,0,TEV(J2))
347c342
<             if(rank.eq.0) WRITE (6,101)J1,KSTAR(J1),TEV(J1)+TOFF,TTOT
---
>             WRITE (6,101)J1,KSTAR(J1),TEV(J1)+TOFF,TTOT
1c1
<       SUBROUTINE TSTAB(I,ECC1,SEMI1,PMIN1,YFAC,ITERM)
---
>       SUBROUTINE TSTAB(I,ECC1,SEMI1,PMIN1,PCRIT1,YFAC,JCL,ITERM)
8d7
< *     Safe for parallel
16c15
<       IF (PMIN1.GT.YFAC*PCRIT.OR.KZ(19).EQ.0.OR.KZ(27).EQ.0) THEN
---
>       IF (PMIN1.GT.YFAC*PCRIT1.OR.KZ(19).EQ.0.OR.KZ(27).EQ.0) THEN
18c17
<       ELSE IF (NAME(I).LT.0.OR.NAME(JCOMP).LT.0) THEN
---
>       ELSE IF (NAME(I).LT.0.OR.NAME(JCL).LT.0) THEN
21c20
<       ELSE IF (PMIN1.GT.0.8*YFAC*PCRIT.OR.
---
>       ELSE IF (PMIN1.GT.0.8*YFAC*PCRIT1.OR.
26c25
<           TK = TWOPI*SEMI1*SQRT(ABS(SEMI1)/(BODY(I) + BODY(JCOMP)))
---
>           TK = TWOPI*SEMI1*SQRT(ABS(SEMI1)/(BODY(I) + BODY(JCL)))
29c28
< *         WRITE (6,3)  YFAC,PMIN1,PCRIT,0.8*YFAC*PCRIT,NK*TK
---
> *         WRITE (6,3)  YFAC, PMIN1, PCRIT1, 0.8*YFAC*PCRIT1, NK*TK
33,34c32,33
< *       Modify PCRIT so it becomes < SEMI1*(1 - ECC1)*(1 - 2*PERT).
<           IF (PCRIT.LT.PMIN1) PCRIT = 0.999*PMIN1/YFAC
---
> *       Modify PCRIT1 so it becomes < SEMI1*(1 - ECC1)*(1 - 2*PERT).
>           IF (PCRIT1.LT.PMIN1) PCRIT1 = 0.999*PMIN1/YFAC
6a7
>       include 'zdata.h'
15d15
<       include 'zdata.h'
45a46
>       tbgbf = MAX(tbgbf,3.35d0)
404a406,407
> *     a1 = 0.5d0*a1
> *     a1 = 0.6d0*a1
418a422
> *     a1 = 0.5d0*a1
844c848
<       real*8 a,b,c,q
---
>       real*8 a,b,c,q,fac,facmax
848,853c852,864
<       a = 0.1d0
<       b = 0.006d0*MAX(1.d0,2.5d0/m)
<       c = 3.d0
<       q = log(r/rc)
<       rpertf = ((1.d0 + b**c)*((mew/b)**c)*(mew**(a/q)))/
<      &         (1.d0+(mew/b)**c)
---
>       if(mew.le.0.d0)then
>          rpertf = 0.d0
>       else
>          a = 0.1d0
>          b = 0.006d0*MAX(1.d0,2.5d0/m)
>          c = 3.d0
>          q = log(r/rc)
>          fac = a/q
>          facmax = -14.d0/log10(mew)
>          fac = MIN(fac,facmax)
>          rpertf = ((1.d0 + b**c)*((mew/b)**c)*(mew**fac))/
>      &            (1.d0+(mew/b)**c)
>       endif
